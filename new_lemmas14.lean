import imports
lemma new_lemma_112000 (h1 : prod (add_comm_semigroup std_gen) (add_comm_semigroup std_gen)) : set.diagonal (add_comm_semigroup std_gen) h1 := sorry --non-trivial
lemma new_lemma_112001 (h1 : not (complete_lattice (linear_ordered_add_comm_group fun_info) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_112002 (h0 : topological_space (has_top unsigned)) : t1_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_112003 (h0 : functor.add_const (ring (has_add pos)) (option pos)) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112004 (h0 : group (has_lt (random_gen (random_gen (random_gen (random_gen char)))))) : is_cyclic (has_lt (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_112005 (h0 : topological_space (linear_ordered_semiring (has_top num))) : locally_compact_space (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_112006 (h0 : semiring (has_nndist (has_to_string (has_to_string (has_to_string name))))) : is_noetherian_ring (has_nndist (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_112007 (h0 : group (has_add (has_to_string (has_to_string (has_to_string congr_arg_kind))))) : group.fg (has_add (has_to_string (has_to_string (has_to_string congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_112008 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra real)) : unique_factorization_monoid (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_112009 (h0 : uniform_space (boolean_algebra (add_cancel_monoid Type))) : complete_space (boolean_algebra (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_112010 (h0 : monoid (add_cancel_monoid (has_to_string linarith.comp))) : monoid.fg (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_112011 (h0 : ring (semigroup (finset (finset Type)))) : is_principal_ideal_ring (semigroup (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_112012 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring empty)))) : irreducible_space (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_112013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112014 (h0 : topological_space (comm_group (semigroup (comm_group (semigroup unsigned))))) : discrete_topology (comm_group (semigroup (comm_group (semigroup unsigned)))) := sorry --non-trivial
lemma new_lemma_112015 (h0 : functor.add_const (functor.add_const (finset (linear_order unsigned)) empty) num) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_112016 (h0 : ring (encodable linarith.comp_source)) : strong_rank_condition (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_112017 (h0 : topological_space (random_gen (with_bot (with_bot to_additive.value_type)))) : totally_separated_space (random_gen (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_112018 (h0 : topological_space (add_cancel_monoid (has_add pos))) : loc_path_connected_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_112019 (h0 : topological_space (comm_ring linarith.comp_source)) : totally_disconnected_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_112020 (h0 : has_star (denumerable linarith.ineq)) (h1 : ring (has_trivial_star (denumerable linarith.ineq))) : rank_condition (has_trivial_star (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112021 (h0 : function.extfun Type ring) : @is_domain.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_112022 (h0 : ordered_add_comm_monoid (has_Sup (option (option (option empty))))) : archimedean (has_Sup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_112023 (h0 : topological_space (has_add real)) : topological_space.separable_space (has_add real) := sorry --non-trivial
lemma new_lemma_112024 (h0 : group (has_one (has_top congr_arg_kind))) : group.fg (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112025 (h1 : topological_space string_imp) : totally_disconnected_space string_imp := sorry --non-trivial
lemma new_lemma_112026 (h0 : function.extfun (Type 1) (functor.comp topological_space comm_group)) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_112027 (h1 : not (uniform_space (has_union linarith.comp) -> false)) : @complete_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_112028 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_112029 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_112030 (h0 : ring (with_one char)) : is_domain (with_one char) := sorry --non-trivial
lemma new_lemma_112031 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_112032 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @irreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112033 (h0 : topological_space (is_R_or_C (semiring empty))) : preirreducible_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_112034 (h0 : monoid (left_cancel_semigroup unsigned)) : monoid.fg (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_112035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112036 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_neg environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_112037 (h0 : topological_space (has_zero (comm_group (comm_group Type)))) : locally_compact_space (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_112038 (h1 : not (complete_lattice (complete_semilattice_Sup linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_112039 (h0 : linear_ordered_add_comm_group (dlist char) -> linear_ordered_add_comm_group (dlist char) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_112040 (h0 : add_group (has_norm (has_inv (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (has_norm (has_inv (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_112041 (h0 : functor.add_const (topological_space (ordered_ring num)) congr_arg_kind) : @locally_compact_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112042 (h0 : functor.add_const (group (add_cancel_comm_monoid empty)) empty) : @normalizer_condition.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112043 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_112044 (h0 : functor.add_const (topological_space (ring name)) Type) : @preconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_112045 (h0 : topological_space (plift empty)) : t1_space (plift empty) := sorry --non-trivial
lemma new_lemma_112046 (h0 : uniform_space (has_bot (has_Inf (has_Inf (has_Inf linarith.comp))))) : complete_space (has_bot (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_112047 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset empty)) num) : @unique_factorization_monoid.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_112048 (h0 : set (linarith.ineq -> lex (add_comm_semigroup enat))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_112049 (h0 : functor.add_const (complete_lattice (has_neg Type)) (has_add pos)) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112050 (h0 : topological_space (has_top (with_one (has_inv (has_ssubset (has_inv fun_info)))))) : t0_space (has_top (with_one (has_inv (has_ssubset (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_112051 (h0 : functor.add_const (filter unsigned) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112052 (h0 : add_group (comm_ring string_imp)) : is_add_cyclic (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_112053 (h0 : nat) (h1 : vector Prop (has_add.add h0 has_one.one)) : vector.last h1 := sorry --non-trivial
lemma new_lemma_112054 (h0 : not (complete_lattice (add_left_cancel_monoid linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_112055 (h0 : topological_space (add_comm_semigroup std_gen)) (h2 : preorder (add_comm_semigroup std_gen)) : order_closed_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_112056 (h0 : filter (measurable_space (random_gen empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112057 (h0 : group (add_comm_monoid (ring (finset linarith.comp)))) : group.fg (add_comm_monoid (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_112058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112059 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112060 (h1 : topological_space (parser (random_gen char))) : path_connected_space (parser (random_gen char)) := sorry --non-trivial
lemma new_lemma_112061 (h0 : not (topological_space (with_one unsigned) -> false)) : @irreducible_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_112062 (h0 : has_pos_part linarith.comp -> has_pos_part linarith.comp -> Prop) (h1 : function.extfun (has_pos_part linarith.comp) (fun (x : has_pos_part linarith.comp), Prop)) : set.unbounded h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_112063 (h0 : functor.add_const (topological_space (has_bot pos)) pos) : @path_connected_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112064 (h0 h1 : multiset (simple_graph char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_112065 (h0 : topological_space (has_to_string (comm_group name))) : topological_space.separable_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_112066 (h0 : functor.add_const (functor.add_const (function.extfun Type group) environment.implicit_infer_kind) Type) : @is_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind) Type h0)) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_112067 (h0 : topological_space (cancel_monoid Type)) : topological_space.separable_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_112068 (h0 : group (ordered_comm_monoid Type)) : normalizer_condition (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_112069 (h0 : add_monoid (has_zero (has_add name))) : add_monoid.fg (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_112070 (h0 : functor.add_const (add_group (has_pos_part pos)) pos) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112071 (h0 : list (group_with_zero (option (option (option unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112072 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : preirreducible_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112073 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : locally_compact_space (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_112074 (h0 : ring (add_cancel_monoid empty)) : is_principal_ideal_ring (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_112075 (h0 : group (has_add (has_neg pos))) : is_cyclic (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_112076 (h0 : uniform_space (denumerable (random_gen string_imp))) : complete_space (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_112077 (h0 : topological_space (mul_one_class (add_comm_semigroup (group reducibility_hints)))) : totally_disconnected_space (mul_one_class (add_comm_semigroup (group reducibility_hints))) := sorry --non-trivial
lemma new_lemma_112078 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : sequential_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_112079 (h0 : complete_lattice (random_gen (semiring empty))) : is_compactly_generated (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_112080 (h0 : functor.add_const (ring (ordered_comm_semiring congr_arg_kind)) (semiring (semiring (semiring (semiring num))))) : @strong_rank_condition.{0} (ordered_comm_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_semiring.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))) h0)  := sorry --non-trivial
lemma new_lemma_112081 (h0 h1 : list (linear_ordered_comm_monoid_with_zero (option empty))) : list.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_112082 (h0 : topological_space (has_emptyc (random_gen to_additive.value_type))) : discrete_topology (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_112083 (h0 : topological_space (has_inter (option empty))) : discrete_topology (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_112084 (h0 : list (boolean_algebra linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112085 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112086 (h1 : add_group ereal) : is_add_cyclic ereal := sorry --non-trivial
lemma new_lemma_112087 (h0 : group (has_add (finset (has_neg pos)))) : normalizer_condition (has_add (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_112088 (h0 : functor.comp group has_to_string pos) : @group.fg.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_112089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_112090 (h0 : topological_space (is_R_or_C unsigned)) : totally_separated_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_112091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_112092 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_to_string (add_comm_monoid pos)))) : unique_factorization_monoid (add_cancel_monoid (has_to_string (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_112093 (h0 : uniform_space (boolean_algebra.core (comm_group Type))) : complete_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_112094 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (comm_group name)) := sorry --non-trivial
lemma new_lemma_112095 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @sequential_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_112096 (h1 : complete_lattice (has_add (fintype char))) : is_compactly_generated (has_add (fintype char)) := sorry --non-trivial
lemma new_lemma_112097 (h0 : functor.add_const (ring ennreal) (option unsigned)) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_112098 (h0 : topological_space (has_append (comm_ring linarith.ineq))) : totally_disconnected_space (has_append (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112099 (h0 : group (sub_neg_monoid (sub_neg_monoid pos))) : group.fg (sub_neg_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_112100 (h1 : ring (with_zero string_imp)) : rank_condition (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_112101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_112102 (h0 : uniform_space (has_nndist (finset (finset Type)))) : complete_space (has_nndist (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_112103 (h0 : group (cancel_monoid (has_add (has_add Type)))) : normalizer_condition (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_112104 (h0 : topological_space (has_inv (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_112105 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring (option name))) := sorry --non-trivial
lemma new_lemma_112106 (h0 : group (canonically_ordered_monoid pos)) : is_cyclic (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_112107 (h0 : multiset (semi_normed_ring reducibility_hints)) (h1 : not (multiset (semi_normed_ring reducibility_hints) -> false)) : multiset.subset h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_112108 (h0 : filter (add_group (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112109 (h0 : ring (distrib (has_ssubset (has_ssubset (random_gen char))))) : is_domain (distrib (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_112110 (h0 : list (has_emptyc string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112111 (h0 : monoid (metric_space to_additive.value_type)) (h1 : ring (uniform_space (star_monoid (metric_space to_additive.value_type)))) : strong_rank_condition (uniform_space (star_monoid (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_112112 (h0 : functor.add_const (ring (ordered_comm_ring pos)) linarith.comp) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112113 (h0 : list (has_add (boolean_algebra environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112114 (h0 : functor.add_const (ring (partial_order congr_arg_kind)) unsigned) : @rank_condition.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112115 (h0 : semiring (plift (option (semiring num)))) : is_noetherian_ring (plift (option (semiring num))) := sorry --non-trivial
lemma new_lemma_112116 (h0 : ordered_comm_monoid (ring (boolean_algebra.core Type))) : has_exists_mul_of_le (ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_112117 (h0 : functor.add_const (group (normed_comm_ring Type)) (has_to_string (has_neg linarith.comp))) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) (has_to_string.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_112118 (h0 : group (simple_graph (has_add (boolean_algebra.core Type)))) : is_simple_group (simple_graph (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_112119 (h0 : ring (ordered_comm_ring (has_add pos))) : rank_condition (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_112120 (h0 : ring (mul_one_class (mul_one_class std_gen))) : strong_rank_condition (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_112121 (h0 : add_group (dlist (distrib linarith.ineq))) : is_add_cyclic (dlist (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112122 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112123 (h0 : topological_space (has_pos_part (has_neg (has_neg name)))) : preconnected_space (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_112124 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_112125 (h3 : ring (has_top fun_info)) : is_domain (has_top fun_info) := sorry --non-trivial
lemma new_lemma_112126 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_112127 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @t1_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_112128 (h0 : filter (has_norm (has_top (random_gen (random_gen (random_gen fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112129 (h0 : topological_space (semigroup (normed_comm_ring (normed_comm_ring name)))) : locally_compact_space (semigroup (normed_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_112130 (h0 : functor.add_const (monoid (has_neg_part name)) linarith.comp) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112131 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : path_connected_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112132 (h0 : topological_space (has_to_string (has_neg (has_to_string (has_add linarith.comp))))) : totally_disconnected_space (has_to_string (has_neg (has_to_string (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_112133 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen congr_arg_kind))))) : discrete_topology (normed_group (random_gen (random_gen (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_112134 (h0 : ring (simple_graph reducibility_hints)) : rank_condition (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_112135 (h0 : ring (canonically_ordered_comm_semiring (option empty))) : is_domain (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_112136 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_112137 (h0 : topological_space (has_pos_part (has_nndist (boolean_algebra.core Type)))) : t0_space (has_pos_part (has_nndist (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_112138 (h0 : group (has_Inf (finset (finset linarith.comp)))) : group.fg (has_Inf (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_112139 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112140 (h0 : uniform_space (ordered_comm_ring (sub_neg_monoid pos))) : separated_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_112141 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112142 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_112143 (h0 : topological_space (has_bot (has_pos_part pos))) : sequential_space (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_112144 (h0 : group (has_add (has_zero Type))) : group.fg (has_add (has_zero Type)) := sorry --non-trivial
lemma new_lemma_112145 (h0 : topological_space (has_to_string num)) : preconnected_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_112146 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112147 (h0 : monoid (has_neg (finset pos))) : monoid.fg (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_112148 (h0 : fun_info -> fun_info -> Prop) : is_symm fun_info h0 := sorry --non-trivial
lemma new_lemma_112149 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112150 (h0 : functor.add_const (group (add_semigroup empty)) (option (option (option empty)))) : @normalizer_condition.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_112151 (h0 : functor.comp topological_space has_add pos) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_112152 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : sequential_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_112153 (h0 : not (ring (topological_space (has_ssubset linarith.comp_source)) -> false)) : @rank_condition.{0} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_112154 (h0 : complete_lattice (with_zero string_imp)) : is_compactly_generated (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_112155 (h0 : functor.add_const (semiring (ring pos)) linarith.comp) : @is_noetherian_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112156 (h0 : ring (semigroup (semiring unsigned))) : is_principal_ideal_ring (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_112157 (h0 : functor.add_const (add_group (finset Type)) (has_add pos)) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (finset.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112158 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_112159 (h0 : preorder (add_comm_semigroup char)) (h1 : set (add_comm_semigroup char)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_112160 (h0 : filter (has_to_string (has_neg_part (has_neg_part Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_112161 (h0 : topological_space (has_nndist (has_neg linarith.comp))) : normal_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_112162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112163 (h0 : ring (add_cancel_monoid (has_nndist Type))) : is_principal_ideal_ring (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_112164 (h0 : group (has_norm linarith.comp)) : group.fg (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_112165 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112166 (h0 : topological_space (complete_linear_order empty)) : topological_space.separable_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_112167 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_112168 (h0 : filter (has_to_string (finset (finset environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_112169 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_112170 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_112171 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112172 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112173 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) (boolean_algebra Type)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_112174 (h0 : ring (random_gen (comm_ring (random_gen to_additive.value_type)))) : is_domain (random_gen (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_112175 (h0 : topological_space (right_cancel_semigroup environment.implicit_infer_kind)) : normal_space (right_cancel_semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_112176 (h0 : set (non_unital_non_assoc_semiring (mul_one_class std_gen))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_112177 (h0 : ring (ordered_cancel_comm_monoid linarith.ineq)) : strong_rank_condition (ordered_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_112178 (h0 : list (monoid_with_zero (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112179 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_112180 (h0 : list (complete_semilattice_Sup (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112181 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_112182 (h0 : list (normed_comm_ring (has_to_string linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112183 (h0 : has_mem.mem num has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num h0)  := sorry --non-trivial
lemma new_lemma_112184 (h0 : topological_space (ordered_comm_ring (has_add (ordered_comm_monoid pos)))) : discrete_topology (ordered_comm_ring (has_add (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_112185 (h1 : uniform_space (metric_space (has_nnnorm to_additive.value_type))) : complete_space (metric_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_112186 (h0 : functor.add_const (ring (ring pos)) name) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112187 (h0 : functor.add_const (function.extfun (Type 1) group) (ring (has_add (ring Type)))) : @is_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{1} (has_add.{1} (ring.{1} Type))) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_112188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} char))  := sorry --non-trivial
lemma new_lemma_112189 (h0 : finset (is_R_or_C (semiring (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112190 (h0 : topological_space (with_bot (has_top linarith.comp_source))) : path_connected_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_112191 (h0 : group (has_add real)) : normalizer_condition (has_add real) := sorry --non-trivial
lemma new_lemma_112192 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @discrete_topology.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_112193 (h0 : topological_space (random_gen (linear_ordered_add_comm_group linarith.ineq))) : t0_space (random_gen (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112194 (h0 : uniform_space (distrib_lattice (has_nnnorm linarith.ineq))) : complete_space (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112195 (h0 : topological_space (normed_group (semiring empty))) : path_connected_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_112196 (h2 : complete_lattice (dlist to_additive.value_type)) : is_compactly_generated (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112197 (h0 : uniform_space (linear_ordered_semiring congr_arg_kind)) : separated_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112198 (h0 : functor.add_const (monoid (cancel_monoid name)) (has_neg_part Type)) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (cancel_monoid.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_112199 (h0 : list (has_neg_part (finset (finset (has_add ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112200 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_112201 (h0 : complete_lattice (add_right_cancel_monoid (semiring empty))) : is_compactly_generated (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_112202 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_112203 (h0 : uniform_space (add_cancel_monoid (has_pos_part linarith.comp))) : complete_space (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_112204 (h0 : group (has_bot (has_Inf real))) : group.fg (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_112205 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid ennreal)) ennreal) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_112206 (h0 : complete_lattice (has_add to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112207 (h0 : function.extfun Type add_monoid) : add_monoid.fg (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_112208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_zero.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_112210 (h2 : ring (distrib_lattice char)) : rank_condition (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_112211 (h0 : topological_space (semigroup (normed_comm_ring (finset pos)))) : regular_space (semigroup (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_112212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_112213 (h0 : filter (partial_order empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112214 (h0 : topological_space (mul_zero_class (semiring num))) : t0_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_112215 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112216 (h0 : ring (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : strong_rank_condition (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_112217 (h0 : ring (has_nndist (comm_group (comm_group ennreal)))) : is_principal_ideal_ring (has_nndist (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_112218 (h0 : functor.add_const (function.extfun Type topological_space) (normed_comm_ring pos)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (normed_comm_ring.{0} pos) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112219 (h0 : set (prod name name)) (h1 : prod name name) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_112220 (h0 : topological_space enat) (h1 : linear_ordered_add_comm_monoid_with_top char) (h2 : ring enat) (h3 : add_valuation enat char) : order_topology enat := sorry --non-trivial
lemma new_lemma_112221 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_112222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_112223 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_112224 (h0 : topological_space (add_cancel_monoid (group_with_zero name))) : preconnected_space (add_cancel_monoid (group_with_zero name)) := sorry --non-trivial
lemma new_lemma_112225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_ssubset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112226 (h0 : group (metric_space empty)) : group.fg (metric_space empty) := sorry --non-trivial
lemma new_lemma_112227 (h0 : filter (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112228 (h0 : functor.add_const (topological_space (preorder num)) unsigned) : @normal_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112229 (h0 : functor.add_const (ring (add_left_cancel_semigroup empty)) empty) : @is_domain.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112230 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : locally_compact_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_112231 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) linarith.comp) : @is_atomistic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112232 (h0 : functor.add_const (add_group (partial_order num)) empty) : @is_add_cyclic.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_112233 (h0 : list (cancel_monoid (add_comm_monoid (semigroup (normed_comm_ring environment.implicit_infer_kind))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112234 (h0 : topological_space (add_cancel_monoid unsigned)) : path_connected_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_112235 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_112236 (h0 : functor.add_const (ring (semiring congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112237 (h0 : filter (has_dist ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112238 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @t0_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_112239 (h0 : topological_space auto.case_option) : locally_compact_space auto.case_option := sorry --non-trivial
lemma new_lemma_112240 (h0 : has_mem.mem (has_one congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_112241 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : locally_compact_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_112242 (h0 : functor.add_const (complete_lattice (has_to_string Type)) Type) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_112243 (h0 : functor.add_const (topological_space (has_dist empty)) ennreal) : @t1_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_112244 (h0 : semiring (canonically_linear_ordered_monoid name)) : is_noetherian_ring (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_112245 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @topological_space.separable_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112246 (h0 : not (add_monoid (partial_order congr_arg_kind) -> false)) : @add_monoid.fg.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_112247 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_112248 (h1 : set (set fun_info)) (h2 : set fun_info) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_112249 (h0 : topological_space (has_add (option unsigned))) : sequential_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_112250 (h0 : list (has_pos_part (has_add (has_Inf real)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112251 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_112252 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_112253 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) real.angle)  := sorry --non-trivial
lemma new_lemma_112254 (h0 : not (topological_space (complete_linear_order num) -> false)) : @totally_disconnected_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_112255 (h0 : functor.add_const (add_monoid (has_neg environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_112256 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf linarith.comp)) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112257 (h0 : group (random_gen linarith.comp)) : group.fg (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_112258 (h0 : not (uniform_space (complete_semilattice_Sup empty) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112259 (h1 : ordered_add_comm_monoid (measurable_space (random_gen (random_gen (random_gen string_imp))))) : archimedean (measurable_space (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_112260 (h0 : uniform_space (has_Inf (has_Inf (has_Inf (has_Inf pos))))) : complete_space (has_Inf (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_112261 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112262 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_112263 (h0 : topological_space (finset (has_add unsigned))) : irreducible_space (finset (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_112264 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_112265 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_112266 (h0 : topological_space (add_comm_monoid unsigned)) : t0_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_112267 (h0 : measurable_space (has_ssubset (has_ssubset reducibility_hints))) (h1 : filter (has_ssubset (has_ssubset reducibility_hints))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_112268 (h0 : not (topological_space (plift complex) -> false)) : @totally_disconnected_space.{1} (plift.{1} complex) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} complex)) h0)  := sorry --non-trivial
lemma new_lemma_112269 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112270 (h0 : complete_lattice (has_top (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_112271 (h0 : ring (option (semiring (semiring (semiring (semiring unsigned)))))) : strong_rank_condition (option (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_112272 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg linarith.comp)) : @t0_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112273 (h0 : filter (add_comm_monoid (finset (has_add (complete_distrib_lattice Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112274 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_112275 (h0 : uniform_space (boolean_algebra (has_Inf pos))) : complete_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_112276 (h1 : complete_lattice (simple_graph to_additive.value_type)) : is_compactly_generated (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112277 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112278 (h0 : group (cancel_monoid (has_nndist pos))) : is_cyclic (cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_112279 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_112280 (h0 : topological_space (as_linear_order unsigned)) : totally_disconnected_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_112281 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid num)) := sorry --non-trivial
lemma new_lemma_112282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112283 (h0 : topological_space (has_add real)) : regular_space (has_add real) := sorry --non-trivial
lemma new_lemma_112284 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid pos))) : locally_compact_space (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_112285 (h0 : group (semi_normed_ring (random_gen (has_nnnorm (random_gen linarith.comp_source))))) : is_cyclic (semi_normed_ring (random_gen (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_112286 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112287 (h0 : list (complete_distrib_lattice (semigroup linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112288 (h0 : add_group (with_one (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) : is_add_cyclic (with_one (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_112289 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf Type)))) : path_connected_space (add_cancel_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_112290 (h0 : topological_space (pseudo_metric_space (finset name))) : t1_space (pseudo_metric_space (finset name)) := sorry --non-trivial
lemma new_lemma_112291 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_112292 (h0 : group (add_comm_monoid (sub_neg_monoid (sub_neg_monoid pos)))) : group.fg (add_comm_monoid (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_112293 (h0 : functor.add_const (ring environment.implicit_infer_kind) name) : @strong_rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_112294 (h1 : topological_space (has_nnnorm to_additive.value_type)) (h2 : preorder (has_nnnorm to_additive.value_type)) : order_topology (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112295 (h0 : uniform_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind))) : separated_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112296 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space.dynkin_system empty)) := sorry --non-trivial
lemma new_lemma_112297 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112298 (h0 : filter (simple_graph (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112299 (h0 : functor.add_const (semiring (has_add name)) unsigned) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112300 (h0 : complete_lattice (fintype linarith.ineq)) : is_compactly_generated (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_112301 (h1 : add_group (comm_ring (random_gen char))) : is_add_cyclic (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_112302 (h0 : topological_space (has_neg (option (option name)))) : regular_space (has_neg (option (option name))) := sorry --non-trivial
lemma new_lemma_112303 (h0 : uniform_space (has_dist unsigned)) : complete_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_112304 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : t0_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_112305 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_112306 (h0 : not (monoid (linear_ordered_semiring fun_info) -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_112307 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_112308 (h2 : topological_space fun_info) (h3 : set fun_info) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_112309 (h0 : topological_space (has_inv (has_ssubset (has_norm linarith.ineq)))) : irreducible_space (has_inv (has_ssubset (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_112310 (h0 : set (has_lt linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_112311 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_112312 (h0 : add_group (finset (option ennreal))) : is_add_cyclic (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_112313 (h0 : group (linear_ordered_semiring (semiring (random_gen unsigned)))) : group.fg (linear_ordered_semiring (semiring (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_112314 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112315 (h1 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h1 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112316 (h0 : topological_space (has_bot (sub_neg_monoid real))) : locally_compact_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_112317 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_112318 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) pos) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_112319 (h0 : functor.add_const (add_monoid (add_cancel_monoid pos)) linarith.comp) : @add_monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112320 (h0 : ring (linear_ordered_field (option unsigned))) : is_domain (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_112321 (h0 : add_group (has_nnnorm (has_compl string_imp))) : is_add_cyclic (has_nnnorm (has_compl string_imp)) := sorry --non-trivial
lemma new_lemma_112322 (h0 : topological_space ennreal) : regular_space ennreal := sorry --non-trivial
lemma new_lemma_112323 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_112324 (h1 : set (ereal -> metric_space enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_112325 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) (has_neg linarith.comp)) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112326 (h0 : functor.add_const (functor.comp complete_lattice has_neg_part ennreal) (option pos)) : @is_atomistic.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} ennreal)) unsigned (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg_part.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_neg_part.{0} ennreal) (option.{0} pos) h0)))  := sorry --non-trivial
lemma new_lemma_112327 (h0 : topological_space (has_bot (has_Inf (has_Inf Type)))) : sequential_space (has_bot (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_112328 (h0 : monoid (has_neg Type)) : monoid.fg (has_neg Type) := sorry --non-trivial
lemma new_lemma_112329 (h0 : functor.add_const Prop (has_norm (has_norm empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_112330 (h0 : not (topological_space (plift num) -> false)) : @totally_separated_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_112331 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid nnreal) empty) num) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_112332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112333 (h0 : add_group (simple_graph (ring linarith.comp))) : is_add_cyclic (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_112334 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_112335 (h0 : functor.add_const (functor.add_const (semiring (has_star empty)) empty) num) : @is_noetherian_ring.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (semiring.{0} (has_star.{0} empty)) empty) num h0))  := sorry --non-trivial
lemma new_lemma_112336 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_112337 (h0 : monoid (ordered_comm_monoid (has_Inf (has_Inf pos)))) : monoid.fg (ordered_comm_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_112338 (h0 : group (semigroup (finset environment.implicit_infer_kind))) : group.fg (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112339 (h3 : semiring (add_comm_semigroup char)) (h4 : ideal (add_comm_semigroup char)) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_112340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112342 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112343 (h0 : topological_space (has_inv char)) : path_connected_space (has_inv char) := sorry --non-trivial
lemma new_lemma_112344 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112345 (h0 : functor.add_const (filter (has_to_string name)) (comm_group Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112346 (h0 : group (has_Inf (has_nndist linarith.comp))) : normalizer_condition (has_Inf (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_112347 (h0 : functor.add_const (finset (generalized_boolean_algebra linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112348 (h0 : empty) : @preirreducible_space.{0} (partial_order.{0} congr_arg_kind) (@empty.elim.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_112349 (h0 : uniform_space (semi_normed_ring enat)) : complete_space (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_112350 (h0 : group (semigroup (has_to_string congr_arg_kind))) : is_cyclic (semigroup (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112351 (h0 : not (topological_space (uniform_space string_imp) -> false)) : @t0_space.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_112352 (h0 : add_monoid (has_norm (semiring (semiring (semiring unsigned))))) : add_monoid.fg (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_112353 (h0 : add_group (mul_one_class ereal)) : is_add_cyclic (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_112354 (h0 h1 : not (multiset (mul_one_class string_imp) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_112355 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_Inf pos))) : archimedean (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_112356 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @sequential_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_112357 (h0 : ring (has_add (finset linarith.comp))) : is_domain (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_112358 (h0 : topological_space (simple_graph (has_add Type))) : locally_compact_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_112359 (h0 : group (boolean_algebra.core pos)) : is_simple_group (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_112360 (h2 : ring (nondiscrete_normed_field char)) : strong_rank_condition (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_112361 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) (ring (has_neg Type))) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (add_cancel_monoid.{1} Type)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_112362 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_112363 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_112364 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_112365 (h0 : filter (complete_distrib_lattice (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112366 (h0 : topological_space (normed_group empty)) : t1_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_112367 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112368 (h0 : topological_space char) : path_connected_space char := sorry --non-trivial
lemma new_lemma_112369 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @t0_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_112370 (h1 : topological_space (add_comm_semigroup std_gen)) : topological_space.first_countable_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_112371 (h0 : generalized_boolean_algebra (has_add real) -> generalized_boolean_algebra (has_add real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_112372 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (has_neg (ordered_ring (has_neg pos)))) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} (ordered_ring.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_112373 (h0 : topological_space (normed_field (mul_one_class fun_info))) : totally_disconnected_space (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_112374 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_112375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_112376 (h0 : topological_space (ordered_comm_ring real)) : regular_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_112377 (h0 : add_group (complete_linear_order (semiring num))) : is_add_cyclic (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_112378 (h0 : not (semiring (id unsigned) -> false)) : @is_noetherian_ring.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_112379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_112380 (h0 : functor.add_const (monoid (comm_group Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112381 (h0 : Prop -> Prop) (h1 : Exists (fun (x : Prop), h0 x)) : classical.some h1 := sorry --non-trivial
lemma new_lemma_112382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_112383 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_112384 (h0 : topological_space (has_pos_part real)) : sequential_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_112385 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_112386 (h0 : functor.add_const (group (has_neg pos)) linarith.comp) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112387 (h0 : prod (option (measurable_space.dynkin_system unsigned)) (option (measurable_space.dynkin_system unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_112388 (h0 : topological_space (finset (has_Inf pos))) : locally_compact_space (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_112389 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_add pos))) : archimedean (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_112390 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_bot (ordered_comm_group empty))) := sorry --non-trivial
lemma new_lemma_112391 (h0 : complete_lattice (random_gen (normed_field reducibility_hints))) : is_compactly_generated (random_gen (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_112392 (h0 : topological_space (add_comm_monoid (option (option (option (option unsigned)))))) : t0_space (add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_112393 (h0 : group (has_norm empty)) : is_cyclic (has_norm empty) := sorry --non-trivial
lemma new_lemma_112394 (h0 : functor.add_const (finset (add_comm_monoid name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112395 (h2 : set (linarith.ineq -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_112396 (h0 : Prop) (h1 : set environment.projection_info) (h2 : environment.projection_info) : yyy_to h0 (set.compl h1 h2) := sorry --non-trivial
lemma new_lemma_112397 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112398 (h0 : functor.add_const (add_group (option pos)) pos) : @is_add_cyclic.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112399 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_112400 (h0 : semiring (with_zero char)) (h1 : uniform_space (polynomial (with_zero char))) : complete_space (polynomial (with_zero char)) := sorry --non-trivial
lemma new_lemma_112401 (h0 : functor.add_const (complete_lattice (finset ennreal)) unsigned) : @is_atomistic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112402 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112403 (h0 : add_group (random_gen (semigroup char))) : is_add_cyclic (random_gen (semigroup char)) := sorry --non-trivial
lemma new_lemma_112404 (h0 : topological_space (has_emptyc (has_top linarith.ineq))) : irreducible_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112405 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112406 (h1 : ring (random_gen (comm_ring char))) : strong_rank_condition (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_112407 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_112408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112409 (h0 : topological_space (has_ssubset (has_nnnorm linarith.ineq))) : path_connected_space (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112410 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112411 (h0 : to_additive.value_type -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_112412 (h0 : Type -> Type -> Prop) (h1 : well_founded h0) (h2 : Pi (x : Type), (Pi (y : Type), h0 y x -> ordered_add_comm_monoid y) -> ordered_add_comm_monoid x) : @archimedean.{0} (ordered_comm_group.{0} congr_arg_kind) (@well_founded.recursion.{2 1} Type h0 h1 ordered_add_comm_monoid.{0} (ordered_comm_group.{0} congr_arg_kind) h2)  := sorry --non-trivial
lemma new_lemma_112413 (h0 : monoid (ordered_comm_monoid (has_to_string linarith.comp))) : monoid.fg (ordered_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_112414 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_112415 (h0 : ring (finset (has_add (has_add linarith.comp)))) : is_domain (finset (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_112416 (h0 : topological_space (has_to_string (boolean_algebra (has_add Type)))) : irreducible_space (has_to_string (boolean_algebra (has_add Type))) := sorry --non-trivial
lemma new_lemma_112417 (h0 : finset (has_to_string (option (option name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112418 (h0 : function.extfun nat fin) : @preconnected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_112419 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112420 (h0 : ring (ring (has_add pos))) : is_domain (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_112421 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_112422 (h0 : complete_lattice (has_norm (has_top linarith.comp_source))) : is_compactly_generated (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_112423 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112424 (h0 : prod (has_zero (option empty)) (has_zero (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_112425 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @complete_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_112426 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) pos) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_112427 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_112428 (h0 : topological_space (encodable (normed_lattice_add_comm_group linarith.ineq))) : totally_disconnected_space (encodable (normed_lattice_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112429 (h0 : ring (has_neg (has_nndist (finset environment.implicit_infer_kind)))) : strong_rank_condition (has_neg (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_112430 (h0 : topological_space (has_nndist Type)) : regular_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_112431 (h0 : complete_lattice (has_bot (has_bot Type))) : is_atomistic (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_112432 (h0 : topological_space (comm_semigroup (ordered_comm_monoid pos))) : t0_space (comm_semigroup (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_112433 (h0 : filter (linear_ordered_add_comm_group char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112434 (h0 : complete_lattice (cancel_monoid (boolean_algebra.core ennreal))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_112435 (h0 : topological_space (boolean_algebra.core Type)) : preconnected_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_112436 (h0 : topological_space (has_edist empty)) : discrete_topology (has_edist empty) := sorry --non-trivial
lemma new_lemma_112437 (h0 : normed_comm_ring (finset name) -> normed_comm_ring (finset name) -> Prop) : is_antisymm (normed_comm_ring (finset name)) h0 := sorry --non-trivial
lemma new_lemma_112438 (h1 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h1 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (option empty)) := sorry --non-trivial
lemma new_lemma_112440 (h0 : topological_space (has_ssubset (denumerable char))) : locally_compact_space (has_ssubset (denumerable char)) := sorry --non-trivial
lemma new_lemma_112441 (h0 : complete_lattice (distrib (random_gen linarith.ineq))) : is_compactly_generated (distrib (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112442 (h0 : pfun ereal Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_112443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_112444 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112445 (h0 : topological_space (denumerable (has_nnnorm fun_info))) : t0_space (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_112446 (h0 : functor.add_const (group (cancel_monoid pos)) name) : @group.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112447 (h0 : uniform_space (canonically_linear_ordered_monoid (boolean_algebra real))) : complete_space (canonically_linear_ordered_monoid (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_112448 (h0 : functor.add_const (topological_space (ring Type)) (has_neg linarith.comp)) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112449 (h0 : functor.add_const (ring (ordered_ring num)) num) : @is_domain.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_112450 (h0 : topological_space (pseudo_metric_space (has_to_string congr_arg_kind))) : discrete_topology (pseudo_metric_space (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112452 (h0 : functor.add_const (filter (has_pos_part pos)) (ring pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112453 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_112454 (h0 : ring (has_to_string pos)) : is_domain (has_to_string pos) := sorry --non-trivial
lemma new_lemma_112455 (h0 : function.extfun Type group) : @group.fg.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_112456 (h0 : uniform_space (plift (semiring (semiring unsigned)))) : separated_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_112457 (h0 : uniform_space (has_pos_part Type)) : complete_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_112458 (h0 : fin has_zero.zero) : @is_domain.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_112459 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid unsigned)) : archimedean (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_112460 (h0 : functor.add_const (ring (comm_group name)) (has_add (has_add name))) : @strong_rank_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_112461 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp)))) : regular_space (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_112462 (h1 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_112463 (h0 : set (non_unital_non_assoc_semiring (pseudo_metric_space (mul_one_class linarith.ineq)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_112464 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112465 (h0 : complete_lattice (has_norm string_imp)) : is_compactly_generated (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_112466 (h0 : complete_lattice (pseudo_metric_space pos)) : is_compactly_generated (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_112467 (h1 : group linarith.comp_source) : group.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_112468 (h0 : functor.add_const (list (finset linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112469 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : topological_space.separable_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_112470 (h0 : functor.add_const (group (complete_distrib_lattice Type)) linarith.comp) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112471 (h0 : list (linear_ordered_comm_group (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112472 (h0 : functor.add_const (complete_lattice (semiring empty)) empty) : @is_compactly_generated.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112473 (h0 : functor.add_const (list (ordered_ring num)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112474 (h1 : complete_lattice (linear_ordered_add_comm_group fun_info)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_112475 (h0 : topological_space (semiring num)) : t1_space (semiring num) := sorry --non-trivial
lemma new_lemma_112476 (h0 : topological_space (cancel_monoid num)) : t0_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_112477 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) name) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112478 (h0 : functor.add_const (topological_space (has_Sup unsigned)) congr_arg_kind) : @t0_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112479 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (ring (ring (ring Type))))) : archimedean (ordered_comm_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_112480 (h3 : complete_lattice (normed_field to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112481 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) num) : @preirreducible_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_112482 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (ordered_ring (has_Inf Type))) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} linarith.comp)) (ordered_ring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_112483 (h0 : topological_space (has_to_string name)) : locally_compact_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_112484 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112485 (h0 : add_monoid (has_add environment.implicit_infer_kind)) : add_monoid.fg (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_112486 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (finset linarith.comp)) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112487 (h0 h1 : multiset (semi_normed_ring linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_112488 (h0 : fin has_zero.zero) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_112489 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_112490 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : regular_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_112491 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112492 (h0 : uniform_space (comm_semigroup (sub_neg_monoid (has_Inf real)))) : separated_space (comm_semigroup (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_112493 (h0 : complete_lattice (has_to_string (finset (normed_comm_ring Type)))) : is_compactly_generated (has_to_string (finset (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_112494 (h0 : ring (left_cancel_monoid congr_arg_kind)) : rank_condition (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112495 (h2 : not (ring (has_append fun_info) -> false)) : @rank_condition.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_112496 (h0 : functor.add_const (topological_space (add_comm_monoid ennreal)) name) : @discrete_topology.{0} (add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_112497 (h0 : topological_space (has_pos_part (has_pos_part (has_add pos)))) : loc_path_connected_space (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_112498 (h0 : topological_space (semiring (preorder congr_arg_kind))) : path_connected_space (semiring (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112499 (h0 : functor.add_const (add_monoid (has_zero name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112500 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112501 (h0 : functor.add_const (topological_space (add_right_cancel_monoid unsigned)) unsigned) : @t0_space.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112502 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_112503 (h2 : topological_space (normed_field (random_gen char))) : totally_disconnected_space (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_112504 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen char)))) : is_cyclic (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_112505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_112506 (h0 : ring (nondiscrete_normed_field (group linarith.ineq))) : strong_rank_condition (nondiscrete_normed_field (group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112507 (h0 : not (ring (mul_one_class linarith.ineq) -> false)) : @is_domain.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_112508 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_112509 (h0 : function.extfun Type (functor.add_const (group (omega_complete_partial_order empty)))) : @normalizer_condition.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_112510 (h0 : topological_space (with_bot empty)) : normal_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_112511 (h1 : complete_lattice (has_emptyc to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112512 (h0 : ordered_comm_monoid (has_add (option unsigned))) : has_exists_mul_of_le (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_112513 (h0 : not (has_mem.mem fun_info has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_112514 (h0 : monoid (has_add (has_add environment.implicit_infer_kind))) : monoid.fg (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112515 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112516 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_112517 (h0 : complete_lattice (has_norm (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_112518 (h0 : functor.add_const (group (normed_comm_ring unsigned)) congr_arg_kind) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112519 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_112520 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @normal_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_112521 (h0 : monoid (has_add (has_add real))) : monoid.fg (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_112522 (h0 : list (comm_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112523 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid Type))) : totally_separated_space (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_112524 (h0 : finset (has_Inf (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112525 (h0 : not (topological_space (fintype fun_info) -> false)) : @t0_space.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_112526 (h0 : topological_space (topological_space (has_nnnorm linarith.ineq))) : path_connected_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112527 (h0 : not (topological_space (normed_field to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_112528 (h0 : uniform_space (div_inv_monoid (with_zero linarith.ineq))) : complete_space (div_inv_monoid (with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112529 (h2 : uniform_space (distrib (comm_ring char))) : complete_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_112530 (h0 : complete_lattice (has_inter (option unsigned))) : is_compactly_generated (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_112531 (h0 : topological_space (add_group (semiring (semiring (semiring num))))) : normal_space (add_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_112532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112533 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_112534 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_112535 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @totally_disconnected_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112536 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_112537 (h0 : topological_space (option (option unsigned))) : totally_separated_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_112538 (h0 : topological_space (add_cancel_monoid (option unsigned))) : preconnected_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_112539 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_112540 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_112541 (h0 : group (left_cancel_semigroup empty)) : is_cyclic (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_112542 (h0 : functor.add_const (add_group (cancel_monoid name)) name) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_112543 (h0 : ring (with_one (has_top (has_top linarith.ineq)))) : is_domain (with_one (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_112544 (h0 : functor.add_const (uniform_space (add_cancel_monoid name)) Type) : @complete_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_112545 (h0 : uniform_space (normed_comm_ring (has_nndist name))) : complete_space (normed_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_112546 (h0 : not (ring (random_gen bool) -> false)) : @strong_rank_condition.{0} (random_gen.{0} bool) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} bool)) h0)  := sorry --non-trivial
lemma new_lemma_112547 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_112548 (h0 : add_group (nondiscrete_normed_field std_gen)) : is_add_cyclic (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_112549 (h4 : uniform_space (semi_normed_ring linarith.ineq)) : complete_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_112550 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_112551 (h0 : ring (finset (finset environment.implicit_infer_kind))) : is_domain (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112552 (h0 : group (semigroup unsigned)) : group.fg (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_112553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112554 (h1 : ring (comm_ring char)) : rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_112555 (h0 : ring (canonically_linear_ordered_monoid (has_add real))) : strong_rank_condition (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_112556 (h0 : topological_space (has_one (semiring linarith.comp))) : normal_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_112557 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_112558 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_neg Type)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_112559 (h0 : topological_space (has_neg (has_neg (finset pos)))) : t1_space (has_neg (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_112560 (h0 : semiring (complete_linear_order unsigned)) : is_noetherian_ring (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_112561 (h0 : add_monoid (left_cancel_semigroup (semiring (semiring (semiring empty))))) : add_monoid.fg (left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_112562 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112563 (h0 : ring (complete_distrib_lattice (has_pos_part (has_add pos)))) : rank_condition (complete_distrib_lattice (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_112564 (h0 : topological_space (measurable_space (semiring empty))) : path_connected_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_112565 (h0 : functor.comp ring canonically_ordered_comm_semiring unsigned) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_112566 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @locally_compact_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_112567 (h0 : functor.add_const (function.extfun nat fin) Type) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_112568 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (has_neg (has_neg (has_neg linarith.comp)))) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (has_neg.{0} (has_neg.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_112569 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_112570 (h0 : topological_space (normed_comm_ring (has_add name))) : topological_space.separable_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_112571 (h0 : list (ordered_comm_monoid (finset (ring (has_pos_part Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112572 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112573 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) pos) pos) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_112574 (h0 : filter (has_one (semiring (semiring (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112575 (h0 : topological_space (has_nndist ennreal)) : discrete_topology (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_112576 (h0 : complete_lattice (has_lt (metric_space (metric_space char)))) : is_compactly_generated (has_lt (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_112577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_112578 (h0 : topological_space (ordered_comm_monoid pos)) : regular_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_112579 (h0 : topological_space (with_bot empty)) : locally_compact_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_112580 (h0 : monoid (random_gen num)) : monoid.fg (random_gen num) := sorry --non-trivial
lemma new_lemma_112581 (h0 : ring (cancel_monoid (has_add (has_add Type)))) : rank_condition (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_112582 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_112583 (h0 : uniform_space (topological_space rat)) : complete_space (topological_space rat) := sorry --non-trivial
lemma new_lemma_112584 (h0 : topological_space (with_bot linarith.comp)) : totally_separated_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_112585 (h0 : functor.add_const (finset (has_add linarith.comp)) (has_Inf (finset Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112586 (h0 : topological_space (linear_ordered_semiring unsigned)) : normal_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_112587 (h0 : not (complete_lattice (topological_space linarith.comp_source) -> false)) : is_compactly_generated (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_112588 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add Type)))) : preirreducible_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_112589 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_112590 (h0 : add_group (has_lt reducibility_hints)) : is_add_cyclic (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_112591 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112592 (h0 : topological_space (has_Inf (has_neg name))) : totally_disconnected_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_112593 (h0 : functor.add_const (ring (has_add linarith.comp)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112594 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112595 (h0 : functor.add_const (ordered_comm_monoid pos) (finset (finset (finset Type)))) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} pos) (finset.{1} (finset.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_112596 (h0 : complete_lattice (pseudo_metric_space num)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_112597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_112598 (h0 : add_group (has_nnnorm (has_nnnorm string_imp))) : is_add_cyclic (has_nnnorm (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_112599 (h0 : ring (cancel_monoid (has_add Type))) : is_domain (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_112600 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : topological_space.separable_space ennreal := sorry --non-trivial
lemma new_lemma_112601 (h0 : add_monoid (complete_distrib_lattice Type)) : add_monoid.fg (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_112602 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_112603 (h0 : ordered_comm_monoid (has_Inf (has_neg (has_neg (has_neg (has_neg (has_neg pos))))))) : has_exists_mul_of_le (has_Inf (has_neg (has_neg (has_neg (has_neg (has_neg pos)))))) := sorry --non-trivial
lemma new_lemma_112604 (h0 : functor.add_const (filter (has_add pos)) (has_neg (mul_one_class Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112605 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : irreducible_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_112606 (h0 : filter (normed_group (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112607 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : irreducible_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_112608 (h0 : topological_space (dlist linarith.ineq)) : t0_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_112609 (h0 : semiring (finset (has_add (has_add (has_to_string name))))) : is_noetherian_ring (finset (has_add (has_add (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_112610 (h0 : not (topological_space (with_bot to_additive.value_type) -> false)) : @discrete_topology.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_112611 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_112612 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112613 (h0 : ring (semiring (semiring unsigned))) : is_principal_ideal_ring (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_112614 (h0 : monoid (finset ennreal)) : monoid.fg (finset ennreal) := sorry --non-trivial
lemma new_lemma_112615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_112616 (h0 : group (has_zero environment.implicit_infer_kind)) : is_simple_group (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_112617 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112618 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) (ring (finset linarith.comp))) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_112619 (h0 : has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_112620 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112621 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112622 (h0 : topological_space (boolean_algebra.core pos)) : regular_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_112623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112624 (h0 : uniform_space nnreal) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_112625 (h0 : function.extfun Type group) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_112626 (h0 : add_group (linear_order (option (option (option (option (option empty))))))) : is_add_cyclic (linear_order (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_112627 (h0 : complete_lattice (linear_ordered_comm_group num)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_112628 (h0 : uniform_space (complete_semilattice_Sup (has_norm num))) : separated_space (complete_semilattice_Sup (has_norm num)) := sorry --non-trivial
lemma new_lemma_112629 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_112630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_112631 (h0 : ring (finset (has_add (has_Inf pos)))) : is_principal_ideal_ring (finset (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_112632 (h0 : topological_space (has_neg (has_pos_part (has_add (has_Inf pos))))) : discrete_topology (has_neg (has_pos_part (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_112633 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112634 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112635 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_112636 (h0 h1 : multiset ereal) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_112637 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem multiset)) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type multiset.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) multiset.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) multiset.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) Prop)  := sorry --non-trivial
lemma new_lemma_112638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_112639 (h0 : functor.add_const (topological_space (linear_ordered_comm_group Type)) linarith.comp) : @locally_compact_space.{1} (linear_ordered_comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (linear_ordered_comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112640 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_112641 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf Type)))) : sequential_space (add_cancel_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_112642 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option unsigned))) : archimedean (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_112643 (h0 : add_group (mul_one_class to_additive.value_type)) (h1 : add_subgroup (mul_one_class to_additive.value_type)) : add_subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_112644 (h0 : topological_space (simple_graph (ring Type))) : totally_disconnected_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_112645 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) ennreal) : @regular_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_112646 (h0 : functor.add_const (semiring (has_nndist pos)) (has_to_string (boolean_algebra Type))) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (has_nndist.{0} pos)) (has_to_string.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_112647 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_112648 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112649 (h0 : functor.add_const (complete_lattice (simple_graph pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112650 (h0 : add_group (linear_ordered_comm_group empty)) : is_add_cyclic (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_112651 (h0 : add_group (denumerable congr_arg_kind)) : is_add_cyclic (denumerable congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112652 (h0 : topological_space (boolean_algebra (boolean_algebra (has_add name)))) : normal_space (boolean_algebra (boolean_algebra (has_add name))) := sorry --non-trivial
lemma new_lemma_112653 (h0 : functor.comp topological_space has_to_string name) : @t1_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_112654 (h0 h1 h2 : Prop) : @equiv.swap_core.{1} Prop (λ (a b : Prop), @eq.decidable.{0} Prop Prop.linear_order a b) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_112655 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top congr_arg_kind)) : discrete_topology (linear_ordered_add_comm_monoid_with_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112656 (h1 : not (monoid (normed_group fun_info) -> false)) : @monoid.fg.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_112657 (h0 : topological_space (has_nndist (mul_zero_class pos))) : regular_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_112658 (h0 : not (topological_space (with_zero fun_info) -> false)) : @path_connected_space.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_112659 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_112660 (h0 : topological_space (sub_neg_monoid Type)) : totally_disconnected_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_112661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_112662 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) (has_neg (has_neg (add_cancel_monoid Type)))) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (add_cancel_monoid.{1} Type)) (has_neg.{1} (has_neg.{1} (add_cancel_monoid.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_112663 (h0 : ring (has_pos_part (complete_distrib_lattice num))) : rank_condition (has_pos_part (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_112664 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_112665 (h0 : topological_space (add_group (semiring (semiring empty)))) : path_connected_space (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_112666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_112667 (h0 : functor.add_const (complete_lattice (free_add_monoid num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_112668 (h0 : group (with_one fun_info)) : normalizer_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_112669 (h1 : not (ring (semiring num) -> false)) : @strong_rank_condition.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_112670 (h0 : group (boolean_algebra (has_add (has_add (comm_group ennreal))))) : is_simple_group (boolean_algebra (has_add (has_add (comm_group ennreal)))) := sorry --non-trivial
lemma new_lemma_112671 (h0 : monoid (normed_comm_ring (has_neg linarith.comp))) : monoid.fg (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_112672 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_112673 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : t0_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_112674 (h0 : ulower pnat) (h1 : list (ulower pnat)) (h2 : pnat) : pnat.coprime (ulower.up (list.ilast' h0 h1)) h2 := sorry --non-trivial
lemma new_lemma_112675 (h1 h2 : multiset (simple_graph linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_112676 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_112677 (h0 : topological_space (measurable_space (random_gen string_imp))) : path_connected_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_112678 (h0 : ring (semigroup (option (option (option unsigned))))) : strong_rank_condition (semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_112679 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_112680 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112681 (h1 : add_group (has_nnnorm reducibility_hints)) : is_add_cyclic (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_112682 (h0 : functor.add_const (prod (partial_order congr_arg_kind) (partial_order congr_arg_kind)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112683 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_112684 (h0 : topological_space (has_Inf (ordered_ring name))) : preirreducible_space (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_112685 (h0 : ordered_add_comm_monoid (finset (has_add (has_Inf Type)))) : archimedean (finset (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_112686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_112687 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112688 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (finset pos)) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112689 (h0 : topological_space (ordered_ring (semiring empty))) : totally_separated_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_112690 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @t0_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112691 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_112692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_112693 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_112694 (h0 : functor.add_const (complete_lattice (has_to_string Type)) Type) : @is_atomistic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_112695 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112696 (h0 : complete_lattice (has_star (semiring unsigned))) : is_atomistic (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_112697 (h1 : complete_lattice (measurable_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_112698 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) (has_neg pos)) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112699 (h0 : ring (add_comm_semigroup environment.projection_info)) : is_domain (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_112700 (h0 : functor.add_const (topological_space (has_neg Type)) (has_to_string Type)) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_112701 (h0 : monoid (comm_monoid (option unsigned))) : monoid.fg (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_112702 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112703 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_112704 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_112706 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) (finset linarith.comp)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_112707 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_add pos))) : archimedean (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_112708 (h0 : functor.add_const (group (has_neg_part Type)) name) : @normalizer_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_112709 (h0 : ring (normed_field (has_nnnorm (random_gen (has_nnnorm reducibility_hints))))) : rank_condition (normed_field (has_nnnorm (random_gen (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_112710 (h0 : topological_space (option (plift complex))) : path_connected_space (option (plift complex)) := sorry --non-trivial
lemma new_lemma_112711 (h0 : add_monoid (has_star unsigned)) : add_monoid.fg (has_star unsigned) := sorry --non-trivial
lemma new_lemma_112712 (h0 : not (function.extfun (finset Type) (has_mem.mem congr_arg_kind) -> false)) : @is_compactly_generated.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_112713 (h0 : add_monoid (option (semiring (semiring (semiring congr_arg_kind))))) : add_monoid.fg (option (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_112714 (h1 : complete_lattice (has_top (has_ssubset (has_ssubset to_additive.value_type)))) : is_compactly_generated (has_top (has_ssubset (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_112715 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112716 (h0 : complete_lattice (has_compl (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_112717 (h0 : functor.add_const (filter (has_zero (comm_group pos))) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112718 (h1 : topological_space (mul_one_class (normed_field environment.projection_info))) : t0_space (mul_one_class (normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_112719 (h0 : not (topological_space (lattice (has_nnnorm (has_nnnorm linarith.ineq))) -> false)) : @t0_space.{0} (lattice.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (lattice.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_112720 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @t0_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_112721 (h0 : topological_space (simple_graph (has_Inf (has_pos_part pos)))) : irreducible_space (simple_graph (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_112722 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_112723 (h0 : group (encodable (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : is_cyclic (encodable (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_112724 (h0 : functor.add_const (semiring (semigroup name)) name) : @is_noetherian_ring.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_112725 (h0 : functor.add_const (semiring (complete_distrib_lattice pos)) linarith.comp) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112726 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg name)) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} name) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_112727 (h0 : topological_space (non_assoc_semiring num)) : totally_separated_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_112728 (h0 : function.extfun nat fin) : @monoid.fg.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_112729 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add pos)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_112730 (h0 : ring (dlist (random_gen fun_info))) : is_domain (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_112731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112732 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112733 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112734 (h0 : ring (has_norm (random_gen (random_gen string_imp)))) : is_domain (has_norm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_112735 (h0 : topological_space (measurable_space (has_top to_additive.value_type))) : path_connected_space (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_112736 (h0 : functor.add_const (filter (has_Inf pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112737 (h0 : ring (add_cancel_monoid num)) : rank_condition (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_112738 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112739 (h0 : ordered_comm_monoid (mul_zero_class (has_neg_part (finset ennreal)))) : has_exists_mul_of_le (mul_zero_class (has_neg_part (finset ennreal))) := sorry --non-trivial
lemma new_lemma_112740 (h0 : function.extfun (Type 1) (functor.comp uniform_space has_neg)) : @separated_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} has_neg.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} uniform_space.{1} has_neg.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_112741 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112742 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.ineq))) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_112743 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112744 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_112745 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112746 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_112747 (h0 : topological_space (left_cancel_semigroup (option unsigned))) : totally_disconnected_space (left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_112748 (h0 : not (add_monoid (with_bot empty) -> false)) : @add_monoid.fg.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112749 (h0 : semiring (has_top (has_norm empty))) : is_noetherian_ring (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_112750 (h0 : topological_space (has_lt fun_info)) (h1 : preorder (has_lt fun_info)) : order_topology (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_112751 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_112752 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @complete_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_112753 (h0 : complete_lattice (linear_ordered_add_comm_group linarith.ineq)) : is_atomistic (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_112754 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112755 (h0 : add_group (encodable fun_info)) : is_add_cyclic (encodable fun_info) := sorry --non-trivial
lemma new_lemma_112756 (h0 : filter (add_monoid (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_112758 (h0 : finset (ordered_cancel_add_comm_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112759 (h0 : topological_space (has_add ennreal)) : preirreducible_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_112760 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_112761 (h0 : topological_space (has_one (semiring (has_norm empty)))) : discrete_topology (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_112762 (h0 : topological_space (with_zero linarith.comp_source)) : totally_disconnected_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_112763 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112764 (h0 : uniform_space (has_zero (has_to_string Type))) : separated_space (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_112765 (h0 : topological_space (finset (add_comm_monoid Type))) : topological_space.separable_space (finset (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_112766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_112767 (h0 : topological_space (with_one (has_top (has_top (has_top num))))) : path_connected_space (with_one (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_112768 (h0 : topological_space (has_star congr_arg_kind)) : preirreducible_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112769 (h0 : complete_lattice (has_neg (finset (finset (finset (finset environment.implicit_infer_kind)))))) : is_compactly_generated (has_neg (finset (finset (finset (finset environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_112770 (h0 : ring (has_to_string unsigned)) : is_domain (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_112771 (h0 : topological_space (semigroup (finset (ring Type)))) : regular_space (semigroup (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_112772 (h0 : group (denumerable (has_nnnorm char))) : is_cyclic (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_112773 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : topological_space.separable_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_112774 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112775 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_112776 (h0 : topological_space (boolean_algebra (boolean_algebra stieltjes_function))) : normal_space (boolean_algebra (boolean_algebra stieltjes_function)) := sorry --non-trivial
lemma new_lemma_112777 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @sequential_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_112778 (h0 : complete_lattice (set.set_semiring (semiring empty))) : is_atomistic (set.set_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_112779 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_112780 (h0 : complete_lattice (preorder (option empty))) : is_compactly_generated (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_112781 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_112782 (h0 : uniform_space (has_zero (boolean_algebra linarith.comp))) : separated_space (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_112783 (h0 : topological_space (has_nndist (finset (has_nndist name)))) : preirreducible_space (has_nndist (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_112784 (h0 : functor.add_const (add_group (ring Type)) (has_to_string (has_add (has_to_string unsigned)))) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ring.{1} Type)) (has_to_string.{0} (has_add.{0} (has_to_string.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_112785 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_112786 (h0 : topological_space (finset (has_add name))) : preirreducible_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_112787 (h0 : topological_space (add_group (has_one congr_arg_kind))) : path_connected_space (add_group (has_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112788 (h0 : add_group (ring (finset (mul_one_class (mul_one_class Type))))) : is_add_cyclic (ring (finset (mul_one_class (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_112789 (h0 : ring (boolean_algebra.core (has_neg_part Type))) : is_principal_ideal_ring (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_112790 (h0 : complete_lattice (has_add (has_neg linarith.comp))) : is_atomistic (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_112791 (h0 : has_add Type -> char) (h1 : coe_sort (set.range h0)) (h2 : set Type) : @right_add_coset.{1} Type (@set.range_splitting.{1 0} (has_add.{1} Type) char h0 h1) h2 (add_semigroup.{0} std_gen) enat  := sorry --non-trivial
lemma new_lemma_112792 (h0 : group (random_gen (mul_one_class (mul_one_class fun_info)))) : is_cyclic (random_gen (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_112793 (h0 : add_monoid (add_cancel_monoid (has_add (has_add (has_add name))))) : add_monoid.fg (add_cancel_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_112794 (h0 : complete_lattice (normed_group (random_gen (with_bot string_imp)))) : is_atomistic (normed_group (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_112795 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_112796 (h0 : list (distrib_lattice (has_top (random_gen (has_nnnorm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112797 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (has_add.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (has_add.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_112798 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112799 (h0 : ring (topological_space (has_lt (denumerable linarith.ineq)))) : strong_rank_condition (topological_space (has_lt (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_112800 (h0 : topological_space (ring num)) : normal_space (ring num) := sorry --non-trivial
lemma new_lemma_112801 (h0 : complete_lattice (normed_group (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_112802 (h0 : group (add_comm_monoid (finset Type))) : group.fg (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_112803 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_112804 (h0 : function.extfun (monoid (boolean_algebra.core ennreal)) (fun (x : monoid (boolean_algebra.core ennreal)), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (monoid.{0} (boolean_algebra.core.{0} ennreal)) (@function.extfun_app.{1 1} (monoid.{0} (boolean_algebra.core.{0} ennreal)) (λ (x : monoid.{0} (boolean_algebra.core.{0} ennreal)), Prop) h0)  := sorry --non-trivial
lemma new_lemma_112805 (h0 : functor.add_const (cancel_comm_monoid_with_zero (option unsigned)) pos) : @unique_factorization_monoid.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (option.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_112806 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112807 (h0 h1 : multiset (add_comm_semigroup (mul_one_class char))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_112808 (h0 : ordered_add_comm_monoid (normed_comm_ring (option ennreal))) : archimedean (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_112809 (h1 : has_neg (mul_one_class char)) (h2 : measurable_space (mul_one_class char)) : has_measurable_neg (mul_one_class char) := sorry --non-trivial
lemma new_lemma_112810 (h0 : topological_space (normed_comm_ring (has_neg pos))) : loc_path_connected_space (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_112811 (h1 : complete_lattice (has_append to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112812 (h0 : topological_space (generalized_boolean_algebra (finset Type))) : preconnected_space (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_112813 (h0 : topological_space (metric_space (semiring (semiring (semiring (semiring linarith.comp)))))) : irreducible_space (metric_space (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_112814 (h0 : add_group (has_inner empty unsigned)) : is_add_cyclic (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_112815 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) semiring.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_112816 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112818 (h0 : group (has_zero num)) : is_simple_group (has_zero num) := sorry --non-trivial
lemma new_lemma_112819 (h0 : add_group (ordered_ring (semiring (semiring empty)))) : is_add_cyclic (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_112820 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_112821 (h0 : ring (has_zero (finset (finset Type)))) : is_principal_ideal_ring (has_zero (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_112822 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_112823 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : totally_disconnected_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_112824 (h0 : functor.add_const (finset (boolean_algebra name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112826 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_112827 (h0 : monoid (measure_theory.measure_space (semiring congr_arg_kind))) : monoid.fg (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112828 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_112829 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_neg (ring name)))) : archimedean (add_cancel_monoid (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_112830 (h1 : list (has_emptyc (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_112831 (h0 : topological_space (linear_ordered_semiring (has_top (semiring empty)))) : t0_space (linear_ordered_semiring (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_112832 (h0 : topological_space (semigroup (semigroup Type))) : t1_space (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_112833 (h0 : uniform_space real) : separated_space real := sorry --non-trivial
lemma new_lemma_112834 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (div_inv_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (div_inv_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112835 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_112836 (h0 : functor.comp topological_space normed_comm_ring pos) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_112837 (h0 : ordered_comm_monoid (has_bot (has_add name))) : has_exists_mul_of_le (has_bot (has_add name)) := sorry --non-trivial
lemma new_lemma_112838 (h0 : complete_lattice (has_star unsigned)) : is_compactly_generated (has_star unsigned) := sorry --non-trivial
lemma new_lemma_112839 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_112840 (h3 : ring (add_comm_semigroup (mul_one_class (mul_one_class (mul_one_class ereal))))) : strong_rank_condition (add_comm_semigroup (mul_one_class (mul_one_class (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_112841 (h0 : complete_lattice (add_group unsigned)) : complete_lattice.is_Sup_finite_compact (add_group unsigned) := sorry --non-trivial
lemma new_lemma_112842 (h0 : functor.add_const (finset (complete_distrib_lattice Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112843 (h0 : list (group_with_zero congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_112844 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_112845 (h0 : group (canonically_ordered_comm_semiring linarith.comp)) : is_cyclic (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_112846 (h0 : not (add_group (semiring empty) -> false)) : @is_add_cyclic.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112847 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_112848 (h0 : list (canonically_ordered_comm_semiring (option (option name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112849 (h0 : add_group (has_neg (boolean_algebra.core pos))) : is_add_cyclic (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_112850 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} (has_inv.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_112851 (h0 : topological_space (has_div to_additive.value_type)) : totally_disconnected_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112852 (h0 : topological_space (has_nndist (has_neg ennreal))) : loc_path_connected_space (has_nndist (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_112853 (h0 : group (has_zero num)) : group.fg (has_zero num) := sorry --non-trivial
lemma new_lemma_112854 (h0 : group (has_nnnorm (linear_ordered_add_comm_group fun_info))) : group.fg (has_nnnorm (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_112855 (h0 : topological_space (has_top (has_norm to_additive.value_type))) : path_connected_space (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_112856 (h0 : topological_space (has_inv (random_gen (has_top linarith.ineq)))) : totally_separated_space (has_inv (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_112857 (h0 : ring (monoid_with_zero (option num))) : strong_rank_condition (monoid_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_112858 (h0 : topological_space (has_nndist (option congr_arg_kind))) : totally_separated_space (has_nndist (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112859 (h0 : finset (bin_tree (option (option (option (option (option (option unsigned)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112860 (h1 : has_lt (mul_one_class (mul_one_class enat))) : no_max_order (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_112861 (h1 : ring (semiring (random_gen (has_top linarith.ineq)))) : is_domain (semiring (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_112862 (h0 : monoid (add_comm_monoid pos)) : monoid.fg (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_112863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112864 (h0 : topological_space (has_ssubset (random_gen (has_add (random_gen char))))) : totally_disconnected_space (has_ssubset (random_gen (has_add (random_gen char)))) := sorry --non-trivial
lemma new_lemma_112865 (h0 : topological_space (semigroup (finset (boolean_algebra (has_to_string Type))))) : normal_space (semigroup (finset (boolean_algebra (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_112866 (h0 : monoid (normed_comm_ring name)) : monoid.fg (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_112867 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_112868 (h0 : topological_space (partial_order (option (option (option unsigned))))) : locally_compact_space (partial_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_112869 (h0 : uniform_space (has_Inf (has_add (has_add (has_Inf real))))) : separated_space (has_Inf (has_add (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_112870 (h1 : topological_space (measurable_space (has_norm congr_arg_kind))) : totally_separated_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_112871 (h0 : add_group (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : is_add_cyclic (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_112872 (h0 : topological_space (metric_space (semiring empty))) : discrete_topology (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_112873 (h3 : complete_lattice (normed_field char)) : complete_lattice.is_Sup_finite_compact (normed_field char) := sorry --non-trivial
lemma new_lemma_112874 (h0 : list (topological_space (distrib_lattice to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112875 (h0 : functor.add_const (topological_space nnreal) unsigned) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_112876 (h0 : topological_space (add_right_cancel_monoid (semiring num))) : preirreducible_space (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_112877 (h0 : topological_space (semiring (has_norm empty))) : totally_disconnected_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_112878 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @preirreducible_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_112879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112880 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) (option (option empty))) : @rank_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112881 (h0 : semiring (add_group linarith.comp)) (h1 : semiring (add_group (polynomial (add_group linarith.comp)))) : is_noetherian_ring (add_group (polynomial (add_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_112882 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_112883 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid environment.implicit_infer_kind)) ennreal) : @unique_factorization_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_112884 (h1 : not (complete_lattice (has_nnnorm linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_112885 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @normal_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_112886 (h0 : functor.add_const (finset (ring linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112887 (h1 : not (topological_space (normed_field reducibility_hints) -> false)) : @path_connected_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_112888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_112889 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_112890 (h0 : has_mem.mem linarith.ineq has_emptyc.emptyc) : @is_domain.{0} linarith.ineq (@finset.pi.empty.{1 0} Type ring.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_112891 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : preirreducible_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_112892 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_112893 (h0 : ordered_comm_monoid (has_pos_part (canonically_linear_ordered_monoid Type))) : has_exists_mul_of_le (has_pos_part (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_112894 (h0 : functor.add_const (ring (has_zero pos)) environment.implicit_infer_kind) : @is_domain.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112895 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_112896 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_112897 (h0 : functor.add_const (ring (has_nndist linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112898 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_112899 (h0 : functor.add_const (group (has_zero Type)) (has_neg pos)) : @group.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_112900 (h0 : group (div_inv_monoid fun_info)) : is_cyclic (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_112901 (h0 : set (has_lt linarith.comp_source)) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_112902 (h0 : group (add_comm_monoid (option (option empty)))) : normalizer_condition (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_112903 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_112904 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_112905 (h0 : topological_space (fintype (random_gen linarith.ineq))) : t0_space (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_112906 (h0 : has_mem.mem (linear_ordered_semiring (semiring empty)) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_112907 (h0 : functor.add_const (group (ordered_comm_ring Type)) linarith.comp) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112908 (h0 : ring (add_comm_monoid real)) : is_domain (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_112909 (h6 : set (ereal -> add_comm_semigroup ereal)) : set.separates_points h6 := sorry --non-trivial
lemma new_lemma_112910 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_112911 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) pos) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_112912 (h0 : topological_space (plift unsigned)) : normal_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_112913 (h0 : group (has_dist ennreal)) : is_cyclic (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_112914 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_112915 (h0 : topological_space (comm_semigroup real)) : totally_separated_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_112916 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112917 (h0 : topological_space (with_one (semiring (semiring empty)))) : path_connected_space (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_112918 (h0 : ring (add_cancel_monoid (has_Inf Type))) : is_domain (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_112919 (h0 : fintype linarith.comp -> num -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_112920 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_112921 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_112922 (h0 : topological_space (has_pos_part (finset linarith.comp))) : discrete_topology (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_112923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_112924 (h0 : finset (has_zero (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_112925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_112926 (h0 : functor.add_const (add_group (ordered_comm_ring pos)) linarith.comp) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_112927 (h0 : functor.add_const (group (has_Inf name)) name) : @is_cyclic.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_112928 (h0 : add_monoid (boolean_algebra (add_comm_monoid name))) : add_monoid.fg (boolean_algebra (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_112929 (h0 : functor.add_const (complete_lattice (ring Type)) Type) : @is_atomistic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_112930 (h0 : functor.add_const (list (add_cancel_monoid Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112931 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_112932 (h2 : ring (distrib_lattice string_imp)) : rank_condition (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_112933 (h0 : semiring (has_add (has_add (has_bot (has_bot real))))) : is_noetherian_ring (has_add (has_add (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_112934 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_112935 (h0 : topological_space (has_top (measurable_space fun_info))) : totally_separated_space (has_top (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_112936 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @discrete_topology.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_112937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112938 (h0 : ring (simple_graph (has_pos_part linarith.comp))) : is_principal_ideal_ring (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_112939 (h0 : ring (non_assoc_semiring (option empty))) : is_principal_ideal_ring (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_112940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112941 (h0 : add_group (add_group (has_top (semiring (has_top (has_top (has_top (has_top fun_info)))))))) : is_add_cyclic (add_group (has_top (semiring (has_top (has_top (has_top (has_top fun_info))))))) := sorry --non-trivial
lemma new_lemma_112942 (h0 : topological_space (has_pos_part (sub_neg_monoid real))) : totally_disconnected_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_112943 (h0 : functor.add_const (topological_space (finset unsigned)) (has_neg congr_arg_kind)) : @irreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (has_neg.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_112944 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) unsigned) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_112945 (h0 : not (complete_lattice (uniform_space linarith.ineq) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_112946 (h0 : group (metric_space unsigned)) : normalizer_condition (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_112947 (h1 : complete_lattice (distrib (random_gen (random_gen reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (distrib (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_112948 (h0 : topological_space (add_right_cancel_monoid (has_top unsigned))) : path_connected_space (add_right_cancel_monoid (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_112949 (h1 : topological_space (add_comm_semigroup fun_info)) (h2 : add_group (add_comm_semigroup fun_info)) : topological_add_group (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_112950 (h0 : functor.add_const (monoid (complete_semilattice_Sup linarith.ineq)) (random_gen linarith.comp_source)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@functor.add_const.run.{0 0} (monoid.{0} (complete_semilattice_Sup.{0} linarith.ineq)) (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_112951 (h0 : topological_space (random_gen to_additive.value_type)) : discrete_topology (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_112952 (h0 : topological_space (pseudo_emetric_space (option unsigned))) : normal_space (pseudo_emetric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_112953 (h0 : functor.add_const (uniform_space (has_add pos)) pos) : @separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112954 (h0 : topological_space (ordered_comm_ring (ring (has_add Type)))) : preirreducible_space (ordered_comm_ring (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_112955 (h0 : filter (has_edist (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_112956 (h1 : complete_lattice (has_nnnorm linarith.ineq)) : is_compactly_generated (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_112957 (h1 : topological_space (with_one string_imp)) : t0_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_112958 (h0 : topological_space (complete_semilattice_Sup (has_inv linarith.comp_source))) : t0_space (complete_semilattice_Sup (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_112959 (h0 : ring (plift (semiring empty))) : rank_condition (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_112960 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112961 (h0 : set (prod ereal ereal)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_112962 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_112963 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (is_R_or_C unsigned)) := sorry --non-trivial
lemma new_lemma_112964 (h0 : topological_space (complete_distrib_lattice (complete_distrib_lattice unsigned))) : normal_space (complete_distrib_lattice (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_112965 (h0 : ring (ordered_cancel_add_comm_monoid (option (option unsigned)))) : is_domain (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_112966 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid name)) (has_add (ring name))) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} name)) (has_add.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_112967 (h0 : group (boolean_algebra.core unsigned)) : normalizer_condition (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_112968 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_112969 (h0 : list (mul_zero_class name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_112970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_112971 (h0 : topological_space (linear_ordered_field ennreal)) : sequential_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_112972 (h0 : functor.add_const (group (comm_group linarith.comp)) pos) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_112973 (h0 : not (is_empty (has_neg reducibility_hints) -> false)) (h1 : has_neg reducibility_hints) : @path_connected_space.{0} (has_append.{0} linarith.ineq) (@is_empty.elim'.{1 1} (has_neg.{0} reducibility_hints) (topological_space.{0} (has_append.{0} linarith.ineq)) (@classical.by_contradiction'.{0} (is_empty.{1} (has_neg.{0} reducibility_hints)) h0) h1)  := sorry --non-trivial
lemma new_lemma_112974 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) pos) : @discrete_topology.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_112975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_112976 (h0 : topological_space (mul_one_class (add_comm_semigroup fun_info))) (h1 : add_group (mul_one_class (add_comm_semigroup fun_info))) : topological_add_group (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_112977 (h0 : ennreal -> ennreal -> Prop) : is_antisymm ennreal h0 := sorry --non-trivial
lemma new_lemma_112978 (h0 : add_group (normed_comm_ring congr_arg_kind)) : is_add_cyclic (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_112979 (h0 : linear_ordered_field ennreal -> linear_ordered_field ennreal -> Prop) : is_symm (linear_ordered_field ennreal) h0 := sorry --non-trivial
lemma new_lemma_112980 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @irreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_112981 (h0 : add_monoid (has_nndist (canonically_ordered_comm_semiring pos))) : add_monoid.fg (has_nndist (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_112982 (h0 : complete_lattice (has_append bool)) : complete_lattice.is_Sup_finite_compact (has_append bool) := sorry --non-trivial
lemma new_lemma_112983 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_112984 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : topological_space.separable_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_112985 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @path_connected_space.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_112986 (h0 : group (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : group.fg (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_112987 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_112988 (h0 : has_top linarith.comp_source -> to_additive.value_type -> Prop) : relator.left_unique h0 := sorry --non-trivial
lemma new_lemma_112989 (h0 : topological_space (add_cancel_monoid (has_add (has_neg (has_neg linarith.comp))))) : loc_path_connected_space (add_cancel_monoid (has_add (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_112990 (h0 : add_group (complete_semilattice_Sup (has_norm fun_info))) : is_add_cyclic (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_112991 (h0 : functor.add_const (semiring (has_neg linarith.comp)) Type) : @is_noetherian_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_112992 (h0 : topological_space (normed_comm_ring (finset (finset Type)))) : normal_space (normed_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_112993 (h0 : functor.add_const (list (semigroup name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112994 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_112995 (h0 : functor.add_const (filter (has_nndist Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112996 (h0 : topological_space (metric_space (semiring empty))) : locally_compact_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_112997 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_112998 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option empty))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_112999 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_113000 (h1 : group (with_one to_additive.value_type)) : is_cyclic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_113001 (h0 : cancel_comm_monoid_with_zero (has_neg (pseudo_metric_space Type))) : unique_factorization_monoid (has_neg (pseudo_metric_space Type)) := sorry --non-trivial
lemma new_lemma_113002 (h0 : functor.add_const (topological_space (finset pos)) (finset linarith.comp)) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_113003 (h0 : set (mul_one_class environment.projection_info)) (h1 : mul_one_class environment.projection_info) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_113004 (h0 : topological_space (has_bot real)) : regular_space (has_bot real) := sorry --non-trivial
lemma new_lemma_113005 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_113006 (h0 : topological_space (comm_group (option (option pos)))) : path_connected_space (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_113007 (h0 : uniform_space (simple_graph (boolean_algebra.core (ring Type)))) : complete_space (simple_graph (boolean_algebra.core (ring Type))) := sorry --non-trivial
lemma new_lemma_113008 (h0 : add_group (option (semiring congr_arg_kind))) : is_add_cyclic (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113009 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_113010 (h0 : topological_space (has_add (has_nndist Type))) : regular_space (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_113011 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_113012 (h0 : group (has_inter (option (option (option (option ennreal)))))) : is_cyclic (has_inter (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_113013 (h0 : group (canonically_ordered_comm_semiring (cancel_monoid (finset (finset ennreal))))) : is_simple_group (canonically_ordered_comm_semiring (cancel_monoid (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_113014 (h0 : ring (has_to_string (finset (finset linarith.comp)))) : strong_rank_condition (has_to_string (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_113015 (h0 : cancel_comm_monoid_with_zero (has_nndist Type)) : unique_factorization_monoid (has_nndist Type) := sorry --non-trivial
lemma new_lemma_113016 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra name)) pos) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_113017 (h0 : topological_space (has_zero (has_to_string ennreal))) : normal_space (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_113018 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113019 (h0 : topological_space (finset (finset name))) : regular_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_113020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113021 (h0 : topological_space (random_gen (semiring empty))) : locally_compact_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_113022 (h0 : functor.comp group add_comm_monoid Type) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113023 (h0 : ring (has_lt enat)) : is_domain (has_lt enat) := sorry --non-trivial
lemma new_lemma_113024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_113025 (h0 : complete_lattice (has_add (has_add pos))) : is_compactly_generated (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_113026 (h0 : topological_space (option unsigned)) : regular_space (option unsigned) := sorry --non-trivial
lemma new_lemma_113027 (h0 : function.extfun Type ring) : @is_domain.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_113028 (h0 : nat) (h1 : fin (nat.succ h0) -> Prop) (h2 : fin h0) : id (matrix.vec_tail h1 h2) := sorry --non-trivial
lemma new_lemma_113029 (h0 : ring (ring (finset (finset linarith.comp)))) : rank_condition (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_113030 (h0 : topological_space (add_cancel_comm_monoid (random_gen fun_info))) : totally_disconnected_space (add_cancel_comm_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_113031 (h0 : complete_lattice (partial_order empty)) : is_compactly_generated (partial_order empty) := sorry --non-trivial
lemma new_lemma_113032 (h0 : topological_space (has_add name)) : irreducible_space (has_add name) := sorry --non-trivial
lemma new_lemma_113033 (h0 : ring (normed_field (normed_field reducibility_hints))) : is_domain (normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_113034 (h1 : set (distrib linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_113035 (h0 : uniform_space (comm_semigroup real)) : separated_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_113036 (h2 : ring (complete_semilattice_Sup num)) : strong_rank_condition (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_113037 (h0 : topological_space (has_add (boolean_algebra name))) : t1_space (has_add (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_113038 (h0 : pseudo_metric_space (has_edist empty)) (h1 : add_monoid (has_edist empty)) : has_lipschitz_add (has_edist empty) := sorry --non-trivial
lemma new_lemma_113039 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_113040 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (has_neg_part (finset Type))) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} unsigned)) (has_neg_part.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113041 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_113042 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_113043 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) empty) : @t0_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_113044 (h0 : uniform_space (dlist (with_one string_imp))) : complete_space (dlist (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_113045 (h0 : ring (canonically_linear_ordered_monoid linarith.comp)) : strong_rank_condition (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_113046 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @monoid.fg.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_113047 (h0 : functor.comp topological_space has_zero name) : @t0_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113048 (h0 : functor.add_const (group (has_nndist Type)) linarith.comp) : @normalizer_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113049 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_113050 (h0 : ring (non_unital_non_assoc_semiring (linear_order fun_info))) (h1 : option (ring (non_unital_non_assoc_semiring (linear_order fun_info)))) : is_domain (non_unital_non_assoc_semiring (linear_order fun_info)) := sorry --non-trivial
lemma new_lemma_113051 (h0 : topological_space (with_one congr_arg_kind)) : path_connected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113052 (h0 : topological_space (with_one to_additive.value_type)) : irreducible_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_113053 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113054 (h0 : complete_lattice (canonically_ordered_monoid (has_neg name))) : is_compactly_generated (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_113055 (h0 : group (has_add unsigned)) : is_cyclic (has_add unsigned) := sorry --non-trivial
lemma new_lemma_113056 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) (has_pos_part pos)) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113057 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113058 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113059 (h0 : topological_space (normed_field (mul_one_class fun_info))) : t0_space (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_113060 (h0 : topological_space (distrib (has_ssubset (has_ssubset (has_nnnorm char))))) : path_connected_space (distrib (has_ssubset (has_ssubset (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_113061 (h2 : topological_space (random_gen (complete_semilattice_Sup (random_gen (has_norm (random_gen string_imp)))))) : t0_space (random_gen (complete_semilattice_Sup (random_gen (has_norm (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_113062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_113063 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113064 (h0 : functor.add_const (cancel_comm_monoid_with_zero (metric_space unsigned)) unsigned) : @unique_factorization_monoid.{0} (metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113065 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_113066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113067 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group pos)) name) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_113068 (h0 : function.extfun Type ring) : @is_domain.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113069 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_113070 (h0 : uniform_space (canonically_ordered_monoid (has_bot name))) : separated_space (canonically_ordered_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_113071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_113072 (h0 : topological_space (semigroup (has_add (has_add pos)))) : sequential_space (semigroup (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_113073 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_113074 (h4 : uniform_space (has_ssubset linarith.comp_source)) : complete_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113075 (h0 : not (uniform_space (linear_ordered_comm_ring empty) -> false)) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_113076 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring unsigned)) (option unsigned)) : @archimedean.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_113077 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @totally_disconnected_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113078 (h0 : list (bin_tree (semiring (semiring num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113079 (h0 : topological_space (has_top linarith.comp_source)) : locally_compact_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113080 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113081 (h0 : topological_space (distrib std_gen)) (h1 : preorder (distrib std_gen)) : order_topology (distrib std_gen) := sorry --non-trivial
lemma new_lemma_113082 (h0 : complete_lattice (ring (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_113083 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} fun_info))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_113084 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113086 (h0 : complete_lattice (denumerable (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_113087 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) environment.implicit_infer_kind) : @archimedean.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_113088 (h0 : group (topological_space fun_info)) : group.fg (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_113089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113090 (h0 : filter (topological_space (has_add fun_info))) : @path_connected_space.{0} (has_add.{0} fun_info) (@filter.Limsup.{0} (topological_space.{0} (has_add.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_add.{0} fun_info)) (@topological_space.complete_lattice.{0} (has_add.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_113091 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113092 (h0 : functor.add_const (group (complete_distrib_lattice Type)) linarith.comp) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113093 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_113094 (h0 : list pnat) (h1 : with_bot pnat) (h2 : ne h1 has_bot.bot) : pnat.coprime (list.head h0) (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_113095 (h0 : measurable_space ereal) (h2 : Prop) : measurable_set (id (fun (h1 : ereal), h2)) := sorry --non-trivial
lemma new_lemma_113096 (h0 : topological_space (semigroup (has_to_string linarith.comp))) : loc_path_connected_space (semigroup (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_113097 (h1 : ring (add_comm_semigroup enat)) : strong_rank_condition (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_113098 (h0 h1 : multiset (add_comm_semigroup char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_113099 (h0 : functor.add_const (topological_space (plift empty)) unsigned) : @totally_separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113101 (h0 : group (normed_group (semiring congr_arg_kind))) : group.fg (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113102 (h0 : string_imp -> ring (semi_normed_ring (mul_one_class char))) (h1 : not (ordinal -> false)) (h2 : has_lt.lt (classical.by_contradiction' h1) (ordinal.type well_ordering_rel)) : @strong_rank_condition.{0} (semi_normed_ring.{0} (mul_one_class.{0} char)) (@ordinal.bfamily_of_family.{0 0} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} char))) string_imp h0 (@classical.by_contradiction'.{2} ordinal.{0} h1) h2)  := sorry --non-trivial
lemma new_lemma_113103 (h0 : topological_space (has_emptyc linarith.comp_source)) : irreducible_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113104 (h0 : not (add_group (has_lt (mul_one_class char)) -> false)) : @is_add_cyclic.{0} (has_lt.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_113105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_113106 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @totally_separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113107 (h0 : not (group (metric_space num) -> false)) : @group.fg.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_113108 (h0 : topological_space (has_bot (has_Inf real))) : locally_compact_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_113109 (h0 : group (mul_zero_class (semiring unsigned))) : normalizer_condition (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_113110 (h0 : enat -> enat -> Prop) (h1 : enat) : set.finite (add_con_gen.rel h0 h1) := sorry --non-trivial
lemma new_lemma_113111 (h0 : function.extfun Type ring) : @is_domain.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113112 (h0 : topological_space (normed_group linarith.comp_source)) : t0_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113113 (h0 : functor.add_const (ring (canonically_ordered_monoid linarith.comp)) (has_neg pos)) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113114 (h0 : complete_lattice (canonically_ordered_monoid (has_add real))) : is_atomistic (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_113115 (h0 : topological_space (has_Inf (ring (ring (has_Inf (ring Type)))))) : discrete_topology (has_Inf (ring (ring (has_Inf (ring Type))))) := sorry --non-trivial
lemma new_lemma_113116 (h0 : uniform_space (complete_distrib_lattice (option (option (option empty))))) : complete_space (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_113117 (h0 : topological_space (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind))) : totally_disconnected_space (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_113118 (h0 : topological_space (boolean_algebra.core ennreal)) : totally_disconnected_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_113119 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113120 (h0 : complete_lattice (comm_group linarith.comp)) : is_atomistic (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_113121 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113122 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : sequential_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_113123 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113124 (h0 : functor.comp topological_space add_comm_monoid Type) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113125 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @totally_disconnected_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113126 (h0 : list (has_zero (semigroup Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113127 (h1 : complete_lattice (add_left_cancel_monoid (random_gen char))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_113128 (h0 : topological_space (boolean_algebra (finset (has_pos_part (has_neg pos))))) : loc_path_connected_space (boolean_algebra (finset (has_pos_part (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_113129 (h0 : cancel_comm_monoid_with_zero (finset (cancel_monoid Type))) : unique_factorization_monoid (finset (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_113130 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup (has_neg pos))) pos) : @archimedean.{0} (semigroup.{0} (has_neg.{0} pos)) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} (has_neg.{0} pos))) pos h0)  := sorry --non-trivial
lemma new_lemma_113131 (h0 : add_group (comm_ring (random_gen reducibility_hints))) : is_add_cyclic (comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_113132 (h0 : function.extfun Type topological_space) : @t0_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113133 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_113134 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @totally_disconnected_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_113135 (h0 : has_lt (has_lt (has_lt string_imp))) : no_max_order (has_lt (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_113136 (h0 : ring (add_group num)) : rank_condition (add_group num) := sorry --non-trivial
lemma new_lemma_113137 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add pos)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_113138 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @normal_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_113139 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_113140 (h0 : ring (linear_ordered_comm_monoid_with_zero (semiring (semiring (semiring empty))))) : strong_rank_condition (linear_ordered_comm_monoid_with_zero (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_113141 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_113142 (h0 : topological_space (semiring (has_union unsigned))) : normal_space (semiring (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_113143 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_113144 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_113145 (h0 : functor.add_const (group (complete_distrib_lattice Type)) linarith.comp) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113146 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_113147 (h0 : group (generalized_boolean_algebra (has_Inf Type))) : group.fg (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_113148 (h0 : functor.add_const (semiring (ordered_comm_monoid pos)) Type) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113149 (h0 : function.extfun nat fin) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_113150 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113151 (h0 : add_monoid (add_cancel_monoid (finset linarith.comp))) : add_monoid.fg (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_113152 (h0 : topological_space (is_R_or_C (option unsigned))) : totally_disconnected_space (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_113153 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_add.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_113154 (h0 : topological_space (has_Inf (has_neg (has_Inf Type)))) : preconnected_space (has_Inf (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_113155 (h0 : functor.comp topological_space finset Type) : @totally_separated_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113156 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (finset (has_neg Type))) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (finset.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113157 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_113158 (h0 : monoid (metric_space (has_norm (semiring congr_arg_kind)))) : monoid.fg (metric_space (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_113159 (h0 : uniform_space (has_norm (semiring (semiring num)))) : complete_space (has_norm (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_113160 (h0 : add_group (linear_ordered_semiring (add_group unsigned))) : is_add_cyclic (linear_ordered_semiring (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_113161 (h0 : functor.add_const (filter (semigroup unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113162 (h0 : topological_space (with_bot (has_top (has_top num)))) : discrete_topology (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_113163 (h0 : has_lt (semi_normed_comm_ring fun_info)) : no_max_order (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_113164 (h0 : functor.add_const (function.extfun Type topological_space) (normed_comm_ring pos)) : @loc_path_connected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (normed_comm_ring.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_113165 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_113166 (h0 : prod (has_bot unsigned) (has_bot unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_113167 (h1 : complete_lattice (semi_normed_ring string_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_113168 (h0 : uniform_space (semigroup (semigroup Type))) : separated_space (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_113169 (h0 : not (complete_lattice (non_assoc_semiring congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113170 (h0 : topological_space (has_nndist (has_add ennreal))) : topological_space.separable_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_113171 (h0 : ring (encodable (has_nnnorm char))) : is_domain (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_113172 (h0 : function.extfun Type (functor.comp uniform_space has_zero)) : @complete_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_zero.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_zero.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_113173 (h0 : topological_space (complete_distrib_lattice empty)) : preirreducible_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_113174 (h0 : topological_space (ordered_comm_ring (ring name))) : totally_separated_space (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_113175 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string Type))) : regular_space (canonically_ordered_comm_semiring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_113176 (h0 : not (has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_113177 (h0 : not (topological_space (bin_tree empty) -> false)) : @topological_space.separable_space.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_113178 (h0 : add_left_cancel_semigroup empty -> add_left_cancel_semigroup empty -> add_left_cancel_semigroup empty) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_113179 (h1 : set (mul_one_class std_gen -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_113180 (h0 : topological_space (has_add (has_Inf (sub_neg_monoid (has_bot Type))))) : totally_disconnected_space (has_add (has_Inf (sub_neg_monoid (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_113181 (h0 : topological_space (normed_group num)) : preirreducible_space (normed_group num) := sorry --non-trivial
lemma new_lemma_113182 (h0 : group (cancel_monoid (finset (finset ennreal)))) : group.fg (cancel_monoid (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_113183 (h0 : topological_space (has_div enat)) : path_connected_space (has_div enat) := sorry --non-trivial
lemma new_lemma_113184 (h0 : topological_space (cancel_monoid (option num))) : preirreducible_space (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_113185 (h0 : function.extfun Type (functor.comp monoid add_cancel_monoid)) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} add_cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} monoid.{0} add_cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_113186 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_113187 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_113188 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113189 (h0 : functor.add_const (ring (has_zero pos)) (has_to_string pos)) : @rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113190 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_113191 (h0 : uniform_space (boolean_algebra.core (has_to_string (has_to_string pos)))) : complete_space (boolean_algebra.core (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_113192 (h0 : topological_space (normed_group (has_nnnorm linarith.ineq))) : totally_disconnected_space (normed_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_113193 (h0 : functor.add_const pnat pos) (h1 : pnat) : pnat.coprime (functor.add_const.run h0) h1 := sorry --non-trivial
lemma new_lemma_113194 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg pos)) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113197 (h0 : monoid (has_bot (has_Inf real))) : monoid.fg (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_113198 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113199 (h0 : functor.add_const (ordered_add_comm_monoid Type) linarith.comp) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113200 (h0 : topological_space (linear_ordered_comm_ring (normed_group (normed_comm_ring congr_arg_kind)))) : t0_space (linear_ordered_comm_ring (normed_group (normed_comm_ring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_113201 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113202 (h0 : topological_space (has_add (has_Inf (normed_comm_ring pos)))) : t1_space (has_add (has_Inf (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_113203 (h0 : group (distrib_lattice (random_gen char))) : group.fg (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_113204 (h0 : ring (random_gen (has_ssubset fun_info))) : rank_condition (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_113205 (h0 : prod (filter num) (filter num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_113206 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113207 (h0 : functor.add_const (filter (has_zero Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113208 (h3 : uniform_space (denumerable (has_nnnorm (mul_one_class char)))) : complete_space (denumerable (has_nnnorm (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_113209 (h0 : prod (ring unsigned) (ring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_113210 (h0 : ring (has_nnnorm string.iterator_imp)) : rank_condition (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_113211 (h0 : semiring (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : is_noetherian_ring (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_113212 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part name))) : irreducible_space (canonically_ordered_comm_semiring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_113213 (h0 : set (add_comm_semigroup (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_113214 (h1 : group (encodable string_imp)) : is_cyclic (encodable string_imp) := sorry --non-trivial
lemma new_lemma_113215 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_113216 (h0 : ordered_comm_monoid (mul_zero_class ennreal)) : has_exists_mul_of_le (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_113217 (h1 : ring (denumerable string_imp)) : strong_rank_condition (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_113218 (h0 : topological_space (comm_group (has_add (has_add pos)))) : totally_separated_space (comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_113219 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_113220 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @path_connected_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_113221 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_113222 (h0 : functor.add_const (group (semigroup linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_113223 (h0 : group (add_cancel_monoid (option (option pos)))) : is_simple_group (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_113224 (h0 : group (random_gen (has_nnnorm to_additive.value_type))) : group.fg (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113225 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_113226 (h0 : functor.comp monoid complete_distrib_lattice name) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113227 (h0 : list (has_add (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113228 (h0 : add_monoid (linear_ordered_semiring fun_info)) : add_monoid.fg (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_113229 (h0 : topological_space (complete_distrib_lattice (has_neg (finset Type)))) : t0_space (complete_distrib_lattice (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_113230 (h0 : filter (add_group (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113231 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (topological_space.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (topological_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_113232 (h0 : Prop -> Prop -> Prop) (h1 : function.extfun (Prop -> Prop -> Prop) quot) : quot.out (function.extfun_app h1 h0) := sorry --non-trivial
lemma new_lemma_113233 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_113234 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) pos) : @is_domain.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_113235 (h0 : group (omega_complete_partial_order empty)) : group.fg (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_113236 (h0 : topological_space (has_neg (has_neg linarith.comp))) : t1_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_113237 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_bot (comm_semigroup (sub_neg_monoid real))))) : unique_factorization_monoid (has_pos_part (has_bot (comm_semigroup (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_113238 (h0 : functor.add_const (ring (semigroup name)) name) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_113239 (h0 : topological_space (monoid unsigned)) : preconnected_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_113240 (h0 : topological_space (comm_semigroup (has_pos_part pos))) : t0_space (comm_semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_113241 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_113242 (h0 : ring (free_add_monoid num)) : rank_condition (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_113243 (h0 : uniform_space (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind))))) : separated_space (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_113244 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_113245 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113246 (h0 : functor.add_const (finset (complete_distrib_lattice linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113247 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @discrete_topology.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113248 (h0 : functor.add_const (topological_space (add_right_cancel_monoid congr_arg_kind)) num) : @t0_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_113249 (h0 : group (with_bot num)) : group.fg (with_bot num) := sorry --non-trivial
lemma new_lemma_113250 (h0 : ring (canonically_ordered_comm_semiring (ring Type))) : rank_condition (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_113251 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_113252 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_113253 (h1 : filter (with_zero (has_inf (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_113254 (h0 : filter (has_zero (has_add (option pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_113255 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (measurable_space unsigned)) := sorry --non-trivial
lemma new_lemma_113256 (h0 : functor.add_const (list (ring linarith.comp)) (ordered_ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113258 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (ring pos)) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (ring.{0} pos) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_113259 (h0 : topological_space (normed_field enat)) : t0_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_113260 (h0 : add_group (measure_theory.measure_space unsigned)) : is_add_cyclic (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_113261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_113262 (h0 : functor.add_const (list (boolean_algebra Type)) (finset pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113263 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : totally_disconnected_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_113264 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_113265 (h0 : uniform_space (has_compl (mul_one_class enat))) : complete_space (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_113266 (h0 : topological_space (ordered_comm_ring (has_Inf (ring (ring name))))) : t0_space (ordered_comm_ring (has_Inf (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_113267 (h0 : ordered_comm_monoid (has_nndist (option name))) : has_exists_mul_of_le (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_113268 (h0 : finset (has_star congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_113269 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113270 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_113271 (h0 : complete_lattice (add_cancel_comm_monoid empty)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_113272 (h2 : ring (has_ssubset (random_gen to_additive.value_type))) : strong_rank_condition (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113273 (h0 : topological_space (with_bot (semiring (with_bot (semiring unsigned))))) : totally_separated_space (with_bot (semiring (with_bot (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_113274 (h0 : complete_lattice (has_star num)) : is_atomistic (has_star num) := sorry --non-trivial
lemma new_lemma_113275 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @discrete_topology.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_113276 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_113277 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @irreducible_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113278 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113279 (h0 : add_group (fintype (random_gen to_additive.value_type))) : is_add_cyclic (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113280 (h1 : uniform_space (has_nnnorm linarith.comp_source)) : complete_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113281 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid empty)) num) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_113282 (h0 : not (add_group (has_ssubset (has_nnnorm reducibility_hints)) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_113283 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_113284 (h0 : topological_space (metric_space (semiring (semiring (semiring linarith.comp))))) : normal_space (metric_space (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_113285 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : t0_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_113286 (h0 : topological_space (simple_graph (has_add linarith.comp))) : loc_path_connected_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_113287 (h0 : topological_space (semigroup (has_add name))) : sequential_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_113288 (h0 : not (group (partial_order congr_arg_kind) -> false)) : @normalizer_condition.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113289 (h0 : functor.add_const (topological_space name) num) : @path_connected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_113290 (h0 : uniform_space (add_group (semiring empty))) : separated_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_113291 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113292 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @totally_disconnected_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_113293 (h0 : group (has_emptyc (has_top num))) : is_cyclic (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_113294 (h0 : functor.add_const (group (has_star num)) num) : @group.fg.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_113295 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_113296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113297 (h0 : not (topological_space (non_assoc_semiring num) -> false)) : @irreducible_space.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_113298 (h0 : topological_space (normed_linear_ordered_group (random_gen linarith.ineq))) : locally_compact_space (normed_linear_ordered_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_113299 (h0 : ring (has_nnnorm (normed_field char))) : strong_rank_condition (has_nnnorm (normed_field char)) := sorry --non-trivial
lemma new_lemma_113300 (h0 : list (has_Inf name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113301 (h0 : functor.add_const (complete_lattice (ordered_comm_ring real)) real) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_113302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_113303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_113304 (h0 : functor.add_const (functor.add_const (semiring Type) pos) pos) : @is_noetherian_ring.{1} Type (@functor.add_const.run.{1 0} (semiring.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (semiring.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_113305 (h0 : add_group (finset (cancel_monoid linarith.comp))) : is_add_cyclic (finset (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_113306 (h0 : topological_space (complete_distrib_lattice (finset Type))) : loc_path_connected_space (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_113307 (h0 : function.extfun Type topological_space) : @normal_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_113308 (h0 : group (has_to_string (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp)))))) : is_cyclic (has_to_string (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_113309 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_113310 (h0 : functor.add_const (topological_space (has_star unsigned)) num) : @t0_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_113311 (h0 : monoid (linear_ordered_comm_monoid_with_zero empty)) : monoid.fg (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_113312 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_113313 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_113314 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (option (has_add ennreal)))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (option (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_113315 (h0 : not (ring (has_compl fun_info) -> false)) : @rank_condition.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_113316 (h0 : add_group (semiring (has_norm empty))) : is_add_cyclic (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_113317 (h0 : uniform_space (simple_graph (has_dist unsigned))) : complete_space (simple_graph (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_113318 (h0 : functor.comp topological_space has_zero Type) : @path_connected_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113319 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) ennreal) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_113320 (h0 : topological_space (has_neg (ordered_ring Type))) : discrete_topology (has_neg (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_113321 (h0 : topological_space (complete_semilattice_Sup fun_info)) : irreducible_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_113322 (h0 : normed_field std_gen -> Prop) (h1 : Prop) (h2 : Pi (a : normed_field std_gen), h0 a -> Prop) : classical.exists_cases h1 h2 := sorry --non-trivial
lemma new_lemma_113323 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class ereal))) : path_connected_space (linear_ordered_comm_group_with_zero (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_113324 (h0 : has_lt (simple_graph string.iterator_imp)) : no_max_order (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_113325 (h0 : add_group (add_cancel_monoid (has_nndist (ring (finset Type))))) : is_add_cyclic (add_cancel_monoid (has_nndist (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_113326 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113327 (h0 : functor.add_const (topological_space (finset name)) name) : @path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_113328 (h0 : list (encodable (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113329 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) Type) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_113330 (h0 : filter (ordered_cancel_add_comm_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113331 (h0 : functor.add_const (complete_lattice (has_to_string pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_113332 (h0 : topological_space (left_cancel_monoid (semiring num))) : totally_disconnected_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_113333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113334 (h0 : function.extfun Type (functor.add_const (function.extfun Type add_monoid))) : @add_monoid.fg.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) unsigned (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type add_monoid.{0})) h0 unsigned)) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_113335 (h0 : topological_space (has_scalar ennreal Type)) : totally_disconnected_space (has_scalar ennreal Type) := sorry --non-trivial
lemma new_lemma_113336 (h0 : topological_space (has_neg (option unsigned))) : t1_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_113337 (h2 h3 : multiset (has_nnnorm to_additive.value_type)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_113338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (bin_tree.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (bin_tree.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_113339 (h0 : complete_lattice (normed_group unsigned)) : is_atomistic (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_113340 (h0 : ring (has_emptyc congr_arg_kind)) : is_domain (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113341 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup enat))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_113342 (h0 : ring (normed_field (has_lt (metric_space char)))) : is_domain (normed_field (has_lt (metric_space char))) := sorry --non-trivial
lemma new_lemma_113343 (h0 : ring (canonically_ordered_add_monoid (option (option (option (option unsigned)))))) : rank_condition (canonically_ordered_add_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_113344 (h0 : topological_space (normed_group (has_top (has_top (has_top fun_info))))) : totally_disconnected_space (normed_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_113345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113346 (h0 : filter (with_bot (semiring (semiring (semiring (semiring (semiring num))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113347 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113348 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 empty) := sorry --non-trivial
lemma new_lemma_113349 (h0 : functor.add_const (function.extfun Type filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_113350 (h0 : complete_lattice (filter unsigned)) : is_compactly_generated (filter unsigned) := sorry --non-trivial
lemma new_lemma_113351 (h0 : functor.add_const (topological_space (comm_group Type)) ennreal) : @totally_separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_113352 (h0 : has_lt (nondiscrete_normed_field environment.projection_info)) : no_max_order (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_113353 (h0 : complete_lattice (normed_comm_ring (ring linarith.comp))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_113354 (h0 : add_group (boolean_algebra (semigroup (semigroup (finset linarith.comp))))) : is_add_cyclic (boolean_algebra (semigroup (semigroup (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_113355 (h0 : topological_space (boolean_algebra (has_neg (has_neg Type)))) : totally_separated_space (boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_113356 (h0 : topological_space znum) : preconnected_space znum := sorry --non-trivial
lemma new_lemma_113357 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) (normed_comm_ring Type)) : @loc_path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_113358 (h0 : function.extfun nat fin) : @regular_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_113359 (h0 : functor.add_const (finset (has_zero linarith.comp)) (has_to_string (comm_group Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113360 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg name)) linarith.comp) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113361 (h0 : functor.add_const (group (has_nndist congr_arg_kind)) congr_arg_kind) : @is_cyclic.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_113362 (h0 : not (topological_space (normed_group char) -> false)) : @t0_space.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_113363 (h0 : complete_lattice (monoid unsigned)) : is_compactly_generated (monoid unsigned) := sorry --non-trivial
lemma new_lemma_113364 (h0 : functor.add_const (functor.add_const (filter Type) (has_neg (ring (has_neg (has_neg Type))))) Type) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_113365 (h0 : functor.add_const (add_group (boolean_algebra Type)) (ring (has_pos_part Type))) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (boolean_algebra.{1} Type)) (ring.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113366 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113367 (h0 : not (has_mem.mem (with_bot fun_info) has_emptyc.emptyc -> false)) : @complete_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_113368 (h0 : functor.comp cancel_comm_monoid_with_zero has_to_string ennreal) : @unique_factorization_monoid.{0} (has_to_string.{0} ennreal) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_to_string.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_113369 (h0 : semiring (semigroup (semiring empty))) : is_noetherian_ring (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_113370 (h0 : filter ennreal) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_113371 (h0 : complete_lattice (complete_linear_order congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113372 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : locally_compact_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_113373 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113374 (h0 : functor.add_const (ring (has_to_string name)) (ring environment.implicit_infer_kind)) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_113375 (h0 : uniform_space (has_le (mul_one_class string.iterator_imp))) : complete_space (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_113376 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_113377 (h0 : uniform_space (plift (semiring (semiring unsigned)))) : complete_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_113378 (h0 : topological_space (add_cancel_monoid (has_add name))) : loc_path_connected_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_113379 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_113380 (h0 : semiring (has_Inf (has_add (has_pos_part (has_add (has_add Type)))))) : is_noetherian_ring (has_Inf (has_add (has_pos_part (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_113381 (h0 : complete_lattice (semiring (has_top num))) : is_atomistic (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_113382 (h0 : topological_space (metric_space (semiring (linear_ordered_semiring empty)))) : totally_disconnected_space (metric_space (semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_113383 (h0 : functor.add_const (monoid (normed_comm_ring pos)) (has_add (add_comm_monoid environment.implicit_infer_kind))) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} pos)) (has_add.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113384 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_113385 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_113386 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) Type) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113387 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113388 (h0 : topological_space (with_zero char)) : totally_disconnected_space (with_zero char) := sorry --non-trivial
lemma new_lemma_113389 (h0 : complete_lattice (linear_ordered_field unsigned)) : complete_lattice.is_Sup_finite_compact (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_113390 (h0 : ring (with_bot (with_bot string_imp))) : rank_condition (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_113391 (h0 : group (has_to_string (finset (finset (ring environment.implicit_infer_kind))))) : is_simple_group (has_to_string (finset (finset (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_113392 (h0 : topological_space (ordered_comm_group empty)) : loc_path_connected_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_113393 (h0 : fin has_zero.zero) : @complete_space.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_113394 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @irreducible_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113395 (h0 : topological_space (complete_distrib_lattice (option empty))) : locally_compact_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_113396 (h0 : ring (denumerable (has_nnnorm (has_nnnorm char)))) : is_domain (denumerable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_113397 (h0 : functor.add_const (semiring (has_zero name)) Type) : @is_noetherian_ring.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_113398 (h0 : uniform_space (semigroup (has_neg pos))) : separated_space (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_113399 (h0 : complete_lattice (plift (has_star unsigned))) : is_atomistic (plift (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_113400 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_Inf linarith.comp)) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_113401 (h0 : ring (linear_ordered_add_comm_group (normed_field char))) : rank_condition (linear_ordered_add_comm_group (normed_field char)) := sorry --non-trivial
lemma new_lemma_113402 (h0 : not (has_mem.mem (has_nnnorm linarith.ineq) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_nnnorm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_nnnorm.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_113403 (h2 : ring (has_append reducibility_hints)) : rank_condition (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_113404 (h0 : functor.comp topological_space finset name) : @preirreducible_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113405 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113406 (h0 : ring (add_cancel_monoid (finset ennreal))) : is_domain (add_cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_113407 (h0 : list (free_add_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113408 (h0 : function.extfun Type (functor.add_const (semiring (partial_order unsigned)))) : @is_noetherian_ring.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (partial_order.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113409 (h0 : ordered_add_comm_monoid (has_nndist unsigned)) : archimedean (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_113410 (h0 : group (has_norm congr_arg_kind)) : normalizer_condition (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113411 (h0 : topological_space (has_neg (normed_comm_ring linarith.comp))) : t0_space (has_neg (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_113412 (h0 : uniform_space (canonically_ordered_add_monoid (option (option unsigned)))) : complete_space (canonically_ordered_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_113413 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_113414 (h0 : not (group (has_inv to_additive.value_type) -> false)) : @is_cyclic.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_113415 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid name)) (has_neg real)) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} name)) (has_neg.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_113416 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_113417 (h0 : not (complete_lattice (random_gen congr_arg_kind) -> false)) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113418 (h0 : topological_space (with_zero (has_nnnorm fun_info))) : t0_space (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_113419 (h0 : functor.add_const (topological_space (ordered_comm_monoid name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_113420 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_pos_part real))) : is_atomistic (canonically_linear_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_113421 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @locally_compact_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_113422 (h0 : thunk (fin has_zero.zero)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_113423 (h0 : filter (has_neg (semigroup Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113424 (h0 : functor.comp topological_space add_cancel_monoid name) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113425 (h0 : topological_space (has_Inf (has_add linarith.comp))) : t1_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_113426 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : path_connected_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_113427 (h0 : list (boolean_algebra.core (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113428 (h0 : ring (boolean_algebra (has_add name))) : strong_rank_condition (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_113429 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113430 (h0 : topological_space (has_ssubset linarith.ineq)) (h1 : preorder (has_ssubset linarith.ineq)) : order_closed_topology (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_113431 (h0 : group (has_top (has_nnnorm (random_gen linarith.ineq)))) : is_cyclic (has_top (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_113432 (h0 : group (boolean_algebra (has_add Type))) : normalizer_condition (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_113433 (h0 : functor.add_const (topological_space (has_neg pos)) unsigned) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113434 (h1 : topological_space (add_comm_semigroup linarith.ineq)) : t0_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_113435 (h0 : ring (option (option (option (option (option (option ennreal))))))) : is_principal_ideal_ring (option (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_113436 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113437 (h0 : topological_space (option (semiring (semiring (semiring (semiring (semiring empty))))))) : t0_space (option (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_113438 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) linarith.comp) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113439 (h0 : functor.add_const (uniform_space (semigroup pos)) (has_nndist name)) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_113440 (h0 : group (normed_linear_ordered_group (option (option unsigned)))) : normalizer_condition (normed_linear_ordered_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_113441 (h0 : topological_space (has_div (mul_one_class (uniform_space linarith.ineq)))) : t0_space (has_div (mul_one_class (uniform_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_113442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113443 (h0 : linarith.comp -> linarith.comp -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_113444 (h1 : complete_lattice (has_compl enat)) : is_atomistic (has_compl enat) := sorry --non-trivial
lemma new_lemma_113445 (h0 : uniform_space (canonically_ordered_comm_semiring (add_comm_monoid name))) : separated_space (canonically_ordered_comm_semiring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_113446 (h0 : ring (has_star (semiring (semiring congr_arg_kind)))) : strong_rank_condition (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_113447 (h0 : topological_space (dlist (with_one (comm_ring (comm_ring (with_one (comm_ring string_imp))))))) : irreducible_space (dlist (with_one (comm_ring (comm_ring (with_one (comm_ring string_imp)))))) := sorry --non-trivial
lemma new_lemma_113448 (h2 : group (has_append to_additive.value_type)) : is_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_113449 (h0 : functor.add_const (uniform_space (add_group empty)) empty) : @separated_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_113450 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113451 (h0 : functor.add_const (fin has_zero.zero) (has_Inf pos)) : @archimedean.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (comm_semigroup.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_113452 (h0 : not (cancel_comm_monoid_with_zero pos -> false)) : @unique_factorization_monoid.{0} pos (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113453 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra)) : @sequential_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_113454 (h0 : functor.add_const (add_group (has_to_string pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_113455 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) auto.case_option) := sorry --non-trivial
lemma new_lemma_113457 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) name) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_113458 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_113459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113460 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113461 (h0 : ring (distrib environment.projection_info)) : strong_rank_condition (distrib environment.projection_info) := sorry --non-trivial
lemma new_lemma_113462 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_113463 (h0 : uniform_space (with_bot (add_group linarith.comp))) : separated_space (with_bot (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_113464 (h0 : topological_space (has_compl (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (has_compl (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_113465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_113466 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_113467 (h0 : topological_space (has_emptyc linarith.comp_source)) : totally_separated_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113468 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph pos)) pos) : @archimedean.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_113469 (h0 : not (group (linear_ordered_add_comm_group linarith.ineq) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_113470 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (has_bot real)))) : totally_separated_space (generalized_boolean_algebra (has_pos_part (has_bot real))) := sorry --non-trivial
lemma new_lemma_113471 (h0 : topological_space (has_zero (boolean_algebra (boolean_algebra linarith.comp)))) : t1_space (has_zero (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_113472 (h0 : group (has_Inf (has_neg (finset (has_add Type))))) : is_cyclic (has_Inf (has_neg (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_113473 (h0 : uniform_space (semigroup (ring environment.implicit_infer_kind))) : complete_space (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_113474 (h0 : group (has_union (has_norm (semiring (semiring (has_norm (semiring empty))))))) : is_cyclic (has_union (has_norm (semiring (semiring (has_norm (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_113475 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset environment.implicit_infer_kind)) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_113476 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring num)))) : totally_disconnected_space (complete_semilattice_Sup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_113477 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_113478 (h0 : not (ring (distrib_lattice linarith.comp_source) -> false)) : @is_domain.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_113479 (h0 : has_neg (has_div (mul_one_class linarith.comp_source))) (h1 : list (measurable_space (has_div (mul_one_class linarith.comp_source)))) : @has_measurable_neg.{0} (has_div.{0} (mul_one_class.{0} linarith.comp_source)) h0 (@list.ilast.{0} (measurable_space.{0} (has_div.{0} (mul_one_class.{0} linarith.comp_source))) (@measurable_space.inhabited.{0} (has_div.{0} (mul_one_class.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_113480 (h0 : filter (left_cancel_semigroup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113481 (h0 : add_group (add_cancel_comm_monoid empty)) : is_add_cyclic (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_113482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113483 (h0 : ring (semi_normed_ring (has_nnnorm (has_nnnorm reducibility_hints)))) : rank_condition (semi_normed_ring (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_113484 (h0 : functor.add_const (semiring (complete_distrib_lattice linarith.comp)) pos) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_113485 (h0 : functor.add_const (add_group (mul_zero_class Type)) Type) : @is_add_cyclic.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_113486 (h0 : not (complete_lattice (normed_field to_additive.value_type) -> false)) : @is_compactly_generated.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_113487 (h0 : topological_space (has_edist unsigned)) : preirreducible_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_113488 (h0 : cancel_comm_monoid_with_zero (has_add real)) : unique_factorization_monoid (has_add real) := sorry --non-trivial
lemma new_lemma_113489 (h0 : function.extfun Prop (fun (x : Prop), Prop)) (h1 : Exists (fun (x : Prop), function.extfun_app h0 x)) : classical.some h1 := sorry --non-trivial
lemma new_lemma_113490 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_113491 (h0 : topological_space stieltjes_function) : totally_disconnected_space stieltjes_function := sorry --non-trivial
lemma new_lemma_113492 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113493 (h0 : add_group (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_113494 (h0 : group (has_nndist (has_to_string Type))) : normalizer_condition (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_113495 (h1 : add_group (nondiscrete_normed_field (mul_one_class ereal))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_113496 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring environment.implicit_infer_kind)) (has_nndist Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_113497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_113498 (h0 : list (has_Inf (ring (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113499 (h0 : complete_lattice (has_inter (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_113500 (h0 : list (semigroup (has_add (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_113502 (h0 : uniform_space (denumerable (random_gen reducibility_hints))) : complete_space (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_113503 (h0 : not (ring (add_left_cancel_monoid linarith.ineq) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_113504 (h0 : topological_space (has_zero unsigned)) : sequential_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_113505 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @t0_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_113506 (h0 : function.extfun Type topological_space) : @regular_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_113507 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_113508 (h0 : ring (bin_tree congr_arg_kind)) : is_principal_ideal_ring (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113509 (h0 : functor.add_const (topological_space (has_add unsigned)) Type) : @preconnected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_113510 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_113511 (h0 : ring (canonically_linear_ordered_monoid (has_neg (has_neg pos)))) : strong_rank_condition (canonically_linear_ordered_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_113512 (h0 : ring (complete_semilattice_Sup (semiring congr_arg_kind))) : strong_rank_condition (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113513 (h0 : not (ring (ordered_comm_semiring fun_info) -> false)) : @rank_condition.{0} (ordered_comm_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (ordered_comm_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_113514 (h0 : ordered_comm_monoid (has_to_string (has_add (finset linarith.comp)))) : has_exists_mul_of_le (has_to_string (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_113515 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_113516 (h0 : topological_space (measurable_space (linear_ordered_semiring num))) : irreducible_space (measurable_space (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_113517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_113518 (h0 : group (add_cancel_monoid (finset linarith.comp))) : normalizer_condition (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_113519 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg linarith.comp)) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_113520 (h1 : topological_space (fintype (encodable linarith.comp_source))) : t0_space (fintype (encodable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_113521 (h0 : functor.add_const (filter (normed_comm_ring name)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113522 (h0 : ring (has_zero (semigroup (finset linarith.comp)))) : is_domain (has_zero (semigroup (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_113523 (h0 : topological_space (has_inv (has_ssubset linarith.comp_source))) : t0_space (has_inv (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_113524 (h0 : functor.add_const (group (ordered_comm_group empty)) empty) : @normalizer_condition.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_113525 (h0 : topological_space (random_gen (semiring (has_norm linarith.comp)))) : totally_disconnected_space (random_gen (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_113526 (h0 : topological_space (comm_ring (comm_ring (comm_ring (comm_ring linarith.ineq))))) : path_connected_space (comm_ring (comm_ring (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_113527 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) name) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_113528 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113529 (h0 : topological_space (finset (normed_comm_ring name))) : t1_space (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_113530 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113531 (h0 : list (has_norm (has_ssubset (has_ssubset (has_ssubset fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113532 (h0 : topological_space (has_lt reducibility_hints)) : t0_space (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_113533 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113534 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_113535 (h0 : ring (normed_comm_ring (has_add Type))) : is_principal_ideal_ring (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_113536 (h0 : fin has_zero.zero) : @group.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113537 (h0 : topological_space (add_comm_monoid (option (option (option unsigned))))) : discrete_topology (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_113538 (h0 : add_monoid (boolean_algebra (has_to_string (has_to_string unsigned)))) : add_monoid.fg (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_113539 (h0 : group (bin_tree (semiring (semiring unsigned)))) : is_cyclic (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_113540 (h0 : complete_lattice (add_monoid char)) : complete_lattice.is_Sup_finite_compact (add_monoid char) := sorry --non-trivial
lemma new_lemma_113541 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @add_monoid.fg.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_113542 (h0 : function.extfun Type (functor.add_const (functor.add_const (uniform_space (add_cancel_monoid empty)) empty))) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_113543 (h0 : uniform_space (boolean_algebra.core (has_neg_part (has_neg_part Type)))) : separated_space (boolean_algebra.core (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_113544 (h0 h1 : multiset (normed_field linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_113545 (h1 : topological_space (normed_field char)) (h2 : add_group (normed_field char)) : topological_add_group (normed_field char) := sorry --non-trivial
lemma new_lemma_113546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_113547 (h0 h1 : multiset (random_gen linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_113548 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_113549 (h0 : topological_space (has_one (semiring num))) : discrete_topology (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_113550 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113552 (h0 : ring (omega_complete_partial_order (semiring unsigned))) : strong_rank_condition (omega_complete_partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_113553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113554 (h0 : cancel_monoid (normed_comm_ring (has_add Type)) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_113555 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_113556 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_113557 (h0 : functor.add_const (filter (has_neg_part Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113558 (h0 : functor.comp topological_space has_nndist name) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113559 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113560 (h0 : ring (has_to_string (has_add linarith.comp))) : rank_condition (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_113561 (h0 : topological_space (add_cancel_monoid (has_add Type))) : topological_space.separable_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_113562 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113563 (h0 : function.extfun Type ring) : @is_domain.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113564 (h0 : not (complete_lattice (has_norm num) -> false)) : @is_compactly_generated.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_113565 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) (has_neg pos)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113566 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_113567 (h0 : functor.add_const (finset (omega_complete_partial_order congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113568 (h0 : has_neg (has_div (semi_normed_ring enat))) (h1 : measurable_space (has_div (semi_normed_ring enat))) : has_measurable_neg (has_div (semi_normed_ring enat)) := sorry --non-trivial
lemma new_lemma_113569 (h0 : list (semigroup congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113570 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_113571 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (comm_group name)) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_113572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113573 (h0 : topological_space (as_linear_order (comm_monoid unsigned))) : preirreducible_space (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_113574 (h0 : ring (has_bot (has_add Type))) : is_domain (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_113575 (h0 : ring (has_nnnorm enat)) : is_domain (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_113576 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_113577 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113578 (h0 : ordered_add_comm_monoid (comm_monoid (option empty))) : archimedean (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_113579 (h0 : set (char -> add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_113580 (h1 : group (has_norm (random_gen linarith.ineq))) : group.fg (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_113581 (h0 : group (has_top (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : group.fg (has_top (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_113582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113583 (h0 : complete_lattice (measure_theory.measure_space unsigned)) : is_atomistic (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_113584 (h0 : functor.add_const (monoid (boolean_algebra Type)) linarith.comp) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113585 (h0 : functor.comp topological_space semigroup Type) : @regular_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_113587 (h0 : topological_space (option ennreal)) : preirreducible_space (option ennreal) := sorry --non-trivial
lemma new_lemma_113588 (h0 : ring (left_cancel_monoid (semiring empty))) : is_principal_ideal_ring (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_113589 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_113590 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_113591 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : preirreducible_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_113592 (h1 : not (topological_space (with_one congr_arg_kind) -> false)) : @path_connected_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_113593 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_113594 (h0 : functor.add_const (finset (comm_group name)) (option pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113595 (h0 : list (has_to_string (has_neg ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113596 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @normal_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_113597 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113598 (h0 : topological_space (has_neg (finset (has_nndist pos)))) : totally_separated_space (has_neg (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_113599 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_neg Type)) : @topological_space.separable_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_semigroup.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_113600 (h0 : function.extfun Type ring) : @is_domain.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_113601 (h3 : topological_space (semi_normed_comm_ring linarith.comp_source)) : path_connected_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113602 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_113603 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113604 (h0 : semiring (has_neg (finset Type))) : is_noetherian_ring (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_113605 (h0 : functor.add_const (group (has_neg unsigned)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_113606 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_113607 (h0 : topological_space (add_comm_monoid (has_pos_part pos))) : discrete_topology (add_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_113608 (h0 : not (has_mem.mem (distrib fun_info) has_emptyc.emptyc -> false)) : @complete_space.{0} (distrib.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (distrib.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_113609 (h0 : topological_space (add_group (semiring (semiring num)))) : t1_space (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_113610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_113611 (h0 : not (ring (distrib_lattice fun_info) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_113612 (h0 : topological_space (mul_zero_class congr_arg_kind)) : normal_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113613 (h2 : ring (has_nnnorm (has_append linarith.comp_source))) : rank_condition (has_nnnorm (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_113614 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @separated_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113615 (h0 : ring (measurable_space (has_top congr_arg_kind))) : is_domain (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113616 (h4 : has_lt (nondiscrete_normed_field linarith.ineq)) : no_max_order (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_113617 (h0 : semiring (add_cancel_monoid (has_nndist (finset unsigned)))) : is_noetherian_ring (add_cancel_monoid (has_nndist (finset unsigned))) := sorry --non-trivial
lemma new_lemma_113618 (h3 : set (fun_info -> fun_info)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_113619 (h1 : uniform_space (with_one (random_gen char))) : complete_space (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_113620 (h0 : filter (with_one to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113621 (h0 : group (has_top string_imp)) : normalizer_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_113622 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113623 (h0 : list (complete_distrib_lattice (boolean_algebra (comm_group (has_add name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113624 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (boolean_algebra Type)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_113625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113626 (h0 : semiring (normed_lattice_add_comm_group (has_neg (has_neg real)))) : is_noetherian_ring (normed_lattice_add_comm_group (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_113627 (h0 : filter (mul_zero_class (has_add (comm_group (comm_group ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_113628 (h0 : ring (encodable (has_inv linarith.ineq))) : rank_condition (encodable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_113629 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113630 (h0 : topological_space (has_ssubset linarith.ineq)) (h1 : preorder (has_ssubset linarith.ineq)) : order_topology (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_113631 (h0 : topological_space (linear_ordered_add_comm_group_with_top empty)) : t0_space (linear_ordered_add_comm_group_with_top empty) := sorry --non-trivial
lemma new_lemma_113632 (h0 : topological_space (has_neg_part (finset (finset name)))) : locally_compact_space (has_neg_part (finset (finset name))) := sorry --non-trivial
lemma new_lemma_113633 (h0 : semiring (pseudo_metric_space num)) : is_noetherian_ring (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_113634 (h0 : has_mem.mem (with_bot (random_gen linarith.comp_source)) has_emptyc.emptyc) : @rank_condition.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_113635 (h1 h2 : multiset (normed_field linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_113636 (h0 : filter (linear_ordered_field (ring pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113637 (h0 : complete_lattice (linear_ordered_field (option ennreal))) : is_compactly_generated (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_113638 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_113639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113640 (h0 : not (ring (mul_zero_class congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113641 (h0 : topological_space (add_comm_monoid (option pos))) : t1_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_113642 (h0 : set (add_comm_semigroup ereal -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_113643 (h0 : monoid (option (semiring (semiring (semiring num))))) : monoid.fg (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_113644 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_113645 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} (has_Inf.{0} linarith.comp)) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_113646 (h0 : has_star (with_bot (complete_lattice linarith.comp))) (h1 : topological_space (has_trivial_star (with_bot (complete_lattice linarith.comp)))) : totally_disconnected_space (has_trivial_star (with_bot (complete_lattice linarith.comp))) := sorry --non-trivial
lemma new_lemma_113647 (h0 : topological_space (ordered_ring (semiring num))) : path_connected_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_113648 (h0 : ring (add_group (semiring (semiring empty)))) : is_domain (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_113649 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113650 (h2 : pfun linarith.ineq Prop) (h3 : coe_sort (pfun.dom h2)) : pfun.as_subtype h2 h3 := sorry --non-trivial
lemma new_lemma_113651 (h0 : functor.comp ring semigroup pos) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) pos (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_113652 (h0 : ring (has_nndist (has_to_string pos))) : is_principal_ideal_ring (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_113653 (h0 : topological_space (linear_order (option empty))) : totally_disconnected_space (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_113654 (h0 : ring (add_cancel_comm_monoid (has_subset char))) : is_domain (add_cancel_comm_monoid (has_subset char)) := sorry --non-trivial
lemma new_lemma_113655 (h0 : add_monoid (ring (has_pos_part (has_pos_part linarith.comp)))) : add_monoid.fg (ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_113656 (h0 : functor.add_const (ring (boolean_algebra.core pos)) Type) : @strong_rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113657 (h0 : semiring (has_star empty)) : is_noetherian_ring (has_star empty) := sorry --non-trivial
lemma new_lemma_113658 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_113659 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @irreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_113660 (h0 : list (semigroup (has_neg (has_pos_part (finset (finset linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113661 (h0 : not (ring (complete_semilattice_Sup congr_arg_kind) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113662 (h0 : ordered_add_comm_monoid (monoid congr_arg_kind)) : archimedean (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113663 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_113664 (h0 : filter (normed_group (has_inv (has_inv (random_gen linarith.comp_source))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_113666 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @locally_compact_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113667 (h0 : ring (ordered_ring num)) : strong_rank_condition (ordered_ring num) := sorry --non-trivial
lemma new_lemma_113668 (h1 : group (topological_space linarith.comp_source)) : is_cyclic (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_113669 (h0 : ring (pseudo_metric_space Type)) : is_domain (pseudo_metric_space Type) := sorry --non-trivial
lemma new_lemma_113670 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113671 (h0 : group (left_cancel_monoid (semiring (semiring num)))) : normalizer_condition (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_113672 (h0 : set (random_gen reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_113673 (h0 : ordered_add_comm_monoid (add_semigroup (option empty))) : archimedean (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_113674 (h0 : topological_space (has_top (linear_ordered_semiring fun_info))) : irreducible_space (has_top (linear_ordered_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_113675 (h0 : topological_space (with_one linarith.comp)) : irreducible_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_113676 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113677 (h2 : group (has_ssubset (denumerable char))) : is_cyclic (has_ssubset (denumerable char)) := sorry --non-trivial
lemma new_lemma_113678 (h0 : has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_113679 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113680 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset empty)) := sorry --non-trivial
lemma new_lemma_113681 (h0 : functor.comp ring add_cancel_monoid ennreal) : @strong_rank_condition.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_113682 (h0 : list (comm_group (semigroup environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113683 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_113684 (h0 : group (has_one (has_norm linarith.comp))) : group.fg (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_113685 (h0 : function.extfun Type topological_space) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_113686 (h0 : group (sub_neg_monoid (finset pos))) : normalizer_condition (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_113687 (h0 : ordered_comm_monoid (has_nndist (option (cancel_monoid pos)))) : has_exists_mul_of_le (has_nndist (option (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_113688 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_113689 (h0 : measurable_space (linear_ordered_comm_group_with_zero char)) (h1 : filter (linear_ordered_comm_group_with_zero char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_113690 (h0 : functor.add_const (monoid (add_cancel_monoid ennreal)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113691 (h2 : uniform_space (simple_graph linarith.ineq)) : complete_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_113692 (h0 : functor.add_const (uniform_space (comm_group pos)) Type) : @separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113693 (h0 : topological_space (mul_one_class (mul_one_class char))) : t0_space (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_113694 (h0 : functor.add_const (group (comm_monoid unsigned)) num) : @group.fg.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_113695 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : locally_compact_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_113696 (h0 : functor.add_const (filter (add_cancel_monoid Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113697 (h0 : topological_space (has_Inf (finset (has_to_string pos)))) : locally_compact_space (has_Inf (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_113698 (h0 : finset (has_neg (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_113699 (h0 : complete_lattice (comm_semigroup (comm_semigroup (comm_semigroup real)))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_113700 (h0 : topological_space (normed_linear_ordered_group num)) : path_connected_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_113701 (h0 : ring (ring real)) : rank_condition (ring real) := sorry --non-trivial
lemma new_lemma_113702 (h0 : functor.add_const (group (has_zero Type)) pos) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_113703 (h0 : topological_space (semi_normed_comm_ring (mul_one_class (mul_one_class char)))) : path_connected_space (semi_normed_comm_ring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_113704 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113705 (h0 : topological_space (mul_zero_class (semiring (semiring unsigned)))) : discrete_topology (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_113706 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_113707 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : discrete_topology (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_113708 (h0 : functor.add_const (ring (left_cancel_semigroup num)) empty) : @rank_condition.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_113709 (h0 : ring (denumerable (denumerable (has_inv (has_compl linarith.ineq))))) : strong_rank_condition (denumerable (denumerable (has_inv (has_compl linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_113710 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113711 (h0 : filter (has_bot (sub_neg_monoid real))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113712 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_113713 (h0 : complete_lattice (measurable_space (random_gen fun_info))) : is_atomistic (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_113714 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring congr_arg_kind)) : unique_factorization_monoid (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113715 (h0 : group (has_neg_part ennreal)) : normalizer_condition (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_113716 (h0 : add_monoid (ordered_comm_monoid (has_pos_part linarith.comp))) : add_monoid.fg (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_113717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113718 (h0 : topological_space (partial_order (option (option (option (option congr_arg_kind)))))) : preirreducible_space (partial_order (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_113719 (h0 : function.extfun Type complete_lattice) : is_atomistic (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113720 (h0 : functor.comp (functor.comp topological_space has_neg_part) with_top nnreal) : @totally_separated_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_113721 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113722 (h0 : add_monoid (complete_distrib_lattice (ring Type))) : add_monoid.fg (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_113723 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core name))) : locally_compact_space (canonically_ordered_comm_semiring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_113724 (h0 : group (left_cancel_semigroup empty)) : normalizer_condition (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_113725 (h0 : add_group (linear_ordered_comm_ring congr_arg_kind)) : is_add_cyclic (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113726 (h0 : group (has_Inf (has_neg (add_comm_monoid Type)))) : is_simple_group (has_Inf (has_neg (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_113727 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset num)) congr_arg_kind) : @unique_factorization_monoid.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_113728 (h0 : filter (has_zero (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113729 (h0 : cancel_comm_monoid_with_zero (finset Type)) : unique_factorization_monoid (finset Type) := sorry --non-trivial
lemma new_lemma_113730 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid unsigned)) : unique_factorization_monoid (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_113731 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113732 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @strong_rank_condition.{0} name (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) name)  := sorry --non-trivial
lemma new_lemma_113733 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_group empty)) empty) : @unique_factorization_monoid.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_113734 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : t0_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_113735 (h0 : topological_space (as_linear_order (comm_monoid unsigned))) : loc_path_connected_space (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_113736 (h0 : functor.add_const (filter (has_to_string pos)) (ring linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_113737 (h0 : group (is_R_or_C congr_arg_kind)) : group.fg (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113738 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113740 (h0 : group (random_gen (comm_ring (random_gen fun_info)))) : group.fg (random_gen (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_113741 (h0 : functor.add_const (uniform_space (has_neg Type)) linarith.comp) : @separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113742 (h0 : topological_space (option (option (option (option (option unsigned)))))) : locally_compact_space (option (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_113743 (h0 : group (left_cancel_monoid unsigned)) : normalizer_condition (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_113744 (h0 : not (topological_space (preorder unsigned) -> false)) : @t0_space.{0} (preorder.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (preorder.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_113745 (h0 : topological_space (encodable (has_inv (has_inv to_additive.value_type)))) : t0_space (encodable (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_113746 (h0 : ring (canonically_ordered_monoid (has_pos_part real))) : rank_condition (canonically_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_113747 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : t1_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_113748 (h0 : list (has_Inf (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113749 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @normal_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_113750 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113751 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_113752 (h0 : not (group (plift congr_arg_kind) -> false)) : @group.fg.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_113753 (h0 : functor.add_const (add_monoid (has_add pos)) linarith.comp) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113755 (h0 : partial_order (linear_ordered_comm_group ennreal)) (h1 : order_top (linear_ordered_comm_group ennreal)) : is_coatomic (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_113756 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113757 (h0 : ring (semigroup (option (option unsigned)))) : rank_condition (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_113758 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113759 (h0 : complete_lattice (simple_graph (option empty))) : complete_lattice.is_Sup_finite_compact (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_113760 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) name) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_113761 (h0 : ordered_comm_monoid (has_neg (has_nndist pos))) : has_exists_mul_of_le (has_neg (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_113762 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113763 (h0 : group (add_right_cancel_monoid empty)) : group.fg (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_113764 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (has_Inf Type)))) : preconnected_space (complete_distrib_lattice (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_113765 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_113766 (h0 : topological_space (cancel_monoid (has_add (has_add pos)))) : preirreducible_space (cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_113767 (h0 : not (complete_lattice (has_compl reducibility_hints) -> false)) : @is_compactly_generated.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_113768 (h0 : function.extfun nat fin) : @is_atomistic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_113769 (h1 : ring (distrib (comm_ring (comm_ring reducibility_hints)))) : strong_rank_condition (distrib (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_113770 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_113771 (h0 : topological_space (add_left_cancel_semigroup num)) : discrete_topology (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_113772 (h0 : topological_space (complete_distrib_lattice (has_add (has_add Type)))) : t1_space (complete_distrib_lattice (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_113773 (h0 : complete_lattice ereal) : complete_lattice.is_Sup_finite_compact ereal := sorry --non-trivial
lemma new_lemma_113774 (h0 : topological_space (complete_linear_order (has_top (has_star empty)))) : path_connected_space (complete_linear_order (has_top (has_star empty))) := sorry --non-trivial
lemma new_lemma_113775 (h0 : topological_space (boolean_algebra (has_nndist name))) : locally_compact_space (boolean_algebra (has_nndist name)) := sorry --non-trivial
lemma new_lemma_113776 (h2 : ring (random_gen (comm_ring (comm_ring char)))) : is_domain (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_113777 (h0 : group (with_bot (has_inv fun_info))) : is_cyclic (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_113778 (h0 : topological_space (finset (finset pos))) : path_connected_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_113779 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup empty)) num) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_113780 (h0 : set (set Prop)) (h1 : eq (filter.sets (filter.generate h0)) h0) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@filter.mk_of_closure.{0} Prop h0 h1)  := sorry --non-trivial
lemma new_lemma_113781 (h0 : complete_lattice (measure_theory.measure_space empty)) : is_compactly_generated (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_113782 (h0 : functor.add_const (topological_space (finset name)) (finset environment.implicit_infer_kind)) : @path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_113783 (h0 : topological_space (has_nndist (has_Inf Type))) : totally_disconnected_space (has_nndist (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_113784 (h0 : complete_lattice (add_group (semiring num))) : is_atomistic (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_113785 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} (comm_ring.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} (comm_ring.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_113786 (h0 : topological_space (add_comm_monoid (ring (option pos)))) : t0_space (add_comm_monoid (ring (option pos))) := sorry --non-trivial
lemma new_lemma_113787 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_113788 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @t0_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_113789 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_113790 (h0 : monoid (random_gen (random_gen (has_top linarith.ineq)))) : monoid.fg (random_gen (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_113791 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : locally_compact_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113792 (h0 : ring (has_star unsigned)) : is_domain (has_star unsigned) := sorry --non-trivial
lemma new_lemma_113793 (h0 : topological_space (has_sub (semiring unsigned))) : t0_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_113794 (h1 : topological_space (add_cancel_comm_monoid string_imp)) : t0_space (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_113795 (h0 : complete_lattice (semigroup num)) : complete_lattice.is_Sup_finite_compact (semigroup num) := sorry --non-trivial
lemma new_lemma_113796 (h2 h3 : multiset enat) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_113797 (h0 : group (linear_ordered_semiring (semiring empty))) : group.fg (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_113798 (h0 : empty -> empty -> Prop) : is_antisymm empty h0 := sorry --non-trivial
lemma new_lemma_113799 (h0 : topological_space (normed_comm_ring (option (option (option (option ennreal)))))) : locally_compact_space (normed_comm_ring (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_113800 (h0 : finset (has_add (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_113801 (h0 : topological_space (boolean_algebra (has_add unsigned))) : path_connected_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_113802 (h0 : finset (has_Sup (add_right_cancel_monoid empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_113803 (h0 : functor.add_const (uniform_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_113804 (h0 : functor.add_const (complete_lattice (comm_group pos)) pos) : @is_atomistic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_113805 (h0 : ring (has_append to_additive.value_type)) : is_domain (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_113806 (h0 : ring (has_Inf (has_add (has_add (has_add (has_add name)))))) : is_domain (has_Inf (has_add (has_add (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_113807 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_113808 (h0 : topological_space (has_Inf (boolean_algebra.core pos))) : topological_space.separable_space (has_Inf (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_113809 (h0 : topological_space (ordered_comm_ring (has_nndist Type))) : sequential_space (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_113810 (h0 : topological_space (simple_graph string_imp)) : path_connected_space (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_113811 (h0 : functor.add_const (uniform_space (has_to_string name)) Type) : @complete_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_113812 (h0 : ring (add_cancel_monoid (finset Type))) : rank_condition (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_113813 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (cancel_monoid linarith.comp)) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (cancel_monoid.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_113814 (h0 : complete_lattice (normed_comm_ring pos)) : is_atomistic (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_113815 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) Type) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_113816 (h0 : group (has_add (has_to_string (has_add (ring (has_add pos)))))) : normalizer_condition (has_add (has_to_string (has_add (ring (has_add pos))))) := sorry --non-trivial
lemma new_lemma_113817 (h0 : functor.comp semiring has_to_string Type) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_113818 (h0 : uniform_space (add_comm_monoid environment.implicit_infer_kind)) : separated_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_113819 (h4 : ring (distrib_lattice (has_nnnorm char))) : strong_rank_condition (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_113820 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113821 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_113822 (h0 : ring (with_bot (random_gen to_additive.value_type))) : rank_condition (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113823 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_113824 (h0 : topological_space (comm_semigroup name)) : discrete_topology (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_113825 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : t0_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_113826 (h0 : topological_space (has_to_string (has_to_string pos))) : preirreducible_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_113827 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113828 (h0 : group (is_R_or_C (semiring (semiring empty)))) : is_cyclic (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_113829 (h1 : uniform_space doc_category) : complete_space doc_category := sorry --non-trivial
lemma new_lemma_113830 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_113831 (h0 : semiring (omega_complete_partial_order (option empty))) : is_noetherian_ring (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_113832 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf real)))) : preconnected_space (normed_lattice_add_comm_group (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_113833 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113834 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_dist empty)) := sorry --non-trivial
lemma new_lemma_113835 (h1 : group (random_gen (random_gen to_additive.value_type))) : group.fg (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113836 (h0 : functor.add_const (topological_space (comm_group pos)) (option name)) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_113837 (h0 : topological_space (boolean_algebra.core (has_add (has_add unsigned)))) : t0_space (boolean_algebra.core (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_113838 (h0 : topological_space (add_group (semiring complex))) : irreducible_space (add_group (semiring complex)) := sorry --non-trivial
lemma new_lemma_113839 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_113840 (h0 : filter (add_left_cancel_monoid (has_ssubset (has_ssubset linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_113841 (h0 : monoid (canonically_ordered_comm_semiring (option num))) : monoid.fg (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_113842 (h0 : complete_lattice (add_monoid (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_113843 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : regular_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_113844 (h0 : topological_space (has_emptyc (semiring num))) : t0_space (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_113845 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_113846 (h0 : topological_space (boolean_algebra.core (option ennreal))) : path_connected_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_113847 (h0 : list (has_top (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113848 (h0 : group (distrib reducibility_hints)) : is_cyclic (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_113849 (h0 : topological_space (boolean_algebra (comm_group (semigroup (comm_group Type))))) : irreducible_space (boolean_algebra (comm_group (semigroup (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_113850 (h0 : group (ordered_cancel_add_comm_monoid pos)) : group.fg (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_113851 (h0 : fin has_zero.zero) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_113852 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113853 (h0 : functor.add_const (complete_lattice (finset Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_113854 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_113856 (h0 : topological_space (distrib_lattice reducibility_hints)) : t0_space (distrib_lattice reducibility_hints) := sorry --non-trivial
lemma new_lemma_113857 (h0 : topological_space (pseudo_metric_space name)) : totally_disconnected_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_113858 (h0 : group (complete_semilattice_Sup unsigned)) : is_cyclic (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_113859 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) num) : @normal_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_113860 (h1 : topological_space (semiring (has_top fun_info))) : totally_separated_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_113861 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_113862 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_113864 (h0 : functor.add_const (cancel_comm_monoid_with_zero (is_R_or_C unsigned)) (option empty)) : @unique_factorization_monoid.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (is_R_or_C.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_113865 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add linarith.comp)))) : totally_separated_space (generalized_boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_113866 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_113867 (h0 : group (boolean_algebra.core name)) : is_simple_group (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_113868 (h0 : function.extfun Type (functor.add_const (topological_space (option unsigned)))) : @loc_path_connected_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (option.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113869 (h0 : topological_space (has_inter (option unsigned))) : path_connected_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_113870 (h0 : functor.add_const (group ennreal) (option ennreal)) : @group.fg.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_113871 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_113872 (h0 : list (left_cancel_semigroup (semiring (semiring (ordered_cancel_comm_monoid (semiring unsigned)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_113873 (h0 : topological_space std_gen) (h1 : set (set std_gen)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_113874 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @discrete_topology.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_113875 (h0 : topological_space (pseudo_metric_space empty)) : totally_disconnected_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_113876 (h0 : functor.add_const (topological_space (has_star empty)) (semiring num)) : @locally_compact_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_113877 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @is_add_cyclic.{0} linarith.comp (@finset.pi.empty.{1 0} Type add_group.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113878 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_113879 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_113880 (h0 : add_group (option (option name))) : is_add_cyclic (option (option name)) := sorry --non-trivial
lemma new_lemma_113881 (h1 : complete_lattice (semi_normed_ring (has_ssubset reducibility_hints))) : is_compactly_generated (semi_normed_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_113882 (h0 : topological_space (has_nnnorm (denumerable linarith.comp_source))) : t0_space (has_nnnorm (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_113883 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_113884 (h1 : complete_lattice (has_div reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_113885 (h0 : functor.add_const (complete_lattice (add_group num)) (semiring (semiring (semiring (semiring num))))) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))) h0)  := sorry --non-trivial
lemma new_lemma_113886 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_semigroup num)) := sorry --non-trivial
lemma new_lemma_113887 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113888 (h0 : functor.comp topological_space canonically_ordered_comm_semiring (finset (finset ennreal))) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} (finset.{0} (finset.{0} ennreal))) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} (finset.{0} (finset.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_113889 (h0 : topological_space (has_nndist (has_to_string (has_to_string (finset name))))) : t1_space (has_nndist (has_to_string (has_to_string (finset name)))) := sorry --non-trivial
lemma new_lemma_113890 (h0 : topological_space (with_bot (random_gen (comm_ring fun_info)))) : t0_space (with_bot (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_113891 (h0 : topological_space (add_semigroup empty)) : totally_separated_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_113892 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @group.fg.{0} char (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) char)  := sorry --non-trivial
lemma new_lemma_113893 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_113894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_113895 (h0 : not (group (measurable_space.dynkin_system unsigned) -> false)) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_113896 (h0 : topological_space (div_inv_monoid (has_nnnorm fun_info))) : totally_disconnected_space (div_inv_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_113897 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113898 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) ennreal) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_113899 (h0 : topological_space (has_pos_part (has_nndist linarith.comp))) : preirreducible_space (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_113900 (h0 : functor.add_const (group (boolean_algebra.core pos)) pos) : @normalizer_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_113901 (h0 : topological_space (canonically_ordered_comm_semiring (option congr_arg_kind))) : discrete_topology (canonically_ordered_comm_semiring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113902 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_113903 (h1 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @discrete_topology.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h1)  := sorry --non-trivial
lemma new_lemma_113904 (h0 : topological_space (dlist to_additive.value_type)) : totally_disconnected_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_113905 (h0 : topological_space (has_pos_part (has_add (finset pos)))) : normal_space (has_pos_part (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_113906 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_113907 (h0 : topological_space (fintype (random_gen (random_gen linarith.comp_source)))) : path_connected_space (fintype (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_113908 (h1 : complete_lattice (has_ssubset (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_113909 (h0 : semiring (has_Inf (has_add (has_add Type)))) : is_noetherian_ring (has_Inf (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_113910 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_113911 (h0 : topological_space (comm_semigroup (has_Inf (sub_neg_monoid (has_Inf (sub_neg_monoid name)))))) : discrete_topology (comm_semigroup (has_Inf (sub_neg_monoid (has_Inf (sub_neg_monoid name))))) := sorry --non-trivial
lemma new_lemma_113912 (h0 : topological_space (has_bot (sub_neg_monoid real))) : totally_separated_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_113913 (h0 : ordered_add_comm_monoid (add_cancel_monoid empty)) : archimedean (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_113914 (h0 : topological_space (has_nndist (finset linarith.comp))) : loc_path_connected_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_113915 (h1 : semiring (mul_one_class enat)) (h2 : ideal (mul_one_class enat)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_113916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_113917 (h0 : complete_lattice (has_lt environment.projection_info)) : is_compactly_generated (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_113918 (h0 : semiring (complete_linear_order (semiring unsigned))) : is_noetherian_ring (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_113919 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_113920 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_113921 (h0 : add_group (normed_group linarith.comp)) : is_add_cyclic (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_113922 (h0 : complete_lattice (has_ssubset linarith.ineq)) : is_compactly_generated (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_113923 (h0 : topological_space (left_cancel_monoid unsigned)) : totally_disconnected_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_113924 (h0 : topological_space (has_zero (add_comm_monoid (has_add Type)))) : preirreducible_space (has_zero (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_113925 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf (has_add pos))))) : totally_disconnected_space (boolean_algebra (has_pos_part (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_113926 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_neg Type)) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_113927 (h0 : topological_space (random_gen string_imp)) : totally_separated_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_113928 (h0 : topological_space (non_assoc_semiring (option empty))) : normal_space (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_113929 (h0 : topological_space (option (semiring num))) : path_connected_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_113930 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_113931 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_113932 (h0 : topological_space (semiring (has_union (has_norm (semiring congr_arg_kind))))) : discrete_topology (semiring (has_union (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_113933 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (ring pos)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_113934 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) Type) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_113935 (h0 : uniform_space (has_sub (has_top congr_arg_kind))) : complete_space (has_sub (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_113936 (h0 : functor.comp topological_space add_cancel_monoid name) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_113937 (h0 : topological_space (finset environment.implicit_infer_kind)) : t0_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_113938 (h0 : monoid (has_Inf real)) : monoid.fg (has_Inf real) := sorry --non-trivial
lemma new_lemma_113939 (h0 : topological_space (has_nndist (finset ennreal))) : preirreducible_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_113940 (h0 : list (has_neg_part (has_add (has_add Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_113941 (h0 : monoid (partial_order (semiring num))) : monoid.fg (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_113942 (h0 : functor.add_const (topological_space (bin_tree unsigned)) empty) : @preirreducible_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_113943 (h0 : functor.add_const (semiring (left_cancel_monoid empty)) empty) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_113944 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_113946 (h0 : semiring (canonically_ordered_comm_semiring (has_pos_part (has_pos_part (has_Inf Type))))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_pos_part (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_113947 (h0 : complete_lattice (has_top (random_gen num))) : is_compactly_generated (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_113948 (h0 : topological_space (encodable (has_nnnorm (random_gen char)))) : path_connected_space (encodable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_113949 (h0 : ordered_add_comm_monoid (has_inner (option empty) congr_arg_kind)) : archimedean (has_inner (option empty) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_113950 (h0 : topological_space (has_pos_part (has_add Type))) : irreducible_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_113951 (h0 : uniform_space (bin_tree unsigned)) : separated_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_113952 (h0 : group (has_neg (has_pos_part Type))) : is_simple_group (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_113953 (h0 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup ereal)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_113954 (h0 : topological_space (random_gen (has_top linarith.comp_source))) : t0_space (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_113955 (h0 : topological_space (add_comm_monoid (has_to_string name))) : t1_space (add_comm_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_113956 (h0 : functor.add_const (topological_space (has_nndist unsigned)) congr_arg_kind) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_113957 (h0 : not (add_group (measure_theory.measure_space unsigned) -> false)) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_113958 (h0 : ring (mul_zero_class (has_add (has_add name)))) : rank_condition (mul_zero_class (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_113959 (h0 : ordered_comm_monoid (has_nndist (has_to_string environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_113960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_113961 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @topological_space.separable_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_113962 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @is_cyclic.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113963 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_ssubset (semigroup char)))) : is_compactly_generated (non_unital_non_assoc_semiring (has_ssubset (semigroup char))) := sorry --non-trivial
lemma new_lemma_113964 (h0 : set (add_comm_semigroup (mul_one_class char) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_113965 (h0 : topological_space (has_inv (linear_ordered_add_comm_group to_additive.value_type))) : path_connected_space (has_inv (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113966 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @totally_separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_113967 (h0 : topological_space (cancel_monoid (option num))) : locally_compact_space (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_113968 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_113969 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero name)) name) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_113970 (h0 : add_group (has_inv (has_top string_imp))) : is_add_cyclic (has_inv (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_113971 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_113972 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_113973 (h0 : uniform_space (canonically_ordered_comm_semiring (ring (ring name)))) : complete_space (canonically_ordered_comm_semiring (ring (ring name))) := sorry --non-trivial
lemma new_lemma_113974 (h0 : group (finset (has_add (has_pos_part linarith.comp)))) : is_simple_group (finset (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_113975 (h0 : uniform_space (normed_comm_ring (option (option ennreal)))) : separated_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_113976 (h0 : function.extfun Type ring) : @is_domain.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_113977 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup num)) congr_arg_kind) : @archimedean.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_113978 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : thunk pnat) : pnat.coprime (@with_bot.unbot.{0} pnat h0 h1) (@trace_call_stack.{0} pnat h2)  := sorry --non-trivial
lemma new_lemma_113979 (h0 : topological_space (normed_comm_ring (semiring empty))) : irreducible_space (normed_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_113980 (h0 : group (has_add (sub_neg_monoid (has_add real)))) : normalizer_condition (has_add (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_113981 (h1 : ring (mul_one_class fun_info)) : is_domain (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_113982 (h0 : ring (measurable_space (random_gen (random_gen fun_info)))) : strong_rank_condition (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_113983 (h0 : functor.add_const (uniform_space (has_add Type)) pos) : @separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_113984 (h0 : ulower Prop) : @ulower.up.{0} Prop encodable.Prop h0  := sorry --non-trivial
lemma new_lemma_113985 (h0 : filter (has_nndist (has_neg (has_neg Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_113986 (h0 : topological_space (preorder (option num))) : irreducible_space (preorder (option num)) := sorry --non-trivial
lemma new_lemma_113987 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_113988 (h0 : uniform_space (has_norm (has_norm (has_norm to_additive.value_type)))) : complete_space (has_norm (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_113989 (h1 : topological_space (add_comm_semigroup enat)) : path_connected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_113990 (h0 : function.extfun (finset Type) (has_mem.mem (add_group_with_zero_nhd num))) : @complete_lattice.is_Sup_finite_compact.{0} (add_group_with_zero_nhd.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (add_group_with_zero_nhd.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (add_group_with_zero_nhd.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_113991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_113992 (h0 : topological_space (mul_zero_class (ring unsigned))) : preirreducible_space (mul_zero_class (ring unsigned)) := sorry --non-trivial
lemma new_lemma_113993 (h0 : functor.add_const (complete_lattice znum) empty) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_113994 (h0 : topological_space (has_ssubset (random_gen to_additive.value_type))) : irreducible_space (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_113995 (h0 : finset (pseudo_metric_space ennreal) -> finset (pseudo_metric_space ennreal) -> Prop) : is_symm (finset (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_113996 (h0 : not (uniform_space (has_star num) -> false)) : @complete_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_113997 (h0 : prod (ring (option (option empty))) (ring (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_113998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_113999 (h0 : semiring (add_comm_semigroup (mul_one_class string.iterator_imp))) (h1 : ideal (add_comm_semigroup (mul_one_class string.iterator_imp))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_114000 (h0 : uniform_space (with_one (semiring (semiring empty)))) : complete_space (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114001 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_114002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_114003 (h0 : functor.add_const (group (has_to_string name)) pos) : @is_cyclic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_114004 (h0 : function.extfun Type (functor.add_const (topological_space linarith.comp))) : @sequential_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} linarith.comp)) h0 name))  := sorry --non-trivial
lemma new_lemma_114005 (h0 : topological_space (normed_field reducibility_hints)) : path_connected_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_114006 (h0 : functor.add_const (topological_space (finset name)) name) : @irreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_114007 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114008 (h0 : list (canonically_linear_ordered_monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114009 (h0 : monoid (has_emptyc (semiring (random_gen linarith.comp_source)))) : monoid.fg (has_emptyc (semiring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114010 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_114011 (h0 : topological_space (has_bot (ordered_comm_group empty))) : totally_disconnected_space (has_bot (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_114012 (h0 h1 : list fun_info) : list.is_prefix h0 h1 := sorry --non-trivial
lemma new_lemma_114013 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @locally_compact_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_114014 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) pos) : @preconnected_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_114015 (h0 : ring string.iterator_imp) : strong_rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_114016 (h0 : topological_space (has_Inf (has_Inf pos))) : preconnected_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_114017 (h0 : list (boolean_algebra.core (add_comm_monoid pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114018 (h0 : ring (distrib (comm_ring (comm_ring linarith.ineq)))) : is_domain (distrib (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_114019 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_Inf (has_pos_part pos)))) : unique_factorization_monoid (complete_distrib_lattice (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_114020 (h0 : topological_space (has_Sup (option empty))) : t1_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_114021 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114022 (h1 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_114023 (h0 : group (comm_ring (mul_one_class (mul_one_class linarith.ineq)))) : is_cyclic (comm_ring (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_114024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_114025 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_114026 (h0 : has_lt (nondiscrete_normed_field (normed_field char))) : no_max_order (nondiscrete_normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_114027 (h0 : list (canonically_ordered_comm_semiring congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114028 (h0 : ring (mul_zero_class (has_add ennreal))) : is_principal_ideal_ring (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_114029 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @irreducible_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_114030 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_114031 (h2 : complete_lattice (non_unital_non_assoc_semiring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_114032 (h0 : list (has_inter unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114033 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_114034 (h0 : set (add_comm_semigroup std_gen -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_114035 (h0 : topological_space (semigroup (mul_one_class (has_to_string Type)))) : normal_space (semigroup (mul_one_class (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_114036 (h1 : not (ring (has_ssubset char) -> false)) : @rank_condition.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_114037 (h0 : group (with_bot (semiring num))) : group.fg (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_114038 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_add.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_114039 (h0 : group (linear_ordered_semiring (has_norm num))) : is_cyclic (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_114040 (h0 : prod (non_assoc_semiring (semiring congr_arg_kind)) (non_assoc_semiring (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_114041 (h0 : ring (has_append (comm_ring (has_nnnorm fun_info)))) : rank_condition (has_append (comm_ring (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_114042 (h1 : ring (normed_field char)) : strong_rank_condition (normed_field char) := sorry --non-trivial
lemma new_lemma_114043 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_114044 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114045 (h0 : topological_space (has_inner (semiring num) unsigned)) : totally_separated_space (has_inner (semiring num) unsigned) := sorry --non-trivial
lemma new_lemma_114046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_114047 (h0 : complete_lattice (has_top (random_gen (random_gen (random_gen (random_gen fun_info)))))) : is_atomistic (has_top (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_114048 (h0 : ring (has_to_string (has_nndist (ring name)))) : is_principal_ideal_ring (has_to_string (has_nndist (ring name))) := sorry --non-trivial
lemma new_lemma_114049 (h0 : topological_space (complete_distrib_lattice (has_add (boolean_algebra Type)))) : t1_space (complete_distrib_lattice (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_114050 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_114051 (h0 : topological_space (plift (option num))) : discrete_topology (plift (option num)) := sorry --non-trivial
lemma new_lemma_114052 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph linarith.comp)) (has_add (has_add pos))) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} linarith.comp)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_114053 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_114054 (h0 : not (topological_space (normed_group linarith.ineq) -> false)) : @irreducible_space.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_114055 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @t1_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_114056 (h0 : add_monoid (monoid_with_zero pos)) : add_monoid.fg (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_114057 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_114058 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114059 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring name)) (has_add (has_neg name))) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} name)) (has_add.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_114060 (h0 : set (has_star congr_arg_kind)) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_114061 (h0 : fin has_zero.zero) (h1 : list (fin has_zero.zero)) : matrix.vec_empty (list.ilast' h0 h1) := sorry --non-trivial
lemma new_lemma_114062 (h0 : ring (add_cancel_comm_monoid (metric_space (metric_space linarith.comp_source)))) : rank_condition (add_cancel_comm_monoid (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114063 (h2 : group (normed_field char)) : is_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_114064 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) linarith.comp) : @t0_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (topological_space.{1} Type) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_114065 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114066 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring num))) : unique_factorization_monoid (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_114067 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_114068 (h0 : uniform_space (has_nnnorm (denumerable (denumerable reducibility_hints)))) : complete_space (has_nnnorm (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_114069 (h0 : topological_space (linear_ordered_field to_additive.value_type)) : t0_space (linear_ordered_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114070 (h0 : ring (add_cancel_comm_monoid (option (option congr_arg_kind)))) : strong_rank_condition (add_cancel_comm_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114071 (h0 : topological_space (preorder (option empty))) : totally_separated_space (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_114072 (h0 : topological_space (has_bot real)) : preconnected_space (has_bot real) := sorry --non-trivial
lemma new_lemma_114073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_114074 (h0 : topological_space (has_inter unsigned)) : preconnected_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_114075 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_114076 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_114077 (h0 : not (has_lt (comm_ring string.iterator_imp) -> false)) : @no_max_order.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (has_lt.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_114078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_114079 (h0 : topological_space (with_one (random_gen (random_gen fun_info)))) : irreducible_space (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_114080 (h0 : topological_space (has_zero (measurable_space (has_zero pos)))) : loc_path_connected_space (has_zero (measurable_space (has_zero pos))) := sorry --non-trivial
lemma new_lemma_114081 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @sequential_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_114082 (h0 : preorder (distrib linarith.ineq)) (h1 : set (distrib linarith.ineq)) : bdd_below h1 := sorry --non-trivial
lemma new_lemma_114083 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114084 (h0 : ring (non_unital_non_assoc_semiring (distrib (has_div (semigroup string.iterator_imp))))) : rank_condition (non_unital_non_assoc_semiring (distrib (has_div (semigroup string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_114085 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_114086 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_114087 (h0 : not (topological_space (has_norm fun_info) -> false)) : @path_connected_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_114088 (h0 : add_monoid (mul_zero_class num)) : add_monoid.fg (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_114089 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_114090 (h1 : topological_space (add_comm_semigroup enat)) : topological_space.first_countable_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_114091 (h0 : complete_lattice (random_gen (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114092 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add (has_Inf pos))))) : normal_space (canonically_ordered_monoid (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_114093 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) pos) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_114094 (h0 : topological_space (has_edist unsigned)) : loc_path_connected_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_114095 (h0 : topological_space (bin_tree empty)) : discrete_topology (bin_tree empty) := sorry --non-trivial
lemma new_lemma_114096 (h0 : group (has_to_string (option (option (option pos))))) : is_cyclic (has_to_string (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_114097 (h0 : not (complete_lattice (id congr_arg_kind) -> false)) : @is_atomistic.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114098 (h0 : set (has_div (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_114099 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @discrete_topology.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_114100 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_114101 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114102 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class num)) (semiring empty)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_114103 (h0 : not (complete_lattice (has_star empty) -> false)) : @is_compactly_generated.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_114104 (h0 : function.extfun Type ring) : @rank_condition.{0} (fintype.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (fintype.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114105 (h0 : filter (boolean_algebra (comm_group (comm_group name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114106 (h0 : group (mul_zero_class Type)) : group.fg (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_114107 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_114108 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114109 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) linarith.comp) : @is_compactly_generated.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114110 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_Inf pos))) : unique_factorization_monoid (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_114111 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114112 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : discrete_topology (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114113 (h0 : topological_space (complete_semilattice_Sup empty)) : topological_space.separable_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_114114 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} (has_add.{0} pos))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_114115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_114116 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_114117 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) (has_add pos)) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_114118 (h0 : topological_space (random_gen (semiring congr_arg_kind))) : irreducible_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114119 (h0 : topological_space (comm_semigroup (has_bot real))) : regular_space (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_114120 (h0 : uniform_space (semigroup unsigned)) : complete_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_114121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114122 (h0 : ring (comm_group pos)) : is_domain (comm_group pos) := sorry --non-trivial
lemma new_lemma_114123 (h0 : add_monoid (semigroup (has_neg_part environment.implicit_infer_kind))) : add_monoid.fg (semigroup (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114124 (h0 : functor.add_const (filter (finset pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114125 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class char))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_114126 (h0 : group (distrib_lattice (has_nnnorm char))) : group.fg (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_114127 (h1 : topological_space (has_compl (random_gen (random_gen to_additive.value_type)))) : t0_space (has_compl (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_114128 (h0 : ring (has_one (has_top linarith.comp))) : rank_condition (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_114129 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) Type) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_114130 (h1 : topological_space (has_inv (has_nnnorm to_additive.value_type))) : path_connected_space (has_inv (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114131 (h0 : uniform_space (add_semigroup (option empty))) : complete_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_114132 (h6 : has_lt (nondiscrete_normed_field reducibility_hints)) : no_max_order (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_114133 (h0 : fin has_zero.zero) : @rank_condition.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_114134 (h0 : monoid (left_cancel_monoid (option (option (option (option (option (option unsigned)))))))) : monoid.fg (left_cancel_monoid (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_114135 (h0 : finset (simple_graph (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114136 (h0 : not (group (has_union unsigned) -> false)) : @normalizer_condition.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_114137 (h1 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h1) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_114138 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : loc_path_connected_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_114139 (h0 : functor.add_const (ring (finset pos)) pos) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114140 (h1 : not (topological_space (normed_field char) -> false)) : @t0_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_114141 (h0 : group (boolean_algebra.core (has_add (has_nndist (option name))))) : is_simple_group (boolean_algebra.core (has_add (has_nndist (option name)))) := sorry --non-trivial
lemma new_lemma_114142 (h0 : complete_lattice (has_top linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_114143 (h0 : group (has_ssubset (random_gen linarith.ineq))) : group.fg (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114144 (h0 : semiring (has_union (semiring (has_top linarith.comp)))) : is_noetherian_ring (has_union (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_114145 (h0 : list (has_add (has_add (has_neg (has_neg (has_neg Type)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114146 (h0 : group (add_cancel_monoid (has_neg (has_neg linarith.comp)))) : group.fg (add_cancel_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_114147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_114148 (h0 : topological_space (preorder num)) : preirreducible_space (preorder num) := sorry --non-trivial
lemma new_lemma_114149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_114150 (h2 : group (add_monoid (has_nnnorm fun_info))) : is_cyclic (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_114151 (h0 : group (option (semiring empty))) : is_cyclic (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_114152 (h0 : group (add_cancel_monoid pos)) : is_simple_group (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_114153 (h0 : functor.add_const (finset (has_neg name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114154 (h1 : list (linear_ordered_add_comm_group (random_gen (random_gen (random_gen linarith.comp_source))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_114155 (h0 : group (semiring (has_top congr_arg_kind))) : normalizer_condition (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114156 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114157 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_inv linarith.ineq))))) : rank_condition (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_114158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (conditionally_complete_linear_order.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (conditionally_complete_linear_order.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_114159 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) ennreal) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_114160 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (has_add (has_pos_part pos))) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (has_add.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_114161 (h0 : ordered_add_comm_monoid (has_bot (has_Inf (sub_neg_monoid real)))) : archimedean (has_bot (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_114162 (h0 : functor.add_const (functor.add_const (topological_space (add_left_cancel_semigroup empty)) num) num) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num) num h0))  := sorry --non-trivial
lemma new_lemma_114163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114164 (h1 : ring (has_nnnorm enat)) : is_domain (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_114165 (h0 : functor.add_const (ring (has_pos_part pos)) name) : @rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_114166 (h2 : not (topological_space to_additive.value_type -> false)) : @t0_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h2)  := sorry --non-trivial
lemma new_lemma_114167 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : t0_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_114168 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114169 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_114170 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_114171 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_pos_part linarith.comp))) : unique_factorization_monoid (canonically_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_114172 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : discrete_topology (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_114173 (h0 : topological_space (mul_zero_class (has_neg_part environment.implicit_infer_kind))) : normal_space (mul_zero_class (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114174 (h0 : topological_space (sub_neg_monoid (has_pos_part pos))) : regular_space (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_114175 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) (h1 : add_group (semi_normed_comm_ring linarith.ineq)) : topological_add_group (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_114176 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_114177 (h0 : functor.add_const (finset (preorder unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114178 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @locally_compact_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_114179 (h0 : topological_space (has_neg nnreal)) : loc_path_connected_space (has_neg nnreal) := sorry --non-trivial
lemma new_lemma_114180 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114181 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_114182 (h0 : list (random_gen (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114183 (h0 : complete_lattice (monoid_with_zero ennreal)) : is_compactly_generated (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_114184 (h0 : ordered_add_comm_monoid (cancel_monoid ennreal)) : archimedean (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_114185 (h0 : topological_space (semigroup unsigned)) : regular_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_114186 (h0 : measurable_space (add_comm_semigroup ereal)) (h1 : has_sup (add_comm_semigroup ereal)) : has_measurable_sup (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_114187 (h0 : topological_space (has_neg_part (boolean_algebra.core ennreal))) : topological_space.separable_space (has_neg_part (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_114188 (h0 : ring (has_nndist name)) : is_domain (has_nndist name) := sorry --non-trivial
lemma new_lemma_114189 (h0 : topological_space (linear_ordered_field (option unsigned))) : preirreducible_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_114190 (h0 : complete_lattice (has_ssubset string_imp)) : is_compactly_generated (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_114191 (h0 : topological_space (boolean_algebra.core (finset (finset (finset (finset pos)))))) : regular_space (boolean_algebra.core (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_114192 (h0 : nat) (h1 : vector Prop h0) : list.head (vector.to_list (id h1)) := sorry --non-trivial
lemma new_lemma_114193 (h0 : function.extfun Type (functor.add_const (list (add_right_cancel_monoid num)))) : list.nodup (functor.add_const.run (function.extfun_app h0 (option empty))) := sorry --non-trivial
lemma new_lemma_114194 (h1 : group (with_one (id to_additive.value_type))) : group.fg (with_one (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114195 (h0 : not (add_group (div_inv_monoid fun_info) -> false)) : @is_add_cyclic.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_114196 (h0 : add_group (comm_group (has_to_string (ring Type)))) : is_add_cyclic (comm_group (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_114197 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_114198 (h0 : topological_space (has_neg_part (has_add unsigned))) : regular_space (has_neg_part (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_114199 (h0 : functor.add_const (semiring (semigroup pos)) (finset linarith.comp)) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114200 (h0 : function.extfun Type topological_space) : @t1_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_114201 (h0 : finset (sub_neg_monoid real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114202 (h0 : topological_space (as_linear_order num)) : totally_separated_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_114203 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid real))) : t1_space (ordered_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_114204 (h0 : ring (distrib char)) : rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_114205 (h0 : ring (linear_ordered_comm_ring (ordered_cancel_comm_monoid empty))) : strong_rank_condition (linear_ordered_comm_ring (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_114206 (h0 : topological_space (has_edist (semiring num))) : irreducible_space (has_edist (semiring num)) := sorry --non-trivial
lemma new_lemma_114207 (h0 : group (normed_comm_ring environment.implicit_infer_kind)) : is_simple_group (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_114208 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (measure_theory.measure_space empty)) := sorry --non-trivial
lemma new_lemma_114209 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) (add_comm_monoid (has_add name))) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) (add_comm_monoid.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_114210 (h0 : functor.add_const (complete_lattice (has_to_string name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114211 (h0 : ordered_add_comm_monoid (complete_distrib_lattice Type)) : archimedean (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_114212 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_114213 (h0 : topological_space (has_union unsigned)) : totally_separated_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_114214 (h0 : uniform_space (has_Inf (has_add (has_add (ring (boolean_algebra.core linarith.comp)))))) : separated_space (has_Inf (has_add (has_add (ring (boolean_algebra.core linarith.comp))))) := sorry --non-trivial
lemma new_lemma_114215 (h0 : group (normed_comm_ring (has_add (finset (has_to_string linarith.comp))))) : normalizer_condition (normed_comm_ring (has_add (finset (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_114216 (h0 : add_group (add_left_cancel_monoid (complete_distrib_lattice char))) : is_add_cyclic (add_left_cancel_monoid (complete_distrib_lattice char)) := sorry --non-trivial
lemma new_lemma_114217 (h0 : set (add_comm_semigroup string.iterator_imp -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_114218 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : t0_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_114219 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part unsigned)) pos) : @unique_factorization_monoid.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_114220 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_114221 (h0 : group (add_comm_monoid (has_to_string linarith.comp))) : group.fg (add_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_114222 (h0 : function.extfun Type ring) : @rank_condition.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114223 (h0 : complete_lattice (measurable_space (has_inv fun_info))) : is_atomistic (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_114224 (h0 : add_monoid (boolean_algebra unsigned)) : add_monoid.fg (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_114225 (h0 : not (semiring (has_norm linarith.comp_source) -> false)) (h1 : has_norm linarith.comp_source) : @odd.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (semiring.{0} (has_norm.{0} linarith.comp_source)) h0) h1  := sorry --non-trivial
lemma new_lemma_114226 (h0 : ordered_add_comm_monoid (has_Inf (ordered_ring linarith.comp))) : archimedean (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_114227 (h0 : functor.add_const (ring (has_pos_part pos)) (ring name)) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_114228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114229 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114230 (h0 : functor.add_const (list (has_add name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114231 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_114232 (h0 : functor.add_const (filter (has_zero empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114233 (h0 : topological_space (normed_comm_ring (ring (ring linarith.comp)))) : path_connected_space (normed_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_114234 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_pos_part pos)) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_pos_part.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_114235 (h0 : topological_space (has_nndist congr_arg_kind)) : topological_space.separable_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114236 (h0 : ring (semiring linarith.ineq)) : is_domain (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_114237 (h0 : topological_space (add_comm_monoid (semigroup name))) : totally_separated_space (add_comm_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_114238 (h0 : functor.add_const (add_monoid (measure_theory.measure_space congr_arg_kind)) empty) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (measure_theory.measure_space.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_114239 (h0 : topological_space (normed_comm_ring (normed_comm_ring (normed_comm_ring Type)))) : discrete_topology (normed_comm_ring (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_114240 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_114241 (h0 : ring (free_add_monoid congr_arg_kind)) : is_domain (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114242 (h0 : add_monoid (boolean_algebra (has_neg name))) : add_monoid.fg (boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_114243 (h0 : topological_space (ring (has_neg linarith.comp))) : path_connected_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_114244 (h0 : complete_lattice (measurable_space num)) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_114245 (h0 : topological_space (add_left_cancel_semigroup (option (option unsigned)))) : loc_path_connected_space (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_114246 (h0 : topological_space (canonically_ordered_monoid (semiring (semiring unsigned)))) : t0_space (canonically_ordered_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_114247 (h0 : filter (boolean_algebra.core (comm_group name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_114248 (h0 : cancel_comm_monoid_with_zero (finset num)) : unique_factorization_monoid (finset num) := sorry --non-trivial
lemma new_lemma_114249 (h0 : topological_space (semigroup (has_to_string environment.implicit_infer_kind))) : t0_space (semigroup (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114250 (h0 : topological_space (generalized_boolean_algebra (ring name))) : loc_path_connected_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_114251 (h0 : not (topological_space (comm_ring fun_info) -> false)) : @locally_compact_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_114252 (h0 : add_monoid (measurable_space linarith.comp)) : add_monoid.fg (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_114253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114254 (h0 : topological_space (topological_space to_additive.value_type)) : locally_compact_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114255 (h0 : ring (has_top (random_gen (random_gen (has_norm (random_gen to_additive.value_type)))))) : is_domain (has_top (random_gen (random_gen (has_norm (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_114256 (h0 : functor.add_const (group (add_cancel_monoid pos)) linarith.comp) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114257 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_114258 (h3 : topological_space (normed_field (normed_field linarith.ineq))) (h4 : set (normed_field (normed_field linarith.ineq))) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_114259 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : normal_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114260 (h0 : complete_lattice (measure_theory.measure_space (has_top (has_top (semiring unsigned))))) : is_atomistic (measure_theory.measure_space (has_top (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_114261 (h1 : not (add_group (distrib to_additive.value_type) -> false)) : @is_add_cyclic.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_114262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114263 (h0 : filter (has_neg_part name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_114264 (h0 : not (uniform_space (mul_zero_class congr_arg_kind) -> false)) : @complete_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114265 (h0 : ring (canonically_ordered_comm_semiring empty)) : is_domain (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_114266 (h0 : uniform_space (random_gen (semiring (semiring unsigned)))) : complete_space (random_gen (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_114267 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) (boolean_algebra name)) : @complete_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_114268 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_114269 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : discrete_topology (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_114270 (h0 : topological_space (measurable_space (has_norm (has_top fun_info)))) : totally_separated_space (measurable_space (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_114271 (h0 : ring (encodable string_imp)) : is_domain (encodable string_imp) := sorry --non-trivial
lemma new_lemma_114272 (h1 : add_group (distrib_lattice (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_114273 (h0 : topological_space (has_to_string (has_add (finset pos)))) : sequential_space (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_114274 (h0 : not (complete_lattice (mul_zero_class unsigned) -> false)) : @is_atomistic.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_114275 (h0 : function.extfun Type (functor.add_const (topological_space (partial_order unsigned)))) : @totally_separated_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (partial_order.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114276 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @path_connected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_114277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_114278 (h0 : topological_space (cancel_monoid (normed_comm_ring Type))) : path_connected_space (cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_114279 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg linarith.comp)) : @discrete_topology.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114281 (h0 : group (generalized_boolean_algebra (has_Inf linarith.comp))) : normalizer_condition (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_114282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_114283 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_114284 (h0 : has_neg (add_comm_semigroup environment.projection_info)) (h1 : measurable_space (add_comm_semigroup environment.projection_info)) : has_measurable_neg (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_114285 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_114286 (h0 : topological_space (measurable_space num)) : totally_separated_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_114287 (h0 : not (group (normed_group linarith.comp_source) -> false)) : @normalizer_condition.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114288 (h0 : topological_space (comm_group (option ennreal))) : regular_space (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_114289 (h0 : topological_space (ring (boolean_algebra (boolean_algebra environment.implicit_infer_kind)))) : irreducible_space (ring (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_114290 (h0 : not (ring (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_114291 (h0 : ring (has_neg_part ennreal)) : strong_rank_condition (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_114292 (h1 : add_group (normed_field (finset string.iterator_imp))) : is_add_cyclic (normed_field (finset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_114293 (h0 : group (boolean_algebra (has_neg_part pos))) : is_simple_group (boolean_algebra (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_114294 (h0 : list (has_nndist pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114295 (h0 : not (add_group (fintype to_additive.value_type) -> false)) : @is_add_cyclic.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_114296 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : totally_separated_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_114297 (h2 : topological_space (has_nnnorm char)) : t0_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_114298 (h0 : ring (linear_ordered_field unsigned)) : rank_condition (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_114299 (h0 : functor.add_const (group (mul_zero_class environment.implicit_infer_kind)) pos) : @group.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_114300 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_114301 (h0 : functor.add_const (fin has_zero.zero) (has_neg real)) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_neg.{0} real) h0))  := sorry --non-trivial
lemma new_lemma_114302 (h0 : function.extfun Type ring) : @is_domain.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114303 (h0 : topological_space (linear_ordered_comm_group num)) : topological_space.separable_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_114304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114305 (h0 : ring (finset (has_add (has_add pos)))) : strong_rank_condition (finset (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_114306 (h0 : add_group (has_to_string (has_nndist environment.implicit_infer_kind))) : is_add_cyclic (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_114308 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) (has_neg Type)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_114309 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_114310 (h0 : not (ring (bin_tree unsigned) -> false)) : @is_domain.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_114311 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114312 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @preirreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_114313 (h0 : functor.add_const (list (has_nndist Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114314 (h0 : ring (normed_comm_ring (has_add name))) : strong_rank_condition (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_114315 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_114316 (h0 : topological_space (has_emptyc (has_top (has_top linarith.comp_source)))) : irreducible_space (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114317 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_114318 (h0 : list (complete_semilattice_Sup (has_norm (dlist (denumerable to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114319 (h0 : filter (linear_ordered_field congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_114320 (h0 : functor.add_const (finset (ordered_cancel_comm_monoid unsigned)) (option unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_114322 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_114323 (h0 : add_group (measurable_space (has_norm linarith.comp))) : is_add_cyclic (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_114324 (h0 : complete_lattice (boolean_algebra (has_bot real))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_114325 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114326 (h0 : ring (has_add (has_add Type))) : rank_condition (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_114327 (h0 : functor.add_const (finset (has_pos_part name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114328 (h0 : ordered_comm_monoid (normed_comm_ring (option (option (option pos))))) : has_exists_mul_of_le (normed_comm_ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_114329 (h0 : cancel_comm_monoid_with_zero (has_dist unsigned)) : unique_factorization_monoid (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_114330 (h0 : topological_space (cancel_monoid (boolean_algebra Type))) : normal_space (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_114331 (h1 : ring (has_nnnorm std_gen)) : is_domain (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_114332 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114333 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_114334 (h0 : complete_lattice (complete_semilattice_Sup (has_inv fun_info))) : is_atomistic (complete_semilattice_Sup (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_114335 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_114336 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : irreducible_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_114337 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_114338 (h0 : topological_space (random_gen (mul_one_class reducibility_hints))) : t0_space (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_114339 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114340 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_bot pos))) : archimedean (complete_distrib_lattice (has_bot pos)) := sorry --non-trivial
lemma new_lemma_114341 (h0 : uniform_space.core subsingleton_info) : @complete_space.{0} subsingleton_info (@uniform_space.of_core.{0} subsingleton_info h0)  := sorry --non-trivial
lemma new_lemma_114342 (h0 : topological_space (add_cancel_monoid empty)) : totally_disconnected_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_114343 (h0 : topological_space (finset empty)) : t0_space (finset empty) := sorry --non-trivial
lemma new_lemma_114344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114345 (h0 : ordered_add_comm_monoid (comm_group Type)) : archimedean (comm_group Type) := sorry --non-trivial
lemma new_lemma_114346 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_114347 (h0 : group (ring (has_to_string (comm_group (has_to_string pos))))) : is_simple_group (ring (has_to_string (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_114348 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114349 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_114350 (h0 : topological_space (has_pos_part (sub_neg_monoid Type))) : regular_space (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_114351 (h0 : complete_lattice (has_one (semiring empty))) : is_compactly_generated (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_114352 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_114353 (h0 : topological_space (dlist (random_gen linarith.ineq))) : locally_compact_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114355 (h0 : not (group (semi_normed_ring linarith.comp_source) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114356 (h0 : group (has_append (denumerable char))) : is_cyclic (has_append (denumerable char)) := sorry --non-trivial
lemma new_lemma_114357 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_114358 (h1 : topological_space (add_monoid (has_lt char))) : totally_disconnected_space (add_monoid (has_lt char)) := sorry --non-trivial
lemma new_lemma_114359 (h0 : finset (finset (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114360 (h0 : uniform_space (linear_ordered_comm_group (option (option unsigned)))) : complete_space (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_114361 (h0 : functor.add_const (fin has_zero.zero) real) : @add_monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_ordered_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_114362 (h0 : ring (normed_comm_ring ennreal)) : is_domain (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_114363 (h0 : topological_space (has_Inf (has_pos_part (has_add linarith.comp)))) : totally_separated_space (has_Inf (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_114364 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) (has_neg (has_neg (has_neg linarith.comp)))) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_114365 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_114366 (h1 : topological_space (encodable char)) : t0_space (encodable char) := sorry --non-trivial
lemma new_lemma_114367 (h0 : functor.add_const (ring environment.implicit_infer_kind) (has_pos_part pos)) : @rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_114368 (h0 : list (has_inv (has_ssubset (has_ssubset (dlist (has_ssubset linarith.ineq)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114369 (h0 : topological_space (has_to_string unsigned)) : preirreducible_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_114370 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : t0_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_114371 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (finset pos)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_114372 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_114373 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) : is_atomistic (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_114374 (h0 : ring (simple_graph ereal)) : strong_rank_condition (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_114375 (h0 : topological_space (cancel_monoid (has_neg_part unsigned))) : loc_path_connected_space (cancel_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_114376 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option num))) : archimedean (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_114377 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114378 (h0 : monoid (has_top (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : monoid.fg (has_top (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_114379 (h0 : not (ring (partial_order congr_arg_kind) -> false)) : @rank_condition.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114380 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114381 (h0 : add_group (normed_group (semiring (semiring num)))) : is_add_cyclic (normed_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_114382 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_Inf Type)) : @totally_separated_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_semigroup.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_114383 (h0 : functor.add_const (add_group (linear_ordered_cancel_comm_monoid empty)) unsigned) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114384 (h0 : not (complete_lattice (has_Sup unsigned) -> false)) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_114385 (h1 : complete_lattice (has_compl to_additive.value_type)) : is_compactly_generated (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114386 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_114387 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : t0_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_114388 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114389 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) : t0_space (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_114390 (h0 : functor.add_const (add_monoid (free_add_monoid empty)) num) : add_monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_114391 (h0 : group (finset (has_neg_part pos))) : is_cyclic (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_114392 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add pos))) : unique_factorization_monoid (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_114393 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114394 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @t0_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114395 (h0 : topological_space (filter congr_arg_kind)) : loc_path_connected_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114396 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_114397 (h1 : topological_space (linear_ordered_semiring congr_arg_kind)) : discrete_topology (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114398 (h0 : monoid (has_inv (random_gen (has_inv (random_gen fun_info))))) : monoid.fg (has_inv (random_gen (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_114399 (h0 : filter (add_cancel_monoid (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114400 (h0 : uniform_space (normed_group (semiring (semiring congr_arg_kind)))) : complete_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114401 (h0 : complete_lattice (semi_normed_ring enat)) : is_compactly_generated (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_114402 (h0 : ring (add_cancel_comm_monoid (has_append linarith.ineq))) : is_domain (add_cancel_comm_monoid (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114403 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) unsigned) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114404 (h0 : topological_space (has_top (has_top (has_top (has_top to_additive.value_type))))) : totally_separated_space (has_top (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_114405 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) (has_neg Type)) : @normalizer_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_114406 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114407 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) name) : @sequential_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_114408 (h0 : fin has_zero.zero) : list.head (matrix.vec_empty (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_114409 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114410 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_114411 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} name))  := sorry --non-trivial
lemma new_lemma_114412 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (option (option ennreal)))) : archimedean (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_114413 (h0 : complete_lattice (has_neg_part pos)) : is_atomistic (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_114414 (h0 : topological_space (semigroup (option (option pos)))) : t1_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_114415 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_114416 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : loc_path_connected_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_114417 (h0 : functor.add_const (ring (cancel_monoid pos)) environment.implicit_infer_kind) : @is_domain.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114418 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : normal_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_114419 (h0 : uniform_space (denumerable (with_zero (has_top (id string_imp))))) : complete_space (denumerable (with_zero (has_top (id string_imp)))) := sorry --non-trivial
lemma new_lemma_114420 (h0 : not (filter (random_gen linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_114421 (h0 : topological_space (partial_order (semiring (semiring num)))) : topological_space.separable_space (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_114422 (h0 : not (filter (has_append string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_114423 (h0 : complete_lattice (has_sub congr_arg_kind)) : is_atomistic (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114424 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_114425 (h0 : functor.add_const (function.extfun Type topological_space) (has_nndist (finset pos))) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_nndist.{0} (finset.{0} pos)) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_114426 (h0 : ring (has_pos_part (has_Inf pos))) : strong_rank_condition (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_114427 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : t0_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_114428 (h0 : functor.add_const (add_monoid (boolean_algebra Type)) linarith.comp) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114429 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_114430 (h0 : complete_lattice (finset (option (option (mul_zero_class name))))) : complete_lattice.is_Sup_finite_compact (finset (option (option (mul_zero_class name)))) := sorry --non-trivial
lemma new_lemma_114431 (h0 : ordered_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) : has_exists_mul_of_le (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_114432 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114433 (h0 : filter (has_neg Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114434 (h0 : group (complete_distrib_lattice (has_pos_part pos))) : group.fg (complete_distrib_lattice (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_114435 (h1 : topological_space (id (with_bot string_imp))) : totally_separated_space (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_114436 (h0 : uniform_space (random_gen (comm_ring reducibility_hints))) : complete_space (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_114437 (h0 : topological_space (has_add (has_add linarith.comp))) : t0_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_114438 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114439 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_monoid.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_114440 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114441 (h0 : fun_info -> fun_info -> Prop) : is_refl fun_info h0 := sorry --non-trivial
lemma new_lemma_114442 (h0 : topological_space (nondiscrete_normed_field fun_info)) (h1 : add_group (nondiscrete_normed_field fun_info)) : topological_add_group (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_114443 (h0 : topological_space (id (has_norm (has_norm linarith.comp)))) : locally_compact_space (id (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_114444 (h0 : prod (ordered_ring (semiring num)) (ordered_ring (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_114445 (h0 : functor.comp filter has_to_string environment.implicit_infer_kind) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_114446 (h0 : topological_space (plift (semiring num))) : path_connected_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_114447 (h0 : uniform_space (has_neg (boolean_algebra.core name))) : complete_space (has_neg (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_114448 (h0 : group (random_gen reducibility_hints)) : is_cyclic (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_114449 (h0 : ring (add_cancel_comm_monoid (metric_space (metric_space linarith.comp_source)))) : strong_rank_condition (add_cancel_comm_monoid (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114450 (h0 : semiring (has_union linarith.comp)) : is_noetherian_ring (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_114451 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114452 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_neg_part (has_neg_part Type)))) : unique_factorization_monoid (boolean_algebra (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_114453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_114454 (h0 : functor.add_const (list (has_Inf linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114455 (h0 : ring (has_Inf (has_add Type))) : strong_rank_condition (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_114456 (h1 : topological_space (canonically_linear_ordered_add_monoid (random_gen string))) : totally_disconnected_space (canonically_linear_ordered_add_monoid (random_gen string)) := sorry --non-trivial
lemma new_lemma_114457 (h0 : topological_space (has_bot (ordered_comm_monoid real))) : path_connected_space (has_bot (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_114458 (h0 : add_group (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_114459 (h0 : filter (has_zero (ring (finset (finset name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114460 (h0 : topological_space (has_nndist (pseudo_metric_space (has_neg (option pos))))) : locally_compact_space (has_nndist (pseudo_metric_space (has_neg (option pos)))) := sorry --non-trivial
lemma new_lemma_114461 (h0 : functor.add_const (topological_space (option empty)) congr_arg_kind) : @totally_separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_114462 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : totally_disconnected_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_114464 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring (semiring num)))))) : t1_space (complete_linear_order (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_114465 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_114466 (h0 : functor.add_const (topological_space znum) unsigned) : @topological_space.separable_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114467 (h0 : complete_lattice (denumerable (has_nnnorm fun_info))) : is_compactly_generated (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_114468 (h0 : functor.comp topological_space comm_group ennreal) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} ennreal h0))  := sorry --non-trivial
lemma new_lemma_114469 (h0 : ring (has_compl (has_nnnorm linarith.comp_source))) : strong_rank_condition (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114470 (h0 : topological_space (nondiscrete_normed_field char)) (h1 : option (topological_space (nondiscrete_normed_field char))) : totally_disconnected_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_114471 (h0 : monoid (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : monoid.fg (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114472 (h0 : ordered_comm_monoid (has_neg_part (ring name))) : has_exists_mul_of_le (has_neg_part (ring name)) := sorry --non-trivial
lemma new_lemma_114473 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114474 (h0 : topological_space name) : totally_disconnected_space name := sorry --non-trivial
lemma new_lemma_114475 (h1 : topological_space (add_left_cancel_monoid (has_nnnorm char))) : path_connected_space (add_left_cancel_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_114476 (h0 : add_group (complete_linear_order num)) : is_add_cyclic (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_114477 (h0 : topological_space (semiring (random_gen (random_gen fun_info)))) : irreducible_space (semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_114478 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_114479 (h0 : group (has_zero (finset (add_cancel_comm_monoid (finset (finset linarith.comp)))))) : is_simple_group (has_zero (finset (add_cancel_comm_monoid (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_114480 (h0 : ring (normed_group (has_top (has_norm linarith.comp_source)))) : is_domain (normed_group (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114481 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} real)) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} (has_Inf.{0} real)))  := sorry --non-trivial
lemma new_lemma_114482 (h0 : ring (random_gen (has_norm congr_arg_kind))) : is_domain (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114483 (h0 : functor.add_const (complete_lattice (has_add Type)) Type) : @is_compactly_generated.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_114484 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_114485 (h0 : functor.add_const (functor.add_const (uniform_space (has_nndist name)) pos) (ring (comm_group linarith.comp))) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (has_nndist.{0} name)) pos) (ring.{0} (comm_group.{0} linarith.comp)) h0))  := sorry --non-trivial
lemma new_lemma_114486 (h1 : topological_space (semi_normed_ring string_imp)) : t0_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_114487 (h0 : functor.add_const (ring empty) (option (option empty))) : @strong_rank_condition.{0} empty (@functor.add_const.run.{0 0} (ring.{0} empty) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_114488 (h0 : set (has_ssubset (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_114489 (h0 : not (filter (option unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_114490 (h0 : functor.comp filter has_nndist ennreal) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_114491 (h0 : topological_space (semigroup (has_neg_part name))) : discrete_topology (semigroup (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_114492 (h0 : not (functor.add_const Prop linarith.comp -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_114493 (h0 : list (linear_order congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114495 (h0 : function.extfun Type group) : @normalizer_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114496 (h0 : semiring (option (semiring (semiring (semiring empty))))) : is_noetherian_ring (option (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_114497 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen string_imp))))) : t0_space (normed_group (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_114498 (h0 : complete_lattice (has_union (semiring empty))) : is_atomistic (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_114499 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_114500 (h0 : ring (finset (finset environment.implicit_infer_kind))) : strong_rank_condition (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114501 (h0 : uniform_space (random_gen (has_ssubset (has_ssubset linarith.ineq)))) : complete_space (random_gen (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_114502 (h0 : functor.comp topological_space boolean_algebra (has_add environment.implicit_infer_kind)) : @normal_space.{0} (boolean_algebra.{0} (has_add.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_114503 (h0 : topological_space (has_neg num)) : path_connected_space (has_neg num) := sorry --non-trivial
lemma new_lemma_114504 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core Type))) : normal_space (ordered_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_114505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_114506 (h0 : functor.add_const (complete_lattice (partial_order num)) empty) : @is_compactly_generated.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_114507 (h0 : ring (partial_order (semiring (semiring congr_arg_kind)))) : is_domain (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114508 (h1 : topological_space (metric_space linarith.comp_source)) : t0_space (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_114509 (h0 : functor.add_const (list (ring name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114510 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_114511 (h0 : add_monoid (cancel_monoid (has_neg_part (has_add (has_add (has_add (has_add pos))))))) : add_monoid.fg (cancel_monoid (has_neg_part (has_add (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_114512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114513 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_114514 (h0 : functor.add_const (group (ordered_ring empty)) unsigned) : @normalizer_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114515 (h1 : topological_space (nondiscrete_normed_field (mul_one_class environment.projection_info))) (h2 : preorder (nondiscrete_normed_field (mul_one_class environment.projection_info))) : order_topology (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_114516 (h0 : topological_space (boolean_algebra.core (has_add pos))) : t0_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_114517 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) pos) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114518 (h0 : not (topological_space auto.case_option -> false)) : @t0_space.{0} auto.case_option (@classical.by_contradiction'.{1} (topological_space.{0} auto.case_option) h0)  := sorry --non-trivial
lemma new_lemma_114519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_114520 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_114521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_114522 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114523 (h0 : uniform_space (add_cancel_monoid (has_add Type))) : complete_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_114524 (h0 : complete_lattice (semi_normed_comm_ring linarith.comp_source)) : is_compactly_generated (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_114525 (h0 : functor.add_const (topological_space (has_add name)) name) : @irreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_114526 (h0 : functor.comp group finset name) : @is_simple_group.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} group.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_114527 (h0 : topological_space (boolean_algebra.core (option empty))) : normal_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_114528 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_114529 (h0 : not (complete_lattice (normed_field string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_114530 (h0 : ring (with_bot (comm_ring to_additive.value_type))) : is_domain (with_bot (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114531 (h0 : topological_space (denumerable (has_inv string_imp))) : t0_space (denumerable (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_114532 (h0 : nat) (h1 : complete_lattice (sym.sym' string_imp h0)) : complete_lattice.is_Sup_finite_compact (sym.sym' string_imp h0) := sorry --non-trivial
lemma new_lemma_114533 (h0 : add_monoid (left_cancel_monoid congr_arg_kind)) : add_monoid.fg (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114534 (h0 : uniform_space (add_comm_monoid pos)) : separated_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_114535 (h0 : function.extfun Type group) : @group.fg.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114536 (h0 : has_lt (normed_field environment.projection_info)) : no_max_order (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_114537 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : locally_compact_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114538 (h0 : topological_space (has_emptyc (has_top fun_info))) : discrete_topology (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_114539 (h1 : add_group (with_zero to_additive.value_type)) : is_add_cyclic (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114540 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice (monoid_with_zero empty)) empty))) : @is_atomistic.{0} (monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid_with_zero.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (monoid_with_zero.{0} empty)) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (monoid_with_zero.{0} empty)) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_114541 (h0 : group (has_neg (has_to_string Type))) : is_simple_group (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_114542 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_114543 (h0 : topological_space (has_add string_imp)) : path_connected_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_114544 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @normal_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_114545 (h0 : ordered_add_comm_monoid (has_to_string (has_add pos))) : archimedean (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_114546 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114547 (h0 : list (canonically_ordered_comm_semiring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114548 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option empty))) : complete_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_114549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114550 (h0 : complete_lattice (has_neg linarith.comp)) : is_atomistic (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_114551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} empty (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) empty)  := sorry --non-trivial
lemma new_lemma_114552 (h2 : nat) : nat.perfect h2 := sorry --non-trivial
lemma new_lemma_114553 (h2 : topological_space (complete_semilattice_Sup (normed_group string_imp))) : t0_space (complete_semilattice_Sup (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_114554 (h0 : fin has_zero.zero) : @is_atomistic.{0} (add_comm_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_114555 (h0 : add_monoid (finset (has_add name))) : add_monoid.fg (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_114556 (h0 : not (ring (semi_normed_ring to_additive.value_type) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_114557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_114558 (h1 : list (denumerable to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_114559 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid Type))) : normal_space (complete_distrib_lattice (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_114560 (h0 : ring (with_bot (has_top (has_top to_additive.value_type)))) : strong_rank_condition (with_bot (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_114561 (h0 : semiring (left_cancel_monoid (semiring (semiring num)))) : is_noetherian_ring (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_114562 (h0 : semiring (generalized_boolean_algebra (boolean_algebra.core (lattice linarith.comp)))) : is_noetherian_ring (generalized_boolean_algebra (boolean_algebra.core (lattice linarith.comp))) := sorry --non-trivial
lemma new_lemma_114563 (h0 : topological_space (ring (mul_one_class Type))) : discrete_topology (ring (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_114564 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_114565 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) Type) (has_add Type)) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (ring.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (ring.{0} environment.implicit_infer_kind) Type) (has_add.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_114566 (h0 : ring (ordered_cancel_add_comm_monoid empty)) : rank_condition (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_114567 (h0 : ring (semi_normed_comm_ring (random_gen (has_ssubset (has_ssubset fun_info))))) : rank_condition (semi_normed_comm_ring (random_gen (has_ssubset (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_114568 (h0 : functor.add_const (ordered_comm_monoid (comm_group name)) Type) : @has_exists_mul_of_le.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_114569 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_114570 (h0 : topological_space (has_neg (option ennreal))) : totally_separated_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_114571 (h0 : ring (has_neg_part (has_add (normed_comm_ring Type)))) : is_domain (has_neg_part (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_114572 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_114573 (h0 : topological_space (has_union num)) : locally_compact_space (has_union num) := sorry --non-trivial
lemma new_lemma_114574 (h0 : list (has_nndist empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114575 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114576 (h0 : functor.add_const (add_group (has_add linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114577 (h0 : topological_space (linear_ordered_field ennreal)) : loc_path_connected_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_114578 (h0 : ring (has_to_string (comm_group pos))) : rank_condition (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_114579 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_ring unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_114580 (h0 : ring (dlist (has_nnnorm to_additive.value_type))) : rank_condition (dlist (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_114582 (h0 : not (uniform_space (with_bot linarith.comp_source) -> false)) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114583 (h0 : functor.add_const (ordered_comm_monoid (has_zero environment.implicit_infer_kind)) (has_pos_part linarith.comp)) : @has_exists_mul_of_le.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114584 (h0 : ring (has_compl (mul_one_class (mul_one_class fun_info)))) : is_domain (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_114585 (h0 : topological_space (add_comm_monoid (has_bot (sub_neg_monoid real)))) : topological_space.separable_space (add_comm_monoid (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_114586 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_114587 (h0 : list (has_to_string (comm_group pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114588 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @discrete_topology.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_114589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114590 (h1 : ring (has_emptyc congr_arg_kind)) : rank_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114591 (h0 : list (has_nndist (has_nndist (has_nndist name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114592 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_114593 (h0 : functor.add_const (ring (ring name)) name) : @is_principal_ideal_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_114594 (h0 : semiring (bin_tree num)) : is_noetherian_ring (bin_tree num) := sorry --non-trivial
lemma new_lemma_114595 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114596 (h0 : ordered_add_comm_monoid (ring (ring pos))) : archimedean (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_114597 (h0 : ring (has_add (has_neg Type))) : rank_condition (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_114598 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_114599 (h0 : topological_space (has_div enat)) (h1 : add_group (has_div enat)) : topological_add_group (has_div enat) := sorry --non-trivial
lemma new_lemma_114600 (h0 : add_group (has_top char)) : is_add_cyclic (has_top char) := sorry --non-trivial
lemma new_lemma_114601 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (finset pos)) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_114602 (h0 : add_group (has_pos_part (has_Inf name))) : is_add_cyclic (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_114603 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114604 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core pos)) linarith.comp) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114605 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_114606 (h0 : functor.add_const (list (semigroup Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114607 (h0 : topological_space (has_add (has_Inf real))) : irreducible_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_114608 (h3 : topological_space environment.projection_info) (h4 : add_group environment.projection_info) : topological_add_group environment.projection_info := sorry --non-trivial
lemma new_lemma_114609 (h0 : add_group (bin_tree (semiring (has_top (has_top unsigned))))) : is_add_cyclic (bin_tree (semiring (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_114610 (h0 h1 : multiset (has_compl linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_114611 (h0 : functor.add_const (function.extfun Type complete_lattice) (mul_zero_class name)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (mul_zero_class.{0} name) h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_114612 (h0 : functor.add_const (functor.comp topological_space normed_comm_ring Type) unsigned) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type (@functor.add_const.run.{1 0} (functor.comp.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type) unsigned h0))  := sorry --non-trivial
lemma new_lemma_114613 (h0 : functor.add_const Prop (has_zero congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_114614 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_114615 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_114617 (h0 : uniform_space (pseudo_metric_space (has_add name))) : complete_space (pseudo_metric_space (has_add name)) := sorry --non-trivial
lemma new_lemma_114618 (h0 : ring (comm_group (has_to_string Type))) : is_principal_ideal_ring (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_114619 (h0 : topological_space Type) : regular_space Type := sorry --non-trivial
lemma new_lemma_114620 (h0 : has_le (has_div string.iterator_imp)) (h1 : has_div string.iterator_imp) : is_max h1 := sorry --non-trivial
lemma new_lemma_114621 (h0 : ring (topological_space (denumerable (comm_ring string.iterator_imp)))) : is_domain (topological_space (denumerable (comm_ring string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_114622 (h0 : topological_space (normed_comm_ring Type)) : preirreducible_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_114623 (h0 : topological_space (add_cancel_monoid (has_neg (has_pos_part Type)))) : normal_space (add_cancel_monoid (has_neg (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_114624 (h0 : list (linear_ordered_add_comm_group (has_ssubset (has_ssubset (has_nnnorm linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114625 (h1 : ring (option_t as_linear_order char)) : is_domain (option_t as_linear_order char) := sorry --non-trivial
lemma new_lemma_114626 (h2 : filter (dlist to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_114627 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_114628 (h0 : ordered_comm_monoid (boolean_algebra (comm_group (has_add name)))) : has_exists_mul_of_le (boolean_algebra (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_114629 (h0 : filter (has_add (has_add (mul_one_class linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114630 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_114631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} (comm_ring.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} (comm_ring.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_114632 (h0 : semiring std_gen) (h1 : std_gen) : even h1 := sorry --non-trivial
lemma new_lemma_114633 (h0 : topological_space (id (has_norm num))) : t0_space (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_114634 (h0 : topological_space (id (semiring (semiring unsigned)))) : t0_space (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_114635 (h0 : not (Prop -> false)) : classical.by_contradiction' h0 := sorry --non-trivial
lemma new_lemma_114636 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : totally_disconnected_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_114637 (h0 : functor.add_const (group (add_left_cancel_semigroup empty)) empty) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_114638 (h0 : add_group (left_cancel_monoid (semiring empty))) : is_add_cyclic (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_114639 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_114640 (h0 : group to_additive.value_type) : is_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_114641 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : locally_compact_space nnreal := sorry --non-trivial
lemma new_lemma_114642 (h0 : semiring (with_bot (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114643 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_114644 (h0 : metric_space (random_gen num)) (h1 : function.extfun (random_gen num) (fun (x : random_gen num), Prop)) : euclidean_geometry.cospherical (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_114645 (h0 : group (with_one (has_inv linarith.comp_source))) : group.fg (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114646 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114647 (h0 : function.extfun Type topological_space) : @t0_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114648 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring empty)))) : preirreducible_space (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114649 (h0 : has_lt (simple_graph to_additive.value_type)) : no_max_order (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114650 (h0 : uniform_space (id unsigned)) : separated_space (id unsigned) := sorry --non-trivial
lemma new_lemma_114651 (h0 : monoid (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : monoid.fg (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_114652 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (semigroup Type)) := sorry --non-trivial
lemma new_lemma_114653 (h0 : group (linear_ordered_add_comm_group (has_top (random_gen string_imp)))) : group.fg (linear_ordered_add_comm_group (has_top (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_114654 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @path_connected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_114655 (h0 : functor.add_const (topological_space (plift num)) empty) : @normal_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_114656 (h0 : complete_linear_order (non_assoc_semiring num) -> complete_linear_order (non_assoc_semiring num) -> Prop) : is_equiv (complete_linear_order (non_assoc_semiring num)) h0 := sorry --non-trivial
lemma new_lemma_114657 (h0 : functor.add_const (add_group (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114658 (h0 : complete_lattice (canonically_ordered_comm_semiring (option empty))) : is_atomistic (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_114659 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @t1_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_114660 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra pos)) linarith.comp) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114661 (h1 : group (with_one (random_gen to_additive.value_type))) : normalizer_condition (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114662 (h0 : has_mem.mem Prop has_emptyc.emptyc) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@finset.pi.empty.{1 0} Type filter.{0} Prop h0)  := sorry --non-trivial
lemma new_lemma_114663 (h0 : filter congr_arg_kind) (h1 : congr_arg_kind -> Prop) : @filter.limsup.{0 0} Prop congr_arg_kind (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_114664 (h0 : Prop) (h1 : measurable_space std_gen) (h2 : measure_theory.measure std_gen) : xor h0 (measure_theory.is_finite_measure h2) := sorry --non-trivial
lemma new_lemma_114665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_114666 (h0 : functor.add_const (add_monoid (has_nndist environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_114667 (h0 : topological_space (has_norm (has_norm linarith.comp_source))) : totally_disconnected_space (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114668 (h0 : functor.add_const (group (measurable_space.dynkin_system num)) (semiring num)) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_114669 (h0 : topological_space (ordered_comm_ring Type)) : locally_compact_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_114670 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_114671 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : topological_space.separable_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_114672 (h0 : topological_space (has_to_string (finset Type))) : irreducible_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_114673 (h1 : ring (denumerable (random_gen (random_gen string_imp)))) : strong_rank_condition (denumerable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_114674 (h1 : ring linarith.comp_source) : rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_114675 (h0 : ring (normed_comm_ring (has_to_string (comm_group (has_to_string (has_to_string pos)))))) : is_domain (normed_comm_ring (has_to_string (comm_group (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_114676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_114677 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_114678 (h0 : functor.comp group mul_zero_class pos) : @is_simple_group.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_114679 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @totally_separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_114680 (h0 : monoid (has_emptyc (random_gen num))) : monoid.fg (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_114681 (h0 : group char) (h1 : subgroup char) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_114682 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_114683 (h0 : group (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : group.fg (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_114684 (h0 : ring (linear_ordered_add_comm_group_with_top string_imp)) : is_domain (linear_ordered_add_comm_group_with_top string_imp) := sorry --non-trivial
lemma new_lemma_114685 (h0 : functor.add_const (functor.add_const Prop unsigned) (option (option unsigned))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114686 (h0 : ring (nondiscrete_normed_field (mul_one_class ereal))) : is_domain (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_114687 (h0 : uniform_space (has_union empty)) : complete_space (has_union empty) := sorry --non-trivial
lemma new_lemma_114688 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_114689 (h0 : semiring (ordered_comm_ring (has_Inf linarith.comp))) : is_noetherian_ring (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_114690 (h0 : functor.add_const (add_monoid (boolean_algebra name)) (has_neg linarith.comp)) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114691 (h0 : topological_space (ring (has_Inf (has_Inf (has_add linarith.comp))))) : preirreducible_space (ring (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_114692 (h0 : group (random_gen (has_inv linarith.comp_source))) : group.fg (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114693 (h0 : uniform_space (pseudo_metric_space (option (option (option (option congr_arg_kind)))))) : separated_space (pseudo_metric_space (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_114694 (h0 : to_additive.value_type -> ring (add_left_cancel_monoid linarith.comp_source)) (h1 : ordinal) (h2 : has_lt.lt h1 (ordinal.type well_ordering_rel)) : @rank_condition.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@ordinal.bfamily_of_family.{0 0} (ring.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) to_additive.value_type h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_114695 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_114696 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_114697 (h0 : topological_space (has_zero unsigned)) : topological_space.separable_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_114698 (h0 : finset (add_cancel_comm_monoid (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114699 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char)))) : strong_rank_condition (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_114700 (h0 : complete_lattice (add_left_cancel_semigroup num)) : is_atomistic (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_114701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_114702 (h0 : group (normed_comm_ring (finset environment.implicit_infer_kind))) : is_simple_group (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114703 (h0 : ring (normed_comm_ring (finset (has_add (finset environment.implicit_infer_kind))))) : rank_condition (normed_comm_ring (finset (has_add (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_114704 (h0 : group (has_neg_part (comm_group name))) : is_simple_group (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_114705 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_114706 (h0 : add_group congr_arg_kind) : is_add_cyclic congr_arg_kind := sorry --non-trivial
lemma new_lemma_114707 (h0 : topological_space (add_comm_monoid (has_Inf (sub_neg_monoid (ordered_comm_monoid (has_pos_part Type)))))) : regular_space (add_comm_monoid (has_Inf (sub_neg_monoid (ordered_comm_monoid (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_114708 (h0 : function.extfun (Type 1) (functor.comp topological_space has_nndist)) : @irreducible_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_nndist.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_114709 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_114710 (h0 : functor.add_const (monoid (finset environment.implicit_infer_kind)) (finset (finset linarith.comp))) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} environment.implicit_infer_kind)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_114711 (h0 : topological_space (simple_graph (option (option (option empty))))) : t0_space (simple_graph (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_114712 (h0 : functor.add_const (ring (normed_comm_ring name)) pos) : @is_domain.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_114713 (h0 : functor.add_const (function.extfun Type topological_space) (boolean_algebra linarith.comp)) : @regular_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (boolean_algebra.{0} linarith.comp) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_114714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114715 (h0 : functor.add_const (topological_space (ring Type)) name) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_114716 (h0 : functor.add_const (add_group (has_to_string name)) Type) : @is_add_cyclic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_114717 (h0 : monoid (boolean_algebra (finset (has_neg Type)))) : monoid.fg (boolean_algebra (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_114718 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h1 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114719 (h0 : not (group (add_cancel_comm_monoid to_additive.value_type) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_114720 (h0 : list (has_norm (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114721 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 : function.extfun (Prop -> Type) (function.extfun Prop)) : @as_false (is_trans.{0} to_additive.value_type h0) (@function.extfun_app.{1 1} Prop decidable (@function.extfun_app.{2 1} (Prop → Type) (function.extfun.{1 1} Prop) h1 decidable) (is_trans.{0} to_additive.value_type h0))  := sorry --non-trivial
lemma new_lemma_114722 (h0 : topological_space (id (random_gen congr_arg_kind))) : discrete_topology (id (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114723 (h0 : topological_space (normed_group (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_114724 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_114725 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_114726 (h0 : prod (as_linear_order (option empty)) (as_linear_order (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_114727 (h0 : ring (simple_graph (option (option empty)))) : rank_condition (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_114728 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_114729 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_114730 (h0 : set (semi_normed_ring (mul_one_class (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_114731 (h1 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @t0_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_114732 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_114733 (h1 : not (group (has_ssubset char) -> false)) : @is_cyclic.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_114734 (h0 : complete_lattice (finset (finset (normed_comm_ring (finset linarith.comp))))) : complete_lattice.is_Sup_finite_compact (finset (finset (normed_comm_ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_114735 (h0 : uniform_space (with_one (semiring (semiring empty)))) : separated_space (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114736 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_114737 (h0 : function.extfun Type (prod (has_dist congr_arg_kind))) : id_rel (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114738 (h0 : add_group (ring (option (option pos)))) : is_add_cyclic (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_114739 (h0 : finset (left_cancel_monoid (semigroup empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114741 (h0 : topological_space (add_comm_semigroup enat)) (h1 : preorder (add_comm_semigroup enat)) : order_closed_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_114742 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_114743 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114744 (h3 : topological_space (distrib (has_nnnorm linarith.ineq))) : t0_space (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114745 (h0 : topological_space (has_to_string pos)) : totally_separated_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_114746 (h0 : topological_space (metric_space (add_cancel_comm_monoid to_additive.value_type))) : t0_space (metric_space (add_cancel_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_114747 (h0 : not (ring (encodable linarith.comp_source) -> false)) : @rank_condition.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114748 (h0 : topological_space (add_cancel_monoid empty)) : t1_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_114749 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114750 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h2 : add_group (nondiscrete_normed_field string.iterator_imp)) : topological_add_group (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_114751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_114752 (h0 : topological_space (comm_semigroup (sub_neg_monoid linarith.comp))) : t1_space (comm_semigroup (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_114753 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114754 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_114755 (h0 : group (finset environment.implicit_infer_kind)) : group.fg (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_114756 (h0 : filter (add_cancel_monoid (has_to_string (has_to_string (has_to_string unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_114757 (h0 : functor.add_const (group (boolean_algebra pos)) linarith.comp) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114758 (h0 : functor.add_const (ring (boolean_algebra.core pos)) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114759 (h0 : topological_space (has_neg_part name)) : discrete_topology (has_neg_part name) := sorry --non-trivial
lemma new_lemma_114760 (h0 : topological_space (ring (has_neg Type))) : preconnected_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_114761 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_114762 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_114763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_114764 (h0 : functor.add_const (monoid (has_neg Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114765 (h0 : ordered_comm_monoid (mul_zero_class pos)) : has_exists_mul_of_le (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_114766 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_114767 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_114768 (h0 : topological_space (finset linarith.comp)) : sequential_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_114769 (h0 : cancel_comm_monoid_with_zero (simple_graph (has_add (has_add linarith.comp)))) : unique_factorization_monoid (simple_graph (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_114770 (h0 : ring (has_norm (semiring (semiring empty)))) : strong_rank_condition (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114771 (h0 : ring (simple_graph (mul_one_class linarith.comp_source))) : is_domain (simple_graph (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114772 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_114773 (h0 : not (ring name -> false)) : @is_principal_ideal_ring.{0} name (@classical.by_contradiction'.{1} (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_114774 (h0 : monoid (ring (has_neg environment.implicit_infer_kind))) : monoid.fg (ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114775 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_114776 (h0 : group (measurable_space (has_norm (has_norm (has_inv linarith.ineq))))) : is_cyclic (measurable_space (has_norm (has_norm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_114777 (h0 : not (add_group linarith.comp -> false)) : @is_add_cyclic.{0} linarith.comp (@classical.by_contradiction'.{1} (add_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114778 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114779 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_114780 (h0 : group (semi_normed_ring fun_info)) : is_cyclic (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_114781 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114782 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) Type) : @complete_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_114783 (h0 : topological_space (filter unsigned)) : totally_disconnected_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_114784 (h0 : ring (linear_ordered_comm_ring congr_arg_kind)) : is_domain (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_114785 (h2 : set (enat -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_114786 (h0 : ring (has_top (random_gen (has_norm linarith.comp_source)))) : is_domain (has_top (random_gen (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_114787 (h0 : uniform_space (has_union (linear_ordered_semiring congr_arg_kind))) : complete_space (has_union (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_114788 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) unsigned) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114789 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @discrete_topology.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_114790 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (option (option pos)))) : archimedean (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_114791 (h0 : topological_space (ring (boolean_algebra name))) : irreducible_space (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_114792 (h0 : prod (mul_zero_class Type) (mul_zero_class Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_114793 (h0 : functor.add_const (add_group (semigroup pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114794 (h0 : topological_space (with_bot linarith.comp)) : locally_compact_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_114795 (h0 : uniform_space (has_append (metric_space (denumerable to_additive.value_type)))) : complete_space (has_append (metric_space (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_114796 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : preconnected_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114797 (h1 : has_le (comm_ring char)) (h2 : group (bounded_order (comm_ring char))) : is_cyclic (bounded_order (comm_ring char)) := sorry --non-trivial
lemma new_lemma_114798 (h0 : topological_space (comm_ring char)) : totally_disconnected_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_114799 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_114800 (h0 : group (linear_ordered_comm_ring (semiring unsigned))) : normalizer_condition (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_114801 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : locally_compact_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114802 (h0 : not (topological_space (encodable int) -> false)) : @path_connected_space.{0} (encodable.{0} int) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_114803 (h0 : list (has_neg (semigroup (has_neg (semigroup (has_neg name)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114804 (h0 : ring (linear_ordered_semiring (has_top unsigned))) : is_domain (linear_ordered_semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_114805 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_114806 (h0 : fin has_zero.zero) : @sequential_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_114807 (h0 : complete_lattice (simple_graph (sub_neg_monoid (sub_neg_monoid linarith.comp)))) : is_compactly_generated (simple_graph (sub_neg_monoid (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_114808 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_114809 (h1 : complete_lattice (semi_normed_comm_ring char)) : is_compactly_generated (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_114810 (h0 : uniform_space (with_bot (has_norm (has_norm congr_arg_kind)))) : separated_space (with_bot (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114811 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (mul_one_class linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114812 (h0 : group (has_union (semiring (has_union (semiring empty))))) : is_cyclic (has_union (semiring (has_union (semiring empty)))) := sorry --non-trivial
lemma new_lemma_114813 (h0 : set (has_div (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_114814 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_114815 (h0 : ring (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : is_domain (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114816 (h0 : uniform_space (ring (has_Inf pos))) : separated_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_114817 (h0 : complete_lattice (has_neg_part (option (option unsigned)))) : is_compactly_generated (has_neg_part (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_114818 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_114819 (h0 : measurable_space (has_ssubset enat)) (h1 : filter (has_ssubset enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_114820 (h0 : uniform_space (has_Inf (ring pos))) : separated_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_114821 (h0 : topological_space (semigroup (has_pos_part (has_add linarith.comp)))) : t0_space (semigroup (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_114822 (h0 : topological_space (normed_group (random_gen fun_info))) : t0_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_114823 (h0 h1 : multiset (canonically_linear_ordered_monoid char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_114824 (h0 : topological_space (option (option pos))) : t1_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_114825 (h0 : topological_space (has_Inf (ordered_ring (has_neg name)))) : regular_space (has_Inf (ordered_ring (has_neg name))) := sorry --non-trivial
lemma new_lemma_114826 (h0 : ordered_add_comm_monoid (normed_comm_ring (canonically_ordered_comm_semiring (has_to_string linarith.comp)))) : archimedean (normed_comm_ring (canonically_ordered_comm_semiring (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_114827 (h0 : not (uniform_space (uniform_space string) -> false)) : @complete_space.{0} (uniform_space.{0} string) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} string)) h0)  := sorry --non-trivial
lemma new_lemma_114828 (h0 : functor.add_const (filter (complete_distrib_lattice unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114829 (h0 : topological_space (boolean_algebra (has_pos_part (has_add linarith.comp)))) : irreducible_space (boolean_algebra (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_114830 (h0 : group (has_neg (comm_group environment.implicit_infer_kind))) : group.fg (has_neg (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114831 (h0 : functor.add_const (uniform_space (comm_group Type)) (has_neg linarith.comp)) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_114832 (h0 : functor.add_const (filter (ring unsigned)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114833 (h0 : uniform_space (monoid (complete_distrib_lattice empty))) : separated_space (monoid (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_114834 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group unsigned)) Type) : @archimedean.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_114835 (h0 : not (ring (has_add linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114836 (h0 : filter (add_comm_monoid (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114837 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) pos) : @complete_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114838 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @normal_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_114839 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (has_to_string pos)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_114840 (h0 : list (has_zero linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_114841 (h0 : topological_space (normed_group linarith.comp_source)) : locally_compact_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_114842 (h0 : functor.add_const (uniform_space (has_Sup empty)) num) : @complete_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_114843 (h0 : topological_space (ordered_comm_ring linarith.comp)) : sequential_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_114844 (h0 : ring (semigroup (has_to_string (has_nndist (finset (finset linarith.comp)))))) : is_domain (semigroup (has_to_string (has_nndist (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_114845 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_114846 (h0 : topological_space (add_cancel_monoid (comm_group unsigned))) : t0_space (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_114847 (h0 : topological_space (normed_lattice_add_comm_group pos)) : preconnected_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_114848 (h0 : filter (has_add (has_neg (has_neg (has_neg (has_neg (has_neg Type))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114850 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_114851 (h0 : functor.add_const (filter (has_nndist pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114852 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_114853 (h0 : topological_space (with_one (measurable_space num))) : t0_space (with_one (measurable_space num)) := sorry --non-trivial
lemma new_lemma_114854 (h0 : topological_space (comm_group (has_add (has_neg (has_add linarith.comp))))) : preirreducible_space (comm_group (has_add (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_114855 (h0 : list (has_star (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114856 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) name) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_114857 (h0 : ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) : rank_condition (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_114858 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_114859 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_114860 (h0 : function.extfun Type monoid) : @monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type monoid.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_114861 (h0 : ring (has_norm (random_gen (has_norm fun_info)))) : rank_condition (has_norm (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_114862 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114863 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_114864 (h1 : monoid (id (random_gen (random_gen (random_gen (random_gen string_imp)))))) : monoid.fg (id (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_114865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114866 (h0 : topological_space (has_bot (sub_neg_monoid real))) : totally_disconnected_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_114867 (h0 : functor.add_const (complete_lattice (has_star (semiring (semiring unsigned)))) num) : @is_compactly_generated.{0} (has_star.{0} (semiring.{0} (semiring.{0} unsigned))) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} (semiring.{0} (semiring.{0} unsigned)))) num h0)  := sorry --non-trivial
lemma new_lemma_114868 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_114869 (h0 : functor.add_const (topological_space (finset Type)) pos) : @path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_114870 (h0 : list (rel (has_to_string (finset (has_to_string Type))) (has_to_string (has_to_string Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114871 (h0 : filter (semigroup (option (has_add (has_nndist ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_114872 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114873 (h0 : topological_space (add_cancel_monoid (boolean_algebra (ring Type)))) : path_connected_space (add_cancel_monoid (boolean_algebra (ring Type))) := sorry --non-trivial
lemma new_lemma_114874 (h0 : functor.add_const (ring (has_neg_part name)) pos) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_114875 (h0 : functor.add_const (group (semigroup Type)) pos) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_114876 (h0 : semiring (add_comm_semigroup char)) (h1 : add_comm_semigroup char) : even h1 := sorry --non-trivial
lemma new_lemma_114877 (h0 : topological_space (has_neg unsigned)) : path_connected_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_114878 (h0 : functor.add_const (uniform_space (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @complete_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_114879 (h0 : complete_lattice (has_lt (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_114880 (h0 : functor.add_const (list (has_zero Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114881 (h0 : topological_space (has_zero (finset name))) : preconnected_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_114882 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp))) : @complete_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_114883 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_114884 (h0 : measurable_space ereal) (h1 : topological_space ereal) (h2 : topological_space char) (h3 : ereal -> char) : measurable_set (continuous_at h3) := sorry --non-trivial
lemma new_lemma_114885 (h0 : functor.add_const (topological_space (partial_order empty)) unsigned) : @locally_compact_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114886 (h0 : complete_lattice (normed_comm_ring ennreal)) : is_compactly_generated (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_114887 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid num)) num) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_114888 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_114889 (h0 : topological_space (ordered_comm_ring Type)) : totally_separated_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_114890 (h0 : complete_lattice (cancel_monoid empty)) : is_atomistic (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_114891 (h0 : complete_lattice (omega_complete_partial_order num)) : is_atomistic (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_114892 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_114893 (h0 : group (has_nndist (mul_zero_class (option Type)))) : group.fg (has_nndist (mul_zero_class (option Type))) := sorry --non-trivial
lemma new_lemma_114894 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_114895 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114896 (h0 : Type -> Type -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_114897 (h0 : monoid (has_nndist (boolean_algebra (has_neg (has_neg (has_neg Type)))))) : monoid.fg (has_nndist (boolean_algebra (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_114898 (h0 : topological_space (has_top (semiring empty))) : topological_space.separable_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_114899 (h0 : functor.add_const (group (boolean_algebra Type)) Type) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_114900 (h0 : not (ring (encodable (fintype linarith.comp_source)) -> false)) : @is_domain.{0} (encodable.{0} (fintype.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} (fintype.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_114901 (h3 : uniform_space char) : complete_space char := sorry --non-trivial
lemma new_lemma_114902 (h0 : topological_space (has_add num)) : normal_space (has_add num) := sorry --non-trivial
lemma new_lemma_114903 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_114904 (h0 : topological_space (as_linear_order (comm_monoid unsigned))) : totally_separated_space (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_114905 (h0 : functor.add_const (topological_space (finset unsigned)) pos) : @preconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_114906 (h0 : empty -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) empty h0  := sorry --non-trivial
lemma new_lemma_114907 (h0 : group (ordered_ring num)) : is_cyclic (ordered_ring num) := sorry --non-trivial
lemma new_lemma_114908 (h0 : add_group (normed_field ereal)) : is_add_cyclic (normed_field ereal) := sorry --non-trivial
lemma new_lemma_114909 (h0 : ring (monoid (option (option empty)))) : rank_condition (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_114910 (h0 : list (complete_semilattice_Sup (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_114911 (h0 : topological_space (add_comm_monoid (ring linarith.comp))) : discrete_topology (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_114912 (h0 : uniform_space (left_cancel_semigroup (semiring empty))) : separated_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_114913 (h0 : uniform_space (finset (option empty))) : separated_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_114914 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_114915 (h0 : functor.comp topological_space cancel_monoid name) : @irreducible_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_114916 (h1 h2 : char -> char) : function.right_inverse h1 h2 := sorry --non-trivial
lemma new_lemma_114917 (h0 : add_monoid (normed_linear_ordered_group num)) : add_monoid.fg (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_114918 (h0 : measurable_space (add_comm_semigroup (normed_field environment.projection_info))) (h1 : measure_theory.measure (add_comm_semigroup (normed_field environment.projection_info))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_114919 (h0 : functor.add_const (finset (left_cancel_monoid empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114920 (h0 : filter (has_star num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_114921 (h0 : not (topological_space (semi_normed_comm_ring bool) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} bool) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} bool)) h0)  := sorry --non-trivial
lemma new_lemma_114922 (h0 : multiset (random_gen fun_info)) (h1 : not (multiset (random_gen fun_info) -> false)) : multiset.le h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_114923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114924 (h0 : functor.add_const (group (complete_distrib_lattice pos)) pos) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_114925 (h0 : uniform_space (add_comm_monoid (boolean_algebra (has_to_string unsigned)))) : separated_space (add_comm_monoid (boolean_algebra (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_114926 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_114927 (h0 : topological_space (measurable_space (random_gen string_imp))) : t0_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_114928 (h0 : monoid (normed_lattice_add_comm_group (has_Inf linarith.comp))) : monoid.fg (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_114929 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_114930 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_114931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_114932 (h0 : finset (normed_comm_ring (finset (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114933 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @loc_path_connected_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_114934 (h0 : ring (comm_ring (has_nnnorm linarith.comp_source))) : rank_condition (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_114935 (h0 : topological_space linarith.comp_source) (h1 : preorder linarith.comp_source) : order_closed_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_114936 (h0 : ring (has_nndist (comm_group (has_to_string unsigned)))) : strong_rank_condition (has_nndist (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_114937 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @t0_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_114938 (h0 : topological_space (denumerable (random_gen string_imp))) : t0_space (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_114939 (h0 : topological_space (normed_group (has_top (denumerable string_imp)))) : path_connected_space (normed_group (has_top (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_114940 (h0 : uniform_space (finset (has_Inf Type))) : separated_space (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_114941 (h0 : ring (ordered_comm_ring (has_add linarith.comp))) : strong_rank_condition (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_114942 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_114943 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid real))) : topological_space.separable_space (normed_lattice_add_comm_group (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_114944 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_114945 (h0 : complete_lattice (add_cancel_monoid (normed_comm_ring linarith.comp))) : is_compactly_generated (add_cancel_monoid (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_114946 (h0 : ring (has_zero (non_unital_non_assoc_ring (has_add linarith.comp)))) : is_principal_ideal_ring (has_zero (non_unital_non_assoc_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_114947 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inter.{0} (canonically_linear_ordered_monoid.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} (canonically_linear_ordered_monoid.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_114948 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : loc_path_connected_space (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_114949 (h0 : add_group (boolean_algebra.core (ring (finset (has_Inf pos))))) : is_add_cyclic (boolean_algebra.core (ring (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_114950 (h0 : complete_lattice (measurable_space (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_114951 (h1 : uniform_space (measurable_space linarith.comp)) : complete_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_114952 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_114953 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_114954 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (option (option ennreal)))) : unique_factorization_monoid (boolean_algebra.core (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_114955 (h0 : not (ring (denumerable linarith.comp_source) -> false)) : @is_domain.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_114956 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @preirreducible_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_114957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_114958 (h0 : topological_space (has_inv (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : t0_space (has_inv (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_114959 (h0 : topological_space (canonically_linear_ordered_monoid real)) : totally_separated_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_114960 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @rank_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114961 (h0 : functor.add_const (filter auto.case_option) (option empty)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_114962 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_114963 (h0 : functor.add_const (uniform_space (preorder empty)) (semiring unsigned)) : @separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_114964 (h0 : add_group (complete_distrib_lattice (has_add Type))) : is_add_cyclic (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_114965 (h1 : topological_space (add_left_cancel_monoid to_additive.value_type)) : totally_disconnected_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_114966 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_114967 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_114968 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_114969 (h0 : not (complete_lattice (has_lt string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_114970 (h0 : uniform_space (has_nndist (add_comm_monoid (finset (option (add_comm_monoid empty)))))) : separated_space (has_nndist (add_comm_monoid (finset (option (add_comm_monoid empty))))) := sorry --non-trivial
lemma new_lemma_114971 (h0 : not (add_group (has_union num) -> false)) : @is_add_cyclic.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_114972 (h0 : monoid (id (option empty))) : monoid.fg (id (option empty)) := sorry --non-trivial
lemma new_lemma_114973 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @locally_compact_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_114974 (h2 : group (has_top string_imp)) : is_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_114975 (h1 : group (topological_space (uniform_space (normed_field string_imp)))) : is_cyclic (topological_space (uniform_space (normed_field string_imp))) := sorry --non-trivial
lemma new_lemma_114976 (h0 : uniform_space (plift empty)) : separated_space (plift empty) := sorry --non-trivial
lemma new_lemma_114977 (h0 : uniform_space (non_unital_non_assoc_semiring environment.projection_info)) : complete_space (non_unital_non_assoc_semiring environment.projection_info) := sorry --non-trivial
lemma new_lemma_114978 (h0 : group (bin_tree (semiring (semiring congr_arg_kind)))) : normalizer_condition (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_114979 (h0 : ring (boolean_algebra.core (option empty))) : rank_condition (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_114980 (h0 : uniform_space (sub_neg_monoid (ring name))) : separated_space (sub_neg_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_114981 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) Type) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_114982 (h0 : topological_space (with_bot (semiring num))) : irreducible_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_114983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_114984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_114985 (h0 : functor.comp uniform_space boolean_algebra.core name) : @separated_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_114986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_114987 (h0 : functor.add_const (complete_lattice (finset unsigned)) name) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_114988 (h0 : not (topological_space (normed_group to_additive.value_type) -> false)) : @locally_compact_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_114989 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_114990 (h0 : functor.comp topological_space boolean_algebra name) : @irreducible_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_114991 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_114992 (h0 : topological_space (has_add (has_neg (has_neg name)))) : locally_compact_space (has_add (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_114993 (h0 : cancel_comm_monoid_with_zero (add_semigroup empty)) : unique_factorization_monoid (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_114994 (h0 : monoid (has_add (has_neg_part environment.implicit_infer_kind))) : monoid.fg (has_add (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_114995 (h0 : add_monoid (has_one (has_one fun_info))) : add_monoid.fg (has_one (has_one fun_info)) := sorry --non-trivial
lemma new_lemma_114996 (h0 : semiring (has_sub (semiring (semiring empty)))) : is_noetherian_ring (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_114997 (h0 : add_group (boolean_algebra.core (has_neg_part Type))) : is_add_cyclic (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_114998 (h0 : finset (has_edist (option (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_114999 (h0 : group (has_add (mul_one_class Type))) : group.fg (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_115000 (h1 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} fun_info) h1)  := sorry --non-trivial
lemma new_lemma_115001 (h0 : function.extfun Type (functor.add_const (prod (left_cancel_semigroup empty) (left_cancel_semigroup empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_115002 (h0 : topological_space (semigroup linarith.comp)) : sequential_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_115003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_115004 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_115005 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_115006 (h0 : topological_space (has_pos_part (has_bot real))) : t0_space (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_115007 (h0 : uniform_space (comm_semigroup (has_Inf (has_bot Type)))) : complete_space (comm_semigroup (has_Inf (has_bot Type))) := sorry --non-trivial
lemma new_lemma_115008 (h0 : group (complete_semilattice_Sup (has_nnnorm char))) : group.fg (complete_semilattice_Sup (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_115009 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_115011 (h3 : topological_space (mul_one_class std_gen)) : totally_disconnected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_115012 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_115013 (h0 : list (has_Inf (ordered_ring (has_Inf linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115014 (h0 : complete_lattice (complete_semilattice_Sup congr_arg_kind)) : is_atomistic (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115015 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) ennreal) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_115016 (h1 : add_group (normed_field linarith.ineq)) : is_add_cyclic (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_115017 (h0 : rel std_gen (mul_one_class char)) (h1 : mul_one_class char) : rel.codom h0 h1 := sorry --non-trivial
lemma new_lemma_115018 (h0 : topological_space (finset (option num))) : t0_space (finset (option num)) := sorry --non-trivial
lemma new_lemma_115019 (h0 : functor.add_const (semiring (ring Type)) Type) : @is_noetherian_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115020 (h0 : uniform_space (random_gen (random_gen (random_gen to_additive.value_type)))) : complete_space (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_115021 (h2 : topological_space (with_one num)) : irreducible_space (with_one num) := sorry --non-trivial
lemma new_lemma_115022 (h0 : functor.add_const (topological_space (ring name)) pos) : @regular_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_115023 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra name)) linarith.comp) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115024 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_115025 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_115026 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_115027 (h0 : functor.add_const (function.extfun (Type 1) finset) (has_pos_part linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_115028 (h0 : fin has_zero.zero) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_115029 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) (comm_group (comm_group unsigned))) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) (comm_group.{0} (comm_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_115030 (h0 : group (complete_distrib_lattice num)) : normalizer_condition (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_115031 (h0 : semiring environment.projection_info) (h1 : not (ideal environment.projection_info -> false) -> ideal environment.projection_info) (h2 : nonempty (ideal environment.projection_info)) : ideal.is_prime (classical.choice_of_by_contradiction' h1 h2) := sorry --non-trivial
lemma new_lemma_115032 (h0 : topological_space (ring (ring (ordered_ring name)))) : locally_compact_space (ring (ring (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_115033 (h0 : semiring (ordered_comm_monoid (ordered_comm_monoid real))) : is_noetherian_ring (ordered_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_115034 (h0 : uniform_space (has_zero num)) : complete_space (has_zero num) := sorry --non-trivial
lemma new_lemma_115035 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) real) : @rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_115036 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @totally_separated_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_115037 (h0 : topological_space (linear_ordered_add_comm_group_with_top linarith.comp_source)) : t0_space (linear_ordered_add_comm_group_with_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115038 (h0 : has_mul Type) : set.center Type (has_mul char) := sorry --non-trivial
lemma new_lemma_115039 (h0 : group (boolean_algebra.core linarith.comp)) : normalizer_condition (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_115040 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) unsigned) : @is_atomistic.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115041 (h0 : fin has_zero.zero) : @is_atomistic.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))))  := sorry --non-trivial
lemma new_lemma_115042 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : loc_path_connected_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_115043 (h0 : ring (canonically_ordered_monoid (has_bot real))) : strong_rank_condition (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_115044 (h0 : topological_space (finset (has_to_string (monoid_with_zero linarith.comp)))) : t0_space (finset (has_to_string (monoid_with_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_115045 (h1 : list (id linarith.comp_source)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_115046 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_115047 (h0 : group (ring (option (option unsigned)))) : normalizer_condition (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_115048 (h0 : add_group (has_dist (option (option (option empty))))) : is_add_cyclic (has_dist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_115049 (h0 : topological_space (mul_zero_class (has_top (semiring (semiring num))))) : t0_space (mul_zero_class (has_top (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_115050 (h0 : topological_space (has_to_string (has_add (boolean_algebra Type)))) : normal_space (has_to_string (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_115051 (h0 : complete_lattice (has_div enat)) : complete_lattice.is_Sup_finite_compact (has_div enat) := sorry --non-trivial
lemma new_lemma_115052 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115053 (h0 : uniform_space (with_bot (has_inv (has_inv (random_gen fun_info))))) : complete_space (with_bot (has_inv (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_115054 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_115055 (h0 : functor.add_const (monoid (left_cancel_monoid num)) (option unsigned)) : @monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} num)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_115056 (h0 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_115057 (h1 : monoid (normed_group (has_norm (has_emptyc linarith.comp_source)))) : monoid.fg (normed_group (has_norm (has_emptyc linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_115058 (h0 : functor.add_const Prop (normed_comm_ring (has_neg Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_115059 (h0 : list (finset (has_add (boolean_algebra.core (add_comm_monoid pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115060 (h0 : complete_lattice (random_gen (metric_space linarith.comp_source))) : is_compactly_generated (random_gen (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115061 (h0 : topological_space (has_emptyc (has_norm (has_norm fun_info)))) : totally_separated_space (has_emptyc (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_115062 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @is_atomistic.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_115063 (h0 : ordered_comm_monoid (boolean_algebra.core (normed_comm_ring (has_add pos)))) : has_exists_mul_of_le (boolean_algebra.core (normed_comm_ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_115064 (h0 : functor.add_const (filter (has_to_string linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115065 (h1 : ring (add_monoid char)) : rank_condition (add_monoid char) := sorry --non-trivial
lemma new_lemma_115066 (h0 : topological_space (complete_semilattice_Sup (with_bot linarith.comp_source))) : locally_compact_space (complete_semilattice_Sup (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115067 (h0 : not (ring (has_emptyc to_additive.value_type) -> false)) : @rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_115068 (h0 : function.extfun (finset Type) (has_mem.mem (is_R_or_C linarith.comp_source))) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (is_R_or_C.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (is_R_or_C.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_115069 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115070 (h0 : not (topological_space (has_norm fun_info) -> false)) : @totally_separated_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_115071 (h0 : group (comm_group (pseudo_metric_space pos))) : is_cyclic (comm_group (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_115072 (h0 : group (has_bot (has_bot real))) : normalizer_condition (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_115073 (h0 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @path_connected_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_115074 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115075 (h0 : ring (ordered_comm_ring (ring (has_add Type)))) : is_principal_ideal_ring (ordered_comm_ring (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_115076 (h0 : add_group (has_neg (has_add name))) : is_add_cyclic (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_115077 (h0 : add_group (linear_ordered_semiring (has_norm unsigned))) : is_add_cyclic (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_115078 (h0 : uniform_space (group_with_zero (option ennreal))) : separated_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_115079 (h0 : topological_space (with_one (metric_space linarith.comp))) : locally_compact_space (with_one (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_115080 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @regular_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_115081 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) Type) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_115082 (h0 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : path_connected_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115083 (h0 : filter (with_bot (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115084 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_115085 (h0 : topological_space (normed_group char)) : t0_space (normed_group char) := sorry --non-trivial
lemma new_lemma_115086 (h0 : cancel_comm_monoid_with_zero (comm_semigroup (sub_neg_monoid name))) : unique_factorization_monoid (comm_semigroup (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_115087 (h1 : topological_space (nondiscrete_normed_field enat)) : t0_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_115088 (h0 : semiring (has_nndist (has_to_string (has_to_string (has_to_string pos))))) : is_noetherian_ring (has_nndist (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_115089 (h0 : cancel_comm_monoid_with_zero (ring (has_Inf (has_add (has_neg Type))))) : unique_factorization_monoid (ring (has_Inf (has_add (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_115090 (h0 : topological_space (finset Type)) : path_connected_space (finset Type) := sorry --non-trivial
lemma new_lemma_115091 (h0 : topological_space (complete_semilattice_Sup string_imp)) : regular_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_115092 (h0 : functor.add_const (uniform_space (boolean_algebra.core name)) name) : @complete_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_115093 (h0 : group (has_sub (has_top congr_arg_kind))) : group.fg (has_sub (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115094 (h0 : fin has_zero.zero) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_115095 (h0 : topological_space (comm_group (normed_comm_ring environment.implicit_infer_kind))) : path_connected_space (comm_group (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115096 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_115097 (h0 : uniform_space (has_neg_part name)) : complete_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_115098 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115099 (h0 : complete_lattice (has_add (has_Inf (has_neg (has_Inf Type))))) : complete_lattice.is_Sup_finite_compact (has_add (has_Inf (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_115100 (h0 : fin has_zero.zero) : @normal_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115101 (h0 : group (has_zero (has_add (option name)))) : normalizer_condition (has_zero (has_add (option name))) := sorry --non-trivial
lemma new_lemma_115102 (h0 : functor.add_const (monoid (has_add Type)) name) : @monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_115103 (h0 : functor.add_const (topological_space (has_Inf pos)) (finset pos)) : @preirreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_115104 (h0 : group (add_cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind))) : is_cyclic (add_cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115105 (h0 : ring (ring (has_add (has_add (ring linarith.comp))))) : is_principal_ideal_ring (ring (has_add (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_115106 (h0 : add_group (measurable_space fun_info)) : is_add_cyclic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_115107 (h0 : ring (sub_neg_monoid (sub_neg_monoid (has_Inf Type)))) : strong_rank_condition (sub_neg_monoid (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_115108 (h0 : cancel_comm_monoid_with_zero (emetric_space (semiring empty))) : unique_factorization_monoid (emetric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_115109 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115110 (h1 : complete_lattice (with_bot linarith.ineq)) : is_atomistic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_115111 (h0 : add_monoid (has_union num)) : add_monoid.fg (has_union num) := sorry --non-trivial
lemma new_lemma_115112 (h1 : add_group (linear_ordered_add_comm_group to_additive.value_type)) : is_add_cyclic (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115113 (h0 : topological_space (normed_lattice_add_comm_group (has_bot real))) : t0_space (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_115114 (h0 : ring (has_zero (boolean_algebra linarith.comp))) : strong_rank_condition (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_115115 (h0 : group (has_add (sub_neg_monoid pos))) : is_simple_group (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_115116 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115117 (h0 : functor.add_const (topological_space (has_zero name)) (has_neg environment.implicit_infer_kind)) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_115118 (h0 : functor.add_const (filter (has_zero Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115119 (h0 : not (topological_space (mul_zero_class num) -> false)) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_115120 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115121 (h0 : functor.add_const (ring (has_neg pos)) linarith.comp) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115122 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_115123 (h0 : topological_space (has_add (has_pos_part (ring (finset Type))))) : regular_space (has_add (has_pos_part (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_115124 (h0 : uniform_space (has_zero (has_pos_part linarith.comp))) : separated_space (has_zero (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_115125 (h0 : topological_space (has_sub (semiring (semiring (semiring (option empty)))))) : totally_disconnected_space (has_sub (semiring (semiring (semiring (option empty))))) := sorry --non-trivial
lemma new_lemma_115126 (h0 : complete_lattice (linear_ordered_field (has_to_string ennreal))) : is_compactly_generated (linear_ordered_field (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_115127 (h0 : functor.add_const (functor.add_const (group pos) unsigned) pos) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) unsigned) pos h0))  := sorry --non-trivial
lemma new_lemma_115128 (h0 : topological_space (add_comm_semigroup std_gen)) (h1 : set (add_comm_semigroup std_gen)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_115129 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) congr_arg_kind) : @is_domain.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_115130 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_115131 (h0 : add_group (random_gen (random_gen (random_gen (has_inv linarith.comp_source))))) : is_add_cyclic (random_gen (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_115132 (h0 : topological_space (ordered_comm_group (option (complete_distrib_lattice empty)))) : t0_space (ordered_comm_group (option (complete_distrib_lattice empty))) := sorry --non-trivial
lemma new_lemma_115133 (h0 : complete_lattice (measurable_space linarith.ineq)) : is_atomistic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_115134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_115135 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_115136 (h0 : cancel_comm_monoid_with_zero (option pos)) : unique_factorization_monoid (option pos) := sorry --non-trivial
lemma new_lemma_115137 (h0 : not (topological_space unsigned -> false)) : @totally_separated_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_115138 (h0 : topological_space (normed_field (has_nnnorm (has_nnnorm reducibility_hints)))) : t0_space (normed_field (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_115139 (h0 : ring (with_one (has_norm congr_arg_kind))) : rank_condition (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115140 (h0 : option empty -> option empty -> Prop) : is_strict_order (option empty) h0 := sorry --non-trivial
lemma new_lemma_115141 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_115142 (h0 : topological_space (canonically_ordered_comm_semiring name)) : regular_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_115143 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115144 (h0 : monoid (omega_complete_partial_order congr_arg_kind)) : monoid.fg (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115145 (h0 : add_group (has_neg (option pos))) : is_add_cyclic (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_115146 (h0 : not (group (measure_theory.measure_space unsigned) -> false)) : @group.fg.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_115147 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option empty)) := sorry --non-trivial
lemma new_lemma_115148 (h1 : topological_space (has_compl to_additive.value_type)) : path_connected_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115149 (h0 : functor.add_const (complete_lattice (finset name)) pos) : @is_atomistic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_115150 (h0 : filter (canonically_ordered_comm_semiring (option (has_nndist pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115151 (h0 : functor.add_const (semiring (has_add environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_115152 (h0 : add_group (uniform_space (semi_normed_ring (random_gen reducibility_hints)))) : is_add_cyclic (uniform_space (semi_normed_ring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_115153 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115154 (h0 : has_mem.mem (denumerable (random_gen linarith.comp_source)) has_emptyc.emptyc) : @totally_separated_space.{0} (denumerable.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (denumerable.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_115155 (h0 : complete_lattice (cancel_monoid (ring (has_add unsigned)))) : is_compactly_generated (cancel_monoid (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_115156 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_115157 (h0 : not (topological_space (has_one congr_arg_kind) -> false)) : @preirreducible_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115158 (h0 : add_group (canonically_linear_ordered_monoid ennreal)) : is_add_cyclic (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_115159 (h0 : not (has_mem.mem (has_emptyc num) has_emptyc.emptyc -> false)) : @t0_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_115160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115162 (h0 : topological_space (has_norm (random_gen num))) : totally_separated_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_115163 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring pos)) Type) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_115164 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (has_to_string pos)) : @topological_space.separable_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_115165 (h0 : add_monoid (has_to_string (has_add Type))) : add_monoid.fg (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_115166 (h0 : monoid (has_add (has_pos_part Type))) : monoid.fg (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_115167 (h0 : functor.comp (functor.comp complete_lattice has_nndist) with_top nnreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_115168 (h0 : topological_space (ring (has_pos_part (has_add pos)))) : discrete_topology (ring (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_115169 (h0 : monoid (with_bot (with_bot linarith.comp_source))) : monoid.fg (with_bot (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115170 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_115172 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid real))) : regular_space (sub_neg_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_115173 (h0 : functor.add_const (filter (semigroup pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115174 (h0 : functor.add_const (group (ring linarith.comp)) name) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_115175 (h0 : complete_lattice (measurable_space.dynkin_system congr_arg_kind)) : is_atomistic (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115176 (h0 : topological_space (has_neg_part (semigroup name))) : loc_path_connected_space (has_neg_part (semigroup name)) := sorry --non-trivial
lemma new_lemma_115177 (h1 : uniform_space (semi_normed_ring string_imp)) : complete_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_115178 (h0 : functor.add_const Prop (semiring (has_norm empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_115179 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115180 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_emptyc (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_115181 (h0 : topological_space (has_inv (has_nnnorm linarith.ineq))) : totally_disconnected_space (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115182 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_115183 (h0 : monoid (has_bot (has_Inf (has_bot Type)))) : monoid.fg (has_bot (has_Inf (has_bot Type))) := sorry --non-trivial
lemma new_lemma_115184 (h0 : functor.add_const (topological_space (finset pos)) unsigned) : @loc_path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115185 (h0 : topological_space (complete_distrib_lattice Type)) : preconnected_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_115186 (h1 : topological_space (div_inv_monoid (has_nnnorm linarith.ineq))) : totally_disconnected_space (div_inv_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115187 (h0 : topological_space (simple_graph (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp)))))) : preconnected_space (simple_graph (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_115188 (h0 : ordered_comm_monoid (add_cancel_monoid (has_neg linarith.comp))) : has_exists_mul_of_le (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_115189 (h0 : functor.add_const (function.extfun Type semiring) (ring (ring pos))) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (ring.{0} (ring.{0} pos)) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_115190 (h0 : ring (ordered_comm_ring (has_pos_part Type))) : is_domain (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_115191 (h2 : topological_space (has_compl char)) : path_connected_space (has_compl char) := sorry --non-trivial
lemma new_lemma_115192 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) unsigned) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115193 (h0 : functor.add_const (ring (boolean_algebra Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115194 (h0 : functor.add_const (filter (add_comm_monoid unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115195 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115196 (h0 : topological_space (has_bot pos)) : sequential_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_115197 (h0 : group (denumerable (has_top linarith.ineq))) : normalizer_condition (denumerable (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115198 (h0 : functor.add_const (topological_space (option unsigned)) empty) : @t0_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_115199 (h0 : not (uniform_space (semiring unsigned) -> false)) : @separated_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_115200 (h0 : ring (complete_semilattice_Sup linarith.comp)) : is_domain (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_115201 (h0 : topological_space (has_norm (has_top (has_top (has_top linarith.ineq))))) : t0_space (has_norm (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_115202 (h0 : function.extfun nat fin) : @is_atomistic.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_115203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_115204 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : preirreducible_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_115205 (h0 : semiring (canonically_ordered_comm_semiring (has_nndist pos))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_115206 (h0 : topological_space (topological_space string_imp)) : locally_compact_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_115207 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (option unsigned)) := sorry --non-trivial
lemma new_lemma_115209 (h0 : ring (normed_group (random_gen (random_gen to_additive.value_type)))) : is_domain (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_115210 (h0 : filter (has_zero (finset (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115211 (h0 : finset (has_bot linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_115212 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_115213 (h0 : topological_space (semigroup congr_arg_kind)) : topological_space.separable_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115214 (h0 : semiring (has_union (has_norm num))) : is_noetherian_ring (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_115215 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_115216 (h0 : group name) : group.fg name := sorry --non-trivial
lemma new_lemma_115217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (sub_neg_monoid.{0} (has_neg.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} (has_neg.{0} name)))  := sorry --non-trivial
lemma new_lemma_115219 (h0 : topological_space (has_sub linarith.comp)) : totally_disconnected_space (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_115220 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (ring Type)) : @regular_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_115221 (h0 : filter (boolean_algebra (comm_group unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115222 (h0 : ring (complete_distrib_lattice (has_add pos))) : is_principal_ideal_ring (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_115223 (h0 : fun_info -> fun_info) (h2 : fun_info) : function.is_fixed_pt h0 h2 := sorry --non-trivial
lemma new_lemma_115224 (h0 : topological_space (has_nndist linarith.comp)) : irreducible_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_115225 (h0 : set char) : set.finite h0 := sorry --non-trivial
lemma new_lemma_115226 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_115227 (h0 : fin has_zero.zero) : @regular_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_115228 (h0 : topological_space (pseudo_metric_space empty)) : path_connected_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_115229 (h0 : functor.add_const (ring (measurable_space.dynkin_system empty)) empty) : @is_domain.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_115230 (h0 : has_mem.mem Type has_emptyc.emptyc) : @path_connected_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_115231 (h0 h1 : local_equiv char char) : local_equiv.eq_on_source h0 h1 := sorry --non-trivial
lemma new_lemma_115232 (h0 : has_inv (has_norm fun_info) -> has_inv (has_norm fun_info) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_115233 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_115234 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_pos_part (finset pos)))) : unique_factorization_monoid (has_to_string (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_115235 (h0 : complete_lattice (boolean_algebra.core (option (option unsigned)))) : is_compactly_generated (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_115236 (h0 : monoid (finset (ring linarith.comp))) : monoid.fg (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_115237 (h0 : ring (denumerable (has_ssubset (has_ssubset fun_info)))) : rank_condition (denumerable (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_115238 (h0 : functor.add_const (finset (normed_comm_ring name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115239 (h0 : uniform_space (with_bot (random_gen (denumerable linarith.ineq)))) : complete_space (with_bot (random_gen (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_115240 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @strong_rank_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_115241 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @discrete_topology.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_115242 (h0 : not (complete_lattice (distrib (has_ssubset (has_ssubset to_additive.value_type))) -> false)) : @is_compactly_generated.{0} (distrib.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_115243 (h1 : complete_lattice (distrib_lattice linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115244 (h0 : group (cancel_monoid pos)) : is_cyclic (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_115245 (h0 : topological_space (with_one (has_norm (has_norm linarith.comp_source)))) : totally_disconnected_space (with_one (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_115246 (h0 : topological_space (has_nndist (has_to_string Type))) : discrete_topology (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_115247 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115248 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : sequential_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_115249 (h0 : functor.add_const (add_monoid (has_Inf linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115250 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_115251 (h0 : functor.add_const (complete_lattice (pseudo_metric_space empty)) unsigned) : @is_atomistic.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115252 (h0 : set (has_nnnorm (distrib string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_115253 (h0 : topological_space (ring (has_Inf (ring Type)))) : irreducible_space (ring (has_Inf (ring Type))) := sorry --non-trivial
lemma new_lemma_115254 (h0 : ring (has_ssubset (comm_ring string_imp))) : is_domain (has_ssubset (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_115255 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @t1_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115256 (h1 : topological_space (semi_normed_comm_ring (random_gen reducibility_hints))) : t0_space (semi_normed_comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_115257 (h0 : filter (comm_group (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115258 (h0 : functor.add_const (group (comm_group pos)) unsigned) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115259 (h0 : ring (finset (has_add (boolean_algebra.core pos)))) : strong_rank_condition (finset (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_115260 (h1 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115261 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_115262 (h0 : complete_lattice (normed_group (has_top (has_top fun_info)))) : is_atomistic (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_115263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_115264 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid ennreal)) : archimedean (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_115265 (h0 : function.extfun Type group) : @normalizer_condition.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_115266 (h0 : functor.add_const (ring (ring Type)) unsigned) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115267 (h0 : ring (add_comm_semigroup ereal)) : strong_rank_condition (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_115268 (h0 : ring (linear_ordered_semiring linarith.comp)) : rank_condition (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_115269 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (boolean_algebra.core ennreal))) : unique_factorization_monoid (normed_comm_ring (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_115270 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @t0_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115271 (h0 : ring (semi_normed_comm_ring (random_gen char))) : is_domain (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_115272 (h0 : fin has_zero.zero) : @archimedean.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_115273 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add Type)))) : path_connected_space (sub_neg_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_115274 (h0 : topological_space (simple_graph (finset (has_add (ring pos))))) : preirreducible_space (simple_graph (finset (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_115275 (h0 : topological_space (add_cancel_monoid (has_to_string (add_comm_monoid name)))) : irreducible_space (add_cancel_monoid (has_to_string (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_115276 (h0 : functor.add_const (ring (has_nndist ennreal)) (option unsigned)) : @is_principal_ideal_ring.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_115277 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_115278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_115280 (h0 : topological_space (has_bot pos)) : topological_space.separable_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_115281 (h0 : has_lift std_gen Prop) (h1 : std_gen) : @lift.{1 1} std_gen Prop h0 h1  := sorry --non-trivial
lemma new_lemma_115282 (h0 : has_le char) (h1 : char) : is_min h1 := sorry --non-trivial
lemma new_lemma_115283 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_115284 (h0 : group (mul_zero_class Type)) : is_simple_group (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_115285 (h0 : functor.add_const (add_group (semigroup unsigned)) unsigned) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115286 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_115287 (h0 : not (has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_115288 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) (has_neg_part pos)) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_115289 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115290 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_115291 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_115292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115293 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115294 (h0 : topological_space (complete_semilattice_Sup (has_inv (has_inv (has_top string_imp))))) : totally_separated_space (complete_semilattice_Sup (has_inv (has_inv (has_top string_imp)))) := sorry --non-trivial
lemma new_lemma_115295 (h0 : has_le (metric_space char)) (h1 : metric_space char) : is_min h1 := sorry --non-trivial
lemma new_lemma_115296 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero environment.implicit_infer_kind)) Type) : @unique_factorization_monoid.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_115297 (h0 : topological_space (ring environment.implicit_infer_kind)) : sequential_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_115298 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_115299 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_nndist name)) := sorry --non-trivial
lemma new_lemma_115300 (h0 : not (monoid (has_star congr_arg_kind) -> false)) : @monoid.fg.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115301 (h0 : functor.add_const (uniform_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115302 (h0 : not (group (complete_semilattice_Sup linarith.ineq) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115303 (h0 : topological_space (boolean_algebra.core (option pos))) : discrete_topology (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_115304 (h1 : ring (random_gen (has_ssubset char))) : is_domain (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_115305 (h0 : group (has_add (has_neg environment.implicit_infer_kind))) : group.fg (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115306 (h0 : functor.add_const (group (finset name)) environment.implicit_infer_kind) : @is_simple_group.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115307 (h0 : functor.add_const Prop (boolean_algebra.core unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_115308 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) environment.implicit_infer_kind) name) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) environment.implicit_infer_kind) name h0))  := sorry --non-trivial
lemma new_lemma_115309 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115310 (h0 : complete_lattice (denumerable (denumerable char))) : is_compactly_generated (denumerable (denumerable char)) := sorry --non-trivial
lemma new_lemma_115311 (h0 : topological_space (has_neg (has_add (has_add (has_neg linarith.comp))))) : t0_space (has_neg (has_add (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_115312 (h0 : ring (has_lt linarith.comp_source)) : rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115313 (h0 : filter (generalized_boolean_algebra (ordered_ring (has_add (finset (ring pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115314 (h0 : topological_space (has_Sup unsigned)) : path_connected_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_115315 (h0 : functor.add_const (ring (semigroup (has_to_string unsigned))) pos) : @is_domain.{0} (semigroup.{0} (has_to_string.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} (has_to_string.{0} unsigned))) pos h0)  := sorry --non-trivial
lemma new_lemma_115316 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_115317 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_115318 (h0 : topological_space (generalized_boolean_algebra (ring name))) : sequential_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_115319 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115320 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : path_connected_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_115321 (h0 : cancel_comm_monoid_with_zero (has_add (has_Inf pos))) : unique_factorization_monoid (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_115322 (h0 : function.extfun Type (functor.add_const (topological_space (partial_order congr_arg_kind)))) : @loc_path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_115323 (h0 : uniform_space (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : complete_space (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_115324 (h0 : add_group (has_add (has_add (has_add pos)))) : is_add_cyclic (has_add (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_115325 (h0 : complete_lattice (normed_group (has_top num))) : is_compactly_generated (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_115326 (h0 : ring (add_comm_monoid (monoid_with_zero ennreal))) : rank_condition (add_comm_monoid (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_115327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_dist empty)) := sorry --non-trivial
lemma new_lemma_115328 (h0 : topological_space (normed_group (has_top (has_top to_additive.value_type)))) : irreducible_space (normed_group (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_115329 (h0 : list (comm_ring to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115330 (h0 : topological_space (comm_monoid (semiring (semiring num)))) : discrete_topology (comm_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_115331 (h0 : topological_space (finset linarith.comp)) : loc_path_connected_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_115332 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_115333 (h0 : complete_lattice (has_top fun_info)) : complete_lattice.is_Sup_finite_compact (has_top fun_info) := sorry --non-trivial
lemma new_lemma_115334 (h0 : not (ring (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_domain.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115335 (h0 : functor.add_const (filter (ring pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115336 (h0 : functor.add_const (prod (has_Sup unsigned) (has_Sup unsigned)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115337 (h0 : not (topological_space (dlist (random_gen linarith.ineq)) -> false)) : @locally_compact_space.{0} (dlist.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_115338 (h0 : group (finset (has_add name))) : group.fg (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_115339 (h0 : functor.add_const (list (mul_zero_class pos)) (mul_zero_class Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115340 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_add (has_neg_part (has_neg_part unsigned))))) : unique_factorization_monoid (add_cancel_monoid (has_add (has_neg_part (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_115341 (h0 : topological_space (has_bot linarith.comp)) : totally_separated_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_115342 (h0 : topological_space (comm_monoid congr_arg_kind)) : path_connected_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115343 (h0 : not (complete_lattice rat -> false)) : @complete_lattice.is_Sup_finite_compact.{0} rat (@classical.by_contradiction'.{1} (complete_lattice.{0} rat) h0)  := sorry --non-trivial
lemma new_lemma_115344 (h0 : add_group (add_cancel_monoid name)) : is_add_cyclic (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_115345 (h0 : not (topological_space (add_group unsigned) -> false)) : @preirreducible_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_115346 (h0 : functor.add_const (group (simple_graph pos)) linarith.comp) : @is_simple_group.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115347 (h0 : topological_space (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : preirreducible_space (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_115348 (h0 : functor.add_const (list (normed_comm_ring name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115349 (h0 : topological_space (filter congr_arg_kind)) : totally_separated_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115350 (h0 : uniform_space (has_neg (mul_zero_class (finset (has_to_string pos))))) : complete_space (has_neg (mul_zero_class (finset (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_115351 (h1 : group (encodable (has_nnnorm string_imp))) : is_cyclic (encodable (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_115352 (h0 : topological_space (semiring empty)) : loc_path_connected_space (semiring empty) := sorry --non-trivial
lemma new_lemma_115353 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_115354 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : preirreducible_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_115355 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_115356 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115357 (h0 : functor.comp topological_space has_nndist Type) : @path_connected_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_115358 (h0 : topological_space (finset (has_neg pos))) : regular_space (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_115359 (h0 : group (distrib_lattice linarith.ineq)) : group.fg (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_115360 (h0 : functor.add_const (semiring (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115361 (h0 : add_group (dlist (random_gen linarith.ineq))) : is_add_cyclic (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115362 (h1 : topological_space (has_compl enat)) : t0_space (has_compl enat) := sorry --non-trivial
lemma new_lemma_115363 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115364 (h0 : ring (random_gen (random_gen linarith.comp_source))) : strong_rank_condition (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115365 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115366 (h0 : functor.add_const (group (finset name)) unsigned) : @normalizer_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115367 (h0 : functor.add_const (ring (partial_order congr_arg_kind)) unsigned) : @is_domain.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115368 (h0 : topological_space (linear_ordered_field (option unsigned))) : totally_separated_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_115369 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115370 (h0 : group (div_inv_monoid (has_nnnorm linarith.ineq))) : is_cyclic (div_inv_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115371 (h0 : list (add_cancel_monoid (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115372 (h0 : topological_space (ring (option (option pos)))) : totally_separated_space (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_115373 (h0 : function.extfun Type (functor.add_const (list (has_edist unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_115374 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @locally_compact_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_115375 (h0 : topological_space (normed_comm_ring (option ennreal))) : totally_disconnected_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_115376 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_115377 (h0 : fin has_zero.zero) : @discrete_topology.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_115378 (h0 : group (semigroup (option pos))) : is_cyclic (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_115379 (h0 : cancel_comm_monoid_with_zero (mul_zero_class empty)) : unique_factorization_monoid (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_115380 (h1 : add_group (encodable (has_nnnorm char))) : is_add_cyclic (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_115381 (h1 : not (monoid (has_norm congr_arg_kind) -> false)) : @monoid.fg.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_115382 (h0 : functor.add_const (filter (has_neg pos)) (has_neg_part (comm_group (comm_group (has_neg_part Type))))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115383 (h0 : group (has_add (option Type))) : is_simple_group (has_add (option Type)) := sorry --non-trivial
lemma new_lemma_115384 (h0 : filter (add_cancel_monoid pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115385 (h0 : topological_space (has_top (has_top to_additive.value_type))) : totally_separated_space (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_115386 (h0 : function.extfun Type ring) : @is_domain.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115387 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115388 (h0 : has_lt (has_div string_imp)) : no_max_order (has_div string_imp) := sorry --non-trivial
lemma new_lemma_115389 (h0 : ring (ordered_comm_ring (has_pos_part linarith.comp))) : strong_rank_condition (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_115390 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @path_connected_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_115391 (h0 : complete_lattice (ordered_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_compactly_generated (ordered_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_115392 (h1 : uniform_space (has_nnnorm (normed_field ereal))) : complete_space (has_nnnorm (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_115393 (h0 : functor.add_const (list (finset linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115394 (h0 : filter (ring (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115395 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115396 (h0 : topological_space (has_Inf (has_add linarith.comp))) : discrete_topology (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_115397 (h2 : add_group (has_compl linarith.comp_source)) : is_add_cyclic (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115398 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_to_string)) : @unique_factorization_monoid.{0} (has_to_string.{0} ennreal) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_to_string.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_to_string.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_115399 (h0 : functor.add_const (topological_space Type) (has_Inf linarith.comp)) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115400 (h0 : not (ring (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115401 (h0 : topological_space (mul_zero_class (boolean_algebra.core (normed_comm_ring pos)))) : loc_path_connected_space (mul_zero_class (boolean_algebra.core (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_115402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_115403 (h1 : has_mem.mem Prop has_emptyc.emptyc) : list.tfae (finset.pi.empty list Prop h1) := sorry --non-trivial
lemma new_lemma_115404 (h0 : functor.comp ring cancel_monoid name) : @is_domain.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_115405 (h0 : group (add_cancel_monoid (finset pos))) : normalizer_condition (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_115406 (h0 : has_mem.mem (complete_lattice num) has_emptyc.emptyc) : @totally_separated_space.{0} (complete_lattice.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_lattice.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_115407 (h0 : ring (add_right_cancel_monoid (option (option (option (option empty)))))) : strong_rank_condition (add_right_cancel_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_115408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_115409 (h0 : complete_lattice (comm_group (finset environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115410 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_115411 (h0 : functor.add_const (complete_lattice (has_nndist Type)) name) : @is_atomistic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_115412 (h0 : add_group (add_cancel_monoid unsigned)) : is_add_cyclic (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_115413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_115414 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group name)))) : t1_space (add_cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_115415 (h0 : std_gen -> normed_field std_gen) (h1 : std_gen -> std_gen -> std_gen) (h2 : normed_field std_gen -> normed_field std_gen -> normed_field std_gen) : function.semiconj₂ h0 h1 h2 := sorry --non-trivial
lemma new_lemma_115416 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_115417 (h1 : ring (has_compl (mul_one_class linarith.comp_source))) : rank_condition (has_compl (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115418 (h0 : topological_space (has_to_string (has_add (semigroup (comm_group (has_add name)))))) : preconnected_space (has_to_string (has_add (semigroup (comm_group (has_add name))))) := sorry --non-trivial
lemma new_lemma_115419 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_115420 (h2 : complete_lattice (has_lt to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115421 (h0 h1 : multiset (linear_ordered_comm_group_with_zero linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_115422 (h0 : group (generalized_boolean_algebra (has_neg name))) : group.fg (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_115423 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @discrete_topology.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115424 (h0 : ring (ring (option (option (option empty))))) : is_principal_ideal_ring (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_115425 (h0 : filter (has_neg (has_neg_part (comm_group (has_neg_part unsigned))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115426 (h0 : not (topological_space (has_lt linarith.comp_source) -> false)) : @t0_space.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_115427 (h0 : not (add_group (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_115429 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115430 (h1 : topological_space (denumerable (random_gen reducibility_hints))) : totally_disconnected_space (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_115431 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @discrete_topology.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_115432 (h0 : topological_space (group_with_zero empty)) : locally_compact_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_115433 (h0 : topological_space (has_compl string_imp)) : t0_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_115434 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115435 (h0 : list (complete_distrib_lattice name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_115437 (h0 : group (has_to_string (has_pos_part (normed_comm_ring pos)))) : group.fg (has_to_string (has_pos_part (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_115438 (h2 : complete_lattice congr_arg_kind) : complete_lattice.is_Sup_finite_compact congr_arg_kind := sorry --non-trivial
lemma new_lemma_115439 (h0 : ring (finset (normed_comm_ring linarith.comp))) : rank_condition (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_115440 (h0 : topological_space (denumerable linarith.ineq)) : path_connected_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_115441 (h0 : topological_space (add_cancel_monoid (has_nndist (has_add Type)))) : irreducible_space (add_cancel_monoid (has_nndist (has_add Type))) := sorry --non-trivial
lemma new_lemma_115442 (h0 : monoid (measure_theory.measure_space congr_arg_kind)) : monoid.fg (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115443 (h0 : group (complete_distrib_lattice (finset unsigned))) : is_simple_group (complete_distrib_lattice (finset unsigned)) := sorry --non-trivial
lemma new_lemma_115444 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @normal_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115445 (h0 : not (topological_space (plift empty) -> false)) : @irreducible_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_115446 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_115447 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115448 (h0 : topological_space (simple_graph (ring linarith.comp))) : totally_separated_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_115449 (h0 : topological_space (has_to_string (has_add (has_add unsigned)))) : preirreducible_space (has_to_string (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_115450 (h0 : uniform_space (normed_group (option (option unsigned)))) : separated_space (normed_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_115451 (h0 : ring (semi_normed_comm_ring (random_gen (has_ssubset string_imp)))) : is_domain (semi_normed_comm_ring (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_115452 (h0 : add_group (canonically_ordered_monoid (has_neg name))) : is_add_cyclic (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_115453 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inner.{0 0} (option.{0} empty) empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inner.{0 0} (option.{0} empty) empty))  := sorry --non-trivial
lemma new_lemma_115454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_115456 (h0 : semiring (boolean_algebra.core (option (option (option congr_arg_kind))))) : is_noetherian_ring (boolean_algebra.core (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_115457 (h0 : ring (has_emptyc (random_gen num))) : strong_rank_condition (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_115458 (h0 : topological_space (semigroup Type)) : path_connected_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_115459 (h0 : ring (distrib_lattice (with_bot linarith.comp_source))) : rank_condition (distrib_lattice (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115460 (h0 : uniform_space (with_bot unsigned)) : separated_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_115461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115462 (h0 : ordered_add_comm_monoid (has_add environment.implicit_infer_kind)) : archimedean (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_115463 (h0 : uniform_space (id (has_top (has_norm (semiring linarith.comp))))) : complete_space (id (has_top (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_115464 (h1 : group (with_one linarith.comp_source)) : is_cyclic (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115465 (h0 : finset (add_cancel_monoid (add_cancel_monoid linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_115466 (h0 : monoid (boolean_algebra (has_nndist linarith.comp))) : monoid.fg (boolean_algebra (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_115467 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) : path_connected_space (mul_one_class (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_115468 (h1 : topological_space (has_ssubset (random_gen (random_gen (random_gen (random_gen char)))))) : totally_disconnected_space (has_ssubset (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_115469 (h0 : group (distrib_lattice (random_gen (has_nnnorm (has_ssubset linarith.comp_source))))) : group.fg (distrib_lattice (random_gen (has_nnnorm (has_ssubset linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_115470 (h0 : ring (linear_ordered_semiring (semiring unsigned))) : is_principal_ideal_ring (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115471 (h0 : functor.add_const Prop (ring (option (option ennreal)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_115472 (h0 : topological_space (boolean_algebra (boolean_algebra.core Type))) : path_connected_space (boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_115473 (h0 : uniform_space (denumerable (comm_ring (comm_ring char)))) : complete_space (denumerable (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_115474 (h0 : ring (has_neg (has_to_string pos))) : is_principal_ideal_ring (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_115475 (h0 : topological_space (add_monoid char)) : path_connected_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_115476 (h0 : topological_space (has_lt char)) : t0_space (has_lt char) := sorry --non-trivial
lemma new_lemma_115477 (h0 : functor.add_const (group (semigroup Type)) name) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_115478 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_115479 (h0 : functor.add_const (topological_space (has_to_string ennreal)) ennreal) : @normal_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_115480 (h0 : function.extfun Type group) : @group.fg.{0} (emetric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (emetric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_115481 (h0 : complete_lattice (comm_group (has_add (finset (finset name))))) : complete_lattice.is_Sup_finite_compact (comm_group (has_add (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_115482 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (random_gen.{0} (has_norm.{0} num)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (random_gen.{0} (has_norm.{0} num)))  := sorry --non-trivial
lemma new_lemma_115483 (h0 : topological_space (add_comm_monoid ennreal)) : path_connected_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_115484 (h0 : topological_space (plift (ordered_ring congr_arg_kind))) : normal_space (plift (ordered_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115485 (h0 : topological_space (plift (semiring congr_arg_kind))) : discrete_topology (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115486 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115487 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (option (option unsigned)))) : archimedean (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_115488 (h1 : add_group (fintype (comm_ring linarith.ineq))) : is_add_cyclic (fintype (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115489 (h0 : group (topological_space (has_nnnorm fun_info))) : group.fg (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_115490 (h0 : cancel_comm_monoid_with_zero (has_union (semiring (semiring empty)))) : unique_factorization_monoid (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_115491 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115492 (h0 h1 : multiset (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_115493 (h0 : topological_space (has_norm linarith.comp)) : locally_compact_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_115494 (h0 : functor.comp topological_space complete_distrib_lattice name) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_115495 (h0 : ring (mul_zero_class pos)) : strong_rank_condition (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_115496 (h1 : ring (topological_space (metric_space reducibility_hints))) : is_domain (topological_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_115497 (h0 : topological_space (semigroup (has_to_string linarith.comp))) : locally_compact_space (semigroup (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_115498 (h0 : filter (measurable_space fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115499 (h1 : topological_space (normed_group linarith.ineq)) : t0_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_115500 (h0 : functor.add_const (topological_space (preorder num)) unsigned) : @topological_space.separable_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115501 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_115502 (h1 : ring (random_gen (random_gen char))) : is_domain (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_115503 (h0 : ring (generalized_boolean_algebra (canonically_linear_ordered_monoid real))) : is_domain (generalized_boolean_algebra (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_115504 (h0 : topological_space (with_bot (random_gen num))) : irreducible_space (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_115505 (h0 : topological_space (normed_comm_ring (option pos))) : normal_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_115506 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @t1_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115507 (h0 : topological_space (mul_zero_class num)) : t1_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_115508 (h0 : list (normed_linear_ordered_group congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115509 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_115510 (h0 : topological_space (random_gen (has_top (has_top (has_top linarith.ineq))))) : path_connected_space (random_gen (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_115511 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preconnected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_115512 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (plift unsigned)) := sorry --non-trivial
lemma new_lemma_115513 (h0 : ring (ordered_comm_ring (ring (has_pos_part Type)))) : is_principal_ideal_ring (ordered_comm_ring (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_115514 (h0 : semiring char) (h1 : ideal char) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_115515 (h0 : uniform_space (encodable linarith.comp_source)) : complete_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115516 (h0 : functor.add_const (ring (has_add pos)) pos) : @is_domain.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_115517 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115518 (h0 : topological_space (has_to_string (semigroup (ring environment.implicit_infer_kind)))) : totally_disconnected_space (has_to_string (semigroup (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_115519 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_Inf (has_Inf Type))) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_115520 (h0 : ring (normed_group char)) : rank_condition (normed_group char) := sorry --non-trivial
lemma new_lemma_115521 (h0 : finset (simple_graph (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_115522 (h0 : monoid (has_top linarith.comp)) : monoid.fg (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_115523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115524 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_115525 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_115526 (h0 : functor.add_const (add_monoid (comm_group name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115527 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) (h1 : preorder (linear_ordered_comm_group_with_zero linarith.comp_source)) : order_topology (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115528 (h0 : uniform_space (mul_zero_class name)) : separated_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_115529 (h0 : complete_lattice (linear_order empty)) : complete_lattice.is_Sup_finite_compact (linear_order empty) := sorry --non-trivial
lemma new_lemma_115530 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_115531 (h0 : finset (canonically_ordered_monoid real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_115532 (h0 : ring (denumerable (comm_ring (comm_ring (comm_ring linarith.comp_source))))) : rank_condition (denumerable (comm_ring (comm_ring (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_115533 (h0 : has_lt (nondiscrete_normed_field char)) : no_max_order (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_115534 (h0 : functor.add_const (topological_space (add_group unsigned)) num) : @irreducible_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_115535 (h0 : ring (simple_graph (option empty))) : strong_rank_condition (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_115536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115537 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_115538 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @strong_rank_condition.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_115539 (h0 : filter (canonically_linear_ordered_monoid (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115540 (h0 : functor.add_const (group (comm_group pos)) (ring (ring (has_to_string Type)))) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) (ring.{1} (ring.{1} (has_to_string.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_115541 (h0 : functor.add_const (ring (has_to_string linarith.comp)) pos) : @rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115542 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_115543 (h0 : group (boolean_algebra.core (has_nndist (has_nndist (finset (finset (has_nndist ennreal))))))) : group.fg (boolean_algebra.core (has_nndist (has_nndist (finset (finset (has_nndist ennreal)))))) := sorry --non-trivial
lemma new_lemma_115544 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) (semiring empty)) : @preirreducible_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_115545 (h0 : group (linear_ordered_semiring empty)) : is_cyclic (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_115546 (h0 : ring (has_union (semiring (has_top congr_arg_kind)))) : rank_condition (has_union (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_115547 (h0 : not (complete_lattice (dlist to_additive.value_type) -> false)) : @is_compactly_generated.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_115548 (h0 : topological_space (has_add (has_neg linarith.comp))) : locally_compact_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_115549 (h0 : cancel_comm_monoid_with_zero (ring (finset (finset linarith.comp)))) : unique_factorization_monoid (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_115550 (h0 : not (topological_space (with_one linarith.ineq) -> false)) : @t0_space.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115551 (h0 : list (dlist (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115552 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115553 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_115554 (h0 : functor.add_const (functor.comp topological_space ring name) name) : @preirreducible_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} ring.{0} name) name h0))  := sorry --non-trivial
lemma new_lemma_115555 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115556 (h0 : functor.add_const (function.extfun (Type 1) group) (has_pos_part pos)) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_pos_part.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_115557 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115558 (h0 : complete_lattice (has_neg (has_to_string ennreal))) : is_atomistic (has_neg (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_115559 (h1 : complete_lattice (semi_normed_ring (comm_ring reducibility_hints))) : is_compactly_generated (semi_normed_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_115560 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type))))))) : sequential_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_115561 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115562 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg (option ennreal))) := sorry --non-trivial
lemma new_lemma_115563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115564 (h0 : functor.add_const (add_monoid (has_pos_part pos)) name) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_115565 (h0 : ring (mul_zero_class name)) : strong_rank_condition (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_115566 (h1 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h1 (function.extfun.{2 1} Type)) complete_lattice.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_115567 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_115568 (h0 : topological_space (ring (finset environment.implicit_infer_kind))) : totally_disconnected_space (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115569 (h0 : filter (normed_group char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115570 (h0 : group (has_neg (has_to_string congr_arg_kind))) : group.fg (has_neg (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115571 (h0 : group (has_Inf Type)) : normalizer_condition (has_Inf Type) := sorry --non-trivial
lemma new_lemma_115572 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_edist empty)) empty) : @unique_factorization_monoid.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_115573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115574 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115575 (h0 : topological_space (has_Inf (has_to_string pos))) : topological_space.separable_space (has_Inf (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_115576 (h0 : not (topological_space (has_star num) -> false)) : @totally_separated_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_115577 (h0 : list (boolean_algebra (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115578 (h0 : semiring (normed_comm_ring (option ennreal))) : is_noetherian_ring (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_115579 (h0 : topological_space (has_add (has_add Type))) : loc_path_connected_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_115580 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115581 (h0 : functor.add_const (ring (finset unsigned)) Type) : @strong_rank_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_115582 (h0 : functor.add_const (list (comm_group pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115583 (h0 : functor.comp group mul_zero_class name) : @is_cyclic.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_115584 (h0 : topological_space (has_neg_part (option unsigned))) : locally_compact_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_115585 (h0 : fin has_zero.zero) : @is_domain.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115586 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) pos) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115587 (h0 : complete_lattice (complete_linear_order to_additive.value_type)) : is_compactly_generated (complete_linear_order to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_115589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115590 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_115591 (h0 : ordered_comm_monoid (semigroup (finset (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (semigroup (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_115592 (h0 : functor.add_const (functor.add_const (function.extfun Type ordered_comm_monoid) Type) pos) : @has_exists_mul_of_le.{0} pos (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type) pos h0)) pos)  := sorry --non-trivial
lemma new_lemma_115593 (h0 : functor.comp filter add_comm_monoid (has_add (has_add (has_add Type)))) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_115594 (h0 : functor.add_const (ring (simple_graph pos)) linarith.comp) : @is_domain.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115595 (h1 : ring (dlist string_imp)) : rank_condition (dlist string_imp) := sorry --non-trivial
lemma new_lemma_115596 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115597 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115598 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115599 (h0 : functor.add_const (topological_space (has_neg pos)) (has_zero (has_zero pos))) : @discrete_topology.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115600 (h0 : topological_space (semiring (has_top (has_norm congr_arg_kind)))) : discrete_topology (semiring (has_top (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_115601 (h0 : functor.add_const (monoid (add_comm_monoid linarith.comp)) pos) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115602 (h0 : complete_lattice (with_one (semiring (has_norm (has_norm (semiring empty)))))) : complete_lattice.is_Sup_finite_compact (with_one (semiring (has_norm (has_norm (semiring empty))))) := sorry --non-trivial
lemma new_lemma_115603 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115604 (h0 : group (has_neg (has_add (has_add Type)))) : normalizer_condition (has_neg (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_115605 (h0 : group (dlist to_additive.value_type)) : normalizer_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115606 (h0 : not (group (fintype linarith.comp_source) -> false)) : @is_cyclic.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_115607 (h0 : prod (left_cancel_monoid (semiring num)) (left_cancel_monoid (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_115608 (h0 : topological_space (ring (normed_comm_ring Type))) : path_connected_space (ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_115609 (h0 : ring (has_top (random_gen (div_inv_monoid linarith.comp_source)))) : strong_rank_condition (has_top (random_gen (div_inv_monoid linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_115610 (h0 : functor.add_const (group (omega_complete_partial_order linarith.comp)) pos) : @normalizer_condition.{0} (omega_complete_partial_order.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115611 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115612 (h0 : monoid (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : monoid.fg (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_115613 (h0 : topological_space (has_add (finset (finset pos)))) : loc_path_connected_space (has_add (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_115614 (h0 : list (has_neg (has_add unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115615 (h0 : functor.add_const (group (add_comm_monoid Type)) linarith.comp) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115616 (h0 : functor.add_const (function.extfun Type topological_space) (finset linarith.comp)) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} linarith.comp) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115617 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115618 (h0 : topological_space (has_to_string (rel environment.implicit_infer_kind name))) : preirreducible_space (has_to_string (rel environment.implicit_infer_kind name)) := sorry --non-trivial
lemma new_lemma_115619 (h0 : ring (has_add (random_gen char))) : rank_condition (has_add (random_gen char)) := sorry --non-trivial
lemma new_lemma_115620 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_115621 (h0 : topological_space (boolean_algebra (finset unsigned))) : loc_path_connected_space (boolean_algebra (finset unsigned)) := sorry --non-trivial
lemma new_lemma_115622 (h0 : filter (boolean_algebra.core pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115623 (h0 : monoid (has_norm (random_gen num))) : monoid.fg (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_115624 (h0 : topological_space (encodable (comm_ring char))) : locally_compact_space (encodable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_115625 (h0 : ring (has_ssubset (random_gen char))) : rank_condition (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_115626 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_115627 (h0 : ring (simple_graph name)) : rank_condition (simple_graph name) := sorry --non-trivial
lemma new_lemma_115628 (h0 : group (has_Inf (ring name))) : is_simple_group (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_115629 (h1 h2 : multiset (semi_normed_ring string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_115630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115631 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_115632 (h0 : filter (normed_comm_ring (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_115633 (h0 : monoid (canonically_linear_ordered_monoid (has_Inf Type))) : monoid.fg (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_115634 (h0 : functor.add_const (group (non_assoc_semiring empty)) congr_arg_kind) : @group.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_115635 (h0 : finset (sub_neg_monoid (has_neg (has_Inf (has_Inf Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_115636 (h0 : filter (random_gen (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115637 (h0 : functor.add_const (group (has_nndist unsigned)) linarith.comp) : @is_simple_group.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115638 (h0 : topological_space (has_emptyc congr_arg_kind)) : totally_disconnected_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115639 (h0 : set (string.iterator_imp -> right_cancel_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_115640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_115641 (h0 : functor.add_const (topological_space (has_to_string unsigned)) unsigned) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115642 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) (has_to_string linarith.comp)) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115643 (h0 : ring (add_group (semiring unsigned))) : is_domain (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115644 (h0 : ring (plift (with_bot (semiring (semiring linarith.comp))))) : strong_rank_condition (plift (with_bot (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_115645 (h0 : add_monoid (plift congr_arg_kind)) : add_monoid.fg (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115646 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid Type) environment.implicit_infer_kind) linarith.comp) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ordered_comm_monoid.{1} Type) environment.implicit_infer_kind) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_115647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_115648 (h0 : ring (has_zero (comm_group (has_add name)))) : is_principal_ideal_ring (has_zero (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_115649 (h0 : uniform_space (has_nndist (complete_distrib_lattice (option empty)))) : separated_space (has_nndist (complete_distrib_lattice (option empty))) := sorry --non-trivial
lemma new_lemma_115650 (h0 : topological_space (plift unsigned)) : irreducible_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_115651 (h0 : complete_lattice (has_neg (comm_group (comm_group pos)))) : is_atomistic (has_neg (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_115652 (h0 : topological_space (has_nnnorm linarith.ineq)) : totally_disconnected_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_115653 (h0 : add_group (comm_ring (random_gen (random_gen (random_gen (random_gen char)))))) : is_add_cyclic (comm_ring (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_115654 (h0 : functor.add_const (complete_lattice (has_add name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_115655 (h2 : topological_space (has_nnnorm (denumerable to_additive.value_type))) : t0_space (has_nnnorm (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_115656 (h0 : functor.add_const (ring (has_inner empty num)) empty) : @is_principal_ideal_ring.{0} (has_inner.{0 0} empty num) (@functor.add_const.run.{0 0} (ring.{0} (has_inner.{0 0} empty num)) empty h0)  := sorry --non-trivial
lemma new_lemma_115657 (h0 : functor.add_const (finset (has_zero linarith.comp)) (finset (finset linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115658 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_115659 (h0 : ordered_comm_monoid (has_zero (has_add linarith.comp))) : has_exists_mul_of_le (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_115660 (h0 : functor.add_const (ring (has_add pos)) unsigned) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115661 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115662 (h0 : group (semi_normed_comm_ring (random_gen linarith.comp_source))) : is_cyclic (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115663 (h0 : list (denumerable (has_ssubset (has_ssubset (has_ssubset string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115664 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type semiring.{0} h0 (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_115665 (h0 : ordered_comm_monoid (has_pos_part (ordered_ring name))) : has_exists_mul_of_le (has_pos_part (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_115666 (h0 : complete_lattice (comm_ring (random_gen fun_info))) : is_compactly_generated (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_115667 (h0 : ring (has_add (has_neg (has_neg Type)))) : rank_condition (has_add (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_115668 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : path_connected_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_115669 (h0 : not (has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_115670 (h0 : ring (has_ssubset fun_info)) : strong_rank_condition (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_115671 (h0 : topological_space (ring (has_neg_part pos))) : loc_path_connected_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_115672 (h0 : ordered_add_comm_monoid nnreal) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_115673 (h0 : ring (has_sdiff (mul_one_class string.iterator_imp))) : is_domain (has_sdiff (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_115674 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115675 (h0 : add_group (linear_ordered_comm_ring unsigned)) : is_add_cyclic (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_115676 (h1 : complete_lattice (complete_semilattice_Sup string_imp)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_115677 (h0 : list linarith.ineq) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115678 (h0 : function.extfun Type (functor.comp group semigroup)) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} semigroup.{0}) h0 pos))))))  := sorry --non-trivial
lemma new_lemma_115679 (h0 : monoid (has_norm (group_with_zero num))) (h1 : submonoid (has_norm (group_with_zero num))) : submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_115680 (h0 : cancel_comm_monoid_with_zero (has_zero (option unsigned))) : unique_factorization_monoid (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_115681 (h0 : not (group (plift linarith.ineq) -> false)) : @is_cyclic.{1} (plift.{1} linarith.ineq) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115682 (h0 : list (add_cancel_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_115683 (h0 : not (group (non_assoc_semiring congr_arg_kind) -> false)) : @normalizer_condition.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115684 (h0 : topological_space (comm_group ennreal)) : discrete_topology (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_115685 (h0 : add_monoid (random_gen (semiring (semiring (semiring (semiring congr_arg_kind)))))) : add_monoid.fg (random_gen (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_115686 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option (option unsigned))))) : locally_compact_space (linear_ordered_comm_monoid_with_zero (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_115687 (h0 : topological_space (has_add (ring linarith.comp))) : sequential_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_115688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_115689 (h0 : topological_space (add_group (has_norm empty))) : path_connected_space (add_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_115690 (h0 : uniform_space (monoid unsigned)) : complete_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_115691 (h0 : topological_space (has_inv fun_info)) : totally_separated_space (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_115692 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @t1_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_115693 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_115694 (h0 : group (semigroup (has_add pos))) : is_cyclic (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_115695 (h0 : functor.add_const (ring (comm_group name)) linarith.comp) : @is_principal_ideal_ring.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115696 (h0 : ring (has_pos_part (has_add pos))) : rank_condition (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_115697 (h0 : group (finset linarith.comp)) : normalizer_condition (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_115698 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_115699 (h0 : group (has_bot (option (option empty)))) : normalizer_condition (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_115700 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_115701 (h0 h2 : multiset string.iterator_imp) : multiset.disjoint h0 h2 := sorry --non-trivial
lemma new_lemma_115702 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_115703 (h0 : functor.add_const (add_group (cancel_monoid unsigned)) linarith.comp) : @is_add_cyclic.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115704 (h0 : ring (with_bot num)) : strong_rank_condition (with_bot num) := sorry --non-trivial
lemma new_lemma_115705 (h0 : not (topological_space linarith.comp -> false)) : @t0_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115706 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) (ring (finset Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115707 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115708 (h0 : topological_space (has_neg (has_to_string (has_add linarith.comp)))) : t1_space (has_neg (has_to_string (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_115709 (h0 : group (has_add (mul_zero_class (option (option (mul_zero_class (mul_zero_class (option pos)))))))) : group.fg (has_add (mul_zero_class (option (option (mul_zero_class (mul_zero_class (option pos))))))) := sorry --non-trivial
lemma new_lemma_115710 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_115711 (h0 : functor.comp ring normed_comm_ring pos) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_115712 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Inf linarith.comp)))) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_115713 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_115714 (h0 : add_group (linear_ordered_add_comm_group (has_nnnorm char))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_115715 (h0 : group (finset (add_comm_monoid Type))) : normalizer_condition (finset (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_115716 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_115717 (h0 : functor.add_const (ring (has_to_string Type)) unsigned) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115718 (h0 : group (comm_group (pseudo_metric_space ennreal))) : group.fg (comm_group (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_115719 (h0 : uniform_space (non_unital_non_assoc_semiring to_additive.value_type)) : complete_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115720 (h0 : topological_space (random_gen (dlist to_additive.value_type))) : locally_compact_space (random_gen (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_115721 (h0 : function.extfun Type (functor.add_const (topological_space (is_R_or_C unsigned)))) : @irreducible_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_115722 (h0 : topological_space (ordered_comm_ring (has_bot (sub_neg_monoid pos)))) : normal_space (ordered_comm_ring (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_115723 (h0 : topological_space (partial_order unsigned)) : discrete_topology (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_115724 (h0 : functor.add_const (group (ring linarith.comp)) (has_pos_part linarith.comp)) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115725 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115726 (h0 : not (topological_space (has_dist linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_dist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_dist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115727 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) linarith.comp) : @preirreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115728 (h0 : ring (linear_ordered_semiring (random_gen congr_arg_kind))) : strong_rank_condition (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115729 (h0 : functor.add_const (topological_space (option ennreal)) ennreal) : @t1_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_115730 (h0 : add_group (non_assoc_semiring (semiring unsigned))) : is_add_cyclic (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115731 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_115732 (h0 : functor.add_const (group (complete_distrib_lattice congr_arg_kind)) empty) : @normalizer_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_115733 (h0 : ring (semi_normed_ring (random_gen char))) : strong_rank_condition (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_115734 (h0 : complete_lattice (add_cancel_monoid congr_arg_kind)) : is_atomistic (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115736 (h0 : functor.add_const (add_group (canonically_linear_ordered_monoid num)) num) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_linear_ordered_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_115737 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) pos)  := sorry --non-trivial
lemma new_lemma_115738 (h0 : list (left_cancel_semigroup (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115739 (h1 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115740 (h0 : functor.add_const (function.extfun (Type 1) group) (has_neg Type)) : @normalizer_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_115741 (h1 : add_group (div_inv_monoid fun_info)) : is_add_cyclic (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_115742 (h1 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h3 : Type) (h4 : h3) (h5 : h3 -> id (measure_theory.measure (nondiscrete_normed_field linarith.ineq))) : measure_theory.is_finite_measure (id_bind h4 h5) := sorry --non-trivial
lemma new_lemma_115743 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @sequential_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_115744 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115745 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_115746 (h0 : ring (with_one (has_union (semiring unsigned)))) : is_domain (with_one (has_union (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_115747 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) (boolean_algebra Type)) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_115748 (h0 : topological_space (finset (has_pos_part (has_Inf pos)))) : locally_compact_space (finset (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_115749 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115750 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @sequential_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_115751 (h0 : ordered_add_comm_monoid (with_bot unsigned)) : archimedean (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_115752 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_add Type)) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_115753 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_115754 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115755 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) pos) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_115756 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_115757 (h1 : group (metric_space (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (metric_space (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_115758 (h0 : complete_lattice (has_add (has_ssubset (has_nnnorm char)))) : complete_lattice.is_Sup_finite_compact (has_add (has_ssubset (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_115759 (h0 : uniform_space (uniform_space (metric_space string_imp))) : complete_space (uniform_space (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_115760 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115761 (h0 : ring (topological_space (random_gen (has_nnnorm (distrib_lattice char))))) : rank_condition (topological_space (random_gen (has_nnnorm (distrib_lattice char)))) := sorry --non-trivial
lemma new_lemma_115762 (h0 : topological_space (id (with_bot linarith.comp_source))) : totally_separated_space (id (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115765 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_115766 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : path_connected_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115767 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115768 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_115769 (h0 : topological_space (with_zero to_additive.value_type)) : locally_compact_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115770 (h0 : ordered_comm_monoid (ordered_comm_monoid (ordered_comm_ring (has_Inf real)))) : has_exists_mul_of_le (ordered_comm_monoid (ordered_comm_ring (has_Inf real))) := sorry --non-trivial
lemma new_lemma_115771 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) real) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_115772 (h0 : ring (measurable_space (random_gen linarith.ineq))) : is_domain (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115773 (h0 : add_monoid (id (canonically_linear_ordered_monoid (has_top (has_norm congr_arg_kind))))) : add_monoid.fg (id (canonically_linear_ordered_monoid (has_top (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_115774 (h0 : group (with_bot (random_gen (comm_ring fun_info)))) : normalizer_condition (with_bot (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_115775 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115776 (h0 : group ereal) (h1 : subgroup ereal) : subgroup.characteristic h1 := sorry --non-trivial
lemma new_lemma_115777 (h0 : functor.add_const (ring (option ennreal)) ennreal) : @is_principal_ideal_ring.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_115778 (h0 : topological_space (has_neg Type)) : totally_disconnected_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_115779 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_115780 (h0 : topological_space (non_unital_non_assoc_semiring (distrib linarith.ineq))) : path_connected_space (non_unital_non_assoc_semiring (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115781 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115782 (h0 : group (comm_group (has_zero name))) : is_cyclic (comm_group (has_zero name)) := sorry --non-trivial
lemma new_lemma_115783 (h0 : functor.add_const (ring (has_Inf Type)) name) : @is_domain.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_115784 (h0 : ring (finset (finset (has_nndist Type)))) : is_principal_ideal_ring (finset (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_115785 (h0 : add_group (random_gen (semiring (has_norm empty)))) : is_add_cyclic (random_gen (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_115786 (h0 : topological_space (preorder empty)) : path_connected_space (preorder empty) := sorry --non-trivial
lemma new_lemma_115787 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_115788 (h0 : fin has_zero.zero) : @complete_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115789 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @sequential_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_115790 (h0 : topological_space (complete_distrib_lattice pos)) : t0_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_115791 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_115792 (h0 : set (semi_normed_ring linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_115793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_115794 (h0 : topological_space (comm_semigroup (has_add real))) : preconnected_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_115795 (h2 : uniform_space (has_ssubset (mul_one_class (random_gen char)))) : complete_space (has_ssubset (mul_one_class (random_gen char))) := sorry --non-trivial
lemma new_lemma_115796 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_115797 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_115798 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115799 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_115800 (h0 : fin has_zero.zero) : @t1_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_115801 (h0 : not (ring (dlist fun_info) -> false)) : @is_domain.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_115802 (h0 : functor.add_const (semiring (ordered_comm_ring name)) name) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_115803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_115804 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115805 (h0 : add_monoid (ring (boolean_algebra name))) : add_monoid.fg (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_115806 (h0 : filter (ring pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115807 (h0 : ring (ordered_comm_ring name)) : strong_rank_condition (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_115808 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm num)))) : locally_compact_space (linear_ordered_semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_115809 (h0 : has_lt (linear_order linarith.ineq)) : no_max_order (linear_order linarith.ineq) := sorry --non-trivial
lemma new_lemma_115810 (h1 : list (has_norm to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_115811 (h0 : set (simple_graph (distrib (distrib linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_115812 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_115813 (h0 : topological_space (measurable_space (has_top (has_top linarith.comp)))) : totally_separated_space (measurable_space (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_115814 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_115815 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_115816 (h1 : topological_space (add_comm_semigroup fun_info)) : totally_disconnected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_115817 (h0 : topological_space fun_info) (h1 : set (set fun_info)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_115818 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (ring (ring pos))) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115819 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_115820 (h0 : monoid (distrib_lattice linarith.comp_source)) : monoid.fg (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_115821 (h0 : not (complete_lattice (simple_graph congr_arg_kind) -> false)) : @is_atomistic.{0} (simple_graph.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115822 (h0 : topological_space (has_nnnorm linarith.ineq)) : path_connected_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_115823 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) name h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_115824 (h0 : topological_space (comm_group (finset ennreal))) : t1_space (comm_group (finset ennreal)) := sorry --non-trivial
lemma new_lemma_115825 (h1 : uniform_space (mul_one_class to_additive.value_type)) : complete_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_115826 (h0 : filter (linear_ordered_semiring (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115827 (h0 : ring (semigroup (comm_group unsigned))) : strong_rank_condition (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_115828 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115829 (h0 : ring (has_emptyc (has_top linarith.comp_source))) : rank_condition (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115830 (h0 : functor.add_const (uniform_space ennreal) num) : @separated_space.{0} ennreal (@functor.add_const.run.{0 0} (uniform_space.{0} ennreal) num h0)  := sorry --non-trivial
lemma new_lemma_115831 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_115832 (h0 : monoid (with_one (has_inv fun_info))) : monoid.fg (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_115833 (h1 : ring reducibility_hints) : strong_rank_condition reducibility_hints := sorry --non-trivial
lemma new_lemma_115834 (h0 : fin has_zero.zero) : @t1_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115835 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_115836 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115837 (h3 : complete_lattice (topological_space char)) : complete_lattice.is_Sup_finite_compact (topological_space char) := sorry --non-trivial
lemma new_lemma_115838 (h0 : ring (has_neg (finset name))) : is_principal_ideal_ring (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_115839 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group unsigned)))) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_115840 (h1 : not (uniform_space (denumerable to_additive.value_type) -> false)) : @complete_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_115841 (h0 : semiring (nondiscrete_normed_field char)) (h1 : ideal (nondiscrete_normed_field char)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_115842 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_115843 (h0 : topological_space (measurable_space (has_top congr_arg_kind))) : path_connected_space (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115844 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115845 (h0 : functor.add_const (ring (has_nndist unsigned)) pos) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_115846 (h0 : topological_space (as_linear_order (option (canonically_ordered_comm_semiring (option (option empty)))))) : normal_space (as_linear_order (option (canonically_ordered_comm_semiring (option (option empty))))) := sorry --non-trivial
lemma new_lemma_115847 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_Inf linarith.comp)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115848 (h0 : semiring (linear_ordered_semiring congr_arg_kind)) : is_noetherian_ring (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115849 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115850 (h0 : function.extfun nat fin) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115851 (h0 : not (filter (dlist fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_115852 (h0 : functor.add_const (topological_space (has_inter unsigned)) empty) : @irreducible_space.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_115853 (h0 : topological_space (has_add (has_add linarith.comp))) : regular_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_115854 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_Inf.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} num))  := sorry --non-trivial
lemma new_lemma_115855 (h0 : topological_space (complete_semilattice_Sup (plift num))) : t0_space (complete_semilattice_Sup (plift num)) := sorry --non-trivial
lemma new_lemma_115856 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_115857 (h0 : functor.add_const (group (boolean_algebra Type)) pos) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_115858 (h0 : topological_space (is_R_or_C empty)) : t1_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_115859 (h0 : list (mul_zero_class pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : totally_separated_space real := sorry --non-trivial
lemma new_lemma_115861 (h0 : topological_space (random_gen (has_norm empty))) : totally_disconnected_space (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_115862 (h0 : semiring (add_group (semiring (semiring unsigned)))) : is_noetherian_ring (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_115863 (h2 : not (add_group (has_top fun_info) -> false)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_115864 (h0 : functor.add_const (complete_lattice (semigroup Type)) ennreal) : @is_atomistic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_115865 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_115866 (h0 : preorder (mul_one_class linarith.ineq)) (h1 : set (mul_one_class linarith.ineq)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_115867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_115868 (h0 : functor.add_const (add_group (comm_group pos)) pos) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_115869 (h0 : cancel_comm_monoid_with_zero (has_scalar (comm_semigroup Type) Type)) : unique_factorization_monoid (has_scalar (comm_semigroup Type) Type) := sorry --non-trivial
lemma new_lemma_115870 (h0 : functor.add_const (ring (add_comm_monoid pos)) pos) : @strong_rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_115871 (h2 : not (ring (random_gen char) -> false)) : @is_domain.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_115872 (h0 : functor.add_const (add_group (has_zero pos)) (has_add name)) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_115873 (h0 : filter (dlist (has_top (has_top to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115874 (h0 : ring (fintype (distrib linarith.ineq))) : rank_condition (fintype (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_115875 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option (option (option ennreal))))) : unique_factorization_monoid (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_115876 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : irreducible_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_115877 (h0 : functor.comp complete_lattice ring name) : @is_atomistic.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_115878 (h0 : topological_space (has_nnnorm (mul_one_class linarith.comp_source))) : t0_space (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115879 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid name))) : strong_rank_condition (canonically_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_115880 (h0 : ring (random_gen (has_compl fun_info))) : rank_condition (random_gen (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_115881 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @t0_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115882 (h0 : functor.add_const (function.extfun Type group) (ring environment.implicit_infer_kind)) : @group.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} environment.implicit_infer_kind) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_115883 (h1 : set (semi_normed_ring to_additive.value_type)) (h2 : punit) : category_theory.hom_of_element (set.subsingleton h1) h2 := sorry --non-trivial
lemma new_lemma_115884 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add (has_add (has_nndist pos))))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add (has_add (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_115885 (h0 : complete_lattice (boolean_algebra.core (normed_comm_ring (finset environment.implicit_infer_kind)))) : is_atomistic (boolean_algebra.core (normed_comm_ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_115886 (h0 : functor.add_const (complete_lattice (sub_neg_monoid linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_115887 (h0 : set (set (random_gen (random_gen to_additive.value_type)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_115888 (h0 : uniform_space (add_group (has_top (has_top (semiring unsigned))))) : complete_space (add_group (has_top (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_115889 (h0 : add_comm_group (encodable string_imp)) (h1 : group (add_comm_group.total_positive_cone (encodable string_imp))) : is_cyclic (add_comm_group.total_positive_cone (encodable string_imp)) := sorry --non-trivial
lemma new_lemma_115890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115891 (h0 : functor.add_const (topological_space (finset pos)) Type) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_115892 (h0 : ring (linear_ordered_semiring (semiring (semiring empty)))) : strong_rank_condition (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_115893 (h0 : group (cancel_monoid (boolean_algebra.core name))) : normalizer_condition (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_115894 (h0 : functor.comp topological_space semigroup name) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_115895 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (partial_order empty)))) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_115896 (h0 : not (topological_space (linear_ordered_semiring linarith.ineq) -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_115897 (h0 : add_group (mul_one_class (mul_one_class environment.projection_info))) : is_add_cyclic (mul_one_class (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_115898 (h0 : linarith.ineq -> linarith.ineq -> Prop) (h1 : set linarith.ineq) : is_strong_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_115899 (h0 : has_neg (has_lt (non_unital_non_assoc_semiring enat))) (h1 : measurable_space (has_lt (non_unital_non_assoc_semiring enat))) : has_measurable_neg (has_lt (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_115900 (h0 : complete_lattice (has_sdiff (ring (has_pos_part (has_neg Type))))) : is_compactly_generated (has_sdiff (ring (has_pos_part (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_115901 (h0 : topological_space (normed_comm_ring (finset (finset environment.implicit_infer_kind)))) : t1_space (normed_comm_ring (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_115902 (h0 : topological_space (non_unital_non_assoc_semiring (has_lt linarith.comp_source))) (h1 : preorder (non_unital_non_assoc_semiring (has_lt linarith.comp_source))) : order_topology (non_unital_non_assoc_semiring (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115903 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_115904 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_115905 (h0 : ring (linear_ordered_add_comm_group (comm_ring (random_gen fun_info)))) : rank_condition (linear_ordered_add_comm_group (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_115906 (h0 : prod (is_R_or_C unsigned) (is_R_or_C unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_115907 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_115908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115909 (h1 : topological_space (uniform_space reducibility_hints)) : t0_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_115910 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_115911 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_115912 (h0 : complete_lattice (non_assoc_semiring unsigned)) : is_atomistic (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_115913 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_115914 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115915 (h0 : ring (random_gen (random_gen congr_arg_kind))) : is_domain (random_gen (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115916 (h0 : topological_space (add_group (semiring congr_arg_kind))) : t0_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_115917 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115918 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @topological_space.separable_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_115919 (h0 : uniform_space (has_neg_part environment.implicit_infer_kind)) : separated_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_115920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_115921 (h0 : topological_space (normed_comm_ring (has_nndist Type))) : discrete_topology (normed_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_115922 (h7 : measurable_space linarith.ineq) (h8 : measure_theory.measure linarith.ineq) : measure_theory.is_finite_measure h8 := sorry --non-trivial
lemma new_lemma_115923 (h0 : fin has_zero.zero) : @is_atomistic.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_115924 (h0 : group (add_comm_monoid Type)) : group.fg (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_115925 (h0 : functor.comp topological_space add_cancel_monoid environment.implicit_infer_kind) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115926 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra environment.implicit_infer_kind))) : t1_space (canonically_ordered_comm_semiring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_115927 (h0 : topological_space (boolean_algebra real)) : totally_disconnected_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_115928 (h0 : function.extfun Type preorder) (h1 : canonically_ordered_comm_semiring empty -> set empty) : @filter.is_antitone_basis.{0 0} empty (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type preorder.{0} h0 (canonically_ordered_comm_semiring.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_115929 (h0 : add_group (semi_normed_ring (has_nnnorm fun_info))) : is_add_cyclic (semi_normed_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_115930 (h1 : has_nnnorm (has_nnnorm to_additive.value_type) -> has_nnnorm (has_nnnorm to_additive.value_type) -> Prop) : is_total_preorder (has_nnnorm (has_nnnorm to_additive.value_type)) h1 := sorry --non-trivial
lemma new_lemma_115931 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115932 (h0 : function.extfun nat fin) : @t1_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_115933 (h0 : topological_space (has_add (ring (ring pos)))) : preirreducible_space (has_add (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_115934 (h0 : ordered_add_comm_monoid (ring (has_add name))) : archimedean (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_115935 (h0 : uniform_space (has_nndist (sub_neg_monoid Type))) : separated_space (has_nndist (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_115936 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_115937 (h0 : group (has_bot (ring (has_Inf pos)))) : is_cyclic (has_bot (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_115938 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf linarith.comp)))) : totally_separated_space (canonically_linear_ordered_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_115939 (h0 : topological_space (has_to_string (has_add pos))) : t0_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_115940 (h0 : complete_lattice (preorder (semiring (semiring (semiring (semiring (semiring num))))))) : is_atomistic (preorder (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_115941 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice empty)) : unique_factorization_monoid (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_115942 (h0 : uniform_space (ring (option pos))) : complete_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_115943 (h0 : topological_space (monoid (option ennreal))) : t1_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_115944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115945 (h0 : ring (non_unital_non_assoc_semiring (uniform_space linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (uniform_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_115946 (h0 : topological_space (has_star unsigned)) : path_connected_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_115947 (h0 : ring (linear_ordered_field (option ennreal))) : is_domain (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_115948 (h0 : functor.add_const (semiring (simple_graph pos)) (has_add linarith.comp)) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115949 (h0 : topological_space (mul_zero_class (finset pos))) : locally_compact_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_115950 (h0 : topological_space (random_gen (linear_ordered_semiring unsigned))) : irreducible_space (random_gen (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115951 (h0 : topological_space (ring (has_neg name))) : sequential_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_115952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_115953 (h0 : semiring (non_assoc_semiring (option unsigned))) : is_noetherian_ring (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_115954 (h0 : functor.add_const (semiring (has_add pos)) (boolean_algebra linarith.comp)) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_115955 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_115956 (h0 : add_group (canonically_ordered_comm_semiring (option (option unsigned)))) : is_add_cyclic (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_115957 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_115958 (h0 : ring (has_nndist (has_add (has_add Type)))) : is_principal_ideal_ring (has_nndist (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_115959 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_115960 (h0 : topological_space (semiring unsigned)) : t1_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_115961 (h0 : functor.add_const (group (simple_graph linarith.comp)) (finset (has_neg (finset (finset pos))))) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) (finset.{0} (has_neg.{0} (finset.{0} (finset.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_115962 (h0 : group (canonically_ordered_comm_semiring num)) : is_cyclic (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_115963 (h0 : complete_lattice (normed_field (has_nnnorm (random_gen char)))) : is_compactly_generated (normed_field (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_115964 (h0 : topological_space (has_neg (option pos))) : normal_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_115965 (h0 : set (std_gen -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_115966 (h0 : empty -> empty -> Prop) : is_equiv empty h0 := sorry --non-trivial
lemma new_lemma_115967 (h0 : group (has_dist num)) : is_simple_group (has_dist num) := sorry --non-trivial
lemma new_lemma_115968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_115969 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_115970 (h1 : topological_space (with_zero (has_inv string_imp))) : path_connected_space (with_zero (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_115971 (h0 : functor.add_const (add_group (complete_semilattice_Sup empty)) unsigned) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (complete_semilattice_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_115972 (h0 : group (ordered_comm_group unsigned)) : is_cyclic (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_115973 (h0 : complete_lattice (has_zero (has_add (has_add Type)))) : is_atomistic (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_115974 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_115975 (h0 : ring (semigroup (mul_one_class environment.projection_info))) : rank_condition (semigroup (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_115976 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_115977 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_115978 (h0 : functor.add_const (finset (option unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_115979 (h0 : ring (add_cancel_monoid (has_Inf (has_neg name)))) : is_principal_ideal_ring (add_cancel_monoid (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_115980 (h0 : not (ring (has_inv to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_115981 (h0 : group char) : is_cyclic char := sorry --non-trivial
lemma new_lemma_115982 (h0 : list (plift (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_115983 (h0 : has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_115984 (h0 : group (add_monoid fun_info)) : is_cyclic (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_115985 (h0 : ring (has_nndist (has_nndist (finset pos)))) : is_domain (has_nndist (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_115986 (h0 : functor.add_const (group (has_zero linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_115987 (h0 : ring (finset (finset (has_nndist environment.implicit_infer_kind)))) : is_principal_ideal_ring (finset (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_115988 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_115989 (h0 : functor.add_const (add_monoid (preorder num)) (option (option (option (option (option unsigned)))))) : @add_monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} num)) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned))))) h0)  := sorry --non-trivial
lemma new_lemma_115990 (h0 : topological_space (finset (finset Type))) : locally_compact_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_115991 (h0 : monoid (complete_distrib_lattice (has_pos_part name))) : monoid.fg (complete_distrib_lattice (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_115992 (h0 : ring (has_inv (random_gen (random_gen to_additive.value_type)))) : is_domain (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_115993 (h0 : complete_lattice (semi_normed_comm_ring (has_compl (mul_one_class string.iterator_imp)))) : is_compactly_generated (semi_normed_comm_ring (has_compl (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_115994 (h0 : filter (has_to_string (has_to_string (has_to_string pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_115995 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_115996 (h0 : topological_space (left_cancel_semigroup (semiring unsigned))) : topological_space.separable_space (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_115997 (h0 : add_group (denumerable (has_nnnorm (has_nnnorm reducibility_hints)))) : is_add_cyclic (denumerable (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_115998 (h0 : functor.add_const (semiring (semigroup name)) Type) : @is_noetherian_ring.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_115999 (h0 : ring (add_semigroup unsigned)) : rank_condition (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_116000 (h0 : ring (semigroup (option name))) : rank_condition (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_116001 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_116002 (h0 : topological_space (has_neg_part (option (has_neg pos)))) : discrete_topology (has_neg_part (option (has_neg pos))) := sorry --non-trivial
lemma new_lemma_116003 (h1 : topological_space (with_one (random_gen linarith.comp))) : sequential_space (with_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_116004 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_cyclic.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_116005 (h0 : semiring (boolean_algebra (has_add (has_add linarith.comp)))) : is_noetherian_ring (boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_116006 (h1 : semiring ereal) (h2 : ideal ereal) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_116007 (h0 : functor.add_const (ring (has_zero linarith.comp)) Type) : @is_domain.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_116008 (h0 : add_group (non_unital_non_assoc_semiring (has_div fun_info))) : is_add_cyclic (non_unital_non_assoc_semiring (has_div fun_info)) := sorry --non-trivial
lemma new_lemma_116009 (h0 : ring num) : is_domain num := sorry --non-trivial
lemma new_lemma_116010 (h1 : topological_space (semi_normed_comm_ring environment.projection_info)) : path_connected_space (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_116011 (h0 : functor.add_const (group (ordered_comm_ring pos)) Type) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_116012 (h0 : not (monoid (with_bot linarith.comp_source) -> false)) : @monoid.fg.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_116013 (h0 : topological_space (topological_space (denumerable to_additive.value_type))) : path_connected_space (topological_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116014 (h0 : topological_space (add_comm_monoid (option ennreal))) : t1_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_116015 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_116016 (h0 : function.extfun Type (functor.add_const (monoid znum))) : @monoid.fg.{0} znum (@functor.add_const.run.{0 0} (monoid.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_116017 (h1 : add_group (has_ssubset (has_nnnorm linarith.ineq))) : is_add_cyclic (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116018 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116019 (h0 : semiring (has_to_string num)) : is_noetherian_ring (has_to_string num) := sorry --non-trivial
lemma new_lemma_116020 (h0 : topological_space (has_union (semiring (semiring unsigned)))) : locally_compact_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_116021 (h0 : functor.add_const (finset (add_cancel_monoid linarith.comp)) (has_neg environment.implicit_infer_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116022 (h0 : complete_lattice (has_Inf Type)) : complete_lattice.is_Sup_finite_compact (has_Inf Type) := sorry --non-trivial
lemma new_lemma_116023 (h0 : topological_space (cancel_monoid Type)) : t1_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_116024 (h0 : functor.add_const (list (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116025 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) (option unsigned)) : @is_atomistic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_116026 (h3 : complete_lattice (parse_result ereal)) : complete_lattice.is_Sup_finite_compact (parse_result ereal) := sorry --non-trivial
lemma new_lemma_116027 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_116028 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_116029 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_116030 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) (has_neg_part linarith.comp)) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_116031 (h1 : ring (comm_ring (has_ssubset (has_ssubset reducibility_hints)))) : is_domain (comm_ring (has_ssubset (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_116032 (h0 : group (has_zero (has_Inf (has_Inf Type)))) : is_simple_group (has_zero (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_116033 (h0 : complete_lattice (random_gen (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_116034 (h0 : topological_space (random_gen (has_norm to_additive.value_type))) : totally_separated_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116035 (h0 : group (has_Inf (ordered_comm_monoid (has_add Type)))) : group.fg (has_Inf (ordered_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_116036 (h0 : topological_space (encodable (has_ssubset linarith.ineq))) : locally_compact_space (encodable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116037 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116038 (h0 : topological_space (has_nndist (finset linarith.comp))) : regular_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_116039 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116040 (h0 : topological_space (boolean_algebra (has_to_string unsigned))) : topological_space.separable_space (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_116041 (h0 : topological_space (has_union (has_norm (has_norm num)))) : totally_disconnected_space (has_union (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_116042 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : t1_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_116043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116044 (h0 : topological_space congr_arg_kind) : totally_disconnected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_116045 (h0 : functor.add_const (topological_space (has_neg empty)) ennreal) : @path_connected_space.{0} (has_neg.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_116046 (h0 : filter (add_left_cancel_monoid (random_gen (has_nnnorm (has_nnnorm (random_gen fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116047 (h0 : topological_space (fintype (has_nnnorm linarith.comp_source))) : totally_disconnected_space (fintype (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116048 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_116049 (h0 : ring (complete_distrib_lattice (complete_distrib_lattice unsigned))) : strong_rank_condition (complete_distrib_lattice (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_116050 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_116051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_116052 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116053 (h0 : functor.add_const (uniform_space (linear_ordered_comm_monoid_with_zero unsigned)) num) : @complete_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_116054 (h0 : ring (add_cancel_monoid (group_with_zero linarith.comp))) : is_domain (add_cancel_monoid (group_with_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_116055 (h0 : topological_space (semigroup (comm_group name))) : irreducible_space (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_116056 (h2 : topological_space (linear_ordered_add_comm_group fun_info)) : t0_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_116057 (h0 : functor.add_const (ordered_comm_monoid (simple_graph pos)) (semigroup (ring linarith.comp))) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (simple_graph.{0} pos)) (semigroup.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_116058 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @regular_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_116059 (h0 : monoid (linear_ordered_semiring (random_gen num))) : monoid.fg (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_116060 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @rank_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_116061 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @discrete_topology.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 name))  := sorry --non-trivial
lemma new_lemma_116062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_116063 (h0 : functor.add_const (group (plift num)) (semiring empty)) : @normalizer_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_116064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116065 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) (has_add Type)) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_116066 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116067 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116068 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116069 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid unsigned)))) : @locally_compact_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_116070 (h0 : topological_space (has_to_string (option pos))) : discrete_topology (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_116071 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116072 (h0 : list (topological_space (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116073 (h0 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_116074 (h0 : ring (semigroup (finset (complete_distrib_lattice (normed_comm_ring Type))))) : is_principal_ideal_ring (semigroup (finset (complete_distrib_lattice (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_116075 (h2 : complete_lattice (normed_field string_imp)) : is_compactly_generated (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_116076 (h0 : finset (finset (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116077 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116078 (h0 : ring (ordered_comm_monoid pos)) : is_domain (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_116079 (h0 : topological_space (ordered_comm_group (option (option empty)))) : preirreducible_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_116080 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_116081 (h0 : uniform_space (boolean_algebra.core (has_to_string pos))) : separated_space (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_116082 (h0 : topological_space (id (has_union (has_one (has_norm empty))))) : path_connected_space (id (has_union (has_one (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_116083 (h0 : group (add_comm_monoid (ring (ring (ring linarith.comp))))) : normalizer_condition (add_comm_monoid (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_116084 (h0 : topological_space fun_info) : normal_space fun_info := sorry --non-trivial
lemma new_lemma_116085 (h0 : topological_space (complete_distrib_lattice (option name))) : normal_space (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_116086 (h1 : topological_space (with_zero linarith.comp_source)) : totally_disconnected_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116087 (h0 : functor.add_const (topological_space (has_nndist (comm_group pos))) Type) : @normal_space.{0} (has_nndist.{0} (comm_group.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} (comm_group.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_116088 (h0 : topological_space (has_neg (add_right_cancel_monoid name))) : totally_separated_space (has_neg (add_right_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_116089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_116090 (h0 : add_monoid (ring environment.implicit_infer_kind)) : add_monoid.fg (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_116091 (h0 : ring (add_left_cancel_monoid char)) : rank_condition (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_116092 (h0 : not (add_monoid (mul_zero_class empty) -> false)) : @add_monoid.fg.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_116093 (h0 : topological_space Type) : totally_separated_space Type := sorry --non-trivial
lemma new_lemma_116094 (h0 : ring (complete_distrib_lattice num)) : strong_rank_condition (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_116095 (h0 : list (has_add (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116096 (h0 h1 : pnat) : pnat.coprime h0 (id (id (id (id h1)))) := sorry --non-trivial
lemma new_lemma_116097 (h0 : functor.add_const (group (has_Inf linarith.comp)) Type) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_116098 (h0 : ring (has_one (has_norm empty))) : strong_rank_condition (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_116099 (h1 : filter (topological_space (topological_space char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_116100 (h0 : topological_space (has_neg (has_neg_part pos))) : preirreducible_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_116101 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid real))) : totally_separated_space (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_116102 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_116103 (h0 : ring (has_bot (has_bot Type))) : rank_condition (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_116104 (h0 : set (mul_one_class (mul_one_class ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_116105 (h0 : ring (has_sub (semiring unsigned))) : is_principal_ideal_ring (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_116106 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) (semiring (semiring (semiring num)))) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_116107 (h1 : group (with_one congr_arg_kind)) : group.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116108 (h5 : not (complete_lattice (distrib linarith.comp_source) -> false)) : @is_compactly_generated.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} linarith.comp_source)) h5)  := sorry --non-trivial
lemma new_lemma_116109 (h0 : monoid (complete_distrib_lattice (boolean_algebra Type))) : monoid.fg (complete_distrib_lattice (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_116110 (h0 : topological_space (option empty)) : t1_space (option empty) := sorry --non-trivial
lemma new_lemma_116111 (h3 : ring environment.projection_info) : strong_rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_116112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_nndist name)) := sorry --non-trivial
lemma new_lemma_116113 (h0 : measurable_space fun_info) (h3 : filter fun_info -> std_gen) (h4 : coe_sort (set.range h3)) : filter.is_measurably_generated (set.range_splitting h3 h4) := sorry --non-trivial
lemma new_lemma_116114 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @t1_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116115 (h0 : topological_space (add_cancel_monoid (ring Type))) : sequential_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_116116 (h1 : not (complete_lattice (add_left_cancel_monoid char) -> false)) : @is_compactly_generated.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_left_cancel_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_116117 (h0 : topological_space (has_add (option (option unsigned)))) : normal_space (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_116118 (h0 : functor.add_const (group (has_zero name)) pos) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_116119 (h1 : ring (uniform_space (has_lt linarith.comp_source))) : strong_rank_condition (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116120 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_116121 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) name) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_116122 (h0 : group (measurable_space.dynkin_system (has_top empty))) : normalizer_condition (measurable_space.dynkin_system (has_top empty)) := sorry --non-trivial
lemma new_lemma_116123 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg Type)) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_116124 (h0 : ring (normed_group congr_arg_kind)) : strong_rank_condition (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116125 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_116126 (h0 : group (has_pos_part (ring pos))) : normalizer_condition (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_116127 (h0 : function.extfun Type group) : @is_cyclic.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116128 (h0 : group (div_inv_monoid to_additive.value_type)) : group.fg (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116129 (h0 : not (ring (has_ssubset linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_116130 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_116131 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.ineq))) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_116132 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))))  := sorry --non-trivial
lemma new_lemma_116133 (h0 : topological_space (comm_semigroup real)) : topological_space.separable_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_116134 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_nndist pos)) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_116135 (h0 : fin has_zero.zero) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_116136 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_116137 (h0 : monoid (linear_ordered_semiring (random_gen (has_top linarith.ineq)))) : monoid.fg (linear_ordered_semiring (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_116138 (h0 : list (preorder empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116139 (h0 : finset (semigroup (has_add (mul_one_class Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116140 (h0 : topological_space (ordered_comm_group num)) : t0_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_116141 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add Type)))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_116142 (h0 : complete_lattice (has_ssubset (metric_space char))) : is_compactly_generated (has_ssubset (metric_space char)) := sorry --non-trivial
lemma new_lemma_116143 (h0 : complete_lattice (add_comm_monoid (finset environment.implicit_infer_kind))) : is_atomistic (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_116144 (h0 : filter (add_monoid to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116145 (h0 : group (with_bot unsigned)) : is_cyclic (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_116146 (h0 : fin has_zero.zero) : @monoid.fg.{0} (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))) (@matrix.vec_empty.{0} (monoid.{0} (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) h0)  := sorry --non-trivial
lemma new_lemma_116147 (h0 : topological_space (has_nndist (boolean_algebra.core linarith.comp))) : loc_path_connected_space (has_nndist (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_116148 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @totally_disconnected_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_116149 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_116150 (h0 : ring (add_comm_monoid (finset Type))) : is_domain (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_116151 (h0 : topological_space (dlist (random_gen (has_top (random_gen linarith.ineq))))) : irreducible_space (dlist (random_gen (has_top (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_116152 (h0 : functor.add_const (list (linear_order unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116153 (h0 : group (has_norm (semiring (semiring empty)))) : group.fg (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_116154 (h0 : finset (has_inter unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116155 (h0 : uniform_space (with_one (has_top congr_arg_kind))) : complete_space (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116156 (h0 : complete_lattice (has_zero ennreal)) : complete_lattice.is_Sup_finite_compact (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_116157 (h0 : topological_space (distrib_lattice (random_gen (random_gen linarith.ineq)))) : totally_separated_space (distrib_lattice (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_116158 (h0 : add_group (has_inv (has_ssubset linarith.ineq))) : is_add_cyclic (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116160 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) (has_neg linarith.comp)) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) (has_neg.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_116161 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (semigroup empty)))) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_116162 (h0 : nat) (h1 : uniform_space (fin h0)) : complete_space (fin h0) := sorry --non-trivial
lemma new_lemma_116163 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116164 (h0 : functor.add_const (group (add_cancel_monoid pos)) name) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_116165 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_116166 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116167 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (mul_one_class string.iterator_imp)))) : t0_space (nondiscrete_normed_field (add_comm_semigroup (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_116168 (h0 : topological_space (finset (has_neg pos))) : irreducible_space (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_116169 (h0 : finset (has_nndist (ring (finset Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116170 (h0 : topological_space (has_to_string (ring pos))) : totally_disconnected_space (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_116171 (h0 : topological_space (add_group (semiring complex))) : locally_compact_space (add_group (semiring complex)) := sorry --non-trivial
lemma new_lemma_116172 (h0 : filter (canonically_ordered_comm_semiring (has_add (has_add (has_to_string pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116173 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_116174 (h0 : functor.add_const (complete_lattice (bin_tree empty)) empty) : @is_compactly_generated.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_116175 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_116176 (h1 : has_coe (nondiscrete_normed_field (mul_one_class string.iterator_imp)) Prop) (h2 : nondiscrete_normed_field (mul_one_class string.iterator_imp)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (mul_one_class.{0} string.iterator_imp)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_116177 (h0 : functor.add_const (function.extfun Type uniform_space) (has_zero (has_zero (has_zero num)))) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_zero.{0} (has_zero.{0} (has_zero.{0} num))) h0) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_116178 (h0 : topological_space (has_ssubset (random_gen (random_gen (has_ssubset to_additive.value_type))))) : path_connected_space (has_ssubset (random_gen (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_116179 (h0 : topological_space (with_bot (has_top congr_arg_kind))) : path_connected_space (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116180 (h0 : fin has_zero.zero) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_116181 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_116182 (h0 : add_group (left_cancel_semigroup num)) : is_add_cyclic (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_116183 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg name)) : @t1_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_116184 (h0 : list (has_to_string (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116185 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116186 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_116187 (h0 : functor.add_const (topological_space (mul_zero_class Type)) pos) : @preconnected_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_116188 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_116189 (h0 : monoid (has_zero (ring (ring (ring pos))))) : monoid.fg (has_zero (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_116190 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @t0_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_116191 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_116192 (h0 : topological_space (complete_distrib_lattice (semiring unsigned))) : preirreducible_space (complete_distrib_lattice (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_116193 (h0 : topological_space (cancel_monoid (comm_group pos))) : loc_path_connected_space (cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_116194 (h4 : ring (distrib linarith.comp_source)) : rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116195 (h0 : group (semigroup (has_add (has_add (has_add Type))))) : group.fg (semigroup (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_116196 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116197 (h1 : not (has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_116198 (h0 : functor.add_const (add_group (ordered_comm_ring name)) (has_add pos)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_116199 (h0 : semiring (metric_space (semiring congr_arg_kind))) : is_noetherian_ring (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116200 (h0 : functor.add_const (functor.add_const (ring Type) Type) (has_to_string linarith.comp)) : @rank_condition.{1} Type (@functor.add_const.run.{1 1} (ring.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (ring.{1} Type) Type) (has_to_string.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_116201 (h0 : add_group (dlist (has_nnnorm fun_info))) : is_add_cyclic (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_116202 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116203 (h0 : add_group (linear_ordered_add_comm_group fun_info)) : is_add_cyclic (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_116204 (h0 : topological_space (has_neg (add_comm_monoid (has_neg_part Type)))) : loc_path_connected_space (has_neg (add_comm_monoid (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_116205 (h1 : topological_space (has_emptyc (has_top fun_info))) : totally_disconnected_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_116206 (h1 : topological_space (nondiscrete_normed_field (mul_one_class char))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_116207 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_116208 (h1 : filter Prop) : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h1  := sorry --non-trivial
lemma new_lemma_116209 (h0 : uniform_space (has_pos_part (ring (boolean_algebra.core linarith.comp)))) : separated_space (has_pos_part (ring (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_116210 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_116211 (h0 : group (add_cancel_monoid (has_neg (has_neg (ring pos))))) : is_simple_group (add_cancel_monoid (has_neg (has_neg (ring pos)))) := sorry --non-trivial
lemma new_lemma_116212 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116213 (h0 : not (semiring (measurable_space.dynkin_system unsigned) -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116214 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @discrete_topology.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_116215 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_116216 (h0 : topological_space (has_add (semigroup environment.implicit_infer_kind))) : t0_space (has_add (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_116217 (h0 : topological_space (has_div (mul_one_class to_additive.value_type))) : totally_disconnected_space (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116218 (h0 : add_monoid (canonically_ordered_add_monoid (option empty))) : add_monoid.fg (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_116219 (h0 : topological_space (ordered_comm_ring (ring Type))) : regular_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_116220 (h1 : topological_space (topological_space (random_gen char))) : totally_disconnected_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_116221 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring Type)) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_116222 (h0 : complete_lattice (has_zero (option unsigned))) : is_compactly_generated (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_116223 (h0 : functor.comp topological_space has_add name) : @irreducible_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_116224 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116225 (h0 : complete_lattice (comm_group (comm_group ennreal))) : is_compactly_generated (comm_group (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_116226 (h0 : monoid (linear_ordered_comm_ring num)) : monoid.fg (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_116227 (h1 : filter (linear_ordered_add_comm_group fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_116228 (h1 : ring (has_ssubset string.iterator_imp)) : is_domain (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_116229 (h0 : function.extfun Type (prod (normed_comm_ring pos))) : id_rel (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_116230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_116231 (h0 : topological_space (measurable_space empty)) : locally_compact_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_116232 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @normal_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_116233 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_116234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_116235 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_116236 (h0 : fin has_zero.zero) : @is_domain.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_116237 (h1 : function.extfun Type ring) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_116238 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_116239 (h0 : function.extfun nat fin) : @separated_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116240 (h0 : not (add_group (add_monoid fun_info) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_116241 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_116242 (h0 : monoid (with_bot num)) : monoid.fg (with_bot num) := sorry --non-trivial
lemma new_lemma_116243 (h0 : monoid (finset (has_add (ring (mul_one_class name))))) : monoid.fg (finset (has_add (ring (mul_one_class name)))) := sorry --non-trivial
lemma new_lemma_116244 (h0 : function.extfun Type group) : @normalizer_condition.{0} (order_dual.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (order_dual.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116245 (h0 : ordered_comm_monoid (comm_group (option (has_to_string (option name))))) : has_exists_mul_of_le (comm_group (option (has_to_string (option name)))) := sorry --non-trivial
lemma new_lemma_116246 (h0 : topological_space (has_top (has_norm fun_info))) : path_connected_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_116247 (h0 : topological_space (linear_ordered_comm_group empty)) : preconnected_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_116248 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116249 (h0 : topological_space (has_nnnorm linarith.comp_source)) : locally_compact_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116250 (h0 : topological_space (has_norm (semiring (semiring (semiring unsigned))))) : path_connected_space (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_116251 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_116252 (h0 : topological_space (has_Inf (has_neg (boolean_algebra (has_pos_part linarith.comp))))) : preirreducible_space (has_Inf (has_neg (boolean_algebra (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_116253 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) pos) Type) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_116254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116255 (h0 : topological_space (div_inv_monoid fun_info)) : totally_disconnected_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_116256 (h0 : add_group (add_semigroup (has_inv (has_inv (random_gen linarith.ineq))))) : is_add_cyclic (add_semigroup (has_inv (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_116257 (h0 : functor.add_const (function.extfun (Type 1) group) (finset (finset linarith.comp))) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (finset.{0} (finset.{0} linarith.comp)) h0) Type)  := sorry --non-trivial
lemma new_lemma_116258 (h0 : function.extfun nat fin) : @archimedean.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116259 (h0 : functor.add_const (function.extfun Type ring) (semiring empty)) : @is_domain.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (semiring.{0} empty) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_116260 (h0 : filter (has_top (has_norm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116261 (h0 : topological_space (monoid congr_arg_kind)) : preirreducible_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116262 (h0 : ring (distrib_lattice (random_gen to_additive.value_type))) : is_domain (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116263 (h0 : add_monoid (preorder (option empty))) : add_monoid.fg (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_116264 (h0 : fin has_zero.zero) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116265 (h0 : functor.add_const (uniform_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116266 (h0 : ring (has_ssubset (random_gen (has_nnnorm fun_info)))) : rank_condition (has_ssubset (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_116267 (h0 : ring (finset (random_gen char))) : rank_condition (finset (random_gen char)) := sorry --non-trivial
lemma new_lemma_116268 (h1 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116269 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @t0_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116270 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116271 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_116272 (h0 : filter (div_inv_monoid to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116273 (h0 : measurable_space ereal) (h1 : has_sub ereal) : has_measurable_sub₂ ereal := sorry --non-trivial
lemma new_lemma_116274 (h0 : ring (has_ssubset (random_gen to_additive.value_type))) : strong_rank_condition (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116275 (h0 : filter (semiring (has_norm linarith.comp))) (h1 : semiring (has_norm linarith.comp) -> Prop) : @filter.limsup.{0 0} Prop (semiring.{0} (has_norm.{0} linarith.comp)) (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_116276 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : preirreducible_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_116277 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_116278 (h0 : ring (has_lt (metric_space (metric_space to_additive.value_type)))) : is_domain (has_lt (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_116279 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (omega_complete_partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_116280 (h0 : topological_space (simple_graph linarith.ineq)) : path_connected_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_116281 (h0 : topological_space (with_one (has_top unsigned))) : irreducible_space (with_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_116282 (h0 : group (has_nndist linarith.comp)) : group.fg (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_116283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116284 (h0 : uniform_space (has_add (has_bot (has_neg real)))) : separated_space (has_add (has_bot (has_neg real))) := sorry --non-trivial
lemma new_lemma_116285 (h0 : semiring (ordered_comm_monoid (has_Inf linarith.comp))) : is_noetherian_ring (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_116286 (h0 : topological_space (has_top string_imp)) : path_connected_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_116287 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_116288 (h1 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_116289 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_116290 (h0 : not (topological_space (linear_ordered_semiring linarith.comp_source) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_116291 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : path_connected_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_116292 (h0 : topological_space (has_compl (boolean_algebra.core (has_nnnorm linarith.ineq)))) : totally_disconnected_space (has_compl (boolean_algebra.core (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_116293 (h0 : ring (complete_distrib_lattice (option empty))) : strong_rank_condition (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_116294 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid (option (option empty)))) : archimedean (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_116295 (h1 : measurable_space (mul_one_class reducibility_hints)) (h2 : measure_theory.measure (mul_one_class reducibility_hints)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_116296 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : preconnected_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_116297 (h0 : not (topological_space num -> false)) : @normal_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_116298 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_116299 (h0 : group (has_Inf name)) : group.fg (has_Inf name) := sorry --non-trivial
lemma new_lemma_116300 (h0 : topological_space (has_pos_part (has_pos_part (has_add linarith.comp)))) : discrete_topology (has_pos_part (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_116301 (h0 : ring (linear_ordered_semiring fun_info)) : strong_rank_condition (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_116302 (h0 : list (has_zero num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116303 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_116304 (h1 : filter (add_left_cancel_monoid (has_ssubset string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_116305 (h0 : functor.add_const (ring (measure_theory.measure_space unsigned)) empty) : @is_domain.{0} (measure_theory.measure_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measure_theory.measure_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_116306 (h1 : to_additive.value_type -> with_one to_additive.value_type -> Prop) : relator.bi_total h1 := sorry --non-trivial
lemma new_lemma_116307 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (semiring empty)))) : @archimedean.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_116308 (h0 : list (linear_ordered_add_comm_group (dlist (dlist linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116309 (h0 : group (normed_comm_ring (has_add unsigned))) : is_simple_group (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_116310 (h0 : has_mem.mem (measurable_space (has_norm unsigned)) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} (has_norm.{0} unsigned)) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116311 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_116312 (h0 : add_group (id linarith.comp_source)) : is_add_cyclic (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_116314 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_116315 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_116316 (h0 : ordered_comm_monoid (comm_group (comm_group Type))) : has_exists_mul_of_le (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_116317 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @t0_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_116318 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) name) : @is_atomistic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_116319 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_116320 (h0 : topological_space (semiring (has_norm (random_gen (random_gen congr_arg_kind))))) : path_connected_space (semiring (has_norm (random_gen (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_116321 (h0 : ring (semi_normed_comm_ring string_imp)) : strong_rank_condition (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_116322 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : t0_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116323 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116324 (h1 : ring (add_comm_semigroup char)) : rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_116325 (h0 : functor.add_const (group (add_right_cancel_monoid congr_arg_kind)) empty) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_116326 (h0 : complete_lattice (topological_space (has_nnnorm reducibility_hints))) : is_compactly_generated (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_116327 (h0 : topological_space (has_norm (has_top (has_norm fun_info)))) : locally_compact_space (has_norm (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_116328 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_116329 (h0 : topological_space (normed_linear_ordered_group num)) : topological_space.separable_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_116330 (h0 : topological_space (mul_one_class fun_info)) (h2 : Prop) : is_path_connected (id (fun (h1 : mul_one_class fun_info), h2)) := sorry --non-trivial
lemma new_lemma_116331 (h0 : functor.add_const (uniform_space (ring linarith.comp)) name) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_116332 (h0 : group (dlist (has_nnnorm (has_top to_additive.value_type)))) : group.fg (dlist (has_nnnorm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_116333 (h0 : finset (option (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116334 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system num)) (semiring empty)) : @complete_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_116335 (h0 : topological_space (complete_distrib_lattice (semiring (semiring unsigned)))) : path_connected_space (complete_distrib_lattice (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_116336 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_116337 (h0 : functor.add_const (functor.comp ring canonically_ordered_comm_semiring name) (option unsigned)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} name) (option.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_116338 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116339 (h0 : functor.add_const (add_group (semigroup name)) Type) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_116340 (h0 : functor.comp topological_space has_add Type) : @t1_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_116341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_116342 (h0 : uniform_space (normed_field linarith.comp_source)) : complete_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116343 (h0 : complete_lattice (add_left_cancel_semigroup (semiring empty))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_116344 (h1 : ring (has_compl (random_gen to_additive.value_type))) : strong_rank_condition (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116345 (h0 : group (has_ssubset (has_nnnorm linarith.ineq))) : is_cyclic (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116346 (h0 : topological_space (has_add (ring linarith.comp))) : t0_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_116347 (h0 : topological_space pos) : totally_disconnected_space pos := sorry --non-trivial
lemma new_lemma_116348 (h0 : function.extfun Type ring) : @rank_condition.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_116349 (h0 : functor.add_const (topological_space (ring Type)) (normed_comm_ring linarith.comp)) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_116350 (h0 : topological_space (has_inner linarith.comp_source (has_top fun_info))) : irreducible_space (has_inner linarith.comp_source (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_116351 (h0 : ring (cancel_monoid (option (option (option pos))))) : strong_rank_condition (cancel_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_116352 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_116353 (h0 : set (normed_comm_ring ennreal)) (h1 : function.extfun (normed_comm_ring ennreal) (fun (x : normed_comm_ring ennreal), Prop)) : set.subset h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_116354 (h0 : ulower (fin has_zero.zero)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_116355 (h0 : topological_space (omega_complete_partial_order unsigned)) : totally_disconnected_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_116356 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_domain.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_116357 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116358 (h1 : uniform_space (uniform_space (has_compl linarith.comp_source))) : complete_space (uniform_space (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116360 (h0 : functor.add_const (uniform_space (has_neg pos)) (has_neg environment.implicit_infer_kind)) : @complete_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_116361 (h0 : has_lt (non_unital_non_assoc_semiring fun_info)) : no_max_order (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_116362 (h0 : topological_space (with_bot (random_gen fun_info))) : totally_separated_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_116363 (h0 : uniform_space (partial_order char)) : complete_space (partial_order char) := sorry --non-trivial
lemma new_lemma_116364 (h0 : functor.add_const (ring (bin_tree num)) num) : @is_principal_ideal_ring.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_116365 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (boolean_algebra.core.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.core.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116366 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : loc_path_connected_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116367 (h0 : set (linear_ordered_comm_group_with_zero reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_116368 (h0 : ring (has_le (normed_field (normed_field std_gen)))) : rank_condition (has_le (normed_field (normed_field std_gen))) := sorry --non-trivial
lemma new_lemma_116369 (h1 : ring (add_cancel_comm_monoid string_imp)) : rank_condition (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_116370 (h0 : ordered_add_comm_monoid (boolean_algebra.core unsigned)) : archimedean (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_116371 (h0 : functor.add_const (topological_space (add_group unsigned)) num) : @t1_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_116372 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_116373 (h0 : topological_space (with_one num)) : preirreducible_space (with_one num) := sorry --non-trivial
lemma new_lemma_116374 (h0 : group (ordered_comm_ring (comm_semigroup (has_bot (comm_semigroup pos))))) : normalizer_condition (ordered_comm_ring (comm_semigroup (has_bot (comm_semigroup pos)))) := sorry --non-trivial
lemma new_lemma_116375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116376 (h0 : functor.add_const (add_group (normed_comm_ring name)) pos) : @is_add_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_116377 (h0 : ring (generalized_boolean_algebra (ring (has_add linarith.comp)))) : is_principal_ideal_ring (generalized_boolean_algebra (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_116378 (h0 : topological_space (cancel_monoid Type)) : locally_compact_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_116379 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) unsigned) : @preirreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116380 (h0 : not (uniform_space (has_emptyc (has_top linarith.comp_source)) -> false)) : @complete_space.{0} (has_emptyc.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_116381 (h0 : function.extfun Type (functor.add_const (prod (add_right_cancel_monoid empty) (add_right_cancel_monoid empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_116382 (h0 : ring (has_zero (has_to_string pos))) : strong_rank_condition (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_116383 (h0 : not (comm_ring (normed_group unsigned) -> false)) : @local_ring.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (comm_ring.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116384 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116385 (h0 : topological_space (comm_ring (dlist fun_info))) : locally_compact_space (comm_ring (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_116386 (h0 : topological_space (has_emptyc (has_inv (has_inv linarith.ineq)))) : t0_space (has_emptyc (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_116387 (h0 : functor.comp complete_lattice cancel_monoid name) : @is_atomistic.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_116388 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @totally_disconnected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_116389 (h0 : ordered_add_comm_monoid (semigroup (add_cancel_monoid linarith.comp))) : archimedean (semigroup (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_116390 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_116391 (h0 : topological_space (has_to_string (semigroup (cancel_monoid (mul_zero_class pos))))) : locally_compact_space (has_to_string (semigroup (cancel_monoid (mul_zero_class pos)))) := sorry --non-trivial
lemma new_lemma_116392 (h0 : has_neg (nondiscrete_normed_field fun_info)) (h1 : measurable_space (nondiscrete_normed_field fun_info)) : has_measurable_neg (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_116393 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116394 (h0 : filter (has_nndist congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116395 (h0 : complete_lattice (measure_theory.measure_space ereal)) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space ereal) := sorry --non-trivial
lemma new_lemma_116396 (h0 : monoid (has_inter (option unsigned))) : monoid.fg (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_116397 (h0 : ring (cancel_monoid (has_neg_part (comm_group Type)))) : strong_rank_condition (cancel_monoid (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_116398 (h0 : function.extfun Type (functor.add_const (semiring (boolean_algebra.core name)))) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} name)) (finset.{0} (has_add.{0} environment.implicit_infer_kind)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (boolean_algebra.core.{0} name))) h0 (finset.{0} (has_add.{0} environment.implicit_infer_kind))))  := sorry --non-trivial
lemma new_lemma_116399 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_116400 (h0 : group (has_norm (has_top fun_info))) : normalizer_condition (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_116401 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116402 (h0 : topological_space (monoid_with_zero (has_add pos))) : normal_space (monoid_with_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_116403 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116404 (h0 : functor.add_const (filter (finset name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116405 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116406 (h0 : topological_space (add_cancel_monoid (option (option (option (option congr_arg_kind)))))) : t0_space (add_cancel_monoid (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_116407 (h0 : functor.add_const (filter (has_neg Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116408 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116409 (h0 : group (mul_zero_class (semiring congr_arg_kind))) : normalizer_condition (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116410 (h0 : complete_lattice (free_add_monoid (semiring (semiring empty)))) : is_compactly_generated (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_116411 (h0 : function.extfun (finset Type) (has_mem.mem (has_one unsigned))) : @strong_rank_condition.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_116412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116413 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116414 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_116415 (h0 : group (has_add Type)) : is_cyclic (has_add Type) := sorry --non-trivial
lemma new_lemma_116416 (h0 : topological_space (fintype (has_nnnorm (add_monoid char)))) : t0_space (fintype (has_nnnorm (add_monoid char))) := sorry --non-trivial
lemma new_lemma_116417 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : normal_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_116418 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ring.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_116419 (h0 : functor.add_const (function.extfun nat fin) (has_Inf (has_add Type))) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) (has_Inf.{1} (has_add.{1} Type)) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116420 (h1 : nat) (h2 : vector Prop (nat.succ h1)) : vector.head h2 := sorry --non-trivial
lemma new_lemma_116421 (h0 : complete_lattice (linear_ordered_semiring (random_gen linarith.ineq))) : is_compactly_generated (linear_ordered_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116422 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_116423 (h0 : filter (option num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116424 (h0 : topological_space (has_pos_part (sub_neg_monoid Type))) : locally_compact_space (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_116425 (h0 : ring (add_cancel_monoid (boolean_algebra.core (has_nndist unsigned)))) : strong_rank_condition (add_cancel_monoid (boolean_algebra.core (has_nndist unsigned))) := sorry --non-trivial
lemma new_lemma_116426 (h1 : not (add_group (uniform_space to_additive.value_type) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_116427 (h0 : functor.add_const (ring (simple_graph unsigned)) empty) : @is_principal_ideal_ring.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_116428 (h0 : functor.add_const (topological_space (semigroup name)) ennreal) : @t0_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_116429 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_116430 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_116431 (h0 : group (with_bot (has_norm unsigned))) : group.fg (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_116432 (h0 : functor.add_const (ring (sub_neg_monoid linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116433 (h0 : not (topological_space (add_cancel_comm_monoid (random_gen linarith.comp_source)) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_116434 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option (option (option empty))))) : totally_disconnected_space (linear_ordered_cancel_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_116435 (h0 : fin has_zero.zero) : @is_domain.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_116436 (h0 : complete_lattice (has_nndist (comm_group (has_add name)))) : complete_lattice.is_Sup_finite_compact (has_nndist (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_116437 (h0 : functor.add_const (group (has_pos_part real)) real) : @is_cyclic.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_116438 (h0 : uniform_space (has_dist (option (option (option (option (option congr_arg_kind))))))) : separated_space (has_dist (option (option (option (option (option congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_116439 (h0 : topological_space (semigroup (finset name))) : loc_path_connected_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_116440 (h0 : complete_lattice (sub_neg_monoid (has_neg (has_neg (has_neg pos))))) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_116441 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class fun_info))) : totally_disconnected_space (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_116442 (h0 : function.extfun Type (functor.add_const (uniform_space znum))) : @complete_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_116443 (h0 : group (linear_order (option unsigned))) : normalizer_condition (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_116444 (h0 : topological_space (has_edist congr_arg_kind)) : topological_space.separable_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116445 (h0 : topological_space (ring (finset pos))) : regular_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_116446 (h0 : topological_space (free_add_monoid (option congr_arg_kind))) : irreducible_space (free_add_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116447 (h0 : topological_space (add_comm_semigroup (mul_one_class ereal))) : path_connected_space (add_comm_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_116448 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : preirreducible_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116449 (h0 : filter (sub_neg_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116450 (h1 : topological_space (with_one linarith.ineq)) : irreducible_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_116451 (h0 : not (filter (semi_normed_comm_ring (has_nnnorm fun_info)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_116452 (h0 : filter (finset (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116453 (h1 : list (distrib_lattice string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_116454 (h0 : uniform_space (random_gen (semiring (semiring num)))) : complete_space (random_gen (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_116455 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_116456 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_116457 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_116458 (h1 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @irreducible_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h1)  := sorry --non-trivial
lemma new_lemma_116459 (h0 : finset (has_nndist (has_edist unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116460 (h1 : topological_space (denumerable linarith.ineq)) : path_connected_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_116461 (h0 : functor.add_const (add_group (has_to_string linarith.comp)) pos) : @is_add_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_116462 (h0 : list (denumerable (random_gen (with_bot to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116463 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_116464 (h0 : fin has_zero.zero) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_116465 (h0 : functor.add_const (filter (simple_graph pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116466 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116467 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116468 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.comp_source)))) : topological_space.separable_space (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_116469 (h0 : functor.add_const (filter (plift num)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116470 (h1 : set (set reducibility_hints)) (h2 : set reducibility_hints) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_116471 (h1 : complete_lattice (with_one (with_bot string_imp))) : is_atomistic (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_116472 (h0 : complete_lattice (fintype (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116473 (h0 : uniform_space (has_to_string (add_left_cancel_monoid environment.implicit_infer_kind))) : separated_space (has_to_string (add_left_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_116474 (h0 : finset (has_neg_part pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116475 (h0 : topological_space (normed_comm_ring (option (option (option (option unsigned)))))) : t1_space (normed_comm_ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_116476 (h0 h1 : multiset (non_unital_non_assoc_semiring linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_116477 (h0 : ring (has_add (finset Type))) : rank_condition (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_116478 (h0 : ring (semigroup (finset (finset linarith.comp)))) : is_domain (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_116479 (h0 : topological_space (id (has_norm linarith.comp))) : normal_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_116480 (h0 : topological_space (add_cancel_monoid (has_add (boolean_algebra (cancel_monoid linarith.comp))))) : t1_space (add_cancel_monoid (has_add (boolean_algebra (cancel_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_116481 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116482 (h0 : complete_lattice (normed_field std_gen)) : complete_lattice.is_Sup_finite_compact (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_116483 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116484 (h1 : topological_space (with_bot to_additive.value_type)) : irreducible_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116485 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) empty) : @separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_116486 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : preirreducible_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_116487 (h0 : topological_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h1 : set (nondiscrete_normed_field (mul_one_class linarith.ineq))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_116488 (h0 : group (canonically_ordered_monoid (has_Inf linarith.comp))) : is_cyclic (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_116489 (h0 : topological_space (monoid congr_arg_kind)) : locally_compact_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116490 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg Type))) : sequential_space (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_116491 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116492 (h2 : uniform_space (id (random_gen to_additive.value_type))) : complete_space (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116493 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : locally_compact_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_116494 (h1 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup congr_arg_kind))) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_116495 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116496 (h0 : ring (complete_linear_order (semiring empty))) : rank_condition (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_116497 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116498 (h0 : ennreal -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_116499 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116500 (h0 : complete_lattice (boolean_algebra.core (add_comm_monoid Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_116501 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116502 (h0 : functor.add_const (topological_space (complete_distrib_lattice congr_arg_kind)) unsigned) : @locally_compact_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116503 (h0 : metric_space (has_norm num)) (h1 : set (has_norm num)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_116504 (h0 : add_monoid (linear_order (option (add_left_cancel_semigroup unsigned)))) : add_monoid.fg (linear_order (option (add_left_cancel_semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_116505 (h0 : not (uniform_space (semiring congr_arg_kind) -> false)) : @separated_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_116506 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116507 (h0 : topological_space (has_to_string (semigroup (comm_group (has_neg_part Type))))) : path_connected_space (has_to_string (semigroup (comm_group (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_116508 (h0 : ordered_add_comm_monoid (free_add_monoid empty)) : archimedean (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_116509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116510 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @t0_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_116511 (h0 : multiset Prop) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) h0  := sorry --non-trivial
lemma new_lemma_116512 (h0 : functor.add_const (monoid (add_cancel_monoid name)) pos) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_116513 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_116514 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : totally_separated_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116515 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (ring name)) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_116516 (h0 : topological_space (normed_linear_ordered_group empty)) : normal_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_116517 (h1 : topological_space (semi_normed_ring char)) : t0_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_116518 (h0 : topological_space (has_zero (finset (finset (finset pos))))) : sequential_space (has_zero (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_116519 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_116520 (h0 : fin has_zero.zero) : @monoid.fg.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116521 (h0 : topological_space (has_neg (semigroup unsigned))) : sequential_space (has_neg (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_116522 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116523 (h0 : topological_space (pseudo_metric_space Type)) : normal_space (pseudo_metric_space Type) := sorry --non-trivial
lemma new_lemma_116524 (h0 : topological_space (has_compl (mul_one_class char))) : path_connected_space (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_116525 (h0 : topological_space (measurable_space congr_arg_kind)) : normal_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116526 (h0 : functor.add_const (topological_space (has_pos_part name)) Type) : @regular_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_116527 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_116528 (h0 : ring (has_pos_part (has_add (has_neg (has_neg linarith.comp))))) : strong_rank_condition (has_pos_part (has_add (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_116529 (h0 : topological_space (add_comm_monoid (boolean_algebra (comm_group (comm_group name))))) : t1_space (add_comm_monoid (boolean_algebra (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_116530 (h1 : ring (add_cancel_comm_monoid (denumerable char))) : is_domain (add_cancel_comm_monoid (denumerable char)) := sorry --non-trivial
lemma new_lemma_116531 (h0 : complete_lattice (has_compl (mul_one_class (random_gen reducibility_hints)))) : is_compactly_generated (has_compl (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_116532 (h0 : topological_space (normed_group (semiring (has_top empty)))) : locally_compact_space (normed_group (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_116533 (h0 : functor.add_const (function.extfun (Type 1) finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_116534 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116535 (h0 : monoid (has_star (has_top (semiring (semiring unsigned))))) : monoid.fg (has_star (has_top (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_116536 (h0 : functor.add_const (uniform_space (has_neg environment.implicit_infer_kind)) (has_neg pos)) : @complete_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_116537 (h0 : not (group (has_top fun_info) -> false)) : @normalizer_condition.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_116538 (h0 : uniform_space (topological_space (random_gen reducibility_hints))) : complete_space (topological_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_116539 (h0 : functor.add_const (group (option name)) pos) : @normalizer_condition.{0} (option.{0} name) (@functor.add_const.run.{0 0} (group.{0} (option.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_116540 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116541 (h0 : finset (finset (option (option (option (option (option (option unsigned)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116542 (h0 : ring (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116544 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_116545 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_116546 (h0 : function.extfun nat fin) : @preconnected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116547 (h0 : not (has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_116548 (h0 : ring (monoid (option unsigned))) : strong_rank_condition (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_116549 (h0 : complete_lattice (linear_ordered_comm_group_with_zero reducibility_hints)) : is_compactly_generated (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_116550 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_116551 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_116552 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116553 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @topological_space.separable_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_116554 (h0 : group (id (semiring (semiring num)))) : is_cyclic (id (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_116555 (h0 : complete_lattice (monoid empty)) : is_compactly_generated (monoid empty) := sorry --non-trivial
lemma new_lemma_116556 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system (has_top (semiring unsigned)))) : unique_factorization_monoid (measurable_space.dynkin_system (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_116557 (h0 : group (as_linear_order (option num))) : normalizer_condition (as_linear_order (option num)) := sorry --non-trivial
lemma new_lemma_116558 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder num)) congr_arg_kind) : @unique_factorization_monoid.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_116559 (h0 : topological_space (free_add_monoid (semiring empty))) : normal_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_116560 (h0 : filter (ordered_comm_semiring (has_pos_part (has_add (finset pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116561 (h0 : not (topological_space (distrib linarith.ineq) -> false)) : @path_connected_space.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_116562 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116563 (h0 : functor.comp ring has_add Type) : @rank_condition.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_116564 (h0 : not (ring (complete_linear_order num) -> false)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_116565 (h1 : uniform_space (topological_space linarith.comp_source)) : complete_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116566 (h0 : ring (ordered_comm_ring (finset (has_add linarith.comp)))) : is_principal_ideal_ring (ordered_comm_ring (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_116567 (h0 : has_nndist (option unsigned) -> has_nndist (option unsigned) -> Prop) : is_irrefl (has_nndist (option unsigned)) h0 := sorry --non-trivial
lemma new_lemma_116568 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @normal_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116569 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_116570 (h0 : topological_space (with_one (has_inv linarith.comp_source))) : locally_compact_space (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116571 (h0 : functor.add_const (ordered_comm_monoid (comm_group name)) linarith.comp) : @has_exists_mul_of_le.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116572 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116573 (h0 : ring (normed_comm_ring (has_to_string num))) : is_domain (normed_comm_ring (has_to_string num)) := sorry --non-trivial
lemma new_lemma_116574 (h0 : topological_space (semigroup (has_to_string (boolean_algebra.core unsigned)))) : preirreducible_space (semigroup (has_to_string (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_116575 (h0 : not (ring (measurable_space linarith.comp_source) -> false)) : @rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_116576 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116577 (h0 : functor.add_const (topological_space (ring pos)) pos) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_116578 (h0 : semiring (generalized_boolean_algebra linarith.comp)) : is_noetherian_ring (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_116579 (h0 : topological_space (finset (ring (has_neg (has_add (has_Inf pos)))))) : regular_space (finset (ring (has_neg (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_116580 (h0 : functor.add_const (list (mul_zero_class Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116581 (h0 : functor.add_const (list (normed_linear_ordered_group empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116582 (h0 : complete_lattice (has_nndist (ring pos))) : is_compactly_generated (has_nndist (ring pos)) := sorry --non-trivial
lemma new_lemma_116583 (h0 : topological_space (has_pos_part (has_Inf pos))) : loc_path_connected_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_116584 (h0 : topological_space (monoid_with_zero (option unsigned))) : locally_compact_space (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_116585 (h0 : topological_space (has_neg_part (finset ennreal))) : topological_space.separable_space (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_116586 (h0 : list (measurable_space (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116587 (h0 : topological_space (ordered_comm_ring (has_nndist name))) : totally_separated_space (ordered_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_116588 (h1 : filter (has_add char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_116589 (h1 : ring (normed_group string_imp)) : strong_rank_condition (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_116590 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_116591 (h0 : topological_space (id (with_bot to_additive.value_type))) : totally_disconnected_space (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116592 (h0 : list (mul_zero_class ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116593 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) unsigned) : @is_domain.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116594 (h0 : filter (has_ssubset (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116595 (h0 : group (has_add linarith.comp)) : is_cyclic (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_116596 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_116597 (h0 : functor.add_const (ring (plift num)) (semiring num)) : @is_domain.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_116598 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_116599 (h0 : topological_space (has_add (has_Inf real))) : discrete_topology (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_116600 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116601 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_116602 (h0 : ring (has_add (cancel_monoid (has_to_string pos)))) : rank_condition (has_add (cancel_monoid (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_116603 (h0 : uniform_space (fintype (has_nnnorm fun_info))) : complete_space (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_116604 (h0 : topological_space (ring (has_neg pos))) : preconnected_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_116605 (h0 : not (semiring (metric_space unsigned) -> false)) : @is_noetherian_ring.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116606 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) num) : @strong_rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_116607 (h0 : monoid (has_neg congr_arg_kind)) : monoid.fg (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116608 (h0 : topological_space (has_Inf (has_add (finset pos)))) : totally_disconnected_space (has_Inf (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_116609 (h0 : functor.add_const (function.extfun Type ring) (option (measurable_space.dynkin_system unsigned))) : @is_domain.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (option.{0} (measurable_space.dynkin_system.{0} unsigned)) h0) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116610 (h0 : ring (option (option (option (option ennreal))))) : is_principal_ideal_ring (option (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_116611 (h0 : not (add_group (dlist linarith.ineq) -> false)) : @is_add_cyclic.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_116612 (h1 : topological_space (has_le std_gen)) : path_connected_space (has_le std_gen) := sorry --non-trivial
lemma new_lemma_116613 (h1 : ring (add_left_cancel_monoid string_imp)) : rank_condition (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_116614 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_116615 (h0 : not (ring (distrib_lattice linarith.ineq) -> false)) : @rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_116616 (h0 : list (boolean_algebra (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116617 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_116618 (h1 : complete_lattice (has_lt string_imp)) : complete_lattice.is_Sup_finite_compact (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_116619 (h0 : ring (random_gen (boolean_algebra to_additive.value_type))) : is_domain (random_gen (boolean_algebra to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116620 (h1 : ring (normed_group to_additive.value_type)) : strong_rank_condition (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116621 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_116622 (h1 : ring (with_one (has_inv (has_inv to_additive.value_type)))) : strong_rank_condition (with_one (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_116623 (h1 : complete_lattice (has_top (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_116624 (h0 : boolean_algebra (comm_group name) -> boolean_algebra (comm_group name) -> Prop) : is_antisymm (boolean_algebra (comm_group name)) h0 := sorry --non-trivial
lemma new_lemma_116625 (h0 : functor.add_const (semiring (sub_neg_monoid real)) Type) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 1} (semiring.{0} (sub_neg_monoid.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_116626 (h0 : topological_space (has_neg (finset (finset (finset (finset pos)))))) : t1_space (has_neg (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_116627 (h0 : ring (canonically_ordered_add_monoid unsigned)) : is_domain (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_116628 (h1 : list (encodable (with_bot string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_116629 (h0 : uniform_space (boolean_algebra (comm_group Type))) : complete_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_116630 (h0 : topological_space (simple_graph (mul_one_class enat))) (h1 : preorder (simple_graph (mul_one_class enat))) : order_closed_topology (simple_graph (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_116631 (h0 : functor.add_const (functor.add_const (group Type) name) name) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) name) name h0))  := sorry --non-trivial
lemma new_lemma_116632 (h0 : has_add (add_comm_monoid ennreal) -> has_add (add_comm_monoid ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_116633 (h0 : ring (complete_distrib_lattice (boolean_algebra.core (finset pos)))) : strong_rank_condition (complete_distrib_lattice (boolean_algebra.core (finset pos))) := sorry --non-trivial
lemma new_lemma_116634 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : discrete_topology (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_116635 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_116636 (h0 : uniform_space (add_cancel_monoid (add_comm_monoid (has_neg_part Type)))) : complete_space (add_cancel_monoid (add_comm_monoid (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_116637 (h0 : add_group (id (has_top num))) : is_add_cyclic (id (has_top num)) := sorry --non-trivial
lemma new_lemma_116638 (h1 : not (topological_space (semiring to_additive.value_type) -> false)) : @discrete_topology.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_116639 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @discrete_topology.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116640 (h0 : functor.add_const (complete_lattice linarith.comp) Type) : @is_atomistic.{0} linarith.comp (@functor.add_const.run.{0 1} (complete_lattice.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_116641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_116642 (h0 : uniform_space (mul_zero_class (option pos))) : separated_space (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_116643 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_116644 (h1 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : path_connected_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_116645 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) (has_neg name)) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_116646 (h0 : topological_space (cancel_monoid (option (has_add (has_to_string ennreal))))) : t0_space (cancel_monoid (option (has_add (has_to_string ennreal)))) := sorry --non-trivial
lemma new_lemma_116647 (h0 : group (canonically_linear_ordered_monoid (has_add real))) : is_simple_group (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_116648 (h1 : topological_space (has_ssubset linarith.comp_source)) : path_connected_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116649 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_116650 (h0 : topological_space (has_neg_part pos)) : locally_compact_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_116651 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116652 (h0 : ring (has_inter ennreal)) : strong_rank_condition (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_116653 (h0 : uniform_space (with_one (semiring (has_norm (semiring empty))))) : complete_space (with_one (semiring (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_116654 (h0 : list (has_top (has_ssubset string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116655 (h0 : add_group (measurable_space (semiring (semiring congr_arg_kind)))) : is_add_cyclic (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_116656 (h1 : not (ring (distrib_lattice linarith.ineq) -> false)) : @rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_116657 (h0 : ring (has_add (has_Inf (has_Inf (finset pos))))) : is_domain (has_add (has_Inf (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_116658 (h0 : topological_space (free_add_monoid (semiring empty))) : t0_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_116659 (h0 : functor.add_const (topological_space (free_add_monoid num)) (semiring empty)) : @totally_separated_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_116660 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116661 (h0 : ring (has_top (normed_lattice_add_comm_group complex))) : is_domain (has_top (normed_lattice_add_comm_group complex)) := sorry --non-trivial
lemma new_lemma_116662 (h1 : uniform_space (has_lt linarith.ineq)) : complete_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_116663 (h0 : monoid (has_top (has_top (random_gen fun_info)))) : monoid.fg (has_top (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_116664 (h0 : functor.add_const (group (finset Type)) pos) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_116665 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116666 (h0 : ring (comm_ring (has_ssubset (has_ssubset (random_gen string_imp))))) : strong_rank_condition (comm_ring (has_ssubset (has_ssubset (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_116667 (h0 : topological_space (distrib_lattice (has_nnnorm fun_info))) : path_connected_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_116668 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_to_string name)) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_116669 (h0 : topological_space (sub_neg_monoid (finset linarith.comp))) : irreducible_space (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_116670 (h1 : complete_lattice (has_div string_imp)) : is_compactly_generated (has_div string_imp) := sorry --non-trivial
lemma new_lemma_116671 (h0 : topological_space (has_neg_part (pseudo_metric_space ennreal))) : t1_space (has_neg_part (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_116672 (h0 : topological_space (parse_result fun_info)) : connected_space (parse_result fun_info) := sorry --non-trivial
lemma new_lemma_116673 (h0 : ring (finset (option unsigned))) : is_domain (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_116674 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_116675 (h0 : fin has_zero.zero) : @t0_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116676 (h0 : filter (boolean_algebra.core (has_neg_part unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116677 (h0 h2 : rat) : rat.le h0 h2 := sorry --non-trivial
lemma new_lemma_116678 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg (has_neg pos))) : @sequential_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} (has_neg.{0} pos)) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_116679 (h1 : ring (has_ssubset linarith.ineq)) : is_domain (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_116680 (h0 : has_coe (nondiscrete_normed_field (nondiscrete_normed_field std_gen)) Prop) (h1 : nondiscrete_normed_field (nondiscrete_normed_field std_gen)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (nondiscrete_normed_field.{0} std_gen)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_116681 (h0 : uniform_space (measure_theory.measure_space (semiring (semiring empty)))) : separated_space (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_116682 (h0 : list (semigroup pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116683 (h0 : complete_lattice (is_R_or_C empty)) : complete_lattice.is_Sup_finite_compact (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_116684 (h0 : not (ring (dlist to_additive.value_type) -> false)) : @strong_rank_condition.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_116685 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_116686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_116687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116688 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_116689 (h1 : group fun_info) : group.fg fun_info := sorry --non-trivial
lemma new_lemma_116690 (h0 : semiring (normed_comm_ring (has_neg_part Type))) : is_noetherian_ring (normed_comm_ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_116691 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116692 (h0 : ring (add_comm_monoid congr_arg_kind)) : is_principal_ideal_ring (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116693 (h0 : functor.add_const (uniform_space (ring linarith.comp)) linarith.comp) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116694 (h0 : topological_space (has_ssubset (random_gen char))) : locally_compact_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_116695 (h0 : functor.add_const (list (finset pos)) (has_neg linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116696 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space empty)) : unique_factorization_monoid (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_116697 (h0 : set (normed_field char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_116698 (h0 : ring stieltjes_function) : is_domain stieltjes_function := sorry --non-trivial
lemma new_lemma_116699 (h0 : group (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : is_simple_group (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_116700 (h0 : group environment.implicit_infer_kind) : is_cyclic environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_116701 (h0 : functor.add_const (monoid (ring Type)) (has_neg Type)) : @monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_116702 (h0 : cancel_comm_monoid_with_zero empty) : unique_factorization_monoid empty := sorry --non-trivial
lemma new_lemma_116703 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : discrete_topology (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_116704 (h0 : has_Inf real -> has_Inf real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_116705 (h0 : complete_lattice (has_norm empty)) : is_atomistic (has_norm empty) := sorry --non-trivial
lemma new_lemma_116706 (h0 : topological_space (has_scalar empty congr_arg_kind)) : loc_path_connected_space (has_scalar empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116707 (h0 : uniform_space (boolean_algebra (boolean_algebra (boolean_algebra (boolean_algebra (has_add pos)))))) : complete_space (boolean_algebra (boolean_algebra (boolean_algebra (boolean_algebra (has_add pos))))) := sorry --non-trivial
lemma new_lemma_116708 (h0 : ring (normed_lattice_add_comm_group (has_neg (has_neg pos)))) : is_domain (normed_lattice_add_comm_group (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_116709 (h0 : filter (has_bot (option (option (option (option (option empty))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116710 (h0 : ring (ring (ordered_ring (has_add pos)))) : is_domain (ring (ordered_ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_116711 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : is_trans to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_116712 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116713 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116714 (h0 : complete_lattice (add_left_cancel_semigroup (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_116715 (h0 : not (topological_space (semiring num) -> false)) : @totally_disconnected_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_116716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_116717 (h1 : topological_space (has_append fun_info)) (h2 : preorder (has_append fun_info)) : order_topology (has_append fun_info) := sorry --non-trivial
lemma new_lemma_116718 (h0 : not (monoid (random_gen unsigned) -> false)) : @monoid.fg.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_116719 (h0 : semiring (mul_zero_class pos)) : is_noetherian_ring (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_116720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116721 (h0 : functor.add_const (topological_space nnreal) num) : loc_path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_116722 (h4 : ring (simple_graph reducibility_hints)) : strong_rank_condition (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_116723 (h1 : ring (normed_field (normed_field reducibility_hints))) : is_domain (normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_116724 (h0 : complete_lattice (has_nndist (has_add Type))) : is_compactly_generated (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_116725 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : sequential_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_116726 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116727 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_116728 (h0 : topological_space (free_add_monoid (option unsigned))) : discrete_topology (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_116729 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_116730 (h0 : complete_lattice (add_left_cancel_semigroup (semiring empty))) : is_compactly_generated (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_116731 (h0 : finset (linear_ordered_comm_monoid_with_zero (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116732 (h0 : topological_space (canonically_ordered_comm_semiring (ring (ring linarith.comp)))) : t1_space (canonically_ordered_comm_semiring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_116733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_116734 (h0 : semiring (boolean_algebra (has_to_string pos))) : is_noetherian_ring (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_116735 (h0 : add_group (pseudo_metric_space (option unsigned))) : is_add_cyclic (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_116736 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_116737 (h0 : topological_space (ordered_comm_ring (ring pos))) : sequential_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_116738 (h0 : topological_space (add_group (semiring empty))) : discrete_topology (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_116739 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116740 (h0 : functor.add_const (add_group (normed_linear_ordered_group empty)) congr_arg_kind) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_116741 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_116742 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116743 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_116744 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116745 (h0 : group (as_linear_order unsigned)) : group.fg (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_116746 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116747 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_116748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_116749 (h0 : group (sub_neg_monoid (finset (has_pos_part pos)))) : is_simple_group (sub_neg_monoid (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_116750 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_116751 (h0 : set (prod linarith.comp_source linarith.comp_source)) (h1 : prod linarith.comp_source linarith.comp_source) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_116752 (h0 : list (ring (option (option (option unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116753 (h0 : complete_lattice (canonically_linear_ordered_monoid unsigned)) : is_atomistic (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_116754 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116755 (h0 : add_group (canonically_ordered_monoid (has_add environment.implicit_infer_kind))) : is_add_cyclic (canonically_ordered_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_116756 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) uniform_space.{1}) h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_116757 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (finset (has_Inf linarith.comp)))) : archimedean (canonically_ordered_comm_semiring (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_116758 (h0 : complete_lattice (linear_ordered_semiring (has_norm empty))) : is_compactly_generated (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_116759 (h0 : uniform_space (boolean_algebra (normed_comm_ring (normed_comm_ring pos)))) : complete_space (boolean_algebra (normed_comm_ring (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_116760 (h0 : not (filter (plift char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_116761 (h0 : rel (has_compl linarith.ineq) (has_lt linarith.comp_source)) (h1 : set (has_lt linarith.comp_source)) : set.finite (rel.core h0 h1) := sorry --non-trivial
lemma new_lemma_116762 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_116763 (h0 : functor.add_const (topological_space (ring name)) Type) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_116764 (h0 : group (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : group.fg (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116765 (h0 : function.extfun Type group) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116766 (h1 : complete_lattice (complete_semilattice_Sup (random_gen (has_nnnorm string_imp)))) : is_compactly_generated (complete_semilattice_Sup (random_gen (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_116767 (h0 : nat) (h1 : fin (nat.succ h0) -> Prop) (h2 : fin h0) : id (id (matrix.vec_tail h1 h2)) := sorry --non-trivial
lemma new_lemma_116768 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_116769 (h0 : complete_lattice (monoid (option (option (option (option (option unsigned))))))) : is_compactly_generated (monoid (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_116770 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_add (cancel_monoid environment.implicit_infer_kind)))) : archimedean (add_comm_monoid (has_add (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_116771 (h0 : complete_lattice (has_nnnorm linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_116772 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf real))) : is_atomistic (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_116773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_comm_ring.{0} (comm_monoid.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} (comm_monoid.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_116774 (h1 : ring (has_emptyc (random_gen congr_arg_kind))) : is_domain (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116775 (h0 : ring (complete_distrib_lattice name)) : is_principal_ideal_ring (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_116776 (h0 : topological_space (linear_ordered_semiring (has_norm num))) : preirreducible_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_116777 (h0 : topological_space (ordered_comm_ring (has_add pos))) : irreducible_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_116778 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_116779 (h0 : ring (with_bot (semiring (semiring (semiring unsigned))))) : rank_condition (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_116780 (h0 : topological_space (monoid (option pos))) : preirreducible_space (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_116781 (h0 : complete_lattice (has_add fun_info)) : complete_lattice.is_Sup_finite_compact (has_add fun_info) := sorry --non-trivial
lemma new_lemma_116782 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char)))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_116783 (h0 : monoid (metric_space (has_top (has_norm unsigned)))) : monoid.fg (metric_space (has_top (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_116784 (h2 : uniform_space (nondiscrete_normed_field fun_info)) : complete_space (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_116785 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_116786 (h1 : topological_space (distrib linarith.comp_source)) : totally_disconnected_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116787 (h0 : topological_space (normed_comm_ring pos)) : normal_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_116788 (h0 : list (cancel_monoid (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116789 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : preconnected_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_116790 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char)))))) : is_compactly_generated (distrib (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_116791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_116792 (h0 : ring (has_to_string (normed_comm_ring name))) : is_domain (has_to_string (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_116793 (h0 : uniform_space (has_zero (has_add Type))) : complete_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_116794 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_116795 (h0 : topological_space (has_top (denumerable char))) : path_connected_space (has_top (denumerable char)) := sorry --non-trivial
lemma new_lemma_116796 (h0 : ring (has_Inf (has_Inf pos))) : rank_condition (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_116797 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf pos)))) : topological_space.separable_space (ordered_comm_ring (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_116798 (h0 : finset (boolean_algebra (has_add (has_add (has_add (has_add Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_116799 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_116800 (h0 : has_lt (add_comm_semigroup (monoid_with_zero string.iterator_imp))) : no_max_order (add_comm_semigroup (monoid_with_zero string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_116801 (h0 : functor.add_const (list (ring unsigned)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116802 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_116803 (h0 : uniform_space (ordered_comm_ring (has_neg name))) : separated_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_116804 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : locally_compact_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116805 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : topological_space.separable_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116806 (h0 : group (has_top (has_top num))) : normalizer_condition (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_116807 (h1 : uniform_space (normed_field (normed_field linarith.ineq))) : complete_space (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_116808 (h2 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h2)  := sorry --non-trivial
lemma new_lemma_116809 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_116810 (h0 : ordered_comm_monoid (has_to_string (has_to_string (has_to_string name)))) : has_exists_mul_of_le (has_to_string (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_116811 (h0 : add_group (random_gen (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_116812 (h0 : complete_lattice (with_bot (has_norm empty))) : is_atomistic (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_116813 (h0 : topological_space (normed_field linarith.comp_source)) (h1 : preorder (normed_field linarith.comp_source)) : order_topology (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116814 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_116815 (h1 : topological_space (linear_ordered_add_comm_monoid to_additive.value_type)) : t0_space (linear_ordered_add_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116816 (h2 : complete_lattice (random_gen string_imp)) : complete_lattice.is_Sup_finite_compact (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_116817 (h0 : list (pseudo_metric_space (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116818 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : preirreducible_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_116819 (h0 : functor.add_const (complete_lattice (semigroup empty)) (semiring empty)) : @is_compactly_generated.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_116820 (h0 : functor.add_const (ring (comm_group unsigned)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_116821 (h2 : complete_lattice (denumerable to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116822 (h0 : topological_space (simple_graph (has_add (finset (finset (has_add (finset pos))))))) : locally_compact_space (simple_graph (has_add (finset (finset (has_add (finset pos)))))) := sorry --non-trivial
lemma new_lemma_116823 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116824 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) (finset pos)) : @normal_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_116825 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_116826 (h0 : set (fun_info -> nondiscrete_normed_field (add_comm_semigroup enat))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_116827 (h2 : function.extfun Type group) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} h2 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_116828 (h0 : topological_space (has_nnnorm (mul_one_class to_additive.value_type))) : topological_space.first_countable_topology (has_nnnorm (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116829 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg name)) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_116830 (h1 : topological_space (semi_normed_comm_ring char)) : path_connected_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_116831 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @is_compactly_generated.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_116832 (h0 : topological_space (ring (option pos))) : totally_separated_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_116833 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class char))))) : is_compactly_generated (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_116834 (h0 : list (has_neg (finset environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_116835 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_116836 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add Type))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_116837 (h0 : functor.add_const (topological_space (has_Sup empty)) unsigned) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116838 (h0 : functor.add_const (add_group (boolean_algebra name)) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_116839 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_116840 (h0 : topological_space (left_cancel_semigroup (semiring (semiring empty)))) : path_connected_space (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_116841 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) congr_arg_kind) : @discrete_topology.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_116842 (h0 : topological_space (has_top congr_arg_kind)) : totally_separated_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116843 (h1 : ring (has_ssubset (random_gen char))) : strong_rank_condition (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_116844 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : normal_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_116845 (h1 : list (topological_space fun_info)) (h2 : function.extfun (((eq h1 list.nil -> Prop) -> Prop) -> Prop) (function.extfun ((eq h1 list.nil -> Prop) -> Prop))) : @totally_separated_space.{0} fun_info (@list.last.{0} (topological_space.{0} fun_info) h1 (@function.extfun_app.{0 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info))) (λ (x : @eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info))), false) (@function.extfun_app.{1 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop) (function.extfun.{0 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)))) (@function.extfun_app.{1 0} ((@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop) → Prop) (function.extfun.{1 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop)) (@function.extfun_app.{1 0} (((@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop) → Prop) → Prop) (function.extfun.{1 0} ((@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop) → Prop)) h2 (function.extfun.{1 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info)) → Prop))) (function.extfun.{0 0} (@eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info))))) (λ (x : @eq.{1} (list.{0} (topological_space.{0} fun_info)) h1 (@list.nil.{0} (topological_space.{0} fun_info))), false))))  := sorry --non-trivial
lemma new_lemma_116846 (h0 : complete_lattice (add_cancel_monoid (has_neg (has_add Type)))) : is_compactly_generated (add_cancel_monoid (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_116847 (h0 : group (has_Inf (ring (ring linarith.comp)))) : normalizer_condition (has_Inf (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_116848 (h0 : set (mul_zero_class fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_116849 (h0 : ordered_add_comm_monoid (has_add (has_add Type))) : archimedean (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_116850 (h0 : functor.add_const (topological_space (linear_ordered_field unsigned)) num) : @normal_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_116851 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : topological_space.separable_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_116852 (h0 : uniform_space (has_to_string (has_norm to_additive.value_type))) : complete_space (has_to_string (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_116853 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_116854 (h0 : topological_space (has_Inf (ring (ring pos)))) : preirreducible_space (has_Inf (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_116855 (h0 : group (measurable_space string_imp)) : is_cyclic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_116856 (h0 : complete_lattice (has_nndist (option unsigned))) : is_atomistic (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_116857 (h0 : cancel_comm_monoid_with_zero (cancel_monoid name)) : unique_factorization_monoid (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_116858 (h0 : complete_lattice (mul_zero_class unsigned)) : is_atomistic (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_116859 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116860 (h0 : functor.add_const (functor.add_const (topological_space empty) empty) empty) : t0_space empty := sorry --non-trivial
lemma new_lemma_116861 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_116862 (h0 : ordered_comm_monoid (semigroup (comm_group (comm_group Type)))) : has_exists_mul_of_le (semigroup (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_116863 (h0 : ring (complete_distrib_lattice (ring (ring (has_nndist (ring Type)))))) : is_principal_ideal_ring (complete_distrib_lattice (ring (ring (has_nndist (ring Type))))) := sorry --non-trivial
lemma new_lemma_116864 (h0 : monoid (normed_group (semiring (semiring empty)))) : monoid.fg (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_116865 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : totally_separated_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_116866 (h2 : monoid congr_arg_kind) : monoid.fg congr_arg_kind := sorry --non-trivial
lemma new_lemma_116867 (h0 : fin has_zero.zero) : @rank_condition.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116868 (h0 : topological_space (comm_group (ring Type))) : path_connected_space (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_116869 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (ring Type)) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_116870 (h0 : list (semi_normed_comm_ring (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_116871 (h0 : topological_space (has_zero (has_add linarith.comp))) : preconnected_space (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_116872 (h0 : group (encodable (has_nnnorm (has_nnnorm fun_info)))) : group.fg (encodable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_116873 (h0 : uniform_space (semiring (has_top (has_top num)))) : separated_space (semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_116874 (h0 : uniform_space (denumerable (comm_ring linarith.comp_source))) : complete_space (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116875 (h0 : group (add_cancel_monoid (has_add Type))) : normalizer_condition (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_116876 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_116877 (h0 : group (add_cancel_monoid (finset environment.implicit_infer_kind))) : normalizer_condition (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_116878 (h0 : add_monoid (cancel_monoid congr_arg_kind)) : add_monoid.fg (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116879 (h1 : ring (random_gen fun_info)) : strong_rank_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_116880 (h0 : topological_space (has_to_string linarith.comp)) : t1_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_116881 (h0 : ordered_add_comm_monoid (has_neg (normed_comm_ring unsigned))) : archimedean (has_neg (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_116882 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_116883 (h0 : add_group (has_zero (has_nndist Type))) : is_add_cyclic (has_zero (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_116884 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_116885 (h1 : add_group (semi_normed_comm_ring to_additive.value_type)) : is_add_cyclic (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116886 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_116887 (h0 : topological_space (semigroup (has_to_string (finset (has_add (finset (finset linarith.comp))))))) : irreducible_space (semigroup (has_to_string (finset (has_add (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_116888 (h0 : functor.add_const (complete_lattice (finset pos)) (ring (has_neg environment.implicit_infer_kind))) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_116889 (h0 : topological_space (boolean_algebra.core (finset ennreal))) : totally_disconnected_space (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_116890 (h0 : functor.add_const (topological_space (option unsigned)) pos) : @t0_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_116891 (h0 : topological_space (has_top unsigned)) : locally_compact_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_116892 (h1 : topological_space (add_monoid fun_info)) : totally_disconnected_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_116893 (h1 : has_lt (add_comm_semigroup ereal)) : no_max_order (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_116894 (h2 : ring (encodable char)) : strong_rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_116895 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_116896 (h0 : group (has_pos_part (has_bot Type))) : normalizer_condition (has_pos_part (has_bot Type)) := sorry --non-trivial
lemma new_lemma_116897 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_116898 (h0 : topological_space (has_emptyc (has_emptyc linarith.comp_source))) : path_connected_space (has_emptyc (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_116899 (h0 : topological_space (with_bot unsigned)) : t1_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_116900 (h1 : topological_space empty) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_116901 (h0 : monoid (fintype unsigned)) : monoid.fg (fintype unsigned) := sorry --non-trivial
lemma new_lemma_116902 (h0 : ordered_add_comm_monoid (simple_graph Type)) : archimedean (simple_graph Type) := sorry --non-trivial
lemma new_lemma_116903 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_116904 (h0 : group (random_gen (random_gen (random_gen linarith.ineq)))) : group.fg (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_116905 (h0 : complete_lattice (canonically_ordered_monoid (finset real))) : is_compactly_generated (canonically_ordered_monoid (finset real)) := sorry --non-trivial
lemma new_lemma_116906 (h0 : ordered_comm_monoid (sub_neg_monoid (finset name))) : has_exists_mul_of_le (sub_neg_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_116907 (h0 : filter (topological_space (add_cancel_comm_monoid reducibility_hints))) : @t0_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@filter.Limsup.{0} (topological_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) (@topological_space.complete_lattice.{0} (add_cancel_comm_monoid.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_116908 (h0 : functor.add_const (uniform_space (add_cancel_monoid environment.implicit_infer_kind)) (has_neg linarith.comp)) : @complete_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_116909 (h0 : topological_space (has_top unsigned)) : topological_space.separable_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_116910 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116911 (h0 : topological_space (non_assoc_semiring rat)) : irreducible_space (non_assoc_semiring rat) := sorry --non-trivial
lemma new_lemma_116912 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116913 (h0 : function.extfun Type ring) : @is_domain.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_116914 (h0 : monoid (ordered_comm_ring (has_neg linarith.comp))) : monoid.fg (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_116915 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_116916 (h0 : complete_lattice (finset (has_to_string (has_to_string (has_to_string congr_arg_kind))))) : is_atomistic (finset (has_to_string (has_to_string (has_to_string congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_116917 (h0 : functor.add_const (add_group (ordered_cancel_add_comm_monoid num)) unsigned) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_cancel_add_comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116918 (h1 : topological_space (measurable_space (semiring congr_arg_kind))) : locally_compact_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_116919 (h0 : uniform_space (add_group empty)) : separated_space (add_group empty) := sorry --non-trivial
lemma new_lemma_116920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116921 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_116922 (h0 : topological_space (add_cancel_monoid (has_nndist (has_add pos)))) : sequential_space (add_cancel_monoid (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_116923 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116924 (h0 : not (topological_space (comm_ring char) -> false)) : @locally_compact_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_116925 (h0 : ordered_comm_monoid (add_cancel_monoid (finset pos))) : has_exists_mul_of_le (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_116926 (h0 : filter (boolean_algebra.core (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_116927 (h0 : functor.add_const (group (add_comm_monoid Type)) name) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_116928 (h0 : uniform_space (plift (semiring unsigned))) : separated_space (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_116929 (h0 : add_group (normed_field linarith.comp_source)) : is_add_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_116930 (h0 : functor.add_const (list (preorder empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116931 (h0 : set (set char)) (h1 : set char) : generate_pi_system h0 h1 := sorry --non-trivial
lemma new_lemma_116932 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) empty) : @archimedean.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) empty h0) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_116933 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (option empty))) : unique_factorization_monoid (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_116934 (h0 : function.extfun nat fin) : @path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_116935 (h0 : fin has_zero.zero) : @separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_116936 (h0 : has_mem.mem (metric_space (has_norm empty)) has_emptyc.emptyc) : @discrete_topology.{0} (metric_space.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_116937 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : preirreducible_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_116938 (h0 : topological_space (ring pos)) : totally_separated_space (ring pos) := sorry --non-trivial
lemma new_lemma_116939 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (omega_complete_partial_order.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_116940 (h0 : functor.add_const (ring (boolean_algebra Type)) (finset linarith.comp)) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_116941 (h0 : group (has_neg congr_arg_kind)) : normalizer_condition (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116942 (h0 : group (add_cancel_monoid (ring (ring (ring (ring linarith.comp)))))) : is_simple_group (add_cancel_monoid (ring (ring (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_116943 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_116944 (h0 : ring (has_nndist congr_arg_kind)) : rank_condition (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_116945 (h0 : not (topological_space (add_monoid fun_info) -> false)) : @totally_disconnected_space.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_116946 (h0 : topological_space (semi_normed_ring linarith.ineq)) (h1 : not (preorder (semi_normed_ring linarith.ineq) -> false)) : @order_topology.{0} (semi_normed_ring.{0} linarith.ineq) h0 (@classical.by_contradiction'.{1} (preorder.{0} (semi_normed_ring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_116947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116948 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_116949 (h0 : topological_space (finset num)) : path_connected_space (finset num) := sorry --non-trivial
lemma new_lemma_116950 (h1 : complete_lattice (linear_ordered_comm_group_with_zero std_gen)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_116951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_116952 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : locally_compact_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_116953 (h0 : uniform_space (normed_lattice_add_comm_group (finset Type))) : separated_space (normed_lattice_add_comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_116954 (h0 : functor.add_const (finset (boolean_algebra unsigned)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116955 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_116956 (h0 : topological_space (mul_zero_class (finset Type))) : loc_path_connected_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_116957 (h0 : add_group (linear_ordered_comm_group_with_zero environment.projection_info)) : is_add_cyclic (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_116958 (h0 : group (random_gen (semiring (semiring num)))) : group.fg (random_gen (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_116959 (h0 : monoid (boolean_algebra real)) : monoid.fg (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_116960 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : strong_rank_condition (denumerable (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_116961 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116962 (h0 : functor.add_const (topological_space Type) pos) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_116963 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116964 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_116965 (h0 : uniform_space (filter.countable_filter_basis to_additive.value_type)) : complete_space (filter.countable_filter_basis to_additive.value_type) := sorry --non-trivial
lemma new_lemma_116966 (h2 : not (complete_lattice linarith.comp_source -> false)) : @is_atomistic.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h2)  := sorry --non-trivial
lemma new_lemma_116967 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_116968 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116969 (h0 : add_monoid (cancel_monoid (has_nndist (semigroup (complete_distrib_lattice (has_add Type)))))) : add_monoid.fg (cancel_monoid (has_nndist (semigroup (complete_distrib_lattice (has_add Type))))) := sorry --non-trivial
lemma new_lemma_116970 (h0 : complete_lattice (boolean_algebra.core (option (option empty)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option (option empty))) := sorry --non-trivial
lemma new_lemma_116971 (h0 : uniform_space (has_bot (has_Inf (has_add linarith.comp)))) : separated_space (has_bot (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_116972 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @sequential_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_116973 (h0 : group (comm_ring (has_nnnorm char))) : group.fg (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_116974 (h0 : ring (option (semiring (semiring (semiring (semiring (semiring empty))))))) : strong_rank_condition (option (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_116975 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_116976 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116977 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_116978 (h0 : topological_space (has_pos_part (has_add pos))) : locally_compact_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_116979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_116980 (h0 : function.extfun Type group) : @is_cyclic.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_116981 (h0 : ring (has_ssubset (has_nnnorm string.iterator_imp))) : is_domain (has_ssubset (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_116982 (h1 : complete_lattice (random_gen string_imp)) : is_compactly_generated (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_116983 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_116984 (h0 : filter (has_add (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_116985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_116986 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_116987 (h0 : functor.add_const (complete_lattice (bin_tree empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_116988 (h0 : function.extfun Type group) : @is_simple_group.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_116989 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_116990 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_116991 (h0 : topological_space (add_left_cancel_semigroup (option unsigned))) : irreducible_space (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_116992 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_116993 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @irreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_116994 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_116995 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_116996 (h0 : not (topological_space (dlist linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_116997 (h0 : add_monoid (id empty)) : add_monoid.fg (id empty) := sorry --non-trivial
lemma new_lemma_116998 (h0 : functor.add_const (filter (has_neg unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_116999 (h0 : semiring (add_comm_semigroup enat)) (h1 : ideal (add_comm_semigroup enat) -> std_gen) (h2 : coe_sort (set.range h1)) : ideal.is_prime (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_117000 (h0 : topological_space (has_Sup (semiring empty))) : t0_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_117001 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_117002 (h0 : topological_space (has_append (comm_ring fun_info))) : path_connected_space (has_append (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_117003 (h0 : ring (linear_ordered_semiring num)) : strong_rank_condition (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_117004 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117005 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_117006 (h0 : functor.add_const (topological_space (non_unital_non_assoc_ring linarith.comp)) (has_Inf (has_add name))) : @totally_separated_space.{0} (non_unital_non_assoc_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (non_unital_non_assoc_ring.{0} linarith.comp)) (has_Inf.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_117007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_117008 (h0 : topological_space (has_nndist (has_nndist environment.implicit_infer_kind))) : regular_space (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117009 (h3 : ring (has_ssubset to_additive.value_type)) : rank_condition (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117010 (h0 : add_monoid (non_assoc_semiring (semiring unsigned))) : add_monoid.fg (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_117011 (h2 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_117013 (h2 : not (ring (has_compl string.iterator_imp) -> false)) : @rank_condition.{0} (has_compl.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string.iterator_imp)) h2)  := sorry --non-trivial
lemma new_lemma_117014 (h0 : topological_space (option (has_to_string pos))) : t0_space (option (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_117015 (h0 : uniform_space (ring (add_comm_monoid Type))) : separated_space (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_117016 (h1 : topological_space fun_info) : t0_space fun_info := sorry --non-trivial
lemma new_lemma_117017 (h0 : functor.add_const (ordered_add_comm_monoid (has_edist unsigned)) empty) : @archimedean.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_117018 (h0 : not (complete_lattice (has_top (semiring linarith.comp_source)) -> false)) : @is_compactly_generated.{0} (has_top.{0} (semiring.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} (semiring.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_117019 (h0 : group (has_inv (has_nnnorm fun_info))) : is_cyclic (has_inv (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_117020 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117021 (h0 : topological_space (has_Sup (option num))) : discrete_topology (has_Sup (option num)) := sorry --non-trivial
lemma new_lemma_117022 (h0 : not (function.extfun Type topological_space -> false)) : @regular_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_117023 (h0 : list (distrib_lattice (has_top (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117024 (h0 : topological_space char) (h1 : set char) : is_preconnected h1 := sorry --non-trivial
lemma new_lemma_117025 (h0 : functor.add_const (complete_lattice (finset Type)) (finset ennreal)) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_117026 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117027 (h0 : group (normed_comm_ring (finset (finset pos)))) : is_simple_group (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_117028 (h0 : topological_space (simple_graph string.iterator_imp)) (h1 : preorder (simple_graph string.iterator_imp)) : order_closed_topology (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_117029 (h0 : uniform_space (has_add (has_neg linarith.comp))) : separated_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_117030 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_117031 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_117032 (h0 : function.extfun (Type 1) (functor.add_const (function.extfun Type ring))) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0})) h0 Type)) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117033 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp))))) : loc_path_connected_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_117034 (h0 : functor.add_const (filter (has_zero unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117035 (h0 : group (random_gen (random_gen (has_inv (random_gen linarith.ineq))))) : is_cyclic (random_gen (random_gen (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_117036 (h1 : partial_order (with_bot string_imp) -> Prop) : Exists h1 := sorry --non-trivial
lemma new_lemma_117037 (h0 : prod (add_comm_monoid environment.implicit_infer_kind) (add_comm_monoid environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_117038 (h0 : complete_lattice (has_add (div_inv_monoid fun_info))) : complete_lattice.is_Sup_finite_compact (has_add (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_117039 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) num) : @totally_separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_117040 (h0 : function.extfun nat fin) : @is_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117041 (h0 : complete_lattice (add_group (semiring num))) : complete_lattice.is_Sup_finite_compact (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_117042 (h0 : uniform_space (ordered_comm_monoid (has_Inf (ring (has_add linarith.comp))))) : complete_space (ordered_comm_monoid (has_Inf (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_117043 (h0 : uniform_space (add_right_cancel_monoid (has_norm (semiring empty)))) : complete_space (add_right_cancel_monoid (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_117044 (h0 : topological_space (has_neg (finset (finset ennreal)))) : t0_space (has_neg (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_117045 (h0 : monoid (denumerable (has_top linarith.ineq))) : monoid.fg (denumerable (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117046 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117047 (h0 : complete_lattice (random_gen (random_gen fun_info))) : is_compactly_generated (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_117048 (h0 : fin has_zero.zero) : @sequential_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_117049 (h0 : group (linear_ordered_field unsigned)) : normalizer_condition (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_117050 (h0 : has_norm linarith.ineq -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_117051 (h0 : functor.add_const (group (normed_comm_ring Type)) linarith.comp) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117052 (h0 : add_monoid (random_gen linarith.comp)) : add_monoid.fg (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_117053 (h0 : semiring (has_star congr_arg_kind)) : is_noetherian_ring (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117054 (h0 h1 : multiset string.iterator) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_117055 (h0 : function.extfun Type (functor.add_const (finset auto.case_option))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_117056 (h0 : ordered_add_comm_monoid (has_add (option pos))) : archimedean (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_117057 (h0 : measurable_space (has_top (has_norm linarith.comp_source))) (h1 : has_mul (has_top (has_norm linarith.comp_source))) : has_measurable_mul (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117058 (h0 : topological_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : totally_disconnected_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117059 (h0 : complete_lattice (id empty)) : is_compactly_generated (id empty) := sorry --non-trivial
lemma new_lemma_117060 (h0 : topological_space (has_to_string (has_neg name))) : discrete_topology (has_to_string (has_neg name)) := sorry --non-trivial
lemma new_lemma_117061 (h0 : not (add_group (add_right_cancel_monoid unsigned) -> false)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_117062 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_117063 (h0 : topological_space (normed_comm_ring (add_comm_monoid name))) : sequential_space (normed_comm_ring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_117064 (h0 : list (has_norm string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117065 (h0 : monoid (ordered_comm_monoid real)) : monoid.fg (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_117066 (h0 : measurable_space (add_comm_semigroup fun_info)) (h1 : set (add_comm_semigroup fun_info)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_117067 (h0 : uniform_space (distrib (has_ssubset (has_ssubset (random_gen (random_gen char)))))) : complete_space (distrib (has_ssubset (has_ssubset (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_117068 (h0 : group (ring (has_add linarith.comp))) : is_simple_group (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_117069 (h0 : ring (with_one linarith.ineq)) : rank_condition (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_117070 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117071 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_117072 (h0 : complete_lattice (metric_space (random_gen linarith.comp))) : is_atomistic (metric_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_117073 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_Inf pos)))) : t1_space (complete_distrib_lattice (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_117074 (h0 : topological_space (dlist to_additive.value_type)) : irreducible_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117075 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) name) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_117076 (h0 : topological_space (add_right_cancel_monoid (semiring unsigned))) : locally_compact_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_117077 (h0 : ring (normed_group (random_gen to_additive.value_type))) : is_domain (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117078 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_117079 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117080 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_117081 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117082 (h0 : ring (has_add (ring environment.implicit_infer_kind))) : is_principal_ideal_ring (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117083 (h1 : topological_space (with_bot linarith.ineq)) : totally_separated_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_117084 (h0 : functor.add_const (semiring (has_nndist pos)) pos) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_117085 (h0 : topological_space (finset (finset (finset (finset (finset (has_nndist (finset ennreal)))))))) : locally_compact_space (finset (finset (finset (finset (finset (has_nndist (finset ennreal))))))) := sorry --non-trivial
lemma new_lemma_117086 (h0 : group (cancel_monoid ennreal)) : is_simple_group (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_117087 (h0 : ring (linear_ordered_add_comm_group (ordered_semiring char))) : rank_condition (linear_ordered_add_comm_group (ordered_semiring char)) := sorry --non-trivial
lemma new_lemma_117088 (h0 : topological_space (has_nndist (ring (has_neg Type)))) : totally_disconnected_space (has_nndist (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_117089 (h0 : function.extfun Type topological_space) : @normal_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117090 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add pos)) : @totally_separated_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} pos) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_117091 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (linear_ordered_field.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (linear_ordered_field.{1} Type))  := sorry --non-trivial
lemma new_lemma_117092 (h0 : measurable_space (cancel_monoid empty)) (h1 : topological_space (measure_theory.measure (cancel_monoid empty))) : loc_path_connected_space (measure_theory.measure (cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_117093 (h0 : uniform_space (has_neg_part (finset (has_nndist environment.implicit_infer_kind)))) : separated_space (has_neg_part (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_117094 (h0 : uniform_space (has_top (has_top (has_top (has_top num))))) : separated_space (has_top (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_117095 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117096 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @sequential_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_117097 (h0 : topological_space (finset (option (preorder unsigned)))) : locally_compact_space (finset (option (preorder unsigned))) := sorry --non-trivial
lemma new_lemma_117098 (h0 : add_group (has_add (boolean_algebra linarith.comp))) : is_add_cyclic (has_add (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_117099 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_117100 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) num) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_117101 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_117102 (h0 : complete_lattice (has_to_string (boolean_algebra environment.implicit_infer_kind))) : is_compactly_generated (has_to_string (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117103 (h0 : not (topological_space (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq))) -> false)) (h1 : preorder (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq)))) : @order_topology.{0} (semi_normed_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) h0) h1  := sorry --non-trivial
lemma new_lemma_117104 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_add Type))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_117105 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @discrete_topology.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_117106 (h0 : functor.add_const Prop (has_bot real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_117107 (h0 : complete_lattice (denumerable (mul_one_class linarith.comp_source))) : is_compactly_generated (denumerable (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117108 (h0 : topological_space (add_semigroup num)) : loc_path_connected_space (add_semigroup num) := sorry --non-trivial
lemma new_lemma_117109 (h0 : set (uniform_space char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_117110 (h0 : uniform_space (add_comm_monoid (has_Inf name))) : complete_space (add_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_117111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_117112 (h0 : topological_space (has_inter (option (option (option (option (option (option num)))))))) : totally_separated_space (has_inter (option (option (option (option (option (option num))))))) := sorry --non-trivial
lemma new_lemma_117113 (h0 : functor.add_const (filter (preorder unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117114 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117115 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_117116 (h0 : monoid (complete_distrib_lattice empty)) : monoid.fg (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_117117 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_117118 (h0 : ring (ring (complete_distrib_lattice name))) : rank_condition (ring (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_117119 (h0 : group (boolean_algebra (comm_group pos))) : normalizer_condition (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_117120 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117121 (h0 : functor.add_const (complete_lattice (comm_group Type)) pos) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_117122 (h0 : group (has_top (random_gen fun_info))) : normalizer_condition (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_117123 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_117124 (h0 : not (topological_space (has_append linarith.comp_source) -> false)) : @path_connected_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117125 (h0 : topological_space (topological_space to_additive.value_type)) : totally_disconnected_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117126 (h0 : topological_space (semiring (random_gen linarith.comp))) : totally_separated_space (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_117127 (h0 : complete_lattice (boolean_algebra (has_add name))) : is_compactly_generated (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_117128 (h0 : functor.add_const (add_monoid (has_zero linarith.comp)) name) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_117129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_117131 (h0 : topological_space (has_bot empty)) : loc_path_connected_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_117132 (h0 : complete_lattice (normed_comm_ring (finset (finset pos)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_117133 (h0 : functor.add_const (complete_lattice (ring pos)) pos) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_117134 (h0 : complete_lattice (linear_order unsigned)) : is_compactly_generated (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_117135 (h0 : ordered_add_comm_monoid (ordered_comm_ring (canonically_ordered_comm_semiring (has_add linarith.comp)))) : archimedean (ordered_comm_ring (canonically_ordered_comm_semiring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_117136 (h0 : topological_space (has_neg (boolean_algebra (semigroup environment.implicit_infer_kind)))) : preconnected_space (has_neg (boolean_algebra (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_117137 (h0 : topological_space (has_nnnorm (random_gen (random_gen string.iterator_imp)))) : t0_space (has_nnnorm (random_gen (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_117138 (h2 : set (add_comm_semigroup char -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_117139 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero pos)) pos) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_117140 (h0 : add_group (left_cancel_semigroup (semiring empty))) : is_add_cyclic (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_117141 (h0 : topological_space (finset (option (option unsigned)))) : discrete_topology (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_117142 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117143 (h0 : ring (has_inv linarith.comp_source)) : rank_condition (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117144 (h0 : complete_lattice (random_gen (with_bot (measurable_space linarith.comp)))) : is_atomistic (random_gen (with_bot (measurable_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_117145 (h0 : group (has_zero (has_add pos))) : normalizer_condition (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_117146 (h0 : functor.comp list distrib_lattice (div_inv_monoid to_additive.value_type)) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_117147 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top linarith.ineq)))) : t0_space (complete_semilattice_Sup (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_117148 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : t1_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_117149 (h0 : group (has_Inf (has_add (ring pos)))) : group.fg (has_Inf (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_117150 (h0 : complete_lattice (has_div (has_nnnorm linarith.comp_source))) : is_compactly_generated (has_div (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117151 (h0 : function.extfun nat fin) : @separated_space.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_117152 (h0 : topological_space (has_nndist (has_nndist (ring linarith.comp)))) : regular_space (has_nndist (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_117153 (h0 : ring (has_one (has_norm unsigned))) : strong_rank_condition (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_117154 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid (option (option unsigned)))) : unique_factorization_monoid (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_117155 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_117156 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_117157 (h0 : ring (has_to_string (option (option empty)))) : strong_rank_condition (has_to_string (option (option empty))) := sorry --non-trivial
lemma new_lemma_117158 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_117159 (h0 : semiring (boolean_algebra.core (add_cancel_monoid linarith.comp))) : is_noetherian_ring (boolean_algebra.core (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_117160 (h0 : topological_space (has_union unsigned)) : sequential_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_117161 (h0 : set (uniform_space to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_117162 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_117163 (h1 h2 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_117164 (h0 : group (sub_neg_monoid Type)) : is_cyclic (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_117165 (h0 : prod (has_sub num) (has_sub num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_117166 (h0 : complete_lattice (dlist (linear_ordered_add_comm_group fun_info))) : complete_lattice.is_Sup_finite_compact (dlist (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_117167 (h0 : functor.add_const (uniform_space (has_to_string unsigned)) (mul_zero_class Type)) : @complete_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} unsigned)) (mul_zero_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_117168 (h0 : topological_space (linear_ordered_field (finset (option (option (option ennreal)))))) : preconnected_space (linear_ordered_field (finset (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_117169 (h1 : ring (encodable (has_ssubset char))) : strong_rank_condition (encodable (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_117170 (h0 : ring (normed_field (has_ssubset char))) : strong_rank_condition (normed_field (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_117171 (h0 : Prop) (h1 : with_bot (decidable h0)) (h2 : ne h1 has_bot.bot) : @as_false h0 (@with_bot.unbot.{0} (decidable h0) h1 h2)  := sorry --non-trivial
lemma new_lemma_117172 (h0 : prod (semigroup pos) (semigroup pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_117173 (h0 : not (topological_space (partial_order unsigned) -> false)) : @topological_space.separable_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_117174 (h0 : group (boolean_algebra (ring (ring Type)))) : is_simple_group (boolean_algebra (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_117175 (h0 : functor.add_const (functor.add_const (topological_space (has_bot empty)) empty) empty) : @loc_path_connected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_117176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117177 (h0 : topological_space (cancel_monoid (has_neg_part name))) : normal_space (cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_117178 (h0 : functor.add_const (complete_lattice (has_neg_part name)) (has_add Type)) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_117179 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : locally_compact_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117180 (h0 : functor.add_const (topological_space (has_neg Type)) (boolean_algebra linarith.comp)) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117181 (h0 : ring (add_group (has_norm (has_norm (has_norm unsigned))))) : is_domain (add_group (has_norm (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_117182 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (with_bot (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_117183 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf Type))))) : t0_space (has_Inf (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_117184 (h0 : functor.add_const Prop (cancel_monoid pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_117185 (h0 : function.extfun Type topological_space) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_117186 (h0 : semiring (generalized_boolean_algebra (has_pos_part (has_add pos)))) : is_noetherian_ring (generalized_boolean_algebra (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_117187 (h0 : functor.add_const (monoid (monoid empty)) empty) : @monoid.fg.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_117188 (h1 : uniform_space (complete_semilattice_Sup string_imp)) : complete_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_117189 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_117190 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117191 (h0 : filter (semigroup (add_comm_monoid name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_117192 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_117193 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117194 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_117195 (h0 : functor.add_const (monoid (ring empty)) congr_arg_kind) : @monoid.fg.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117196 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_well_founded.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_well_founded.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_117197 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_117198 (h0 : uniform_space (canonically_ordered_monoid (sub_neg_monoid Type))) : complete_space (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_117199 (h0 : has_emptyc fun_info -> has_emptyc fun_info) (h1 : has_emptyc fun_info) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_117200 (h1 : ring (metric_space string_imp)) : rank_condition (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_117201 (h0 : topological_space (has_Sup (option congr_arg_kind))) : normal_space (has_Sup (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117202 (h0 : topological_space (has_norm (semiring (semiring empty)))) : t0_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_117203 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117204 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : totally_disconnected_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_117205 (h1 : not (add_group (measurable_space num) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_117206 (h0 : cancel_comm_monoid_with_zero (has_Inf real)) : unique_factorization_monoid (has_Inf real) := sorry --non-trivial
lemma new_lemma_117207 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : t1_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117208 (h0 : complete_lattice (pseudo_metric_space Type)) : is_compactly_generated (pseudo_metric_space Type) := sorry --non-trivial
lemma new_lemma_117209 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_117210 (h0 : not (topological_space (add_group num) -> false)) : @irreducible_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_117211 (h1 : topological_space (has_add linarith.comp_source)) : path_connected_space (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117212 (h0 : uniform_space (boolean_algebra.core linarith.comp)) : separated_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_117213 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117214 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : has_mul (add_comm_semigroup fun_info)) : has_continuous_mul (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_117215 (h0 : has_le (denumerable (random_gen (random_gen linarith.ineq)))) (h1 : bounded_order (denumerable (random_gen (random_gen linarith.ineq)))) : is_simple_order (denumerable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_117216 (h0 : topological_space (linear_ordered_field (option (option (option (option ennreal)))))) : preconnected_space (linear_ordered_field (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_117217 (h0 : group (distrib_lattice string_imp)) : group.fg (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_117218 (h0 : finset (has_neg (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117219 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) name) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_117220 (h0 : ring (denumerable string.iterator_imp)) : rank_condition (denumerable string.iterator_imp) := sorry --non-trivial
lemma new_lemma_117221 (h0 : ring (id (semiring (semiring congr_arg_kind)))) : strong_rank_condition (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_117222 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (boolean_algebra (has_to_string Type))) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (boolean_algebra.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_117223 (h0 : ring (finset (boolean_algebra pos))) : strong_rank_condition (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_117224 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_117225 (h0 : topological_space (comm_group (comm_group ennreal))) : path_connected_space (comm_group (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_117226 (h0 : topological_space (has_add (option (option (option (option (option (option (option ennreal))))))))) : not (t0_space (has_add (option (option (option (option (option (option (option ennreal))))))))) := sorry --non-trivial
lemma new_lemma_117227 (h0 : functor.add_const (functor.add_const (list pos) (ring pos)) (ring name)) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_117228 (h0 : topological_space (has_emptyc (has_norm to_additive.value_type))) : discrete_topology (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117229 (h0 : topological_space (with_bot (random_gen (random_gen fun_info)))) : totally_disconnected_space (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_117230 (h0 : functor.add_const (topological_space (has_nndist unsigned)) empty) : @t0_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_117231 (h0 : ring (has_top (has_nnnorm linarith.ineq))) : strong_rank_condition (has_top (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117232 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : normal_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_117233 (h0 : functor.add_const (functor.comp complete_lattice canonically_ordered_comm_semiring name) name) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) name (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name) name (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name) name h0)))))  := sorry --non-trivial
lemma new_lemma_117234 (h0 : topological_space (dlist (has_ssubset (has_ssubset (has_ssubset (has_ssubset fun_info)))))) : totally_disconnected_space (dlist (has_ssubset (has_ssubset (has_ssubset (has_ssubset fun_info))))) := sorry --non-trivial
lemma new_lemma_117235 (h1 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h1) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117236 (h1 : topological_space (has_div to_additive.value_type)) : t0_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117237 (h0 : topological_space (has_add num)) : t0_space (has_add num) := sorry --non-trivial
lemma new_lemma_117238 (h0 : uniform_space (measurable_space (random_gen to_additive.value_type))) : separated_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117239 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @preirreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_117240 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_117241 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_117242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117243 (h2 : not (group to_additive.value_type -> false)) : @is_cyclic.{0} to_additive.value_type (@classical.by_contradiction'.{1} (group.{0} to_additive.value_type) h2)  := sorry --non-trivial
lemma new_lemma_117244 (h0 : functor.add_const (uniform_space (comm_group name)) environment.implicit_infer_kind) : @separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117245 (h0 : topological_space (random_gen (with_bot to_additive.value_type))) : path_connected_space (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117246 (h0 : ring (comm_group (option unsigned))) : is_principal_ideal_ring (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_117247 (h0 : group (has_inner unsigned unsigned)) : is_cyclic (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_117248 (h0 : complete_lattice (pseudo_metric_space ennreal)) : is_compactly_generated (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_117249 (h0 : topological_space (sub_neg_monoid name)) : regular_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_117250 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117251 (h0 : functor.add_const (ring (has_neg_part pos)) linarith.comp) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117252 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117253 (h0 : group (has_nndist (finset pos))) : group.fg (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_117254 (h0 : filter (group_with_zero ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117255 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117256 (h1 : topological_space (distrib_lattice (random_gen (random_gen string_imp)))) : irreducible_space (distrib_lattice (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_117257 (h0 : not (topological_space (topological_space string.iterator_imp) -> false)) : @path_connected_space.{0} (topological_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_117258 (h0 : group (complete_distrib_lattice (semigroup Type))) : group.fg (complete_distrib_lattice (semigroup Type)) := sorry --non-trivial
lemma new_lemma_117259 (h0 : not (topological_space (semi_normed_comm_ring linarith.comp_source) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117260 (h0 : topological_space (mul_zero_class (semiring (semiring unsigned)))) : t1_space (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_117261 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_117262 (h0 : functor.add_const (semiring (add_cancel_monoid environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_117263 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (ring linarith.comp)) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117264 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_117265 (h0 : fin has_zero.zero) : @group.fg.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_117266 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117267 (h0 : not (topological_space (random_gen linarith.comp_source) -> false)) : @totally_separated_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117268 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) (has_neg (ring (ring linarith.comp)))) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) (has_neg.{0} (ring.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_117269 (h1 : set (semi_normed_ring reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_117270 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) name) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_117271 (h0 : functor.add_const (monoid (linear_ordered_field unsigned)) unsigned) : @monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_field.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117272 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_117273 (h0 : functor.add_const (function.extfun Type complete_lattice) (option empty)) : @complete_lattice.is_Sup_finite_compact.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} empty) h0) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117274 (h0 : topological_space (linear_order (option empty))) : locally_compact_space (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_117275 (h0 : is_empty (has_inv linarith.comp_source)) (h1 : function.extfun Type has_inv) : @normalizer_condition.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source))))) (@is_empty.elim'.{1 1} (has_inv.{0} linarith.comp_source) (group.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source)))))) h0 (@function.extfun_app.{2 1} Type has_inv.{0} h1 linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117276 (h0 h1 : multiset (has_lt fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_117277 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_117278 (h0 : functor.add_const (topological_space (semiring num)) congr_arg_kind) : @locally_compact_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117279 (h0 : topological_space (boolean_algebra.core name)) : preirreducible_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_117280 (h0 : complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_117281 (h0 : complete_lattice (option unsigned)) : is_compactly_generated (option unsigned) := sorry --non-trivial
lemma new_lemma_117282 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_117283 (h0 : complete_lattice (semi_normed_ring (has_nnnorm char))) : is_compactly_generated (semi_normed_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_117284 (h0 : ring (semi_normed_comm_ring (normed_field (mul_one_class (simple_graph enat))))) : rank_condition (semi_normed_comm_ring (normed_field (mul_one_class (simple_graph enat)))) := sorry --non-trivial
lemma new_lemma_117285 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field empty)) : unique_factorization_monoid (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_117286 (h0 : functor.add_const (preorder (non_assoc_semiring unsigned)) unsigned) (h1 : set (non_assoc_semiring unsigned)) : @bdd_below.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (preorder.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0) h1  := sorry --non-trivial
lemma new_lemma_117287 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_117288 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @separated_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_117289 (h0 : functor.add_const Prop (semigroup (has_neg environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_117290 (h0 : complete_lattice (has_inter (option empty))) : is_compactly_generated (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_117291 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_117292 (h0 : ring (has_Sup empty)) : rank_condition (has_Sup empty) := sorry --non-trivial
lemma new_lemma_117293 (h0 : not (complete_lattice (lex congr_arg_kind) -> false)) : @is_compactly_generated.{0} (lex.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (lex.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_117294 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117295 (h0 : group (semigroup num)) : normalizer_condition (semigroup num) := sorry --non-trivial
lemma new_lemma_117296 (h0 : complete_lattice (has_one (has_top empty))) : is_compactly_generated (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_117297 (h0 : topological_space (distrib_lattice (has_inv linarith.comp_source))) : locally_compact_space (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117298 (h0 : fin has_zero.zero) : @preconnected_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_117299 (h0 : semiring (partial_order (semiring unsigned))) : is_noetherian_ring (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_117300 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117301 (h0 : ordered_comm_monoid (has_to_string (option pos))) : has_exists_mul_of_le (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_117302 (h0 : add_monoid (complete_distrib_lattice (option unsigned))) : add_monoid.fg (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_117303 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_117304 (h0 : cancel_comm_monoid_with_zero (omega_complete_partial_order empty)) : unique_factorization_monoid (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_117305 (h0 : add_group (has_top (random_gen string_imp))) : is_add_cyclic (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_117306 (h0 : add_group (has_neg linarith.comp)) : is_add_cyclic (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_117307 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) unsigned) : @t1_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117308 (h0 : group (has_append (random_gen linarith.ineq))) : is_cyclic (has_append (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117309 (h0 : group (has_top (non_assoc_semiring fun_info))) : group.fg (has_top (non_assoc_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_117310 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) unsigned) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117311 (h0 : uniform_space (ring (normed_comm_ring pos))) : complete_space (ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_117312 (h0 : topological_space (linear_order (option empty))) : normal_space (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_117313 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) (has_neg environment.implicit_infer_kind)) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (normed_comm_ring.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_117314 (h0 : functor.add_const (functor.add_const Prop (normed_comm_ring Type)) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117315 (h0 : cancel_comm_monoid_with_zero (is_R_or_C (option unsigned))) : unique_factorization_monoid (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_117316 (h0 : has_le (has_dist num)) : no_bot_order (has_dist num) := sorry --non-trivial
lemma new_lemma_117317 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) Type) : @regular_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_117318 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @totally_separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_117319 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg_part Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_117320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_117321 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_117322 (h0 : with_bot (function.extfun Type topological_space) -> Prop) (h1 : ne (classical.epsilon h0) has_bot.bot) : @locally_compact_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@with_bot.unbot.{1} (function.extfun.{2 1} Type topological_space.{0}) (@classical.epsilon.{2} (with_bot.{1} (function.extfun.{2 1} Type topological_space.{0})) (@nonempty_of_inhabited.{2} (with_bot.{1} (function.extfun.{2 1} Type topological_space.{0})) (@with_bot.inhabited.{1} (function.extfun.{2 1} Type topological_space.{0}))) h0) h1) unsigned)  := sorry --non-trivial
lemma new_lemma_117323 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117324 (h0 : function.extfun Type (functor.add_const (group (has_Sup num)))) : @group.fg.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_Sup.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_117325 (h0 : ring (has_bot Type)) : strong_rank_condition (has_bot Type) := sorry --non-trivial
lemma new_lemma_117326 (h0 : uniform_space (fintype to_additive.value_type)) : complete_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117327 (h0 : topological_space (semigroup (finset (has_to_string pos)))) : irreducible_space (semigroup (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_117328 (h0 : not (uniform_space (has_top fun_info) -> false)) : @separated_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_117329 (h0 : functor.add_const (list (left_cancel_semigroup unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117330 (h0 : topological_space (complete_semilattice_Sup num)) : path_connected_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_117331 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_117332 (h0 : fin has_zero.zero) : @normal_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_117333 (h0 : functor.add_const (add_monoid (mul_zero_class num)) (semiring empty)) : @add_monoid.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_117334 (h0 : functor.add_const (group (ordered_ring unsigned)) empty) : @normalizer_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_117335 (h0 : add_group (has_union (semiring (semiring empty)))) : is_add_cyclic (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_117336 (h0 : topological_space (distrib_lattice (with_one to_additive.value_type))) : t0_space (distrib_lattice (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_117338 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117339 (h0 : filter (add_left_cancel_monoid (fintype linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117340 (h0 : not (uniform_space (has_add linarith.comp_source) -> false)) : @complete_space.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117341 (h0 : functor.add_const (topological_space (has_zero Type)) (has_to_string environment.implicit_infer_kind)) : @regular_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_117342 (h0 : functor.add_const (finset (add_comm_monoid pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_117344 (h0 : functor.add_const (monoid (boolean_algebra.core name)) linarith.comp) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117345 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_117346 (h0 : functor.add_const (ring (canonically_ordered_add_monoid empty)) empty) : @is_domain.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_117347 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_117348 (h0 : group (add_group (semiring linarith.comp))) : is_simple_group (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_117349 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117350 (h0 : list (cancel_monoid (has_add (boolean_algebra (has_add (has_add (has_add name))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_117351 (h0 : monoid_with_zero (has_to_string ennreal)) (h1 : nat.arithmetic_function (has_to_string ennreal)) : nat.arithmetic_function.is_multiplicative h1 := sorry --non-trivial
lemma new_lemma_117352 (h0 : add_monoid (has_pos_part (has_add Type))) : add_monoid.fg (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_117353 (h0 : functor.add_const (ordered_comm_monoid (has_neg Type)) linarith.comp) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117354 (h0 : cancel_comm_monoid_with_zero (has_zero (boolean_algebra (boolean_algebra pos)))) : unique_factorization_monoid (has_zero (boolean_algebra (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_117355 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order empty)) (semiring empty)) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_117356 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_117357 (h0 h1 : fin has_zero.zero) : pnat.coprime (matrix.vec_empty h0) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_117358 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_117359 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @normal_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_117360 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @totally_disconnected_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117361 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117362 (h2 : ring (denumerable (has_inv string_imp))) : strong_rank_condition (denumerable (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_117363 (h4 : topological_space (denumerable (comm_ring reducibility_hints))) : totally_disconnected_space (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_117364 (h1 : ring (with_one linarith.ineq)) : strong_rank_condition (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_117365 (h0 : function.extfun Type topological_space) : @regular_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_117366 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117367 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen unsigned))) : @normal_space.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117368 (h2 : complete_lattice (semi_normed_ring to_additive.value_type)) : is_atomistic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117369 (h0 : cancel_comm_monoid_with_zero (simple_graph unsigned)) : unique_factorization_monoid (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_117370 (h0 : ring (semiring (random_gen (has_norm fun_info)))) : is_domain (semiring (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_117371 (h0 : topological_space (group_with_zero ennreal)) : preirreducible_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_117372 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (has_to_string pos)) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117373 (h0 : filter (has_nndist (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_117374 (h0 : group (canonically_ordered_comm_semiring (has_Inf (has_add (has_neg name))))) : normalizer_condition (canonically_ordered_comm_semiring (has_Inf (has_add (has_neg name)))) := sorry --non-trivial
lemma new_lemma_117375 (h0 : ring (has_bot (has_Inf Type))) : is_principal_ideal_ring (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_117376 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117377 (h0 : group (has_neg num)) : normalizer_condition (has_neg num) := sorry --non-trivial
lemma new_lemma_117378 (h0 : finset std_gen) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117379 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_117380 (h0 : functor.add_const (ring (has_Sup num)) unsigned) : @is_domain.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117381 (h0 : has_lt (has_le linarith.comp_source)) : no_max_order (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_117383 (h0 : fin has_zero.zero) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_117384 (h0 : ordered_add_comm_monoid (has_inter ennreal)) : archimedean (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_117385 (h0 : complete_lattice (has_one num)) : is_atomistic (has_one num) := sorry --non-trivial
lemma new_lemma_117386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_117387 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc congr_arg_kind))) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117388 (h0 : topological_space (lex unsigned)) : irreducible_space (lex unsigned) := sorry --non-trivial
lemma new_lemma_117389 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117390 (h0 : list (has_to_string (has_neg (finset (ring (finset linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117391 (h0 : not (uniform_space (left_cancel_semigroup unsigned) -> false)) : @complete_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_117392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117393 (h0 : functor.add_const (ring (finset Type)) environment.implicit_infer_kind) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117394 (h0 : set (has_lt (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_117395 (h0 : functor.add_const (topological_space Type) (finset (finset pos))) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_117396 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_117397 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : totally_separated_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117398 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset ennreal))) : unique_factorization_monoid (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_117399 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117400 (h0 : group (complete_distrib_lattice (finset ennreal))) : is_simple_group (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_117401 (h1 : list (with_zero string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_117402 (h0 : functor.add_const (list (semigroup unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117403 (h0 : functor.add_const (add_group znum) unsigned) : @is_add_cyclic.{0} znum (@functor.add_const.run.{0 0} (add_group.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117404 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_117405 (h0 : group (has_to_string (finset environment.implicit_infer_kind))) : group.fg (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117406 (h0 : set (has_neg linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_117407 (h0 : not (uniform_space (random_gen (mul_one_class char)) -> false)) : @complete_space.{0} (random_gen.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_117408 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @discrete_topology.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117409 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid num)) num) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_117410 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_compactly_generated.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117411 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) empty) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_117412 (h0 : functor.add_const (functor.add_const (ring (has_add name)) pos) linarith.comp) : @rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (has_add.{0} name)) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_117413 (h0 : ring (mul_zero_class (semiring empty))) : rank_condition (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_117414 (h0 : topological_space (add_comm_monoid (finset (has_neg linarith.comp)))) : loc_path_connected_space (add_comm_monoid (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_117415 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117416 (h0 : add_monoid (normed_lattice_add_comm_group linarith.comp)) : add_monoid.fg (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_117417 (h0 : complete_lattice (normed_group (random_gen to_additive.value_type))) : is_compactly_generated (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117418 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117419 (h0 : group (has_star congr_arg_kind)) : is_cyclic (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117420 (h0 : complete_lattice (measure_theory.measure_space (semiring (semiring (semiring empty))))) : is_atomistic (measure_theory.measure_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_117421 (h0 : group (with_bot (random_gen empty))) : is_cyclic (with_bot (random_gen empty)) := sorry --non-trivial
lemma new_lemma_117422 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117423 (h0 : topological_space (measure_theory.measure_space (semiring empty))) : totally_disconnected_space (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_117424 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_117425 (h0 : ordered_comm_monoid (finset (has_to_string ennreal))) : has_exists_mul_of_le (finset (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_117426 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117427 (h0 : functor.add_const (group (comm_group linarith.comp)) Type) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_117428 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_117429 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_117430 (h0 : topological_space (add_semigroup empty)) : t1_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_117431 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117432 (h0 : complete_lattice (complete_linear_order empty)) : is_compactly_generated (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_117433 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_117434 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) congr_arg_kind) : @t0_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117435 (h0 : functor.add_const (ring (normed_group empty)) (option empty)) : @rank_condition.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_group.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_117436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117437 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_117438 (h0 : group (boolean_algebra (has_add Type))) : group.fg (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_117439 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_117440 (h4 : ring (has_nnnorm reducibility_hints)) : is_domain (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_117441 (h0 : ring (boolean_algebra (finset real))) : is_domain (boolean_algebra (finset real)) := sorry --non-trivial
lemma new_lemma_117442 (h0 : functor.add_const (topological_space auto.case_option) congr_arg_kind) : @normal_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117443 (h0 : topological_space (add_comm_monoid (add_comm_monoid Type))) : t0_space (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_117444 (h1 : complete_lattice (distrib (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117445 (h0 : group (encodable (has_top to_additive.value_type))) : group.fg (encodable (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117446 (h0 : functor.add_const (uniform_space (complete_distrib_lattice name)) (has_neg pos)) : @complete_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117447 (h1 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h1) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117448 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) num) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_117449 (h0 : topological_space (linear_ordered_comm_group linarith.comp_source)) : totally_separated_space (linear_ordered_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117450 (h0 : functor.add_const (topological_space (has_to_string ennreal)) (mul_zero_class pos)) : @totally_disconnected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117451 (h0 : ring (has_neg (boolean_algebra.core pos))) : strong_rank_condition (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_117452 (h0 : ring (has_zero name)) : rank_condition (has_zero name) := sorry --non-trivial
lemma new_lemma_117453 (h0 : topological_space (comm_group Type)) : t0_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_117454 (h0 : topological_space (normed_lattice_add_comm_group (comm_semigroup real))) : locally_compact_space (normed_lattice_add_comm_group (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_117455 (h0 : ring (linear_ordered_comm_group ennreal)) : is_principal_ideal_ring (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_117456 (h1 : ring (with_zero (has_top string_imp))) : is_domain (with_zero (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_117457 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117458 (h0 : semiring std_gen) (h1 : std_gen) : odd h1 := sorry --non-trivial
lemma new_lemma_117459 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117460 (h0 : add_monoid (mul_zero_class (canonically_ordered_comm_semiring name))) : add_monoid.fg (mul_zero_class (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_117461 (h0 : topological_space (has_nndist pos)) : regular_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_117462 (h0 : add_monoid (canonically_linear_ordered_monoid (option (option num)))) : add_monoid.fg (canonically_linear_ordered_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_117463 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117464 (h0 : functor.add_const (list pos) ennreal) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117465 (h0 : topological_space (non_assoc_semiring (option (option empty)))) : totally_separated_space (non_assoc_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_117466 (h0 : not (group (has_emptyc linarith.ineq) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_117467 (h1 : uniform_space (nondiscrete_normed_field char)) : complete_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_117468 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117469 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117470 (h0 : finset (comm_group ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117471 (h0 : topological_space (has_star congr_arg_kind)) : irreducible_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117472 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_117473 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_117474 (h0 : topological_space (has_inter (option (option (option unsigned))))) : path_connected_space (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_117475 (h0 : functor.add_const (finset (has_neg num)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117476 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_117477 (h0 : functor.add_const (topological_space pos) Type) : @t1_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_117478 (h0 : function.extfun Type (functor.add_const (finset ennreal))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_117479 (h0 : measurable_space ereal) (h2 : filter ereal -> ereal) (h3 : coe_sort (set.range h2)) : filter.is_measurably_generated (set.range_splitting h2 h3) := sorry --non-trivial
lemma new_lemma_117480 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117481 (h0 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_117482 (h0 : topological_space (has_Inf (has_add pos))) : sequential_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_117483 (h1 : has_lt std_gen) : no_max_order std_gen := sorry --non-trivial
lemma new_lemma_117484 (h0 : uniform_space (omega_complete_partial_order (option empty))) : separated_space (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_117485 (h0 : ring (has_one (semiring num))) : strong_rank_condition (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_117486 (h0 : uniform_space (ring empty)) : separated_space (ring empty) := sorry --non-trivial
lemma new_lemma_117487 (h0 : functor.add_const (topological_space (has_to_string pos)) (option pos)) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117488 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) Type) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_117489 (h1 : add_group (has_top (random_gen (has_top congr_arg_kind)))) : is_add_cyclic (has_top (random_gen (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_117490 (h0 : topological_space (has_neg (boolean_algebra pos))) : loc_path_connected_space (has_neg (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_117491 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117492 (h0 : topological_space (has_nndist (has_to_string (has_to_string pos)))) : totally_separated_space (has_nndist (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_117493 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg name)) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_117494 (h0 : ring (has_edist (normed_field char))) : strong_rank_condition (has_edist (normed_field char)) := sorry --non-trivial
lemma new_lemma_117495 (h0 : topological_space (topological_space (comm_ring linarith.ineq))) : path_connected_space (topological_space (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117496 (h0 : not (add_group (has_lt fun_info) -> false)) : @is_add_cyclic.{0} (has_lt.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_117497 (h0 : group (linear_ordered_add_comm_group (random_gen (comm_ring to_additive.value_type)))) : is_cyclic (linear_ordered_add_comm_group (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_117498 (h0 : filter (with_one (distrib_lattice linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117499 (h0 : topological_space (fintype linarith.comp_source)) : totally_disconnected_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117500 (h1 : uniform_space (with_zero linarith.ineq)) : complete_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_117501 (h0 : group (dlist (random_gen fun_info))) : is_cyclic (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_117502 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_117503 (h0 : measurable_space (uniform_space char)) (h1 : set (uniform_space char)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_117504 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_117505 (h0 : topological_space (mul_one_class std_gen)) : totally_disconnected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_117506 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_117507 (h0 : group (finset (has_add (has_Inf (has_pos_part (has_pos_part (has_Inf pos))))))) : is_simple_group (finset (has_add (has_Inf (has_pos_part (has_pos_part (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_117508 (h0 : prod (has_top (semiring congr_arg_kind)) (has_top (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_117509 (h0 : topological_space (has_neg (has_add (option Type)))) : regular_space (has_neg (has_add (option Type))) := sorry --non-trivial
lemma new_lemma_117510 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @discrete_topology.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_117511 (h0 : has_neg reducibility_hints) (h1 : finset (has_nnnorm environment.projection_info)) (h2 : has_nnnorm environment.projection_info -> measurable_space reducibility_hints) : @has_measurable_neg.{0} reducibility_hints h0 (@finset.inf.{0 0} (measurable_space.{0} reducibility_hints) (has_nnnorm.{0} environment.projection_info) (@lattice.to_semilattice_inf.{0} (measurable_space.{0} reducibility_hints) (@conditionally_complete_lattice.to_lattice.{0} (measurable_space.{0} reducibility_hints) (@complete_lattice.to_conditionally_complete_lattice.{0} (measurable_space.{0} reducibility_hints) (@measurable_space.complete_lattice.{0} reducibility_hints)))) (@bounded_order.to_order_top.{0} (measurable_space.{0} reducibility_hints) (@preorder.to_has_le.{0} (measurable_space.{0} reducibility_hints) (@partial_order.to_preorder.{0} (measurable_space.{0} reducibility_hints) (@semilattice_inf.to_partial_order.{0} (measurable_space.{0} reducibility_hints) (@lattice.to_semilattice_inf.{0} (measurable_space.{0} reducibility_hints) (@conditionally_complete_lattice.to_lattice.{0} (measurable_space.{0} reducibility_hints) (@complete_lattice.to_conditionally_complete_lattice.{0} (measurable_space.{0} reducibility_hints) (@measurable_space.complete_lattice.{0} reducibility_hints))))))) (@complete_lattice.to_bounded_order.{0} (measurable_space.{0} reducibility_hints) (@measurable_space.complete_lattice.{0} reducibility_hints))) h1 h2)  := sorry --non-trivial
lemma new_lemma_117512 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117513 (h0 : semiring (complete_distrib_lattice (has_nndist (has_nndist linarith.comp)))) : is_noetherian_ring (complete_distrib_lattice (has_nndist (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_117514 (h0 : add_group (boolean_algebra name)) : is_add_cyclic (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_117515 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (option.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_117516 (h0 : uniform_space (has_one empty)) : complete_space (has_one empty) := sorry --non-trivial
lemma new_lemma_117517 (h0 : ordered_comm_monoid (has_add Type) -> ordered_comm_monoid (has_add Type) -> Prop) : is_per (ordered_comm_monoid (has_add Type)) h0 := sorry --non-trivial
lemma new_lemma_117518 (h0 : filter (has_one num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117519 (h0 : ring (has_add (option ennreal))) : rank_condition (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_117520 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top empty)) := sorry --non-trivial
lemma new_lemma_117521 (h1 : topological_space (normed_field fun_info)) : totally_disconnected_space (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_117522 (h0 : fin has_zero.zero) : @monoid.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_117523 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117524 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_117525 (h0 : list (comm_group (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_117526 (h0 : filter (has_top (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset fun_info))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117527 (h0 : topological_space (linear_ordered_field (option empty))) : locally_compact_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_117528 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117529 (h0 : topological_space (linear_ordered_comm_ring empty)) : path_connected_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_117530 (h0 : topological_space (has_top (with_bot to_additive.value_type))) : totally_disconnected_space (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117531 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : functor.add_const.run (function.extfun_app (function.extfun_app h0 (functor.add_const Prop)) name) := sorry --non-trivial
lemma new_lemma_117532 (h0 : functor.add_const (topological_space (semigroup pos)) (has_neg Type)) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_117533 (h0 : ring (has_top (has_ssubset fun_info))) : is_domain (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_117534 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : irreducible_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117535 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) (comm_group ennreal)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) (comm_group.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_117536 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_117537 (h0 : functor.add_const (add_group (has_zero pos)) pos) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_117538 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_117539 (h1 : ring (normed_group linarith.comp_source)) : strong_rank_condition (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117540 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @loc_path_connected_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_117541 (h0 : topological_space (normed_group congr_arg_kind)) : t1_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117542 (h0 : topological_space string) : t0_space string := sorry --non-trivial
lemma new_lemma_117543 (h0 : uniform_space (has_norm (random_gen (has_top to_additive.value_type)))) : separated_space (has_norm (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_117544 (h0 : topological_space (has_one num)) : discrete_topology (has_one num) := sorry --non-trivial
lemma new_lemma_117545 (h0 : complete_lattice (has_nnnorm string_imp)) : is_compactly_generated (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_117546 (h1 : add_monoid (add_comm_semigroup std_gen)) (h2 : add_comm_semigroup std_gen) : set.finite (id (fun (h0 : string.iterator_imp), is_of_fin_add_order h2)) := sorry --non-trivial
lemma new_lemma_117547 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_top.{0} (has_nnnorm.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} (has_nnnorm.{0} (has_top.{0} (has_nnnorm.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_117548 (h0 : topological_space (add_cancel_monoid (option ennreal))) : irreducible_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_117549 (h0 : not (uniform_space (distrib (has_nnnorm linarith.comp_source)) -> false)) : @complete_space.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_117550 (h1 h2 : multiset (uniform_space reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_117551 (h0 : add_group (add_group (has_union (has_union (has_union linarith.comp))))) : is_add_cyclic (add_group (has_union (has_union (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_117552 (h0 : filter (with_bot (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117553 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : matrix.vec_empty (matrix.vec_empty (matrix.vec_tail h1 h2)) := sorry --non-trivial
lemma new_lemma_117554 (h0 : topological_space (semi_normed_ring (has_compl fun_info))) : totally_disconnected_space (semi_normed_ring (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_117555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_117556 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_117557 (h0 : topological_space (has_to_string (ring pos))) : irreducible_space (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_117558 (h0 : finset (option (option congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117559 (h2 : complete_lattice (fintype (comm_ring (comm_ring (has_inv linarith.ineq))))) : complete_lattice.is_Sup_finite_compact (fintype (comm_ring (comm_ring (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_117560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_ssubset.{0} (has_norm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} (has_norm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_117561 (h0 : functor.comp topological_space add_comm_monoid name) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_117562 (h0 : topological_space (ordered_comm_ring (ring (has_neg (ring (ring (has_neg (has_Inf pos)))))))) : t0_space (ordered_comm_ring (ring (has_neg (ring (ring (has_neg (has_Inf pos))))))) := sorry --non-trivial
lemma new_lemma_117563 (h0 : topological_space (semigroup (has_Inf pos))) : totally_separated_space (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_117564 (h0 : not (add_group (encodable fun_info) -> false)) : @is_add_cyclic.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_117565 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_117566 (h0 : group (semigroup (cancel_monoid num))) : group.fg (semigroup (cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_117567 (h0 : functor.comp topological_space semigroup Type) : @irreducible_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_117568 (h0 : functor.comp uniform_space complete_distrib_lattice unsigned) : @separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} uniform_space.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_117569 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @normalizer_condition.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_117570 (h0 : topological_space (ring (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind))))) : normal_space (ring (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_117571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117572 (h0 : topological_space (has_to_string (has_add pos))) : normal_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_117573 (h0 : functor.add_const (filter (has_to_string unsigned)) (has_neg_part Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117574 (h0 : topological_space (canonically_linear_ordered_monoid name)) : t0_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_117575 (h0 : uniform_space (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned)))))) : separated_space (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_117576 (h0 : group (simple_graph (has_add (has_Inf (has_add (has_nndist linarith.comp)))))) : is_simple_group (simple_graph (has_add (has_Inf (has_add (has_nndist linarith.comp))))) := sorry --non-trivial
lemma new_lemma_117577 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_117578 (h0 : filter (normed_group (denumerable (comm_ring linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117579 (h0 : ring (ring ennreal)) : is_principal_ideal_ring (ring ennreal) := sorry --non-trivial
lemma new_lemma_117580 (h0 : function.extfun Type topological_space) : @normal_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_117581 (h0 : list (normed_comm_ring Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117582 (h0 : ring (uniform_space (random_gen char))) : rank_condition (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_117583 (h0 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @normalizer_condition.{0} num (@finset.pi.empty.{1 0} Type group.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_117584 (h0 : list (has_top (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117585 (h0 : filter (has_union (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117586 (h0 : topological_space (has_to_string (has_to_string pos))) : discrete_topology (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_117587 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_117588 (h0 : functor.add_const (finset (has_star congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117589 (h0 : not (complete_lattice (complete_linear_order num) -> false)) : @is_atomistic.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_117590 (h1 : ring (has_inv to_additive.value_type)) : rank_condition (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117591 (h0 h1 : multiset (nondiscrete_normed_field (has_inf char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_117592 (h1 : complete_lattice (measurable_space (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117593 (h0 : functor.add_const (finset (ordered_comm_ring pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117594 (h0 : topological_space (boolean_algebra.core (cancel_monoid (has_add Type)))) : topological_space.separable_space (boolean_algebra.core (cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_117595 (h0 : topological_space (normed_comm_ring (comm_group name))) : topological_space.separable_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_117596 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup empty)) unsigned) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117597 (h0 : has_coe (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) Prop) (h1 : add_comm_semigroup (add_comm_semigroup string.iterator_imp)) : @coe_b.{1 1} (add_comm_semigroup.{0} (add_comm_semigroup.{0} string.iterator_imp)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_117598 (h0 : function.extfun (Type 1) (functor.comp group add_comm_monoid)) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} add_comm_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} add_comm_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_117599 (h0 : topological_space (finset (semigroup (boolean_algebra Type)))) : totally_separated_space (finset (semigroup (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_117600 (h1 : ring (add_left_cancel_monoid to_additive.value_type)) : strong_rank_condition (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117601 (h0 : ring (encodable (has_ssubset string_imp))) : strong_rank_condition (encodable (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_117602 (h0 : uniform_space (left_cancel_semigroup unsigned)) : complete_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_117603 (h0 : list (comm_ring (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117604 (h0 : group (has_compl string_imp)) : group.fg (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_117605 (h0 : uniform_space (normed_group (has_top (random_gen fun_info)))) : complete_space (normed_group (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_117606 (h0 : not (group (with_one fun_info) -> false)) : @group.fg.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_117607 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) (mul_one_class (ring linarith.comp))) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) (mul_one_class.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_117608 (h0 : ordered_comm_monoid (canonically_ordered_monoid linarith.comp)) : has_exists_mul_of_le (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_117609 (h0 : topological_space (ring (has_neg (has_add linarith.comp)))) : irreducible_space (ring (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_117610 (h0 : topological_space (has_norm (has_inv (random_gen (has_inv fun_info))))) : totally_separated_space (has_norm (has_inv (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_117611 (h0 : functor.add_const (finset (has_add pos)) (finset (finset linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117612 (h0 : not (ring (has_div char) -> false)) : @is_domain.{0} (has_div.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_117613 (h0 : topological_space (group_with_zero num)) : preconnected_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_117614 (h0 : topological_space (with_one linarith.comp_source)) : path_connected_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_117616 (h0 : semiring (cancel_monoid num)) : is_noetherian_ring (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_117617 (h0 : function.extfun nat fin) : @complete_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_117618 (h1 : topological_space (semiring linarith.ineq)) : totally_separated_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_117619 (h0 : topological_space (has_add (normed_comm_ring (has_neg name)))) : topological_space.separable_space (has_add (normed_comm_ring (has_neg name))) := sorry --non-trivial
lemma new_lemma_117620 (h0 : uniform_space (has_nndist (ring (comm_group Type)))) : complete_space (has_nndist (ring (comm_group Type))) := sorry --non-trivial
lemma new_lemma_117621 (h0 : not (topological_space (has_ssubset fun_info) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_117622 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_117623 (h0 : add_monoid (with_bot congr_arg_kind)) : add_monoid.fg (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117624 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @sequential_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117625 (h1 : group (fintype string_imp)) : group.fg (fintype string_imp) := sorry --non-trivial
lemma new_lemma_117626 (h0 : list (plift (add_left_cancel_semigroup empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_117627 (h0 : complete_lattice (random_gen (has_norm (has_norm empty)))) : is_atomistic (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_117628 (h0 : function.extfun Type group) : @is_cyclic.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type group.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_117629 (h0 : finset (has_neg_part (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_117631 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117632 (h0 : function.extfun nat fin) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_117633 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_117634 (h0 : group (normed_field (has_nnnorm (random_gen reducibility_hints)))) : is_cyclic (normed_field (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_117635 (h0 : group (distrib_lattice (has_top (has_top (has_top fun_info))))) : group.fg (distrib_lattice (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_117636 (h0 : topological_space (comm_group (has_neg_part (has_neg_part (has_to_string (has_to_string pos)))))) : preconnected_space (comm_group (has_neg_part (has_neg_part (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_117637 (h0 : functor.add_const (finset (finset pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117638 (h0 : topological_space (has_neg_part (has_add (has_add (has_add (has_add unsigned)))))) : preirreducible_space (has_neg_part (has_add (has_add (has_add (has_add unsigned))))) := sorry --non-trivial
lemma new_lemma_117639 (h0 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @t0_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_117640 (h0 : functor.add_const (monoid (has_zero linarith.comp)) (has_neg (finset pos))) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} linarith.comp)) (has_neg.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_117641 (h0 : monoid (has_top num)) : monoid.fg (has_top num) := sorry --non-trivial
lemma new_lemma_117642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117643 (h0 : set (add_comm_semigroup linarith.ineq -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_117644 (h0 : ring (has_neg_part ennreal)) : is_principal_ideal_ring (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_117645 (h0 : functor.comp group has_neg unsigned) : @is_simple_group.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_117646 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_117647 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117648 (h0 : topological_space (has_to_string (finset (mul_one_class (finset linarith.comp))))) : locally_compact_space (has_to_string (finset (mul_one_class (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_117649 (h0 : complete_lattice environment.implicit_infer_kind) : complete_lattice.is_Sup_finite_compact environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_117650 (h0 : topological_space (complete_distrib_lattice (has_Inf name))) : normal_space (complete_distrib_lattice (has_Inf name)) := sorry --non-trivial
lemma new_lemma_117651 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_117652 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_117653 (h0 : topological_space (ordered_comm_monoid (ring name))) : sequential_space (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_117654 (h0 : group (comm_group (has_add (has_add (has_add pos))))) : group.fg (comm_group (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_117655 (h0 : measurable_space (denumerable (random_gen (random_gen to_additive.value_type)))) (h1 : measure_theory.measure (denumerable (random_gen (random_gen to_additive.value_type)))) : measure_theory.sigma_finite h1 := sorry --non-trivial
lemma new_lemma_117656 (h0 : complete_lattice (ordered_comm_group unsigned)) : is_atomistic (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_117657 (h0 : functor.add_const (group (has_zero real)) pos) : @is_simple_group.{0} (has_zero.{0} real) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_117658 (h0 : functor.add_const (topological_space pos) linarith.comp) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117659 (h0 : topological_space (has_bot (has_Inf linarith.comp))) : locally_compact_space (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_117660 (h0 : topological_space (ring (has_add Type))) : regular_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_117661 (h0 : topological_space (semigroup (finset (finset (finset Type))))) : locally_compact_space (semigroup (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_117662 (h0 : add_group (normed_lattice_add_comm_group linarith.comp)) : is_add_cyclic (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_117663 (h0 : uniform_space (measurable_space (random_gen string_imp))) : complete_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_117664 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117665 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg (has_neg name))))) : preirreducible_space (ordered_comm_ring (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_117666 (h0 : filter (id (has_top num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117667 (h0 : functor.add_const (function.extfun Type finset) empty) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_117668 (h0 : topological_space (has_union (has_union num))) : irreducible_space (has_union (has_union num)) := sorry --non-trivial
lemma new_lemma_117669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117670 (h0 : functor.add_const (add_monoid (has_neg Type)) (has_Inf pos)) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117671 (h0 : functor.add_const (uniform_space (semiring num)) congr_arg_kind) : @complete_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117672 (h0 : functor.add_const (function.extfun Type finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_117673 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_117674 (h0 : topological_space (canonically_ordered_comm_semiring (option (option (has_neg_part ennreal))))) : t0_space (canonically_ordered_comm_semiring (option (option (has_neg_part ennreal)))) := sorry --non-trivial
lemma new_lemma_117675 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) pos) : @t0_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_117676 (h0 : ring (has_add (boolean_algebra.core environment.implicit_infer_kind))) : is_domain (has_add (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117677 (h0 : topological_space (filter (semiring (semiring empty)))) : discrete_topology (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_117678 (h0 : functor.add_const (complete_lattice (has_dist empty)) empty) : @is_compactly_generated.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_117679 (h0 : topological_space (has_Inf (has_neg (has_neg (has_neg name))))) : discrete_topology (has_Inf (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_117680 (h0 : not (topological_space (comm_ring char) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_117681 (h0 : uniform_space (simple_graph (option unsigned))) : complete_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_117682 (h0 : topological_space (add_cancel_monoid (finset Type))) : totally_separated_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_117683 (h0 : finset (has_to_string (has_pos_part (has_pos_part linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117684 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117685 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp_source))) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117686 (h0 : ring (has_neg_part Type)) : strong_rank_condition (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_117687 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_117688 (h0 : functor.add_const (topological_space (has_zero Type)) (finset (ring environment.implicit_infer_kind))) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (finset.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_117689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_117690 (h0 : topological_space (add_cancel_monoid (option empty))) : normal_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_117691 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @preirreducible_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117692 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117693 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_117694 (h0 : functor.add_const (topological_space (mul_zero_class pos)) ennreal) : @locally_compact_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_117695 (h1 : topological_space (has_ssubset to_additive.value_type)) : totally_disconnected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117696 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf Type)) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_117697 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} (has_add.{0} (add_comm_monoid.{0} (has_add.{0} (add_comm_monoid.{0} name))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} (has_add.{0} (add_comm_monoid.{0} (has_add.{0} (add_comm_monoid.{0} name))))))  := sorry --non-trivial
lemma new_lemma_117698 (h0 : functor.comp list has_nndist name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_117699 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} (add_left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (add_left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117700 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @t1_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_117701 (h0 : not (ring (measurable_space.dynkin_system congr_arg_kind) -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_117702 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117703 (h0 : functor.add_const (add_monoid (ordered_comm_monoid linarith.comp)) (has_Inf linarith.comp)) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117704 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_117705 (h0 : monoid (semigroup (has_pos_part (has_pos_part Type)))) : monoid.fg (semigroup (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_117706 (h0 : set (enat -> nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_117707 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117708 (h0 : topological_space (preorder (semiring (semiring (semiring num))))) : path_connected_space (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_117709 (h0 : functor.add_const (add_monoid (boolean_algebra real)) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_117710 (h0 : not (add_group (with_one linarith.comp_source) -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_117711 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @path_connected_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_117712 (h0 : add_group (encodable (has_nnnorm to_additive.value_type))) : is_add_cyclic (encodable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117713 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117714 (h0 : filter (dlist linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117715 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @totally_disconnected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_117716 (h2 : complete_lattice (denumerable linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117717 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree num)) num) : @unique_factorization_monoid.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_117718 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117719 (h0 : not (group (add_group empty) -> false)) : @normalizer_condition.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_117720 (h0 : has_le (add_comm_semigroup fun_info)) (h2 : add_comm_semigroup fun_info) : is_bot h2 := sorry --non-trivial
lemma new_lemma_117721 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117722 (h0 : functor.add_const (semiring (add_comm_monoid unsigned)) pos) : @is_noetherian_ring.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_117723 (h0 : functor.add_const (group (ring name)) pos) : @is_simple_group.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_117724 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_one empty)) := sorry --non-trivial
lemma new_lemma_117725 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group unsigned))) : @group.fg.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117726 : infinite char := sorry --non-trivial
lemma new_lemma_117727 (h1 : complete_lattice (metric_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117728 (h0 : list (ordered_comm_ring pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117729 (h0 : finset (filter unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117730 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top (has_norm (has_norm num)))))) : irreducible_space (linear_ordered_add_comm_group (has_top (has_top (has_norm (has_norm num))))) := sorry --non-trivial
lemma new_lemma_117731 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_117732 (h0 : semiring (nondiscrete_normed_field ereal)) (h1 : ideal (nondiscrete_normed_field ereal)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_117733 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_117734 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_117735 (h0 : topological_space (finset (cancel_monoid (add_comm_monoid (has_add pos))))) : normal_space (finset (cancel_monoid (add_comm_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_117736 (h0 : functor.add_const (topological_space char) congr_arg_kind) : @path_connected_space.{0} char (@functor.add_const.run.{0 0} (topological_space.{0} char) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_117737 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_117738 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) pos) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_117739 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_117740 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117741 (h0 : complete_lattice (mul_zero_class (boolean_algebra.core (has_to_string Type)))) : is_compactly_generated (mul_zero_class (boolean_algebra.core (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_117742 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) num) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_117743 (h0 : functor.add_const Prop complex) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_117744 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_117745 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} znum (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) znum)  := sorry --non-trivial
lemma new_lemma_117746 (h0 : list (add_left_cancel_semigroup congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_117747 (h0 : group (linear_ordered_add_comm_group (with_bot to_additive.value_type))) : normalizer_condition (linear_ordered_add_comm_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117748 (h3 : topological_space linarith.comp_source) : locally_compact_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_117749 (h0 : cancel_comm_monoid_with_zero char) (h1 : ring (gcd_monoid char)) : strong_rank_condition (gcd_monoid char) := sorry --non-trivial
lemma new_lemma_117750 (h0 : functor.add_const (group (boolean_algebra.core linarith.comp)) (finset Type)) : @group.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_117751 (h0 : group (add_group (semiring (has_norm unsigned)))) : normalizer_condition (add_group (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_117752 (h0 : functor.add_const (semiring (canonically_ordered_monoid name)) real) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_117753 (h0 : topological_space (has_union (id linarith.comp))) : preirreducible_space (has_union (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_117754 (h0 : nat) (h1 : topological_space (fin h0)) : locally_compact_space (fin h0) := sorry --non-trivial
lemma new_lemma_117755 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) Type) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_117756 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_right_cancel_monoid empty)) (option unsigned)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_117757 (h0 : semiring (linear_ordered_semiring (semiring (semiring (semiring empty))))) : is_noetherian_ring (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_117758 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_117759 (h0 : add_group (normed_group (semiring to_additive.value_type))) : is_add_cyclic (normed_group (semiring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117760 (h0 : uniform_space (cancel_monoid (has_neg linarith.comp))) : complete_space (cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_117761 (h0 : complete_lattice (has_Sup (semiring empty))) : is_compactly_generated (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_117762 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_117763 (h0 : topological_space (finset (option empty))) : totally_disconnected_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_117764 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_117765 (h0 : functor.add_const (topological_space (finset name)) name) : @totally_separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_117766 (h0 : topological_space (boolean_algebra.core (option (option (option (option unsigned)))))) : t1_space (boolean_algebra.core (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_117767 (h0 : add_group (normed_group (has_norm to_additive.value_type))) : is_add_cyclic (normed_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_117768 (h0 : topological_space (denumerable to_additive.value_type)) : path_connected_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117769 (h0 : group (has_add (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (has_add (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_117770 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_117771 (h0 : group (semigroup (ring pos))) : is_cyclic (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_117772 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : topological_space.separable_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_117773 (h0 : uniform_space (has_add (option pos))) : complete_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_117774 (h0 : add_group (id (random_gen linarith.ineq))) : is_add_cyclic (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117775 (h0 : ordered_comm_monoid (boolean_algebra.core (ring name))) : has_exists_mul_of_le (boolean_algebra.core (ring name)) := sorry --non-trivial
lemma new_lemma_117776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117777 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_pos_part (has_add linarith.comp)))) : has_exists_mul_of_le (complete_distrib_lattice (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_117778 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @path_connected_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117779 (h0 : topological_space (comm_group (option (has_add (has_neg_part unsigned))))) : normal_space (comm_group (option (has_add (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_117780 (h0 : topological_space (add_cancel_monoid (has_add name))) : topological_space.separable_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_117781 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117782 (h0 : not (topological_space (has_div string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (has_div.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_117783 (h0 : topological_space (has_neg (option (option pos)))) : t1_space (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_117784 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117785 (h0 : uniform_space (preorder (option unsigned))) : separated_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_117786 (h0 : group (comm_group ennreal)) : group.fg (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_117787 (h0 : topological_space (has_norm (has_norm congr_arg_kind))) : totally_separated_space (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117788 (h0 : ring (has_edist num)) : is_principal_ideal_ring (has_edist num) := sorry --non-trivial
lemma new_lemma_117789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117791 (h0 : topological_space (semigroup linarith.comp)) : t0_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_117792 (h0 : functor.add_const (function.extfun Type ring) (has_neg pos)) : @is_domain.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_neg.{0} pos) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_117793 (h0 : ring (id congr_arg_kind)) : strong_rank_condition (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117794 (h0 : ring (has_zero (has_pos_part pos))) : rank_condition (has_zero (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_117795 (h0 : function.extfun Type (functor.comp filter has_nndist)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_117796 (h2 : complete_lattice (has_append char)) : complete_lattice.is_Sup_finite_compact (has_append char) := sorry --non-trivial
lemma new_lemma_117797 (h0 : functor.add_const (group pos) unsigned) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_117798 (h0 : topological_space (has_inter (option (option ennreal)))) : discrete_topology (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_117799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_117800 (h1 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h1) num)  := sorry --non-trivial
lemma new_lemma_117801 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117802 (h0 : functor.add_const (topological_space auto.case_option) empty) : @locally_compact_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_117803 (h0 : ring (comm_ring (has_ssubset (random_gen (has_ssubset fun_info))))) : strong_rank_condition (comm_ring (has_ssubset (random_gen (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_117804 (h0 : topological_space (boolean_algebra (sub_neg_monoid (has_Inf (has_Inf name))))) : locally_compact_space (boolean_algebra (sub_neg_monoid (has_Inf (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_117805 (h0 : function.extfun nat fin) : @is_atomistic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_117806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_117807 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_117808 (h1 : topological_space (uniform_space linarith.comp_source)) : totally_disconnected_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117809 (h0 : functor.add_const (topological_space (semigroup ennreal)) Type) : @sequential_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_117810 (h0 : ring (finset Type)) : rank_condition (finset Type) := sorry --non-trivial
lemma new_lemma_117811 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (option congr_arg_kind))) : unique_factorization_monoid (normed_comm_ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117812 (h1 : topological_space (has_norm linarith.comp_source)) : irreducible_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117813 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring (has_to_string (has_to_string unsigned)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_117814 (h0 : ring (multiplicative (conditionally_complete_lattice char))) : is_domain (multiplicative (conditionally_complete_lattice char)) := sorry --non-trivial
lemma new_lemma_117815 (h0 : functor.comp topological_space has_add Type) : @t0_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_117816 (h0 : ring (denumerable (denumerable char))) : is_domain (denumerable (denumerable char)) := sorry --non-trivial
lemma new_lemma_117817 (h0 : filter (fintype (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_117818 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add environment.implicit_infer_kind))) : archimedean (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_117819 (h1 : set (normed_field linarith.ineq)) (h2 : normed_field linarith.ineq) : set.compl h1 h2 := sorry --non-trivial
lemma new_lemma_117820 (h0 : not (topological_space (ordered_comm_ring linarith.ineq) -> false)) : @t0_space.{0} (ordered_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_117821 (h0 : group (complete_distrib_lattice (has_neg (add_comm_monoid name)))) : is_simple_group (complete_distrib_lattice (has_neg (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_117822 (h0 : topological_space (has_inner (option empty) unsigned)) : topological_space.separable_space (has_inner (option empty) unsigned) := sorry --non-trivial
lemma new_lemma_117823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_117824 (h0 : uniform_space (has_ssubset (mul_one_class char))) : complete_space (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_117825 (h0 : ring (option ennreal) -> ring (option ennreal) -> Prop) : is_total_preorder (ring (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_117826 (h0 : functor.add_const (topological_space (has_nndist Type)) (has_pos_part pos)) : @topological_space.separable_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117827 (h0 : complete_lattice (monoid (linear_ordered_field unsigned))) : is_atomistic (monoid (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_117828 (h1 : complete_lattice (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) : is_compactly_generated (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_117829 (h0 : add_monoid (has_zero (has_pos_part linarith.comp))) : add_monoid.fg (has_zero (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_117830 (h0 : ring (add_semigroup (option empty))) : rank_condition (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_117831 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117832 (h0 : functor.add_const (filter (has_to_string pos)) (has_nndist pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117833 (h0 : monoid (as_linear_order (option empty))) : monoid.fg (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_117834 (h0 : topological_space (simple_graph linarith.comp)) : t1_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_117835 (h0 : function.extfun Type (functor.add_const (semiring (semigroup empty)))) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_117836 (h0 : measurable_space (nondiscrete_normed_field enat)) (h1 : set (nondiscrete_normed_field enat)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_117837 (h0 : complete_lattice (semiring (has_top empty))) : is_compactly_generated (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_117838 (h0 : topological_space (normed_group (has_top (has_inv linarith.comp_source)))) : totally_separated_space (normed_group (has_top (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_117839 (h0 : ring (measurable_space (semiring congr_arg_kind))) : rank_condition (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117840 (h0 : ordered_comm_monoid (as_linear_order name)) : has_exists_mul_of_le (as_linear_order name) := sorry --non-trivial
lemma new_lemma_117841 (h0 : semiring (ring (has_pos_part (has_pos_part pos)))) : is_noetherian_ring (ring (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_117842 (h0 : finset (has_Inf (has_Inf real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117843 (h0 : functor.comp ring has_nndist Type) : @is_domain.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_117844 (h0 : topological_space (free_add_monoid congr_arg_kind)) : irreducible_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_117845 (h0 : group (semigroup (has_add linarith.comp))) : group.fg (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_117846 (h0 : topological_space (has_add (has_Inf linarith.comp))) : preirreducible_space (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_117847 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117848 (h0 : has_lt (has_ssubset (add_comm_semigroup char))) : no_max_order (has_ssubset (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_117849 (h0 : functor.add_const (finset (generalized_boolean_algebra linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117850 (h0 : function.extfun Type (functor.add_const (ring znum))) : @rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_117851 (h3 : topological_space string.iterator_imp) : totally_disconnected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_117852 (h0 : uniform_space (normed_linear_ordered_group (option empty))) : separated_space (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_117853 (h0 : ring (has_nndist (option (option (option ennreal))))) : rank_condition (has_nndist (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_117854 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_117855 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) name) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_117856 (h0 : function.extfun Type (prod (with_one empty))) : id_rel (function.extfun_app h0 (with_one empty)) := sorry --non-trivial
lemma new_lemma_117857 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117858 (h1 : ring (denumerable (with_bot (random_gen linarith.ineq)))) : is_domain (denumerable (with_bot (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_117859 (h0 : monoid (comm_monoid empty)) : monoid.fg (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_117860 (h0 : topological_space (has_neg (finset (finset (finset (finset pos)))))) : path_connected_space (has_neg (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_117861 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (fintype.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (fintype.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_117862 (h0 : topological_space (semi_normed_comm_ring enat)) (h1 : preorder (semi_normed_comm_ring enat)) : order_closed_topology (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_117863 (h0 : ring (has_inv (has_norm fun_info))) : rank_condition (has_inv (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_117864 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : totally_separated_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_117865 (h0 : not (cancel_comm_monoid_with_zero (partial_order congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_117866 (h0 : group (has_nndist (has_neg_part Type))) : is_simple_group (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_117867 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117868 (h2 : group (distrib char)) : is_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_117869 (h0 : functor.add_const (prod (semigroup empty) (semigroup empty)) (semiring (semiring empty))) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117870 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_117871 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) empty) : @is_add_cyclic.{0} nnreal (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) empty h0) add_group.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_117872 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117873 (h0 : fin has_zero.zero) : @monoid.fg.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_117874 (h0 : topological_space (has_to_string (semigroup (has_neg (has_neg (ring (ring (semigroup linarith.comp)))))))) : t1_space (has_to_string (semigroup (has_neg (has_neg (ring (ring (semigroup linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_117875 (h0 : topological_space (has_one (semiring (semiring (semiring unsigned))))) : discrete_topology (has_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_117876 (h0 : group (complete_distrib_lattice (option unsigned))) : is_cyclic (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_117877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_117878 (h0 : topological_space (has_star (semiring unsigned))) : preirreducible_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_117879 (h1 : not (topological_space (semi_normed_ring linarith.comp_source) -> false)) : @t0_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_117880 (h0 : functor.add_const (ring (has_to_string Type)) (normed_comm_ring linarith.comp)) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117881 (h0 : not (uniform_space linarith.comp -> false)) : @complete_space.{0} linarith.comp (@classical.by_contradiction'.{1} (uniform_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_117882 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_117883 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117884 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117885 (h0 : topological_space (has_inter ennreal)) : t1_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_117886 (h0 : topological_space (monoid_with_zero (option pos))) : t0_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_117887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_117888 (h1 : uniform_space (comm_ring (denumerable char))) : complete_space (comm_ring (denumerable char)) := sorry --non-trivial
lemma new_lemma_117889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_117890 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @t0_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_117891 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117892 (h0 : ordered_comm_monoid (generalized_boolean_algebra (canonically_ordered_monoid linarith.comp))) : has_exists_mul_of_le (generalized_boolean_algebra (canonically_ordered_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_117893 (h0 : group (complete_distrib_lattice (has_zero ennreal))) : is_cyclic (complete_distrib_lattice (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_117894 (h0 : complete_lattice (semi_normed_ring (has_lt (has_nnnorm (has_nnnorm char))))) : is_compactly_generated (semi_normed_ring (has_lt (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_117895 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} auto.case_option) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} auto.case_option))  := sorry --non-trivial
lemma new_lemma_117896 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_117897 (h0 : topological_space (has_div string_imp)) : t0_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_117898 (h0 : topological_space (has_bot (has_neg name))) : locally_compact_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_117899 (h0 : topological_space (has_top (random_gen (random_gen (random_gen fun_info))))) : t0_space (has_top (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_117900 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_117901 (h0 : group (measurable_space (random_gen linarith.ineq))) : normalizer_condition (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_117902 (h0 : set (ereal -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_117903 (h0 : not (filter (with_one num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_117904 (h0 : prod (has_top (semiring (semiring unsigned))) (has_top (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_117905 (h0 : ordered_comm_monoid (has_neg (has_pos_part (has_Inf pos)))) : has_exists_mul_of_le (has_neg (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_117906 (h1 : topological_space (has_compl (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (has_compl (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_117907 (h0 : group (comm_group (option (option (has_add pos))))) : group.fg (comm_group (option (option (has_add pos)))) := sorry --non-trivial
lemma new_lemma_117908 (h0 : measurable_space (non_unital_non_assoc_semiring char)) (h1 : filter (non_unital_non_assoc_semiring char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_117909 (h0 : monoid (has_union (semiring (semiring congr_arg_kind)))) : monoid.fg (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_117910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_117911 (h0 : not (topological_space (semi_normed_ring std_gen) -> false)) : @t0_space.{0} (semi_normed_ring.{0} std_gen) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} std_gen)) h0)  := sorry --non-trivial
lemma new_lemma_117912 (h0 : group (has_to_string name)) : is_cyclic (has_to_string name) := sorry --non-trivial
lemma new_lemma_117913 (h0 : topological_space (has_nndist (finset pos))) : discrete_topology (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_117914 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @discrete_topology.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_117915 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_117916 (h1 : complete_lattice (has_nnnorm string_imp)) : complete_lattice.is_Sup_finite_compact (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_117917 (h0 : complete_lattice (measurable_space fun_info)) : is_atomistic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_117918 (h2 : topological_space (has_append char)) : t0_space (has_append char) := sorry --non-trivial
lemma new_lemma_117919 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : sequential_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_117920 (h1 : ring (distrib (metric_space (metric_space to_additive.value_type)))) : rank_condition (distrib (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_117921 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117922 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117923 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117924 (h0 : uniform_space name) : separated_space name := sorry --non-trivial
lemma new_lemma_117925 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117926 (h0 : ring (distrib_lattice (random_gen fun_info))) : rank_condition (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_117927 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} (option.{0} (ring.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} (option.{0} (ring.{0} pos))))  := sorry --non-trivial
lemma new_lemma_117928 (h0 : ring (has_zero fun_info)) : strong_rank_condition (has_zero fun_info) := sorry --non-trivial
lemma new_lemma_117929 (h0 : functor.comp group semigroup name) : @is_cyclic.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_117930 (h0 : topological_space (add_group linarith.comp)) : t0_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_117931 (h0 : function.extfun Type group) : @group.fg.{0} znum (@function.extfun_app.{2 1} Type group.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_117932 (h0 : functor.add_const (uniform_space (comm_group ennreal)) environment.implicit_infer_kind) : @complete_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_117933 (h0 : group (canonically_ordered_monoid real)) : group.fg (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_117934 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117935 (h0 : group (measurable_space (has_norm linarith.comp_source))) : group.fg (measurable_space (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_117936 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_117937 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_117938 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @preirreducible_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_117939 (h0 : topological_space (has_add (has_Inf (has_Inf linarith.comp)))) : topological_space.separable_space (has_add (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_117940 (h0 : group (semigroup linarith.comp)) : normalizer_condition (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_117941 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_117942 (h0 : functor.add_const (list (has_nndist name)) (has_to_string pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_117943 (h0 : complete_lattice (normed_group (random_gen (random_gen num)))) : is_compactly_generated (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_117944 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_117945 (h0 : complete_lattice (has_norm (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_117946 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @t1_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_117947 (h0 : group (sub_neg_monoid (sub_neg_monoid real))) : group.fg (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_117948 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) Type) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_117949 (h2 : complete_lattice (uniform_space linarith.comp_source)) : is_compactly_generated (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117950 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} real (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) real)  := sorry --non-trivial
lemma new_lemma_117951 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_117952 (h0 : add_group (has_nnnorm (nondiscrete_normed_field enat))) : is_add_cyclic (has_nnnorm (nondiscrete_normed_field enat)) := sorry --non-trivial
lemma new_lemma_117953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117954 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero char) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_117955 (h0 : topological_space (boolean_algebra (ring (has_to_string Type)))) : loc_path_connected_space (boolean_algebra (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_117956 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_117957 (h0 : filter (ring (option (option unsigned)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_117958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_117959 (h0 : topological_space (has_norm linarith.comp_source)) : locally_compact_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_117960 (h0 : finset (complete_distrib_lattice (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_117961 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : path_connected_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_117962 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_117963 (h0 : functor.add_const (group (normed_comm_ring unsigned)) pos) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_117964 (h0 : ring (has_norm (has_norm (has_norm num)))) : is_domain (has_norm (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_117965 (h0 : functor.add_const (function.extfun Type uniform_space) (finset (finset (finset linarith.comp)))) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} (finset.{0} (finset.{0} linarith.comp))) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117966 (h0 : functor.add_const (group (normed_comm_ring Type)) (finset (has_nndist environment.implicit_infer_kind))) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) (finset.{0} (has_nndist.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_117967 (h1 : ring (distrib (mul_one_class (has_ssubset (has_nnnorm reducibility_hints))))) : is_domain (distrib (mul_one_class (has_ssubset (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_117968 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_117969 (h0 : functor.add_const (function.extfun Type filter) (finset pos)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_117970 (h1 : ring (distrib (random_gen char))) : rank_condition (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_117971 (h0 : topological_space (generalized_boolean_algebra pos)) : path_connected_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_117972 (h0 : add_group (has_pos_part (has_nndist (ring Type)))) : is_add_cyclic (has_pos_part (has_nndist (ring Type))) := sorry --non-trivial
lemma new_lemma_117973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_117974 (h0 : monoid real) : monoid.fg real := sorry --non-trivial
lemma new_lemma_117975 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_117976 (h0 : group (normed_comm_ring (option ennreal))) : group.fg (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_117977 (h0 : ring (has_neg (has_add (has_pos_part linarith.comp)))) : is_principal_ideal_ring (has_neg (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_117978 (h0 : function.extfun Type topological_space) : @normal_space.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_117979 (h0 : uniform_space (boolean_algebra (mul_one_class linarith.comp))) : separated_space (boolean_algebra (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_117980 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_117981 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra pos)) (has_add pos)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_117982 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_117983 (h0 : not (list (with_bot linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_117984 (h0 : topological_space (with_bot (random_gen fun_info))) : totally_disconnected_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_117985 (h2 : ring (random_gen to_additive.value_type)) : strong_rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_117986 (h0 : uniform_space (fintype linarith.ineq)) : complete_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_117987 (h0 : not (monoid (has_union unsigned) -> false)) : @monoid.fg.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_117988 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : locally_compact_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_117989 (h0 : add_monoid (ordered_comm_monoid (boolean_algebra.core pos))) : add_monoid.fg (ordered_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_117990 (h0 : nat) (h1 h2 : fin h0) : fin.lt (id h1) (id (id (id h2))) := sorry --non-trivial
lemma new_lemma_117991 (h0 : ordered_comm_monoid (ordered_comm_ring (has_pos_part pos))) : has_exists_mul_of_le (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_117992 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_117993 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_117994 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_117995 (h0 : Prop) (h1 : not h0) (h2 : h0) : matrix.vec_empty (not.elim h1 h2) := sorry --trivial
lemma new_lemma_117996 (h0 : ring (add_comm_monoid (ordered_comm_monoid linarith.comp))) : is_domain (add_comm_monoid (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_117997 (h0 : topological_space (uniform_space (random_gen (random_gen (comm_ring string_imp))))) : t0_space (uniform_space (random_gen (random_gen (comm_ring string_imp)))) := sorry --non-trivial
lemma new_lemma_117998 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117999 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_118000 (h0 : fun_info -> fun_info -> Prop) : is_partial_order fun_info h0 := sorry --non-trivial
lemma new_lemma_118001 (h0 : add_group (add_comm_monoid empty)) : is_add_cyclic (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_118002 (h0 : not (topological_space (option empty) -> false)) : @preirreducible_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_118003 (h0 : functor.add_const (list (omega_complete_partial_order unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118004 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_118005 (h0 : filter (ring (normed_comm_ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_118006 (h0 : complete_lattice (with_one (has_norm congr_arg_kind))) : is_atomistic (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118007 (h0 : list (has_to_string (has_neg_part (has_add unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118008 (h0 : finset (has_to_string name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118009 (h0 : ordered_add_comm_monoid (has_neg (has_add linarith.comp))) : archimedean (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_118010 (h0 : topological_space (pseudo_metric_space unsigned)) : preconnected_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_118011 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118012 (h0 : topological_space (semigroup (has_Inf pos))) : totally_disconnected_space (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_118013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_118014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118015 (h0 : ordered_comm_monoid (ordered_comm_ring (ring linarith.comp))) : has_exists_mul_of_le (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_118016 (h1 : ring (has_append (random_gen (random_gen char)))) : is_domain (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_118017 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_118018 (h0 : functor.add_const (add_group (has_to_string pos)) unsigned) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118019 (h0 : functor.add_const (add_group (has_zero pos)) (ring (boolean_algebra linarith.comp))) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} pos)) (ring.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_118020 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (boolean_algebra pos)) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_118021 (h0 : ring (has_add real)) : strong_rank_condition (has_add real) := sorry --non-trivial
lemma new_lemma_118022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_118023 (h0 : topological_space (simple_graph (option (option congr_arg_kind)))) : path_connected_space (simple_graph (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_118024 (h0 : topological_space (random_gen (random_gen (has_top linarith.comp_source)))) : path_connected_space (random_gen (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_118025 (h0 : group (complete_linear_order (semiring empty))) : normalizer_condition (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_118026 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_118027 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_118028 (h0 : functor.add_const (list (canonically_linear_ordered_monoid unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118029 (h0 : functor.add_const (list (normed_comm_ring Type)) (has_to_string environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118030 (h0 : semiring (has_add (option (option (option ennreal))))) : is_noetherian_ring (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_118031 (h0 : add_group (metric_space num)) : is_add_cyclic (metric_space num) := sorry --non-trivial
lemma new_lemma_118032 (h0 : topological_space (with_bot (semiring num))) : t0_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_118033 (h0 : uniform_space (has_sub (semiring num))) : complete_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_118034 (h1 : ring empty) : is_domain empty := sorry --non-trivial
lemma new_lemma_118035 (h0 : has_neg (has_ssubset enat)) (h1 : measurable_space (has_ssubset enat)) : has_measurable_neg (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_118036 (h0 : ring (free_add_monoid (semiring empty))) : is_domain (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_118037 (h0 : not (complete_lattice (complete_linear_order unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118038 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_118039 (h0 : topological_space (has_le enat)) : path_connected_space (has_le enat) := sorry --non-trivial
lemma new_lemma_118040 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_118041 (h0 : preorder (mul_one_class enat)) (h1 : set (mul_one_class enat)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_118042 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118043 (h0 : ring (distrib (has_ssubset (random_gen char)))) : rank_condition (distrib (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_118044 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) empty) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_118045 (h0 : complete_lattice (has_to_string (option pos))) : is_atomistic (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_118046 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_118047 (h0 : ring (linear_ordered_semiring (has_top empty))) : strong_rank_condition (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_118048 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : t1_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_118049 (h0 : topological_space (has_norm (semiring empty))) : preirreducible_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_118050 (h0 : topological_space (with_zero string_imp)) : totally_disconnected_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_118051 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118052 (h0 : group (complete_linear_order (semiring empty))) : group.fg (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_118053 (h0 : add_monoid (complete_linear_order (semiring num))) : add_monoid.fg (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_118054 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_118055 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118056 (h0 : functor.add_const (topological_space (semigroup empty)) num) : @loc_path_connected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_118057 (h0 : ring (has_add (option pos))) : is_principal_ideal_ring (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_118058 (h0 : ring (has_zero (has_to_string (finset pos)))) : is_principal_ideal_ring (has_zero (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_118059 (h0 : function.extfun Type group) : @is_cyclic.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_118060 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_118061 (h0 : group (semigroup (ring Type))) : normalizer_condition (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_118062 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : totally_separated_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_118063 (h0 : filter (has_norm (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118064 (h0 : complete_lattice (linear_ordered_add_comm_group (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_118065 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118067 (h0 : not (add_group (mul_one_class linarith.ineq) -> false)) : @is_add_cyclic.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (mul_one_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_118068 (h0 : monoid (add_cancel_monoid (has_nndist (has_neg (has_neg Type))))) : monoid.fg (add_cancel_monoid (has_nndist (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_118069 (h0 : monoid (comm_group (has_add (has_add Type)))) : monoid.fg (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_118070 (h0 : topological_space (normed_group (has_top (has_ssubset (random_gen linarith.ineq))))) : t0_space (normed_group (has_top (has_ssubset (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118071 (h0 : uniform_space (monoid_with_zero (ring pos))) : complete_space (monoid_with_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_118072 (h0 : ring (ordered_comm_ring (ordered_comm_ring Type))) : strong_rank_condition (ordered_comm_ring (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_118073 (h0 : ordered_semiring (random_gen reducibility_hints)) (h1 : topological_space (distrib (floor_semiring (random_gen reducibility_hints)))) : t0_space (distrib (floor_semiring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_118074 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (boolean_algebra.core (has_neg Type))) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (boolean_algebra.core.{1} (has_neg.{1} Type)) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_118075 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @rank_condition.{0} (with_bot.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} unsigned)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} unsigned))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118076 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_118077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118078 (h0 : topological_space char) : totally_disconnected_space char := sorry --non-trivial
lemma new_lemma_118079 (h0 : topological_space (boolean_algebra (has_add (has_add Type)))) : preconnected_space (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_118080 (h3 : group (has_append char)) : is_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_118081 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118082 (h0 : topological_space (ring Type)) : path_connected_space (ring Type) := sorry --non-trivial
lemma new_lemma_118083 (h1 : group (normed_group linarith.comp)) : normalizer_condition (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_118084 (h0 : filter (has_emptyc fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118085 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t1_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118086 (h0 : topological_space (linear_ordered_semiring fun_info)) : discrete_topology (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_118087 (h0 : topological_space (id (has_inv linarith.comp_source))) : path_connected_space (id (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118088 (h0 : topological_space (normed_linear_ordered_group empty)) : t0_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_118089 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : totally_separated_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118090 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118091 (h0 : nat) : nat.perfect h0 := sorry --non-trivial
lemma new_lemma_118092 (h0 : function.extfun nat fin) : @is_simple_group.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118093 (h0 : ring (dlist (has_ssubset (has_inv (has_ssubset (has_ssubset to_additive.value_type)))))) : is_domain (dlist (has_ssubset (has_inv (has_ssubset (has_ssubset to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_118094 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_118095 (h0 : function.extfun nat fin) : @separated_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118096 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @preirreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_118097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_118098 (h0 : topological_space (semiring (has_one (has_top linarith.comp)))) : totally_disconnected_space (semiring (has_one (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_118099 (h2 : complete_lattice (mul_one_class ereal)) : complete_lattice.is_Sup_finite_compact (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_118100 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_118101 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : path_connected_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_118102 (h0 : topological_space (cancel_monoid (option empty))) : t0_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_118103 (h0 : group congr_arg_kind) : group.fg congr_arg_kind := sorry --non-trivial
lemma new_lemma_118104 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group linarith.comp)) pos) : @archimedean.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_118105 (h0 : list (normed_linear_ordered_group (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_118106 (h4 : add_group (random_gen char)) : is_add_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_118107 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118108 (h0 : functor.add_const (group (add_cancel_monoid pos)) pos) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_118109 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_118110 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (encodable string_imp)) := sorry --non-trivial
lemma new_lemma_118111 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) linarith.comp) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118112 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring pos)) name) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_118113 (h0 : topological_space (with_bot (has_inv linarith.ineq))) : locally_compact_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118114 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) name) : @discrete_topology.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_118115 (h0 : group (has_add (finset (finset environment.implicit_infer_kind)))) : is_simple_group (has_add (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_118116 (h0 : add_group (has_star (semiring (semiring (semiring congr_arg_kind))))) : is_add_cyclic (has_star (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_118117 (h0 : topological_space (comm_ring reducibility_hints)) : totally_disconnected_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_118118 (h0 : not (complete_lattice (semi_normed_comm_ring string_imp) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_118119 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_118120 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @complete_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118121 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_118122 (h0 : topological_space (add_comm_monoid (comm_group Type))) : locally_compact_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_118123 (h0 : topological_space (has_to_string (has_to_string unsigned))) : preconnected_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_118124 (h0 : topological_space (semiring unsigned)) : loc_path_connected_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_118125 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add name)) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} name) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_118126 (h0 : functor.add_const (filter (comm_group unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118127 (h1 : ring (comm_ring char)) : strong_rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_118128 (h0 : functor.add_const (function.extfun Type ring) empty) : @is_domain.{0} (filter.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) empty h0) (filter.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_118129 (h0 : functor.add_const (ring (has_nndist unsigned)) empty) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_118130 (h0 : topological_space (with_bot num)) : t0_space (with_bot num) := sorry --non-trivial
lemma new_lemma_118131 (h1 : add_comm_group (has_zero to_additive.value_type)) (h2 : has_norm (has_zero to_additive.value_type)) : normed_group.core (has_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118132 (h0 : has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_118133 (h4 : topological_space (normed_field char)) : path_connected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_118134 (h0 : topological_space (has_compl (mul_one_class string.iterator_imp))) : t0_space (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_118135 (h0 : topological_space linarith.comp_source) (h1 : linarith.comp_source) (h2 : ring (topological_space (topological_space.open_nhds_of h1))) : rank_condition (topological_space (topological_space.open_nhds_of h1)) := sorry --non-trivial
lemma new_lemma_118136 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_118137 (h0 : topological_space char) (h1 : group char) : topological_group char := sorry --non-trivial
lemma new_lemma_118138 (h0 : ring (comm_ring (has_nnnorm linarith.ineq))) : is_domain (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118139 (h0 : topological_space (has_pos_part linarith.comp)) : sequential_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_118140 (h0 : topological_space (comm_group (complete_distrib_lattice ennreal))) : normal_space (comm_group (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_118141 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @is_atomistic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_118142 (h0 : group (has_to_string (finset pos))) : is_cyclic (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_118143 (h0 : semiring (with_bot (semiring unsigned))) : is_noetherian_ring (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118144 (h0 : set (mul_one_class (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_118145 (h0 : uniform_space (add_cancel_monoid (has_neg name))) : complete_space (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_118146 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118147 (h1 : semiring (semiring congr_arg_kind) -> semiring (semiring congr_arg_kind) -> Prop) : is_partial_order (semiring (semiring congr_arg_kind)) h1 := sorry --non-trivial
lemma new_lemma_118148 (h0 : functor.comp group normed_comm_ring name) : @group.fg.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} group.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_118149 (h0 : functor.comp topological_space has_to_string unsigned) : @t1_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_118150 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_118151 (h1 : preorder (mul_one_class (add_comm_semigroup ereal))) (h2 : set (mul_one_class (add_comm_semigroup ereal))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_118152 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118153 (h0 : ring (left_cancel_semigroup (semiring empty))) : strong_rank_condition (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_118154 (h0 : topological_space (boolean_algebra.core (add_comm_monoid (option empty)))) : irreducible_space (boolean_algebra.core (add_comm_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_118155 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_118156 (h0 : topological_space (comm_monoid congr_arg_kind)) : topological_space.separable_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118157 (h0 : functor.add_const (complete_lattice (add_cancel_monoid ennreal)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_118158 (h0 : list (dlist (has_nnnorm (has_nnnorm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118159 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118160 (h0 : topological_space (boolean_algebra.core (normed_comm_ring unsigned))) : loc_path_connected_space (boolean_algebra.core (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_118161 (h0 : set (random_gen ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_118162 (h0 : functor.add_const (add_group (preorder empty)) (option unsigned)) : @is_add_cyclic.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (preorder.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_118163 (h0 : functor.add_const (group (has_dist empty)) unsigned) : @normalizer_condition.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118164 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_118165 (h0 : topological_space (has_star (semiring num))) : discrete_topology (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_118166 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup congr_arg_kind)))) : @t0_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_118167 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid name)) name) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_118168 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} (has_inv.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (has_inv.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_118169 (h0 : topological_space (add_comm_monoid empty)) : discrete_topology (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_118170 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_118171 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset (ring name)))) : unique_factorization_monoid (has_nndist (finset (ring name))) := sorry --non-trivial
lemma new_lemma_118172 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_118173 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_118174 (h0 : functor.add_const (topological_space (has_zero ennreal)) unsigned) : @topological_space.separable_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118175 (h0 : function.extfun (Type 1) (functor.add_const (ordered_comm_monoid pos))) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (ordered_comm_monoid.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_118176 (h0 : complete_lattice (has_add (has_Inf pos))) : is_atomistic (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_118177 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) pos) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_118178 (h0 : functor.add_const (ring (has_zero empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_118179 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) (semigroup name)) : @totally_separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_118180 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_118181 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_118182 (h0 : monoid (canonically_linear_ordered_monoid pos)) : monoid.fg (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_118183 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @normal_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118184 (h0 : functor.add_const (complete_lattice (bin_tree num)) num) : @is_atomistic.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_118185 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_118186 (h0 : topological_space (has_ssubset linarith.comp_source)) (h1 : preorder (has_ssubset linarith.comp_source)) : order_topology (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118187 (h0 : topological_space (has_neg (has_neg (has_neg Type)))) : t0_space (has_neg (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_118188 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118189 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118190 (h0 : functor.add_const Prop (ring congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_118191 (h0 : uniform_space (with_bot (has_top fun_info))) : complete_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_118192 (h0 : ring (add_cancel_monoid (option (option ennreal)))) : strong_rank_condition (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_118193 (h0 : topological_space (measurable_space.dynkin_system (option empty))) : t1_space (measurable_space.dynkin_system (option empty)) := sorry --non-trivial
lemma new_lemma_118194 (h1 : ring (uniform_space to_additive.value_type)) : is_domain (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118195 (h0 : topological_space (add_comm_semigroup (mul_one_class ereal))) : t0_space (add_comm_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_118196 (h0 : topological_space (has_union (has_norm linarith.comp))) : normal_space (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_118197 (h0 : filter (has_star (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118198 (h0 : functor.add_const (semiring (has_to_string name)) (has_add pos)) : @is_noetherian_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_118199 (h0 : topological_space (has_Sup (semiring (ordered_ring empty)))) : preirreducible_space (has_Sup (semiring (ordered_ring empty))) := sorry --non-trivial
lemma new_lemma_118200 (h0 : complete_lattice (random_gen linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118201 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) (option (option (option unsigned)))) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_118202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_118203 (h0 : topological_space (comm_group (has_neg (has_neg (has_nndist name))))) : totally_separated_space (comm_group (has_neg (has_neg (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_118204 (h0 : group (metric_space (semiring (semiring (semiring congr_arg_kind))))) : group.fg (metric_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_118205 (h0 : topological_space (uniform_space unsigned)) : path_connected_space (uniform_space unsigned) := sorry --non-trivial
lemma new_lemma_118206 (h0 : group (boolean_algebra.core (finset environment.implicit_infer_kind))) : is_cyclic (boolean_algebra.core (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118207 (h0 : list (finset pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118208 (h0 : not (topological_space (has_one congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_118209 (h0 : functor.add_const (complete_lattice (semigroup empty)) empty) : @is_compactly_generated.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118210 (h0 : prod string.iterator_imp string.iterator_imp) : set.diagonal string.iterator_imp h0 := sorry --non-trivial
lemma new_lemma_118211 (h0 : complete_lattice (has_union unsigned)) : is_atomistic (has_union unsigned) := sorry --non-trivial
lemma new_lemma_118212 (h0 : functor.add_const (group (canonically_ordered_add_monoid unsigned)) empty) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_118213 (h0 : topological_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118214 (h0 : topological_space (has_neg_part name)) : locally_compact_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_118215 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) pos) : @is_compactly_generated.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_118216 (h0 : with_bot (fin has_zero.zero)) (h1 : ne h0 has_bot.bot) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) (@with_bot.unbot.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0 h1))))  := sorry --non-trivial
lemma new_lemma_118217 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118218 (h0 : topological_space (random_gen (has_norm (has_norm fun_info)))) : irreducible_space (random_gen (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_118219 (h0 : set (has_le (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_118220 (h0 : list (linear_ordered_add_comm_group (dlist string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118221 (h0 : topological_space (has_Inf (finset pos))) : path_connected_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_118222 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118223 (h0 : ring (linear_ordered_add_comm_group string_imp)) : rank_condition (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_118224 (h0 h1 : multiset (has_ssubset char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_118225 (h0 : complete_lattice (normed_linear_ordered_group (option unsigned))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_118226 (h0 : topological_space (metric_space linarith.comp)) : preirreducible_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_118227 (h0 : not (ring (has_top fun_info) -> false)) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_118228 (h0 : not (ring (left_cancel_semigroup congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_118229 (h0 : topological_space (has_to_string (finset (has_add (finset environment.implicit_infer_kind))))) : loc_path_connected_space (has_to_string (finset (has_add (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_118230 (h0 : topological_space (has_bot (has_add pos))) : irreducible_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_118231 (h0 : functor.add_const (monoid (has_add Type)) pos) : @monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_118232 (h0 : functor.add_const (ring (has_Inf Type)) Type) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_118233 (h0 : functor.add_const (group (non_assoc_semiring congr_arg_kind)) unsigned) : @normalizer_condition.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118234 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_118235 (h0 : topological_space (normed_comm_ring unsigned)) : t1_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_118236 (h0 : set (linear_ordered_comm_group_with_zero std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_118237 (h0 : group (measure_theory.measure_space unsigned)) : normalizer_condition (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_118238 (h2 : ring (has_nnnorm (has_ssubset to_additive.value_type))) : strong_rank_condition (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118239 (h0 : group (complete_semilattice_Sup (random_gen fun_info))) : group.fg (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_118240 (h0 : functor.add_const (topological_space (add_group num)) num) : @locally_compact_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_118241 (h0 : topological_space (semigroup (has_add unsigned))) : t1_space (semigroup (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_118242 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @is_add_cyclic.{0} unsigned (@finset.pi.empty.{1 0} Type add_group.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118243 (h0 : group (has_inv (has_norm to_additive.value_type))) : group.fg (has_inv (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118244 (h0 : not (topological_space (semiring unsigned) -> false)) : @totally_disconnected_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118245 (h0 : add_group (add_monoid (fintype fun_info))) : is_add_cyclic (add_monoid (fintype fun_info)) := sorry --non-trivial
lemma new_lemma_118246 (h0 : group (has_norm (random_gen num))) : normalizer_condition (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_118247 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ring unsigned)) := sorry --non-trivial
lemma new_lemma_118248 (h0 : group (has_inter congr_arg_kind)) : normalizer_condition (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118249 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group (option empty))) : unique_factorization_monoid (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_118250 (h0 : group (has_Inf (has_add environment.implicit_infer_kind))) : group.fg (has_Inf (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118251 (h0 : complete_lattice (id (has_norm (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (id (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_118252 (h0 : group (encodable (has_nnnorm linarith.ineq))) : is_cyclic (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118253 (h0 : topological_space (ordered_comm_monoid pos)) : totally_disconnected_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_118254 (h0 : has_mem.mem (ring congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (ring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (ring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_118255 (h0 : add_group (has_add (has_add (has_add linarith.comp)))) : is_add_cyclic (has_add (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_118256 (h0 : not (ring linarith.comp_source -> false)) : @strong_rank_condition.{0} linarith.comp_source (@classical.by_contradiction'.{1} (ring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_118257 (h1 h2 : multiset string.iterator) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_118258 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118259 (h0 : finset environment.implicit_infer_kind) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118260 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_118261 (h1 : add_group (has_ssubset char)) : is_add_cyclic (has_ssubset char) := sorry --non-trivial
lemma new_lemma_118262 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_ring unsigned)) unsigned) : @archimedean.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118263 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @irreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118264 (h0 : add_group (parser linarith.comp_source)) : is_add_cyclic (parser linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118265 (h0 : uniform_space (with_bot (random_gen (random_gen to_additive.value_type)))) : complete_space (with_bot (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_118266 (h0 : group (topological_space (has_nnnorm (random_gen linarith.comp_source)))) : group.fg (topological_space (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_118267 (h0 : group (has_to_string (has_neg_part unsigned))) : normalizer_condition (has_to_string (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_118268 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_118269 (h0 : prod (has_add (has_add unsigned)) (has_add (has_add unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_118270 (h1 : complete_lattice (mul_one_class (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_118271 (h0 : functor.add_const (topological_space (complete_linear_order congr_arg_kind)) empty) : @totally_separated_space.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_118272 (h0 : group (complete_semilattice_Sup string_imp)) : group.fg (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_118273 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @sequential_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_118274 (h0 : add_group (random_gen (has_norm (has_norm linarith.ineq)))) : is_add_cyclic (random_gen (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_118275 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @totally_separated_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118276 (h0 : topological_space (has_neg linarith.comp)) : normal_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_118277 (h0 : functor.add_const (ordered_add_comm_monoid (ring name)) linarith.comp) : @archimedean.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118278 (h0 : topological_space (normed_comm_ring (option (option empty)))) : totally_disconnected_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_118279 (h1 : topological_space (has_inv string_imp)) : t0_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_118280 (h0 : group (fintype (has_nnnorm linarith.ineq))) : is_cyclic (fintype (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118281 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : totally_separated_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_118282 (h0 : topological_space (has_bot (has_Inf pos))) : irreducible_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_118283 (h0 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_118284 (h0 : ring (add_comm_monoid (has_add name))) : rank_condition (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_118285 (h0 : ring (partial_order (option unsigned))) : is_domain (partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_118286 (h0 : functor.add_const (ring (has_neg Type)) (has_pos_part (has_pos_part pos))) : @rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_pos_part.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_118287 (h0 : ring (has_top congr_arg_kind)) : is_principal_ideal_ring (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118288 (h0 : topological_space (monoid_with_zero (option (option (option (option ennreal)))))) : irreducible_space (monoid_with_zero (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_118289 (h0 : complete_lattice (add_monoid (comm_ring (random_gen (comm_ring char))))) : complete_lattice.is_Sup_finite_compact (add_monoid (comm_ring (random_gen (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_118290 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_118291 (h0 : functor.add_const (ring (comm_group unsigned)) environment.implicit_infer_kind) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118292 (h0 : topological_space (has_ssubset (has_norm linarith.comp))) : locally_compact_space (has_ssubset (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_118293 (h0 : topological_space (normed_field char)) (h1 : preorder (normed_field char)) : order_topology (normed_field char) := sorry --non-trivial
lemma new_lemma_118294 (h0 : topological_space (normed_comm_ring (semigroup (semigroup unsigned)))) : irreducible_space (normed_comm_ring (semigroup (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_118295 (h0 : topological_space (simple_graph reducibility_hints)) : path_connected_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_118296 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : discrete_topology (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_118297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_118298 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118299 (h0 : filter (is_R_or_C empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118300 (h0 : ring (ring (option (option pos)))) : is_principal_ideal_ring (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_118301 (h0 : functor.add_const (add_group (mul_zero_class ennreal)) Type) : @is_add_cyclic.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (add_group.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_118302 (h0 : topological_space (semi_normed_ring (random_gen (mul_one_class name)))) : totally_disconnected_space (semi_normed_ring (random_gen (mul_one_class name))) := sorry --non-trivial
lemma new_lemma_118303 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118304 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_118305 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} (has_Inf.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_118306 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_118307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (finset unsigned)) := sorry --non-trivial
lemma new_lemma_118308 (h0 : ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) : has_exists_mul_of_le (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_118309 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (semigroup linarith.comp)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_118310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_118311 (h0 : not (complete_lattice (denumerable fun_info) -> false)) : @is_compactly_generated.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_118312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_118313 (h0 : cancel_comm_monoid_with_zero (has_to_string (boolean_algebra.core name))) : unique_factorization_monoid (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_118314 (h0 : topological_space (topological_space (has_nnnorm (comm_ring (has_nnnorm linarith.ineq))))) : path_connected_space (topological_space (has_nnnorm (comm_ring (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118315 (h1 : set (mul_one_class fun_info -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_118316 (h0 : ring (non_unital_non_assoc_semiring char)) : rank_condition (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_118317 (h0 : ring (has_neg (finset (has_to_string (finset pos))))) : is_domain (has_neg (finset (has_to_string (finset pos)))) := sorry --non-trivial
lemma new_lemma_118318 (h0 : topological_space (with_bot (has_norm linarith.comp_source))) : totally_disconnected_space (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118319 (h0 : topological_space (left_cancel_monoid num)) : totally_disconnected_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_118320 (h0 : ordered_add_comm_monoid (has_dist (option num))) : archimedean (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_118321 (h0 : complete_lattice (random_gen (has_nnnorm (has_lt linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm (has_lt linarith.ineq))) := sorry --non-trivial
lemma new_lemma_118322 (h0 : topological_space (has_top (semiring congr_arg_kind))) : totally_separated_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118323 (h0 : add_group (semiring (semiring (semiring linarith.comp)))) : is_add_cyclic (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_118324 (h0 : functor.add_const (group (has_add pos)) linarith.comp) : @is_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118325 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist pos)) Type) : @archimedean.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_118326 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_118327 (h0 : monoid (comm_monoid unsigned)) : monoid.fg (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_118328 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_118329 (h0 : ring (comm_monoid (option (option (option empty))))) : strong_rank_condition (comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_118330 (h0 : topological_space (normed_comm_ring (has_to_string unsigned))) : preconnected_space (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_118331 (h0 : add_group (cancel_monoid (has_add (has_add environment.implicit_infer_kind)))) : is_add_cyclic (cancel_monoid (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_118332 (h0 : char -> char -> char) : nonempty (left_cancelative h0) := sorry --non-trivial
lemma new_lemma_118333 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_118334 (h0 : topological_space (option (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_118335 (h0 : functor.add_const (list (ring linarith.comp)) (ring (has_to_string (has_neg environment.implicit_infer_kind)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118337 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @t1_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118338 (h0 : group (boolean_algebra.core (option empty))) : is_cyclic (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_118339 (h0 : functor.add_const (ordered_add_comm_monoid (has_add Type)) environment.implicit_infer_kind) : @archimedean.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118340 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118341 (h0 : ring (fintype (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : strong_rank_condition (fintype (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_118342 (h0 : complete_lattice (has_neg (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_118343 (h0 : topological_space (pseudo_metric_space (option pos))) : topological_space.separable_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_118344 (h0 : functor.add_const (list (add_group empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118345 (h0 : topological_space (with_one unsigned)) : normal_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_118346 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (comm_group (comm_group name))) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (comm_group.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_118347 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_118348 (h0 : group (ring (ring (has_zero Type)))) : is_cyclic (ring (ring (has_zero Type))) := sorry --non-trivial
lemma new_lemma_118349 (h0 : cancel_comm_monoid_with_zero (has_dist empty)) : unique_factorization_monoid (has_dist empty) := sorry --non-trivial
lemma new_lemma_118350 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118351 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_118352 (h0 : ring (generalized_boolean_algebra Type)) : is_principal_ideal_ring (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_118353 (h0 : ring (comm_ring linarith.ineq)) : strong_rank_condition (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_118354 (h0 : functor.add_const (monoid (generalized_boolean_algebra Type)) linarith.comp) : @monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118355 (h0 : group (semigroup (has_zero (has_zero linarith.comp)))) : normalizer_condition (semigroup (has_zero (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_118356 (h0 : ring (linear_ordered_comm_group_with_zero nnreal)) : strong_rank_condition (linear_ordered_comm_group_with_zero nnreal) := sorry --non-trivial
lemma new_lemma_118357 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_118358 (h0 : has_mem.mem Type has_emptyc.emptyc) : @is_domain.{1} Type (@finset.pi.empty.{2 1} (Type 1) ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_118359 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_118360 (h0 : topological_space (has_nndist Type)) : loc_path_connected_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_118361 (h0 : has_to_string (has_dist ennreal) -> has_to_string (has_dist ennreal) -> Prop) : is_symm (has_to_string (has_dist ennreal)) h0 := sorry --non-trivial
lemma new_lemma_118362 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_118363 (h0 : topological_space (has_Inf (has_add Type))) : path_connected_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_118364 (h0 : list (ring (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_118365 (h0 : topological_space (monoid_with_zero (option pos))) : t1_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_118366 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_118367 (h1 : add_group (has_nnnorm linarith.ineq)) : is_add_cyclic (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_118368 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_118369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_118370 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_118371 (h0 : functor.add_const (filter environment.implicit_infer_kind) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118372 (h0 : fin has_zero.zero) : @archimedean.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_118373 (h0 : topological_space (has_neg to_additive.value_type)) : t0_space (has_neg to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118374 (h0 : complete_lattice (canonically_linear_ordered_monoid Type)) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_118375 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118376 (h0 : topological_space (semiring unsigned)) : discrete_topology (semiring unsigned) := sorry --non-trivial
lemma new_lemma_118377 (h0 : complete_lattice (add_comm_monoid (has_add (has_add name)))) : is_compactly_generated (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_118378 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118379 (h0 : lattice (has_top to_additive.value_type)) : is_modular_lattice (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118380 (h0 : complete_lattice (boolean_algebra.core (has_neg_part Type))) : is_compactly_generated (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_118381 (h0 : topological_space (add_cancel_monoid (ring Type))) : loc_path_connected_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_118382 (h0 : has_lt (ordered_comm_monoid (mul_one_class (mul_one_class char)))) : no_max_order (ordered_comm_monoid (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_118383 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : loc_path_connected_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_118384 (h0 : topological_space (partial_order (has_norm empty))) : locally_compact_space (partial_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_118385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118386 (h0 : fin has_zero.zero) : @rank_condition.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_118387 (h0 : topological_space (random_gen (has_top empty))) : preirreducible_space (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_118388 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_118389 (h0 : group (sub_neg_monoid (has_Inf real))) : is_simple_group (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_118390 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118391 (h0 : topological_space (is_R_or_C unsigned)) : irreducible_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_118392 (h0 : filter (distrib_lattice (random_gen (has_inv char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118393 (h0 : complete_lattice (semigroup ennreal)) : is_compactly_generated (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_118394 (h0 : not (topological_space (random_gen (random_gen fun_info)) -> false)) : @locally_compact_space.{0} (random_gen.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_118395 (h0 : not (complete_lattice (has_Sup linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_118396 (h0 : add_group (canonically_ordered_comm_semiring linarith.comp)) : is_add_cyclic (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_118397 (h1 : set (mul_one_class char -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_118398 (h0 : complete_lattice (has_emptyc (has_top num))) : is_atomistic (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_118399 (h0 : list (has_neg ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_118400 (h0 : topological_space (has_to_string (has_bot Type))) : sequential_space (has_to_string (has_bot Type)) := sorry --non-trivial
lemma new_lemma_118401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118402 (h1 : complete_lattice (has_append reducibility_hints)) : is_compactly_generated (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_118403 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118404 (h0 : topological_space (complete_distrib_lattice (comm_group (comm_group (comm_group pos))))) : sequential_space (complete_distrib_lattice (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_118405 (h0 : not (add_group (has_top linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_118406 (h1 : topological_space (metric_space (normed_group linarith.comp))) : discrete_topology (metric_space (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_118407 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : loc_path_connected_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_118408 (h0 : uniform_space (with_bot (semiring unsigned))) : complete_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_118411 (h0 : topological_space (has_union (semiring unsigned))) : topological_space.separable_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118412 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118413 (h0 : topological_space (has_bot (has_bot pos))) : preconnected_space (has_bot (has_bot pos)) := sorry --non-trivial
lemma new_lemma_118414 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_118415 (h0 : complete_lattice (add_cancel_comm_monoid (option empty))) : is_atomistic (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_118416 (h0 : set (has_inter char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_118417 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_118418 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero linarith.comp)) Type) : @archimedean.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_118419 (h0 : preorder ereal) (h2 : Prop) : set.is_pwo (id (fun (h1 : ereal), h2)) := sorry --non-trivial
lemma new_lemma_118420 (h0 : uniform_space (div_inv_monoid (has_nnnorm (has_ssubset (random_gen fun_info))))) : complete_space (div_inv_monoid (has_nnnorm (has_ssubset (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_118421 (h0 : topological_space (normed_group (has_norm fun_info))) : irreducible_space (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_118422 (h0 : group (distrib linarith.ineq)) : is_cyclic (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_118423 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118424 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_118425 (h0 : finset (canonically_ordered_add_monoid (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_118427 (h0 : fin has_zero.zero) : @group.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_118428 (h0 : ring (semigroup (add_comm_monoid (has_nndist (finset Type))))) : is_principal_ideal_ring (semigroup (add_comm_monoid (has_nndist (finset Type)))) := sorry --non-trivial
lemma new_lemma_118429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118430 (h0 : not (complete_lattice (non_assoc_semiring unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118431 (h0 : ring (linear_ordered_semiring (has_norm (semiring empty)))) : strong_rank_condition (linear_ordered_semiring (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_118432 (h0 : list (cancel_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118433 (h1 : add_comm_semigroup enat -> add_comm_semigroup enat -> Prop) (h2 : set (add_comm_semigroup enat)) : set.bounded h1 h2 := sorry --non-trivial
lemma new_lemma_118434 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118435 (h0 : add_group (distrib (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_118436 (h0 : add_group (filter unsigned)) : is_add_cyclic (filter unsigned) := sorry --non-trivial
lemma new_lemma_118437 (h1 : ring (uniform_space linarith.comp_source)) : strong_rank_condition (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118438 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @locally_compact_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_118439 (h0 : ring (has_norm (semiring empty))) : strong_rank_condition (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_118440 (h2 : uniform_space (distrib (has_nnnorm (has_nnnorm (mul_one_class char))))) : complete_space (distrib (has_nnnorm (has_nnnorm (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_118441 (h0 : ring (ordered_ring (option (option unsigned)))) : is_domain (ordered_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_118442 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @locally_compact_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118443 (h0 : filter (add_cancel_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_118444 (h0 : filter (complete_distrib_lattice pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_118445 (h0 : add_monoid (canonically_linear_ordered_monoid (option (option (option num))))) : add_monoid.fg (canonically_linear_ordered_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_118446 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Sup empty)))) : @complete_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_118447 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @preconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_118448 (h0 : not (complete_lattice (has_div string_imp) -> false)) : @is_compactly_generated.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_118449 (h0 : functor.add_const (ring (has_dist empty)) (option empty)) : @is_domain.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118450 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118451 (h0 : filter (add_cancel_monoid (has_neg_part pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118452 (h0 : functor.add_const (topological_space (right_cancel_semigroup Type)) Type) : @t1_space.{1} (right_cancel_semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (right_cancel_semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_118453 (h0 : functor.add_const (ring (ring Type)) (finset (has_neg environment.implicit_infer_kind))) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) (finset.{0} (has_neg.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_118454 (h0 : functor.add_const Prop (simple_graph empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_118455 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (option unsigned)) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_118456 (h0 : topological_space (simple_graph (generalized_boolean_algebra pos))) : locally_compact_space (simple_graph (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_118457 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_118458 (h0 : functor.add_const (complete_lattice (has_nndist Type)) (has_add linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_118459 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_118460 (h0 : functor.add_const (topological_space (has_inter empty)) congr_arg_kind) : @locally_compact_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_118461 (h0 : functor.add_const (topological_space znum) unsigned) : @preirreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118462 (h0 : topological_space (ordered_comm_ring (finset (has_pos_part name)))) : discrete_topology (ordered_comm_ring (finset (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_118463 (h0 : functor.add_const (ring pos) (option pos)) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_118464 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_118465 (h0 : uniform_space (has_bot (simple_graph linarith.comp))) : separated_space (has_bot (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_118466 (h1 : complete_lattice (has_nnnorm char)) : complete_lattice.is_Sup_finite_compact (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_118467 (h0 : ordered_add_comm_monoid (comm_group (finset environment.implicit_infer_kind))) : archimedean (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118468 (h0 : fun_info -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_118469 (h0 : filter (add_right_cancel_monoid (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118470 (h0 : topological_space (ordered_comm_monoid (ring (ordered_comm_monoid (ring (ring linarith.comp)))))) : locally_compact_space (ordered_comm_monoid (ring (ordered_comm_monoid (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_118471 (h0 : group (boolean_algebra.core (comm_group (comm_group Type)))) : is_cyclic (boolean_algebra.core (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_118472 (h0 : functor.add_const (complete_lattice (finset Type)) name) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_118473 (h0 : fin has_zero.zero) : @discrete_topology.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_118474 (h1 : group (normed_field (comm_ring linarith.comp_source))) : is_cyclic (normed_field (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118475 (h0 : topological_space (add_left_cancel_semigroup (semiring (semiring (semiring empty))))) : totally_separated_space (add_left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_118476 (h0 : add_group (measurable_space congr_arg_kind)) : is_add_cyclic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118477 (h0 : ring (with_one (random_gen fun_info))) : rank_condition (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_118478 (h0 : ring (has_neg_part (has_add pos))) : is_domain (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_118479 (h0 : add_monoid (linear_ordered_comm_ring (semiring num))) : add_monoid.fg (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_118480 (h0 : complete_lattice (semigroup (boolean_algebra.core unsigned))) : is_atomistic (semigroup (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_118481 (h0 : topological_space (simple_graph pos)) : t1_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_118482 (h1 : not (filter (semiring linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_118483 (h0 : topological_space (has_norm (has_nnnorm to_additive.value_type))) : locally_compact_space (has_norm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118484 (h0 : set (ereal -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_118485 (h0 : ring (canonically_ordered_add_monoid (option unsigned))) : is_principal_ideal_ring (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_118486 (h0 : add_group (ring (add_comm_monoid Type))) : is_add_cyclic (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_118487 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : discrete_topology (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_118488 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_118489 (h0 : group (has_add (ordered_comm_monoid (has_bot name)))) : normalizer_condition (has_add (ordered_comm_monoid (has_bot name))) := sorry --non-trivial
lemma new_lemma_118490 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : regular_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_118491 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : t0_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_118492 (h0 h1 : ulower pnat) : pnat.coprime (ulower.up h0) (id (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_118493 (h0 : ring (normed_group (has_top unsigned))) : is_domain (normed_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_118494 (h0 : topological_space (comm_monoid unsigned)) : locally_compact_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_118495 (h0 : uniform_space (comm_ring char)) : complete_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_118496 (h0 : ring (left_cancel_semigroup (semiring (semiring empty)))) : is_domain (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_118497 (h0 : topological_space (normed_group (has_norm congr_arg_kind))) : irreducible_space (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118498 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_118499 (h0 : uniform_space (has_norm (random_gen linarith.ineq))) : complete_space (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118500 (h0 : functor.comp ring complete_distrib_lattice name) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_118501 (h0 : not (complete_lattice (measure_theory.measure_space unsigned) -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118502 (h1 : ring (complete_semilattice_Sup linarith.ineq)) : rank_condition (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_118503 (h0 : functor.add_const (add_group (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118504 (h0 : functor.add_const (complete_lattice (has_zero pos)) ennreal) : @is_compactly_generated.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_118505 (h0 : topological_space (comm_group (comm_group (option pos)))) : t1_space (comm_group (comm_group (option pos))) := sorry --non-trivial
lemma new_lemma_118506 (h0 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : totally_disconnected_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118507 (h0 : ring (canonically_ordered_comm_semiring (option (option num)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option (option num))) := sorry --non-trivial
lemma new_lemma_118508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_118509 (h0 : topological_space (id to_additive.value_type)) : normal_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118510 (h0 : topological_space (finset (ring (has_neg (finset pos))))) : locally_compact_space (finset (ring (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_118511 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118512 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118513 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_118514 (h0 : functor.add_const (group (add_cancel_monoid empty)) empty) : @group.fg.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118515 (h0 : complete_lattice (normed_group (random_gen char))) : is_compactly_generated (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_118516 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_118518 (h0 : uniform_space ennreal) : separated_space ennreal := sorry --non-trivial
lemma new_lemma_118519 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118520 (h0 : topological_space (boolean_algebra (has_Inf pos))) : t0_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_118521 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_118522 (h3 : complete_lattice (has_append to_additive.value_type)) : is_compactly_generated (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118523 (h0 : topological_space (has_Inf (ordered_comm_ring (ring linarith.comp)))) : preirreducible_space (has_Inf (ordered_comm_ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_118524 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_118525 (h0 : functor.add_const (finset (add_cancel_monoid environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118526 (h0 : topological_space (ordered_comm_monoid Type)) : preirreducible_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_118527 (h0 : functor.add_const (ring (finset pos)) (has_neg name)) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_118528 (h0 : list (has_zero (mul_zero_class name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118529 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118530 (h0 : complete_lattice (has_compl char)) : is_compactly_generated (has_compl char) := sorry --non-trivial
lemma new_lemma_118531 (h0 : topological_space (has_neg (normed_comm_ring environment.implicit_infer_kind))) : loc_path_connected_space (has_neg (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118532 (h0 : topological_space (canonically_linear_ordered_monoid (has_zero congr_arg_kind))) : preirreducible_space (canonically_linear_ordered_monoid (has_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118533 (h0 : filter (cancel_monoid (finset ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_118534 (h0 : not (add_group (dlist (has_nnnorm (has_nnnorm linarith.comp_source))) -> false)) : @is_add_cyclic.{0} (dlist.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_118535 (h0 : functor.add_const Prop (has_nndist ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_118536 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_118537 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_pos_part.{0} (boolean_algebra.core.{0} (has_pos_part.{0} (has_pos_part.{0} linarith.comp)))) (@matrix.vec_empty.{0} (monoid.{0} (has_pos_part.{0} (boolean_algebra.core.{0} (has_pos_part.{0} (has_pos_part.{0} linarith.comp))))) h0)  := sorry --non-trivial
lemma new_lemma_118538 (h0 : finset (has_add (ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118539 (h0 : topological_space (simple_graph (mul_one_class string_imp))) : totally_disconnected_space (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_118540 (h0 : add_monoid (has_Inf (has_Inf (has_Inf (has_Inf real))))) : add_monoid.fg (has_Inf (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_118541 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_118542 (h0 : function.extfun Type (functor.add_const (ring (bin_tree empty)))) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (bin_tree.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_118543 (h0 : add_group (has_neg (finset (finset (finset pos))))) : is_add_cyclic (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_118544 (h0 : not (complete_lattice (with_one num) -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_118545 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring unsigned)) pos) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_118546 (h0 : functor.add_const (ring (simple_graph Type)) Type) : @rank_condition.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_118547 (h0 : ring (comm_ring (has_nnnorm (random_gen linarith.ineq)))) : strong_rank_condition (comm_ring (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_118548 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @is_domain.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_118549 (h0 : functor.add_const (function.extfun Type complete_lattice) (mul_zero_class name)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (mul_zero_class.{0} name) h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118550 (h0 : ordered_add_comm_monoid (comm_group (option (option pos)))) : archimedean (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_118551 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_118552 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_118553 (h0 : topological_space (finset Type)) : t1_space (finset Type) := sorry --non-trivial
lemma new_lemma_118554 (h0 : functor.add_const (group (ring name)) Type) : @is_simple_group.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_118555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_118556 (h0 : function.extfun nat fin) : is_domain real := sorry --non-trivial
lemma new_lemma_118557 (h0 : not (add_group (denumerable reducibility_hints) -> false)) : @is_add_cyclic.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_118558 (h0 : prod (left_cancel_monoid auto.case_option) (left_cancel_monoid auto.case_option)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_118559 (h0 : uniform_space (measurable_space.dynkin_system (semiring num))) : complete_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_118560 (h0 : lattice (linear_ordered_comm_ring num)) : is_modular_lattice (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_118561 (h0 : add_group (has_le (mul_one_class ereal))) : is_add_cyclic (has_le (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_118562 (h0 : ring (ordered_comm_ring (boolean_algebra.core (has_add (ring linarith.comp))))) : strong_rank_condition (ordered_comm_ring (boolean_algebra.core (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_118563 (h0 : topological_space (has_top num)) : discrete_topology (has_top num) := sorry --non-trivial
lemma new_lemma_118564 (h0 : topological_space (boolean_algebra.core empty)) : normal_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_118565 (h0 : ordered_add_comm_monoid (bin_tree (option (option unsigned)))) : archimedean (bin_tree (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_118566 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118567 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118568 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) pos) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_118569 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118570 (h0 : add_group (has_nndist (has_add (has_add ennreal)))) : is_add_cyclic (has_nndist (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_118571 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (boolean_algebra (ring Type))) : @t0_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (boolean_algebra.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_118572 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (denumerable linarith.ineq))))) : t0_space (has_ssubset (has_nnnorm (has_nnnorm (denumerable linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118573 (h0 : not (uniform_space (distrib string_imp) -> false)) : @complete_space.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_118574 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_118575 (h0 : function.extfun Type (functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)))) : @is_atomistic.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_118576 (h0 : ring (has_compl char)) : is_domain (has_compl char) := sorry --non-trivial
lemma new_lemma_118577 (h0 : functor.comp topological_space has_zero Type) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_118578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118579 (h0 : topological_space (has_nndist (option empty))) : totally_separated_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_118580 (h0 : functor.add_const (group (mul_zero_class empty)) empty) : @normalizer_condition.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118581 (h1 : topological_space (simple_graph linarith.comp_source)) : t0_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118582 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg Type)) (has_neg (has_neg Type))) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_neg.{1} Type)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_118583 (h0 : topological_space (add_cancel_monoid (has_Inf (has_add linarith.comp)))) : preirreducible_space (add_cancel_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_118584 (h0 : group (plift (option (semiring unsigned)))) : group.fg (plift (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_118585 (h0 : list (linear_ordered_add_comm_group (comm_ring (has_inv (has_norm linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118586 (h0 : topological_space (normed_group linarith.ineq)) : totally_disconnected_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_118587 (h0 : complete_lattice (linear_ordered_semiring (semiring empty))) : is_atomistic (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_118588 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @discrete_topology.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118589 (h0 : ring (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : strong_rank_condition (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118590 (h0 : complete_lattice nnreal) : is_compactly_generated nnreal := sorry --non-trivial
lemma new_lemma_118591 (h0 : list Prop) : id (list.head h0) := sorry --non-trivial
lemma new_lemma_118592 (h0 : ring (has_to_string (has_add (has_add Type)))) : strong_rank_condition (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_118593 (h0 : functor.add_const (topological_space (comm_group unsigned)) linarith.comp) : @t0_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118594 (h0 : ring (has_top (semiring congr_arg_kind))) : rank_condition (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118595 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_118596 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_118597 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_118598 (h0 : topological_space (add_left_cancel_semigroup (option (option empty)))) : irreducible_space (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_118599 (h0 : ring (option (semiring (semiring empty)))) : is_principal_ideal_ring (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_118600 (h0 : topological_space (has_nnnorm ereal)) : path_connected_space (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_118601 (h0 : topological_space (ordered_comm_ring (comm_semigroup real))) : irreducible_space (ordered_comm_ring (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_118602 (h0 : not (monoid (has_star unsigned) -> false)) : @monoid.fg.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118603 (h0 : functor.add_const (ring (has_pos_part Type)) name) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_118604 (h0 : uniform_space (add_comm_semigroup reducibility_hints)) : complete_space (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_118605 (h0 : monoid (has_Inf (has_neg linarith.comp))) : monoid.fg (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_118606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_118607 (h0 : topological_space (random_gen (has_one unsigned))) : totally_disconnected_space (random_gen (has_one unsigned)) := sorry --non-trivial
lemma new_lemma_118608 (h0 : list (dlist (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118609 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_118610 (h0 : complete_lattice (with_bot (random_gen (random_gen (random_gen num))))) : is_compactly_generated (with_bot (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_118611 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_118612 (h0 : has_le (has_lt linarith.comp_source)) (h1 : has_lt linarith.comp_source) : is_max h1 := sorry --non-trivial
lemma new_lemma_118613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118614 (h0 : not (filter (complete_semilattice_Sup empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_118615 (h0 : ring (with_one (has_top num))) : strong_rank_condition (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_118616 (h0 : not (filter (with_zero char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_118617 (h0 : topological_space (boolean_algebra.core Type)) : totally_separated_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_118618 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) pos) : @path_connected_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_118619 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : totally_separated_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118620 (h0 : not (ring (with_one string_imp) -> false)) : @strong_rank_condition.{0} (with_one.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_118621 (h0 : topological_space (mul_zero_class (has_add ennreal))) : normal_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_118622 (h0 : topological_space (has_add (has_add (has_add (has_nndist (has_add (add_cancel_monoid name))))))) : t0_space (has_add (has_add (has_add (has_nndist (has_add (add_cancel_monoid name)))))) := sorry --non-trivial
lemma new_lemma_118623 (h0 : group (has_top (random_gen to_additive.value_type))) : normalizer_condition (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118624 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group congr_arg_kind)) empty) : @separated_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_118625 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_118626 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118627 (h0 : add_monoid (has_zero unsigned)) : add_monoid.fg (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_118628 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_118629 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) (has_to_string environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_118630 (h0 : has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_118631 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118632 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118633 (h0 : uniform_space (finset (option ennreal))) : separated_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_118634 (h0 : semiring (linear_ordered_semiring unsigned)) : is_noetherian_ring (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_118635 (h0 : complete_lattice (has_pos_part (canonically_ordered_monoid real))) : complete_lattice.is_Sup_finite_compact (has_pos_part (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_118636 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118637 (h0 : ordered_comm_monoid (has_bot (has_neg (has_neg (has_bot real))))) : has_exists_mul_of_le (has_bot (has_neg (has_neg (has_bot real)))) := sorry --non-trivial
lemma new_lemma_118638 (h0 : functor.add_const (topological_space (ring empty)) unsigned) : @preconnected_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118639 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : normal_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_118640 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_118641 (h1 : uniform_space (has_div string_imp)) : complete_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_118642 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @totally_disconnected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118643 (h0 : functor.add_const (group pos) Type) : @is_simple_group.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_118644 (h0 : functor.add_const (group (ring pos)) name) : @is_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_118645 (h0 : semiring (non_assoc_semiring congr_arg_kind)) : is_noetherian_ring (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118646 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h1 (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_118647 (h1 : ring (has_compl reducibility_hints)) : strong_rank_condition (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_118648 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_118649 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_118650 (h0 : topological_space (has_neg (finset pos))) : normal_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_118651 (h0 : list (dlist (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118652 (h0 : topological_space (ring pos)) : discrete_topology (ring pos) := sorry --non-trivial
lemma new_lemma_118653 (h0 : ring (has_to_string (has_neg_part (has_to_string unsigned)))) : is_domain (has_to_string (has_neg_part (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_118654 (h1 : ring (with_bot (complete_semilattice_Sup to_additive.value_type))) : is_domain (with_bot (complete_semilattice_Sup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118655 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : preirreducible_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_118656 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_118657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_118658 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring unsigned))) : unique_factorization_monoid (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118660 (h0 : finset (linear_ordered_comm_ring (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118661 (h1 : uniform_space (has_append reducibility_hints)) : complete_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_118662 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) name) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_118663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_118664 (h0 : add_group (has_Inf (has_add pos))) : is_add_cyclic (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_118665 (h0 : add_monoid (measure_theory.measure_space (semiring congr_arg_kind))) : add_monoid.fg (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118666 (h0 : filter (linear_ordered_cancel_comm_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118667 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_118668 (h0 : topological_space (comm_group (ring (has_add linarith.comp)))) : preconnected_space (comm_group (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_118669 (h0 : functor.add_const (topological_space (has_zero unsigned)) (comm_group Type)) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} unsigned)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_118670 (h0 : functor.add_const (add_monoid (option empty)) empty) : @add_monoid.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118671 (h0 : topological_space (metric_space empty)) : discrete_topology (metric_space empty) := sorry --non-trivial
lemma new_lemma_118672 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_118673 (h0 : functor.add_const (ring (partial_order congr_arg_kind)) num) : @is_principal_ideal_ring.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_118674 (h0 : ring (add_comm_semigroup char)) : is_domain (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_118675 (h0 : filter (monoid ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118676 (h1 : group (add_monoid linarith.comp_source)) : is_cyclic (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118677 (h0 : functor.add_const (function.extfun (Type 1) filter) (ring Type)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_118678 (h0 : has_lt (add_comm_semigroup enat)) : no_max_order (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_118679 (h0 : ring (finset linarith.comp)) : is_principal_ideal_ring (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_118680 (h1 : topological_space (has_norm (random_gen string_imp))) : path_connected_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_118681 (h0 : topological_space (mul_one_class linarith.comp_source)) : totally_disconnected_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118682 (h0 : group (comm_monoid num)) : is_cyclic (comm_monoid num) := sorry --non-trivial
lemma new_lemma_118683 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118684 (h0 : topological_space (preorder (semiring (option empty)))) : path_connected_space (preorder (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_118685 (h0 : complete_lattice (has_lt enat)) : complete_lattice.is_Sup_finite_compact (has_lt enat) := sorry --non-trivial
lemma new_lemma_118686 (h0 : set (linarith.ineq -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_118687 (h0 : ring (linear_ordered_field empty)) : is_principal_ideal_ring (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_118688 (h0 : functor.add_const (ring (free_add_monoid num)) empty) : @is_domain.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_118689 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_118690 (h0 : ring (ring (ring (ring linarith.comp)))) : rank_condition (ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_118691 (h1 : ring (fintype to_additive.value_type)) : is_domain (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118692 (h0 : topological_space (has_Inf real)) : regular_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_118693 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @totally_disconnected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118694 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : sequential_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118695 (h0 : functor.add_const (finset (has_pos_part environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118696 (h0 : filter (linear_ordered_field (option (option pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_118697 (h0 : functor.add_const (ring (ring linarith.comp)) (has_neg Type)) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_118698 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_compl.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_compl.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118699 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_118700 (h0 : topological_space (random_gen (comm_ring (comm_ring reducibility_hints)))) : totally_disconnected_space (random_gen (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_118701 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_118702 (h0 h1 : multiset (nondiscrete_normed_field (add_comm_semigroup (nondiscrete_normed_field enat)))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_118703 (h1 : filter (has_ssubset (has_append string.iterator_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_118704 (h0 : functor.add_const (filter (linear_order unsigned)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118705 (h0 : group (measure_theory.measure_space (semiring (semiring empty)))) : normalizer_condition (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_118706 (h1 : ring (non_unital_non_assoc_semiring (has_append reducibility_hints))) : strong_rank_condition (non_unital_non_assoc_semiring (has_append reducibility_hints)) := sorry --non-trivial
lemma new_lemma_118707 (h0 : functor.add_const (group (filter empty)) empty) : @group.fg.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_118708 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_118709 (h0 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118710 (h0 : add_monoid (canonically_ordered_comm_semiring (finset (has_to_string name)))) : add_monoid.fg (canonically_ordered_comm_semiring (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_118711 (h0 : functor.add_const (topological_space (has_neg_part pos)) Type) : @discrete_topology.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_118712 (h0 : add_group (linear_order (semiring unsigned))) : is_add_cyclic (linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118713 (h0 : set (has_compl (mul_one_class (mul_one_class to_additive.value_type)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_118714 (h0 : ring (ring (has_Inf real))) : is_domain (ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_118715 (h0 : functor.add_const (add_monoid (monoid_with_zero pos)) unsigned) : @add_monoid.fg.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (monoid_with_zero.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118716 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp))) : @is_domain.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118717 (h0 : semiring (add_cancel_monoid (has_add (add_comm_monoid (has_to_string Type))))) : is_noetherian_ring (add_cancel_monoid (has_add (add_comm_monoid (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_118718 (h0 : functor.add_const (group auto.case_option) (option (option (option (option unsigned))))) : @group.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_118719 (h0 : add_group (mul_zero_class (has_nndist pos))) : is_add_cyclic (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_118720 (h0 : monoid (canonically_ordered_monoid (sub_neg_monoid Type))) : monoid.fg (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_118721 (h0 : not (function.extfun Type (functor.add_const Prop) -> false)) : functor.add_const.run (function.extfun_app (classical.by_contradiction' h0) unsigned) := sorry --non-trivial
lemma new_lemma_118722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118723 (h0 : complete_lattice (semiring (random_gen linarith.comp_source))) : is_compactly_generated (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118724 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : t1_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_118725 (h0 : complete_lattice (semigroup (semiring empty))) : complete_lattice.is_Sup_finite_compact (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_118726 (h0 : topological_space (add_comm_semigroup enat)) (h1 : has_sub (add_comm_semigroup enat)) : has_continuous_sub (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_118727 (h0 : group (has_pos_part reducibility_hints)) : is_cyclic (has_pos_part reducibility_hints) := sorry --non-trivial
lemma new_lemma_118728 (h0 : filter (has_add (option num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118729 (h1 : topological_space (random_gen fun_info)) : irreducible_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_118730 (h0 : functor.add_const (filter (has_neg_part pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118731 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_118732 (h0 : functor.add_const (finset (left_cancel_monoid congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118733 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_118734 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118735 (h0 : function.extfun Type (prod (measure_theory.measure_space unsigned))) : id_rel (function.extfun_app h0 (measure_theory.measure_space unsigned)) := sorry --non-trivial
lemma new_lemma_118736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_118737 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_atomistic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_118738 (h0 : with_bot fun_info -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (with_bot.{0} fun_info) h0  := sorry --non-trivial
lemma new_lemma_118739 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_118740 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118741 (h0 : group (ordered_comm_group (option (option empty)))) : normalizer_condition (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_118742 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118743 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_118744 (h0 : ring (add_comm_monoid linarith.comp)) : is_principal_ideal_ring (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_118745 (h0 : complete_lattice (add_cancel_monoid (finset (finset (has_add ennreal))))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (finset (finset (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_118746 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_118747 (h0 : topological_space (add_cancel_monoid (has_add pos))) : sequential_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_118748 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_118749 (h0 : functor.add_const (list (add_left_cancel_semigroup empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118750 (h0 : topological_space (has_neg_part (cancel_monoid (has_to_string ennreal)))) : normal_space (has_neg_part (cancel_monoid (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_118751 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118752 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118753 (h0 : ring (add_cancel_monoid (has_neg Type))) : rank_condition (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_118754 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_118755 (h0 : ring (topological_space (has_nnnorm to_additive.value_type))) : is_domain (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_118756 (h2 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_118757 (h0 : topological_space (metric_space (semiring (semiring congr_arg_kind)))) : normal_space (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_118758 (h0 : functor.add_const (uniform_space (has_zero name)) name) : @complete_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_118759 (h0 : function.extfun (topological_space fun_info -> false) (fun (x : topological_space fun_info -> false), false)) : @totally_disconnected_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) (@function.extfun_app.{0 0} (topological_space.{0} fun_info → false) (λ (x : topological_space.{0} fun_info → false), false) h0))  := sorry --non-trivial
lemma new_lemma_118760 (h1 : ring (dlist (has_ssubset char))) : rank_condition (dlist (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_118761 (h0 : add_group (measurable_space (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_118762 (h0 : topological_space (sub_neg_monoid real)) : path_connected_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_118763 (h0 : topological_space (cancel_monoid unsigned)) : topological_space.separable_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_118764 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_118765 (h0 : complete_lattice (measurable_space (has_top linarith.comp_source))) : is_compactly_generated (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_118766 (h0 : add_monoid (has_zero (has_add ennreal))) : add_monoid.fg (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_118767 (h0 : functor.add_const (function.extfun Type topological_space) (finset (finset pos))) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (finset.{0} pos)) h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_118768 (h0 : ring (has_ssubset to_additive.value_type)) : is_domain (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118769 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : topological_space.separable_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118770 (h0 : function.extfun (Type 1) (functor.comp monoid finset)) : @monoid.fg.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} monoid.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_118771 (h1 : has_lt (has_ssubset (has_dist (has_ssubset environment.projection_info)))) : no_max_order (has_ssubset (has_dist (has_ssubset environment.projection_info))) := sorry --non-trivial
lemma new_lemma_118772 (h0 : topological_space (left_cancel_monoid (semiring unsigned))) : discrete_topology (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118773 (h1 : ring (with_zero (has_inv (has_nnnorm linarith.ineq)))) : is_domain (with_zero (has_inv (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_118774 (h0 : complete_lattice (finset (has_neg_part pos))) : is_atomistic (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_118775 (h0 : topological_space (preorder (option (option unsigned)))) : normal_space (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_118776 (h0 : ordered_add_comm_monoid (has_zero (pseudo_metric_space unsigned))) : archimedean (has_zero (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_118777 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_118778 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add (has_add (has_add name))))))) : normal_space (boolean_algebra (has_add (has_add (has_add (has_add (has_add name)))))) := sorry --non-trivial
lemma new_lemma_118779 (h0 : group (has_to_string (has_neg (has_add (has_add (has_Inf pos)))))) : normalizer_condition (has_to_string (has_neg (has_add (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_118780 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_118781 (h0 : partial_order empty) (h1 : not (filter (partial_order empty) -> false)) : @totally_separated_space.{0} (partial_order.{0} empty) (@nhds_adjoint.{0} (partial_order.{0} empty) h0 (@classical.by_contradiction'.{1} (filter.{0} (partial_order.{0} empty)) h1))  := sorry --non-trivial
lemma new_lemma_118782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118783 (h0 : topological_space (normed_group (denumerable (denumerable (denumerable linarith.ineq))))) : t0_space (normed_group (denumerable (denumerable (denumerable linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118784 (h0 h1 : not (multiset (semi_normed_ring reducibility_hints) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_118785 (h0 : topological_space (generalized_boolean_algebra (has_nndist Type))) : preconnected_space (generalized_boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_118786 (h0 : functor.add_const (monoid (has_star empty)) (semiring empty)) : @monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_star.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118787 (h0 : topological_space (has_pos_part (has_neg name))) : regular_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_118788 (h0 : ring (has_compl (comm_ring (comm_ring linarith.comp_source)))) : is_domain (has_compl (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_118789 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_118790 (h0 : functor.add_const (complete_lattice (has_inter empty)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_118791 (h0 : functor.add_const (topological_space (linear_order unsigned)) unsigned) : @topological_space.separable_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_118792 (h0 : functor.add_const (list (ring name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118793 (h1 : complete_lattice (topological_space linarith.comp_source)) : is_compactly_generated (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118794 (h0 : functor.comp ring complete_distrib_lattice Type) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_118795 (h2 h3 : multiset enat) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_118796 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118797 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : totally_disconnected_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_118798 (h0 : topological_space (ring (has_neg environment.implicit_infer_kind))) : discrete_topology (ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118799 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (sub_neg_monoid.{0} (has_neg.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} (has_neg.{0} name)))  := sorry --non-trivial
lemma new_lemma_118800 (h0 : ring (add_group (semiring unsigned))) : is_principal_ideal_ring (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118801 (h0 : uniform_space (non_unital_non_assoc_semiring (uniform_space linarith.ineq))) : complete_space (non_unital_non_assoc_semiring (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118802 (h0 : topological_space (simple_graph string.iterator_imp)) : path_connected_space (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_118803 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118804 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) (h1 : punit) : @category_theory.hom_of_element.{0} Prop (@discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)) h1  := sorry --non-trivial
lemma new_lemma_118805 (h0 : ring (add_cancel_monoid (comm_group pos))) : is_domain (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_118806 (h0 : topological_space (has_one (has_norm unsigned))) : discrete_topology (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_118807 (h0 : topological_space (has_add ennreal)) : discrete_topology (has_add ennreal) := sorry --non-trivial
lemma new_lemma_118808 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_118809 (h0 : functor.add_const (list (measure_theory.measure_space unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118810 (h0 : topological_space (has_to_string (option (option ennreal)))) : preirreducible_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_118811 (h0 : group (semiring (random_gen fun_info))) : normalizer_condition (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_118812 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118813 (h0 : topological_space (has_bot (has_add Type))) : locally_compact_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_118814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_118815 (h0 : topological_space (has_add unsigned)) : loc_path_connected_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_118816 (h0 : group (add_cancel_comm_monoid (has_nnnorm char))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_118817 (h0 : topological_space (has_to_string (has_add name))) : loc_path_connected_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_118818 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_118819 (h0 : not (semiring (mul_zero_class (semiring (semiring (semiring (semiring congr_arg_kind))))) -> false)) : @is_noetherian_ring.{0} (mul_zero_class.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))) (@classical.by_contradiction'.{1} (semiring.{0} (mul_zero_class.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) h0)  := sorry --non-trivial
lemma new_lemma_118820 (h0 : ring (linear_ordered_add_comm_group char)) : rank_condition (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_118821 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_118822 (h0 : ring (add_cancel_monoid (has_neg (has_neg (has_neg (finset linarith.comp)))))) : is_principal_ideal_ring (add_cancel_monoid (has_neg (has_neg (has_neg (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_118823 (h1 : list (with_one linarith.comp_source)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_118824 (h0 : list (with_one linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118825 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118826 (h0 : functor.add_const (list (cancel_monoid pos)) (has_add name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118827 (h0 : monoid (with_one (comm_ring (random_gen (has_inv (comm_ring fun_info)))))) : monoid.fg (with_one (comm_ring (random_gen (has_inv (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_118828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118829 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118830 (h0 : uniform_space (semigroup (option (option empty)))) : separated_space (semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_118831 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118832 (h0 : topological_space (finset (option ennreal))) : loc_path_connected_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_118833 (h0 : functor.add_const (ring (option unsigned)) empty) : @is_domain.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_118834 (h0 : add_group (has_union (has_top congr_arg_kind))) : is_add_cyclic (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118835 (h0 : ring (sub_neg_monoid (has_neg Type))) : rank_condition (sub_neg_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_118836 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_118838 (h0 : functor.add_const (topological_space (ring pos)) (boolean_algebra linarith.comp)) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_118839 (h0 : functor.add_const (ring (has_edist num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_118840 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string pos)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118841 (h0 : ordered_comm_monoid (cancel_monoid (option ennreal))) : has_exists_mul_of_le (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_118842 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (has_neg environment.implicit_infer_kind)) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_118843 (h0 : not (complete_lattice (linear_ordered_semiring num) -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_118844 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) Type) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_118845 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @t0_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_118846 (h0 : monoid (has_dist num)) : monoid.fg (has_dist num) := sorry --non-trivial
lemma new_lemma_118847 (h0 : add_group (ordered_comm_ring (has_add name))) : is_add_cyclic (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_118848 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_118849 (h0 : functor.add_const (group (has_nndist unsigned)) name) : @group.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_118850 (h0 : topological_space (linear_ordered_field unsigned)) : preirreducible_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_118851 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @group.fg.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_118852 (h1 : group (semi_normed_comm_ring (comm_ring char))) : is_cyclic (semi_normed_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_118853 (h0 : topological_space fun_info) : path_connected_space fun_info := sorry --non-trivial
lemma new_lemma_118854 (h0 : semiring (has_union empty)) : is_noetherian_ring (has_union empty) := sorry --non-trivial
lemma new_lemma_118855 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118856 (h0 : topological_space (linear_ordered_semiring empty)) : locally_compact_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_118857 (h2 : topological_space (random_gen char)) : path_connected_space (random_gen char) := sorry --non-trivial
lemma new_lemma_118858 (h0 : complete_lattice (has_sub (has_top (has_top (has_top (has_top (semiring (has_top empty)))))))) : is_compactly_generated (has_sub (has_top (has_top (has_top (has_top (semiring (has_top empty))))))) := sorry --non-trivial
lemma new_lemma_118859 (h0 : functor.comp topological_space has_to_string Type) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_118860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_118861 (h0 : functor.add_const (uniform_space (finset Type)) linarith.comp) : @complete_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_118862 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_118863 (h0 : has_mem.mem fin has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} linarith.ineq) (@matrix.vec_empty.{0} (group.{0} (measurable_space.{0} linarith.ineq)) (@function.extfun_app.{1 1} nat fin (@finset.pi.empty.{1 0} (nat → Type) (function.extfun.{1 1} nat) fin h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118864 (h0 : complete_lattice (option to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (option to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118865 (h0 : add_group (random_gen (has_norm num))) : is_add_cyclic (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_118866 (h0 : group (option (semiring (semiring num)))) : group.fg (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_118867 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid Type))) : locally_compact_space (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_118868 (h0 : add_monoid (has_one (has_top congr_arg_kind))) : add_monoid.fg (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118869 (h0 : list (linear_ordered_cancel_comm_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_118870 (h0 : fin has_zero.zero) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_118871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118872 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_118873 (h1 : topological_space (has_append (has_nnnorm (has_nnnorm reducibility_hints)))) : path_connected_space (has_append (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_118874 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (has_top empty))) : unique_factorization_monoid (left_cancel_semigroup (has_top empty)) := sorry --non-trivial
lemma new_lemma_118875 (h0 : topological_space (linear_ordered_comm_ring (mul_zero_class empty))) : t1_space (linear_ordered_comm_ring (mul_zero_class empty)) := sorry --non-trivial
lemma new_lemma_118876 (h1 : add_group (metric_space linarith.comp)) : is_add_cyclic (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_118877 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_118878 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) topological_space.{0}) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118879 (h0 : group (random_gen (random_gen linarith.comp))) : normalizer_condition (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_118880 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : path_connected_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_118881 (h0 : ring (has_one (has_top unsigned))) : strong_rank_condition (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_118882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118883 (h0 : not (finset (left_cancel_semigroup congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_118884 (h0 : group (normed_group (semiring (semiring congr_arg_kind)))) : group.fg (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_118885 (h0 : not (ring (has_one num) -> false)) : @rank_condition.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_118886 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (semiring (semiring (semiring num)))) : @t1_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_118887 (h0 : topological_space (has_ssubset (random_gen (has_ssubset (random_gen linarith.ineq))))) : totally_disconnected_space (has_ssubset (random_gen (has_ssubset (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_118888 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_118889 (h1 : has_lt (has_lt enat)) : no_max_order (has_lt enat) := sorry --non-trivial
lemma new_lemma_118890 (h0 : uniform_space (has_to_string (comm_group Type))) : separated_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_118891 (h0 : add_monoid (linear_ordered_comm_ring num)) : add_monoid.fg (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_118892 (h0 : fin has_zero.zero) : @t0_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_118893 (h0 : add_monoid fun_info) (h1 : has_one fun_info) : char_zero fun_info := sorry --non-trivial
lemma new_lemma_118894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_118895 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class string_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_118896 (h0 : not (ring (non_assoc_semiring num) -> false)) : @strong_rank_condition.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_118897 (h0 : not (ring (with_one congr_arg_kind) -> false)) : @rank_condition.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_118898 (h0 : add_monoid (with_one unsigned)) : add_monoid.fg (with_one unsigned) := sorry --non-trivial
lemma new_lemma_118899 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @loc_path_connected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_118900 (h0 : list (has_nndist (boolean_algebra.core ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118901 (h0 : uniform_space (dlist (random_gen linarith.ineq))) : complete_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118902 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118903 (h1 : ring (add_monoid (has_nnnorm linarith.ineq))) : strong_rank_condition (add_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_118904 (h0 : topological_space (random_gen (semiring (semiring (semiring fun_info))))) : irreducible_space (random_gen (semiring (semiring (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_118905 (h0 : functor.add_const (topological_space (comm_group ennreal)) pos) : @preconnected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_118906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_right_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_118907 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normal_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_118908 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (semigroup.{1} (has_add.{1} Type)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_118909 (h0 : complete_lattice (has_norm (random_gen (random_gen linarith.comp_source)))) : is_compactly_generated (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_118910 (h0 : topological_space (ring environment.implicit_infer_kind)) : t0_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_118911 (h0 : ring (random_gen (semiring unsigned))) : strong_rank_condition (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_118912 (h0 : ring (semi_normed_ring (has_ssubset char))) : rank_condition (semi_normed_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_118913 (h0 : group (has_inv (has_top (random_gen (random_gen fun_info))))) : normalizer_condition (has_inv (has_top (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_118914 (h0 : not (ring (measurable_space.dynkin_system linarith.comp) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_118915 (h0 : cancel_comm_monoid_with_zero (has_nndist (option num))) : unique_factorization_monoid (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_118916 (h0 : monoid (has_norm (has_norm (has_norm num)))) : monoid.fg (has_norm (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_118917 (h0 : functor.add_const (filter (semigroup (mul_one_class linarith.comp))) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118918 (h0 : topological_space (has_neg_part (has_add Type))) : path_connected_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_118919 (h0 : filter (uniform_space (encodable fun_info))) : @complete_space.{0} (encodable.{0} fun_info) (@filter.Limsup.{0} (uniform_space.{0} (encodable.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (encodable.{0} fun_info)) (@uniform_space.complete_lattice.{0} (encodable.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_118920 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_118921 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_118922 (h0 : topological_space (canonically_linear_ordered_monoid (complete_distrib_lattice pos))) : t1_space (canonically_linear_ordered_monoid (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_118923 (h1 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_118924 (h0 : not (add_group (normed_field (mul_one_class (has_neg string_imp))) -> false)) : @is_add_cyclic.{0} (normed_field.{0} (mul_one_class.{0} (has_neg.{0} string_imp))) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} (mul_one_class.{0} (has_neg.{0} string_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_118925 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring pos)) : unique_factorization_monoid (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_118926 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part pos)) (has_neg (boolean_algebra (boolean_algebra name)))) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} pos)) (has_neg.{0} (boolean_algebra.{0} (boolean_algebra.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_118927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_118928 (h0 : preorder (add_comm_semigroup (mul_one_class char))) (h1 : topological_space (add_comm_semigroup (mul_one_class char))) : Inf_convergence_class (add_comm_semigroup (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_118929 (h0 : functor.add_const (ring (has_nndist pos)) (finset pos)) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_118930 (h0 : complete_lattice (complete_distrib_lattice (has_add (has_add unsigned)))) : is_compactly_generated (complete_distrib_lattice (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_118931 (h0 : topological_space (cancel_monoid (option empty))) : t1_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_118932 (h0 : functor.add_const (group ennreal) ennreal) : @is_simple_group.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_118933 (h1 h2 : multiset (has_div linarith.comp_source)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_118934 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_118935 (h1 : ring (semi_normed_comm_ring (distrib string.iterator_imp))) : rank_condition (semi_normed_comm_ring (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_118936 (h0 : complete_lattice (linear_ordered_semiring fun_info)) : is_atomistic (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_118937 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_one.{0} (has_one.{0} (has_one.{0} (has_one.{0} (semiring.{0} (has_one.{0} (has_one.{0} num))))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} (has_one.{0} (has_one.{0} (has_one.{0} (semiring.{0} (has_one.{0} (has_one.{0} num))))))))  := sorry --non-trivial
lemma new_lemma_118938 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @t0_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_118939 (h0 : monoid (has_ssubset linarith.comp_source)) : monoid.fg (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_118940 (h0 : fin has_zero.zero) : @preconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_118941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_118942 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @separated_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_118943 (h0 : functor.add_const (group (has_to_string Type)) (ring environment.implicit_infer_kind)) : @is_simple_group.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_118944 (h0 : list (has_top (random_gen (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_118945 (h0 : group (id (random_gen (random_gen string_imp)))) : normalizer_condition (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_118946 (h1 : function.extfun (finset Type) (has_mem.mem linarith.ineq)) : @monoid.fg.{0} linarith.ineq (@finset.pi.empty.{1 0} Type monoid.{0} linarith.ineq (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_118947 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option (option num)))) : archimedean (ordered_cancel_add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_118948 (h0 : functor.add_const (monoid (comm_group environment.implicit_infer_kind)) (boolean_algebra name)) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_118949 (h0 : complete_lattice (random_gen (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (random_gen (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_118950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_118951 (h0 : complete_distrib_lattice ennreal -> complete_distrib_lattice ennreal -> Prop) : is_symm (complete_distrib_lattice ennreal) h0 := sorry --non-trivial
lemma new_lemma_118952 (h0 : group (linear_ordered_cancel_comm_monoid empty)) : group.fg (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_118953 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_118954 (h0 : uniform_space (cancel_monoid (option (option empty)))) : complete_space (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_118955 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_118956 (h1 : ring (linear_ordered_add_comm_group to_additive.value_type)) : rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_118957 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_Inf pos)) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_118958 (h0 : topological_space (has_to_string (has_add (add_cancel_monoid pos)))) : t1_space (has_to_string (has_add (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_118959 (h0 : complete_lattice (with_bot (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_118960 (h0 : functor.add_const (topological_space (comm_group ennreal)) name) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_118961 (h0 : finset (has_neg (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118962 (h0 : group (semigroup (has_nndist pos))) : is_cyclic (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_118963 (h0 : function.extfun Type (functor.add_const (complete_lattice (ordered_ring empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_118964 (h0 : topological_space (plift (semiring (semiring (semiring (semiring congr_arg_kind)))))) : discrete_topology (plift (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_118965 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (finset (finset linarith.comp))) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_118966 (h0 : topological_space (semiring empty)) : t1_space (semiring empty) := sorry --non-trivial
lemma new_lemma_118967 (h0 : topological_space (boolean_algebra (finset (has_pos_part (finset Type))))) : t1_space (boolean_algebra (finset (has_pos_part (finset Type)))) := sorry --non-trivial
lemma new_lemma_118968 (h0 : has_nndist ennreal -> has_nndist ennreal -> Prop) : is_symm (has_nndist ennreal) h0 := sorry --non-trivial
lemma new_lemma_118969 (h0 : semiring (has_union (has_union congr_arg_kind))) : is_noetherian_ring (has_union (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_118970 (h0 : topological_space (non_unital_non_assoc_semiring ereal)) : t0_space (non_unital_non_assoc_semiring ereal) := sorry --non-trivial
lemma new_lemma_118971 (h0 : topological_space (measurable_space unsigned)) : locally_compact_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_118972 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg Type))) : t1_space (canonically_linear_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_118973 (h0 : not (group (has_inv linarith.ineq) -> false)) : @is_cyclic.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_118974 (h0 : filter (ring (add_cancel_monoid Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118975 (h0 : complete_lattice (omega_complete_partial_order (option (option (option (option (option unsigned))))))) : is_atomistic (omega_complete_partial_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_118976 (h0 : topological_space (distrib_lattice (random_gen (random_gen (random_gen fun_info))))) : locally_compact_space (distrib_lattice (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_118977 (h0 : functor.add_const (function.extfun Type group) (has_add Type)) : @is_simple_group.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_add.{1} Type) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_118978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_118979 (h0 : functor.add_const (semiring (has_add linarith.comp)) Type) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_118980 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_118981 (h0 : complete_lattice (with_one (measurable_space empty))) : is_compactly_generated (with_one (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_118982 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_118983 (h0 : monoid (measure_theory.measure_space (semiring num))) : monoid.fg (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_118984 (h0 : group (mul_zero_class (option (has_add (option ennreal))))) : is_simple_group (mul_zero_class (option (has_add (option ennreal)))) := sorry --non-trivial
lemma new_lemma_118985 (h0 : functor.add_const (finset (normed_comm_ring unsigned)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_118986 (h0 : topological_space (denumerable (denumerable (denumerable char)))) : t0_space (denumerable (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_118987 (h0 : ring (has_Inf (has_neg pos))) : is_domain (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_118988 (h0 : topological_space (boolean_algebra.core (semigroup environment.implicit_infer_kind))) : topological_space.separable_space (boolean_algebra.core (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118989 (h0 : complete_lattice (with_one (mul_one_class (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (with_one (mul_one_class (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_118990 (h0 : filter (add_left_cancel_monoid (random_gen (with_one linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_118991 (h0 : topological_space (normed_comm_ring (ring environment.implicit_infer_kind))) : t1_space (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_118992 (h0 : functor.add_const (group (normed_comm_ring name)) Type) : @is_simple_group.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_118993 (h0 : uniform_space (has_top (has_top (has_top (has_top fun_info))))) : complete_space (has_top (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_118994 (h0 : finset (canonically_ordered_add_monoid (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_118995 (h0 : functor.add_const (function.extfun (Type 1) monoid) (finset Type)) : @monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (finset.{1} Type) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_118996 (h1 : ring (has_lt char)) : is_domain (has_lt char) := sorry --non-trivial
lemma new_lemma_118997 (h0 : preorder (has_scalar ennreal ennreal)) (h1 : topological_space (has_scalar ennreal ennreal)) : Inf_convergence_class (has_scalar ennreal ennreal) := sorry --non-trivial
lemma new_lemma_118998 (h0 : topological_space (add_cancel_monoid (has_pos_part (finset Type)))) : t1_space (add_cancel_monoid (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_118999 (h0 : uniform_space (has_to_string (option (option unsigned)))) : complete_space (has_to_string (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119000 (h0 : complete_lattice (has_lt reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_119001 (h0 : ordered_add_comm_monoid (complete_linear_order (option unsigned))) : archimedean (complete_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_119002 (h0 : topological_space enat) : totally_disconnected_space enat := sorry --non-trivial
lemma new_lemma_119003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_119004 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119005 (h0 : topological_space (sub_neg_monoid (has_neg name))) : preconnected_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_119006 (h0 : finset (has_bot (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119007 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_119008 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) (has_neg environment.implicit_infer_kind)) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_119009 (h0 : ring (has_to_string (finset ennreal))) : rank_condition (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_119010 (h0 : list (comm_group (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_119011 (h0 : functor.add_const (uniform_space (finset pos)) pos) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_119012 (h0 : prod (has_zero (has_add (has_to_string unsigned))) (has_zero (has_add (has_to_string unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_119013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_119014 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (has_neg pos)) : @add_monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (has_neg.{0} pos) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_119015 (h0 : finset (has_dist congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119016 (h0 : group (normed_comm_ring (has_nndist linarith.comp))) : is_simple_group (normed_comm_ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_119017 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119018 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_119019 (h1 : not (ring (distrib_lattice fun_info) -> false)) : @rank_condition.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_119020 (h0 : finset (simple_graph (boolean_algebra.core pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119021 (h0 : prod (add_left_cancel_semigroup (option unsigned)) (add_left_cancel_semigroup (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_119022 (h0 : complete_lattice (has_norm congr_arg_kind)) : is_compactly_generated (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119023 (h0 : group (finset (option (option unsigned)))) : group.fg (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119024 (h0 : ring (uniform_space (random_gen linarith.comp_source))) : is_domain (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119025 (h0 : monoid (comm_group (has_to_string (has_to_string name)))) : monoid.fg (comm_group (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_119026 (h0 : topological_space (metric_space (semiring (semiring unsigned)))) : discrete_topology (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_119027 (h0 : list (canonically_ordered_comm_semiring (has_add (has_add Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_119028 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_119029 (h0 : ordered_add_comm_monoid (ordered_ring num)) : archimedean (ordered_ring num) := sorry --non-trivial
lemma new_lemma_119030 (h0 : functor.add_const (topological_space (has_Inf Type)) (ring Type)) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_119031 (h0 : list (add_cancel_monoid (has_neg (add_cancel_monoid linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119032 (h0 : list (with_one (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119033 (h0 : ring (comm_group environment.implicit_infer_kind)) : is_domain (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_119034 (h0 : function.extfun Type topological_space) : @normal_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_119035 (h0 : functor.add_const (add_monoid (has_neg pos)) Type) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_119036 (h0 : ring (cancel_monoid name)) : is_principal_ideal_ring (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_119037 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_add_cyclic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type add_group.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_119038 (h0 : function.extfun (function.extfun Type monoid -> false) (fun (x : function.extfun Type monoid -> false), false)) : @monoid.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) (@function.extfun_app.{0 0} (function.extfun.{2 1} Type monoid.{0} → false) (λ (x : function.extfun.{2 1} Type monoid.{0} → false), false) h0)) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_119039 (h0 : complete_lattice (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_compactly_generated (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119040 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_119041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119042 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119043 (h0 : topological_space (with_one (has_top fun_info))) : t0_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_119044 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : preconnected_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119045 (h3 : prod ereal ereal) : set.diagonal ereal h3 := sorry --non-trivial
lemma new_lemma_119046 (h0 : not (topological_space (has_dist to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_dist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_dist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_119047 (h0 : monoid (free_add_monoid (option unsigned))) : monoid.fg (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_119048 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : locally_compact_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_119049 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : totally_disconnected_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119050 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (has_zero Type)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_119051 (h0 : topological_space (with_bot (random_gen (random_gen linarith.comp)))) : locally_compact_space (with_bot (random_gen (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_119052 (h0 : complete_lattice (finset (finset Type))) : is_compactly_generated (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_119053 (h0 : functor.add_const (group (sub_neg_monoid linarith.comp)) pos) : @is_simple_group.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_119054 (h0 : functor.add_const (function.extfun (Type 1) add_group) (has_neg linarith.comp)) : @is_add_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) (has_neg.{0} linarith.comp) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_119055 (h0 : functor.add_const (group (ring name)) Type) : @group.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_119056 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @discrete_topology.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119057 (h0 : function.extfun Type topological_space) : @regular_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_119058 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @totally_disconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_119059 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_119061 (h0 : group (add_left_cancel_semigroup (semiring (semiring (semiring empty))))) : normalizer_condition (add_left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_119062 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_119063 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_119064 (h0 : functor.add_const (filter (has_nndist congr_arg_kind)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119065 (h0 : ring (mul_zero_class reducibility_hints)) : rank_condition (mul_zero_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_119066 (h0 : uniform_space (random_gen (random_gen linarith.ineq))) : complete_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119067 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_119069 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_119070 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) num) : @loc_path_connected_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_119071 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119072 (h0 : add_monoid unsigned) : add_monoid.fg unsigned := sorry --non-trivial
lemma new_lemma_119073 (h0 : functor.add_const (list (has_to_string pos)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119074 (h1 : complete_lattice (linear_ordered_add_comm_group (random_gen char))) : is_compactly_generated (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_119075 (h0 : topological_space (mul_zero_class (semiring (semiring (semiring congr_arg_kind))))) : totally_disconnected_space (mul_zero_class (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_119076 (h0 : topological_space (has_nndist (option unsigned))) : irreducible_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_119077 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_star num)) := sorry --non-trivial
lemma new_lemma_119078 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119079 (h0 : complete_lattice (add_comm_monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_119080 (h2 : enat -> enat -> enat) (h3 : enat) : right_identity h2 h3 := sorry --non-trivial
lemma new_lemma_119081 (h0 : pseudo_metric_space ennreal -> pseudo_metric_space ennreal -> Prop) : is_trans (pseudo_metric_space ennreal) h0 := sorry --non-trivial
lemma new_lemma_119082 (h0 : topological_space (add_comm_monoid (has_bot (has_bot (sub_neg_monoid pos))))) : t1_space (add_comm_monoid (has_bot (has_bot (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_119083 (h0 : topological_space (simple_graph empty)) : normal_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_119084 (h0 : topological_space (boolean_algebra.core linarith.comp)) : discrete_topology (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_119085 (h0 : filter (has_pos_part (has_neg Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_119086 (h0 : uniform_space (boolean_algebra linarith.comp)) : separated_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_119087 (h0 : uniform_space (ordered_comm_ring (has_Inf (has_bot Type)))) : complete_space (ordered_comm_ring (has_Inf (has_bot Type))) := sorry --non-trivial
lemma new_lemma_119088 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_119089 (h0 : uniform_space (has_top (has_top (has_norm to_additive.value_type)))) : complete_space (has_top (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_119090 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : totally_separated_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_119091 (h0 : has_coe reducibility_hints Prop) (h1 : reducibility_hints) : @coe_b.{1 1} reducibility_hints Prop h0 h1  := sorry --non-trivial
lemma new_lemma_119092 (h0 : topological_space (has_bot (has_bot real))) : t1_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_119093 (h0 : topological_space (semiring (has_norm unsigned))) : t0_space (semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_119094 (h0 : group (comm_ring (mul_one_class (non_unital_non_assoc_semiring to_additive.value_type)))) : is_cyclic (comm_ring (mul_one_class (non_unital_non_assoc_semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_119095 (h0 : uniform_space (semiring num)) : separated_space (semiring num) := sorry --non-trivial
lemma new_lemma_119096 (h0 : ring (semi_normed_ring (partial_order reducibility_hints))) : rank_condition (semi_normed_ring (partial_order reducibility_hints)) := sorry --non-trivial
lemma new_lemma_119097 (h0 : topological_space (normed_group (semiring (semiring linarith.comp)))) : locally_compact_space (normed_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_119098 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_119099 (h0 : not (add_group string_imp -> false)) : @is_add_cyclic.{0} string_imp (@classical.by_contradiction'.{1} (add_group.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_119100 (h0 : finset (add_comm_monoid (has_add (has_to_string name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119101 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : t1_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119102 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @normal_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119103 (h0 : topological_space (random_gen string.iterator_imp)) : t0_space (random_gen string.iterator_imp) := sorry --non-trivial
lemma new_lemma_119104 (h0 : function.extfun Type group) : @group.fg.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119105 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @locally_compact_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119106 (h0 : uniform_space (canonically_linear_ordered_monoid real)) : complete_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_119107 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup environment.implicit_infer_kind)) linarith.comp) : @unique_factorization_monoid.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119108 (h0 : not (filter (partial_order num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_119109 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119110 (h1 : topological_space (nondiscrete_normed_field ereal)) (h2 : preorder (nondiscrete_normed_field ereal)) : order_topology (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_119111 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : discrete_topology (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_119112 (h0 : uniform_space (has_append (denumerable char))) : complete_space (has_append (denumerable char)) := sorry --non-trivial
lemma new_lemma_119113 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup unsigned)) congr_arg_kind) : @archimedean.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_119114 (h0 : function.extfun nat fin) : @is_noetherian_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119115 (h0 : functor.add_const (complete_lattice (ring name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119116 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_119117 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_119118 (h0 : ring (has_div linarith.ineq)) : rank_condition (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_119119 (h0 : topological_space (id num)) : totally_separated_space (id num) := sorry --non-trivial
lemma new_lemma_119120 (h0 : add_group (comm_semigroup real)) : is_add_cyclic (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_119121 (h0 : topological_space (left_cancel_semigroup empty)) : loc_path_connected_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_119122 (h0 : topological_space (add_group (has_norm (semiring (has_norm (semiring num)))))) : preirreducible_space (add_group (has_norm (semiring (has_norm (semiring num))))) := sorry --non-trivial
lemma new_lemma_119123 (h0 : topological_space (complete_semilattice_Sup (encodable to_additive.value_type))) : path_connected_space (complete_semilattice_Sup (encodable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119124 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_119125 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_119126 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_119127 (h0 : filter (has_neg_part (cancel_monoid ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119128 (h0 : not (topological_space (has_one (random_gen congr_arg_kind)) -> false)) : @totally_disconnected_space.{0} (has_one.{0} (random_gen.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} (random_gen.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_119129 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119130 (h0 : function.extfun Type topological_space) : @regular_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119131 (h0 : topological_space (has_add real)) : t1_space (has_add real) := sorry --non-trivial
lemma new_lemma_119132 (h0 : group (linear_ordered_comm_monoid_with_zero (mul_one_class Type))) : is_simple_group (linear_ordered_comm_monoid_with_zero (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_119133 (h0 : complete_lattice (linear_ordered_field (has_add ennreal))) : is_atomistic (linear_ordered_field (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_119134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_119135 (h0 : complete_lattice (with_bot (random_gen num))) : is_compactly_generated (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_119136 (h0 : fin has_zero.zero) : @is_cyclic.{1} (plift.{1} unsigned) (@matrix.vec_empty.{1} (group.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119137 (h0 : topological_space (mul_zero_class (has_add Type))) : t1_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_119138 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_119139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_119140 (h1 : filter (denumerable linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_119141 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119142 (h0 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) (h1 : add_group (mul_one_class (mul_one_class string.iterator_imp))) : topological_add_group (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_119143 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_119145 (h0 : complete_lattice (complete_semilattice_Sup fun_info)) : is_compactly_generated (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_119146 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : totally_disconnected_space (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_119147 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) (ring (has_add Type))) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_Inf.{0} linarith.comp)) (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_119148 (h0 : ring (complete_distrib_lattice string.iterator_imp)) : strong_rank_condition (complete_distrib_lattice string.iterator_imp) := sorry --non-trivial
lemma new_lemma_119149 (h0 : fin has_zero.zero) : @is_simple_group.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_119150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_119151 (h0 : ring (linear_ordered_field (has_nnnorm (has_nnnorm char)))) : strong_rank_condition (linear_ordered_field (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_119152 (h0 : add_group (has_neg_part (option (option unsigned)))) : is_add_cyclic (has_neg_part (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119153 (h0 : function.extfun Type (functor.add_const (group pos))) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_119154 (h0 : topological_space (mul_zero_class (finset Type))) : normal_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_119155 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_119156 (h0 : functor.add_const (filter (has_to_string Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119157 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf real)))) : normal_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_119158 (h0 : topological_space (preorder empty)) : irreducible_space (preorder empty) := sorry --non-trivial
lemma new_lemma_119159 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_119160 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119161 (h0 : topological_space (ring Type)) : normal_space (ring Type) := sorry --non-trivial
lemma new_lemma_119162 (h0 : topological_space (has_dist (option (option empty)))) : loc_path_connected_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_119163 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} (semiring.{0} (semiring.{0} num))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} (semiring.{0} (semiring.{0} num))))  := sorry --non-trivial
lemma new_lemma_119164 (h0 : add_group (with_zero (has_nnnorm linarith.ineq))) : is_add_cyclic (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119165 (h0 : topological_space (with_bot (semiring (semiring (semiring (semiring empty)))))) : t0_space (with_bot (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_119166 (h0 : topological_space (has_add (finset Type))) : path_connected_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_119167 (h0 : topological_space (mul_zero_class (normed_comm_ring (add_comm_monoid (normed_comm_ring Type))))) : discrete_topology (mul_zero_class (normed_comm_ring (add_comm_monoid (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_119168 (h0 : functor.comp topological_space has_add name) : @path_connected_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_119169 (h0 : functor.add_const (monoid (has_zero Type)) pos) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_119170 (h0 : not (complete_lattice (option unsigned) -> false)) : @is_atomistic.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119171 (h0 : not (semiring (plift unsigned) -> false)) : @is_noetherian_ring.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (semiring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119172 (h0 : semiring (boolean_algebra (has_pos_part (metric_space linarith.comp)))) : is_noetherian_ring (boolean_algebra (has_pos_part (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_119173 (h0 : add_monoid (complete_distrib_lattice ennreal)) : add_monoid.fg (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_119174 (h1 : topological_space (non_unital_non_assoc_semiring char)) (h2 : has_inf (non_unital_non_assoc_semiring char)) : has_continuous_inf (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_119175 (h1 : topological_space (normed_field char)) : path_connected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_119176 (h0 : function.extfun Type topological_space) (h1 : function.extfun Type measurable_space) : @opens_measurable_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_119177 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119179 (h0 : monoid (measurable_space (has_norm (random_gen linarith.comp_source)))) : monoid.fg (measurable_space (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_119180 (h1 : uniform_space (has_top fun_info)) : complete_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_119181 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string name)) name) : @unique_factorization_monoid.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119182 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_119183 (h0 : function.extfun Type (functor.comp group has_zero)) : @normalizer_condition.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_119184 (h0 : functor.add_const (finset (has_Inf name)) (ring name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119185 (h0 : topological_space (canonically_ordered_comm_semiring (finset (finset (finset ennreal))))) : preirreducible_space (canonically_ordered_comm_semiring (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_119186 (h0 : uniform_space (simple_graph enat)) : complete_space (simple_graph enat) := sorry --non-trivial
lemma new_lemma_119187 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : discrete_topology (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_119188 (h1 : topological_space (has_le (simple_graph string.iterator_imp))) : path_connected_space (has_le (simple_graph string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_119189 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119190 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_add linarith.comp))) : unique_factorization_monoid (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_119191 (h1 : complete_lattice (has_inv (random_gen (random_gen (has_ssubset (has_ssubset string_imp)))))) : is_compactly_generated (has_inv (random_gen (random_gen (has_ssubset (has_ssubset string_imp))))) := sorry --non-trivial
lemma new_lemma_119192 (h0 : ring (canonically_linear_ordered_monoid ennreal)) : is_domain (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_119193 (h0 : ring (has_ssubset (has_nnnorm (has_nnnorm (mul_one_class reducibility_hints))))) : is_domain (has_ssubset (has_nnnorm (has_nnnorm (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_119194 (h0 : topological_space (has_norm char)) : locally_compact_space (has_norm char) := sorry --non-trivial
lemma new_lemma_119195 (h0 : complete_lattice (has_Sup (semiring unsigned))) : is_atomistic (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_119196 (h0 : ordered_add_comm_monoid (has_zero (has_neg linarith.comp))) : archimedean (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_119197 (h0 : topological_space (boolean_algebra.core pos)) : topological_space.separable_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_119198 (h0 : topological_space (simple_graph enat)) : path_connected_space (simple_graph enat) := sorry --non-trivial
lemma new_lemma_119199 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_119200 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_119201 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_119202 (h0 : ring (add_cancel_monoid (has_neg_part name))) : is_domain (add_cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_119203 (h1 : topological_space (mul_one_class char)) : totally_disconnected_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_119204 (h0 : functor.add_const (add_group (has_dist unsigned)) unsigned) : @is_add_cyclic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_dist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119205 (h0 : ring (linear_ordered_semiring empty)) : strong_rank_condition (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_119206 (h0 : uniform_space (has_union unsigned)) : complete_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_119207 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_119209 (h0 : complete_lattice (has_lt string_imp)) : complete_lattice.is_Sup_finite_compact (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_119210 (h0 : topological_space (linear_ordered_semiring (has_norm congr_arg_kind))) : locally_compact_space (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119211 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_119212 (h0 : ring (topological_space (denumerable linarith.ineq))) : rank_condition (topological_space (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119213 (h0 : complete_lattice (measurable_space (random_gen (has_inv (has_inv linarith.comp_source))))) : is_compactly_generated (measurable_space (random_gen (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_119214 (h0 : complete_lattice (cancel_monoid (option (option empty)))) : is_atomistic (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_119215 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_119216 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_119217 (h0 : not (has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_119218 (h0 : finset (has_Inf (boolean_algebra.core (boolean_algebra.core (has_add linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119219 (h0 : not (ring (has_ssubset ennreal) -> false)) : @is_domain.{0} (has_ssubset.{0} ennreal) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_119220 (h0 : ring (has_inv fun_info)) : strong_rank_condition (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_119221 (h0 : has_add (sub_neg_monoid real) -> has_add (sub_neg_monoid real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_119222 (h0 : group (sub_neg_monoid name)) : normalizer_condition (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_119223 (h1 : topological_space (has_ssubset char)) : t0_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_119224 (h0 : functor.add_const (topological_space (has_zero name)) ennreal) : @normal_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_119225 (h0 : topological_space (add_cancel_monoid (has_to_string pos))) : sequential_space (add_cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_119226 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_119227 (h0 : topological_space enat) (h2 : Prop) : is_path_connected (id (fun (h1 : enat), h2)) := sorry --non-trivial
lemma new_lemma_119228 (h0 : set enat) : set.finite h0 := sorry --non-trivial
lemma new_lemma_119229 (h0 : ring (topological_space (metric_space linarith.comp_source))) : is_domain (topological_space (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119230 (h0 : group (semiring (has_norm (has_norm num)))) : group.fg (semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_119231 (h0 : ring (measurable_space.dynkin_system (has_norm (has_norm unsigned)))) : rank_condition (measurable_space.dynkin_system (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_119232 (h0 : finset (has_bot (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119233 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119234 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_119235 (h0 : complete_lattice (distrib std_gen)) : is_compactly_generated (distrib std_gen) := sorry --non-trivial
lemma new_lemma_119236 (h0 : filter (mul_zero_class (option (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119237 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_119238 (h1 : uniform_space (distrib_lattice (has_nnnorm fun_info))) : complete_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_119239 (h0 : ring (random_gen (random_gen string_imp))) : strong_rank_condition (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_119240 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : path_connected_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_119241 (h0 : topological_space (generalized_boolean_algebra pos)) : totally_separated_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_119242 (h0 : function.extfun nat fin) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.core.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119243 (h0 : monoid (with_one (has_norm linarith.comp))) : monoid.fg (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_119244 (h0 : ring (linear_ordered_cancel_comm_monoid to_additive.value_type)) : strong_rank_condition (linear_ordered_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119245 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119246 (h0 : not (ring (add_left_cancel_monoid fun_info) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_119247 (h0 h1 : pnat) : pnat.coprime h0 h1 := sorry --non-trivial
lemma new_lemma_119248 (h0 : complete_lattice (has_add (has_bot (has_add (has_add real))))) : is_compactly_generated (has_add (has_bot (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_119249 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_119250 (h0 : topological_space (boolean_algebra (add_comm_monoid (has_add pos)))) : locally_compact_space (boolean_algebra (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_119251 (h0 : uniform_space (has_to_string (finset Type))) : separated_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_119252 (h0 : group (encodable (random_gen (random_gen (has_nnnorm linarith.ineq))))) : is_cyclic (encodable (random_gen (random_gen (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_119253 (h0 : fin has_zero.zero) (h1 : function.extfun (Type 1) has_add) : @has_measurable_add.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (measurable_space.{1} (ordered_comm_ring.{1} Type)) h0) (@function.extfun_app.{3 2} (Type 1) has_add.{1} h1 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_119254 (h0 : semiring (sub_neg_monoid (has_Inf Type))) : is_noetherian_ring (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_119255 (h0 : topological_space (preorder (option (option (option num))))) : t1_space (preorder (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_119256 (h0 : filter (has_add linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119257 (h0 : functor.add_const (filter (has_nndist ennreal)) (finset pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119258 (h0 : semiring (has_inner empty unsigned)) : is_noetherian_ring (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_119259 (h0 : ring (boolean_algebra.core (semigroup pos))) : is_principal_ideal_ring (boolean_algebra.core (semigroup pos)) := sorry --non-trivial
lemma new_lemma_119260 (h0 : group unsigned) : normalizer_condition unsigned := sorry --non-trivial
lemma new_lemma_119261 (h0 : complete_lattice (pseudo_metric_space (option name))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option name)) := sorry --non-trivial
lemma new_lemma_119262 (h0 : topological_space (semigroup (add_comm_monoid name))) : irreducible_space (semigroup (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_119263 (h0 : functor.add_const (semiring (complete_distrib_lattice num)) ennreal) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_119264 (h0 : not (finset (has_star congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_119265 (h0 : ring (is_R_or_C (option (semiring (semiring (option num)))))) : is_domain (is_R_or_C (option (semiring (semiring (option num))))) := sorry --non-trivial
lemma new_lemma_119266 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_119267 (h0 : functor.add_const (group (has_add pos)) (has_add (has_add linarith.comp))) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_119268 (h0 : semiring (finset (option empty))) : is_noetherian_ring (finset (option empty)) := sorry --non-trivial
lemma new_lemma_119269 (h0 : prod (normed_comm_ring congr_arg_kind) (normed_comm_ring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_119270 (h0 : topological_space (has_top (metric_space (metric_space num)))) : path_connected_space (has_top (metric_space (metric_space num))) := sorry --non-trivial
lemma new_lemma_119271 (h0 : functor.add_const (list (has_Inf Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119272 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119273 (h0 : topological_space (mul_zero_class congr_arg_kind)) : irreducible_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119274 (h0 : functor.add_const (add_monoid (has_Sup empty)) (semiring (semiring empty))) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119275 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_119276 (h0 : group (has_bot (has_Inf Type))) : normalizer_condition (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_119277 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_119278 (h0 : uniform_space (generalized_boolean_algebra (has_add pos))) : complete_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_119279 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119280 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring unsigned))) : @path_connected_space.{0} (linear_ordered_semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119282 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : preirreducible_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_119283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_119284 (h0 : ring (has_nnnorm (denumerable char))) : is_domain (has_nnnorm (denumerable char)) := sorry --non-trivial
lemma new_lemma_119285 (h0 : functor.add_const (complete_lattice (ordered_ring num)) empty) : @is_compactly_generated.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_119286 (h0 : ring (semigroup (has_add (finset (has_add pos))))) : strong_rank_condition (semigroup (has_add (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_119287 (h0 : congr_arg_kind -> congr_arg_kind -> Prop) : is_strict_order congr_arg_kind h0 := sorry --non-trivial
lemma new_lemma_119288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119289 (h0 : ring (has_add (has_to_string (finset environment.implicit_infer_kind)))) : is_domain (has_add (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_119290 (h0 : complete_lattice (boolean_algebra.core pos)) : is_atomistic (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_119291 (h0 : fin has_zero.zero) : @is_domain.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_119292 (h0 : add_group (has_pos_part (has_Inf (has_pos_part linarith.comp)))) : is_add_cyclic (has_pos_part (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_119293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_ring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_119294 (h1 : filter (has_add (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_119295 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119296 (h0 : complete_lattice (add_group (semiring (semiring empty)))) : is_compactly_generated (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_119297 (h0 : ring (ordered_cancel_add_comm_monoid (option empty))) : rank_condition (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_119298 (h0 : ring (topological_space linarith.ineq)) : is_domain (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_119299 (h0 : semiring (with_one (has_norm (has_norm num)))) : is_noetherian_ring (with_one (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_119300 (h0 : complete_lattice (has_bot (has_bot real))) : complete_lattice.is_Sup_finite_compact (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_119301 (h0 : group (complete_linear_order num)) : group.fg (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_119302 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) (has_neg_part unsigned)) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) (has_neg_part.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_119303 (h0 : list (random_gen (has_top (has_top (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119304 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) pos) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_119305 (h0 : complete_lattice (ring (has_neg linarith.comp))) : is_compactly_generated (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_119306 (h0 : group (has_top (semiring (semiring (semiring (semiring (semiring num))))))) : normalizer_condition (has_top (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_119307 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_119308 (h0 : topological_space (has_emptyc (has_norm congr_arg_kind))) : totally_disconnected_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119309 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_119310 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_119311 (h0 : ring (generalized_boolean_algebra (has_pos_part Type))) : rank_condition (generalized_boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_119312 (h0 : ring (linear_ordered_cancel_comm_monoid (option empty))) : strong_rank_condition (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_119313 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_119314 (h0 : functor.add_const (topological_space (cancel_monoid num)) empty) : @path_connected_space.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_119315 (h0 : function.extfun nat fin) : @regular_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119316 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) name) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) name h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_119317 (h0 : topological_space (ordered_comm_monoid (finset Type))) : preirreducible_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_119318 (h0 : topological_space (distrib_lattice (random_gen fun_info))) : totally_separated_space (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_119319 (h0 : complete_lattice (has_norm (has_norm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119320 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_119321 (h0 : group (normed_group (has_inv linarith.comp_source))) : normalizer_condition (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119322 (h0 : topological_space (has_nndist (finset (finset pos)))) : loc_path_connected_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_119323 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group (option (option (option (option num)))))) : unique_factorization_monoid (linear_ordered_comm_group (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_119324 (h0 : topological_space (linear_ordered_field pos)) : sequential_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_119325 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty (id h1)) := sorry --non-trivial
lemma new_lemma_119326 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_119327 (h0 : functor.add_const (ring (cancel_monoid empty)) (option unsigned)) : @rank_condition.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_119328 (h0 : group (distrib (comm_ring (has_nnnorm to_additive.value_type)))) : is_cyclic (distrib (comm_ring (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_119329 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_119330 (h0 : functor.add_const (ring (comm_group unsigned)) (finset linarith.comp)) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_119331 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_119332 (h0 : topological_space (ring (ordered_ring Type))) : sequential_space (ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_119333 (h0 : topological_space (add_left_cancel_monoid linarith.ineq)) : path_connected_space (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_119334 (h0 : cancel_comm_monoid_with_zero (finset (has_add name))) : unique_factorization_monoid (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_119335 (h1 : add_group (random_gen reducibility_hints)) : is_add_cyclic (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_119336 (h0 : group (has_inner unsigned congr_arg_kind)) : normalizer_condition (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119337 (h0 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : locally_compact_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_119338 (h2 : complete_lattice num) : complete_lattice.is_Sup_finite_compact num := sorry --non-trivial
lemma new_lemma_119339 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : irreducible_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119340 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119341 (h0 : ring (finset (has_nndist ennreal))) : rank_condition (finset (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_119342 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_119343 (h0 : functor.add_const (ring (bin_tree unsigned)) congr_arg_kind) : @rank_condition.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_119344 (h1 : ring (topological_space (has_nnnorm char))) : strong_rank_condition (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_119345 (h1 : complete_lattice (has_append (ordered_comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_append (ordered_comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119346 (h0 : functor.add_const (monoid (has_nndist name)) Type) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_119347 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (has_neg_part Type)) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_119348 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_119349 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119350 (h0 : uniform_space (with_one (has_top fun_info))) : complete_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_119351 (h0 : topological_space (encodable fun_info)) : path_connected_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_119352 (h0 : ring (monoid_with_zero (option (option (option (option num)))))) : rank_condition (monoid_with_zero (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_119353 (h0 : topological_space (complete_distrib_lattice (finset name))) : regular_space (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_119354 (h0 : uniform_space (boolean_algebra Type)) : complete_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_119355 (h0 : ring (mul_zero_class (semiring (semiring empty)))) : strong_rank_condition (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_119356 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @locally_compact_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119357 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_119358 (h0 : preorder (add_comm_semigroup (mul_one_class enat))) (h1 : set (add_comm_semigroup (mul_one_class enat))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_119359 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) linarith.comp) : @complete_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119360 (h3 : topological_space (has_lt to_additive.value_type)) (h4 : preorder (has_lt to_additive.value_type)) : order_topology (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119361 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_119362 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_119363 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_119364 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) environment.implicit_infer_kind) : @complete_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119365 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) name) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_119366 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_119367 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_Inf (has_Inf linarith.comp))) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_119368 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) environment.implicit_infer_kind) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119369 (h0 : filter (has_dist (option (option (option num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119370 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_add linarith.comp)) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_119371 (h0 : topological_space (add_cancel_monoid (comm_group unsigned))) : loc_path_connected_space (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_119372 (h0 : finset (boolean_algebra (finset (normed_comm_ring (finset (boolean_algebra (has_pos_part linarith.comp))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119373 (h0 : uniform_space (canonically_ordered_comm_semiring (ring Type))) : complete_space (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_119374 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : discrete_topology (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_119375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119376 (h0 : list (pseudo_metric_space congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_119378 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119379 (h0 : topological_space (semigroup (has_to_string linarith.comp))) : preirreducible_space (semigroup (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_119380 (h0 : complete_lattice (id (semiring empty))) : is_atomistic (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_119381 (h0 : topological_space (has_norm to_additive.value_type)) (h1 : set (has_norm to_additive.value_type)) : is_open h1 := sorry --non-trivial
lemma new_lemma_119382 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_119383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_119384 (h0 : set std_gen) (h1 : set (set std_gen)) (h2 : std_gen) : set.sInter (set.insert h0 h1) h2 := sorry --non-trivial
lemma new_lemma_119385 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119386 (h0 : fin has_zero.zero) : @t0_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_119387 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) pos) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_119388 (h3 : topological_space string.iterator_imp) : topological_space.first_countable_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_119389 (h0 : function.extfun Type ring) : @rank_condition.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119390 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (finset pos)) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_119391 (h0 : filter (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119392 (h0 : add_group (has_Inf (sub_neg_monoid real))) : is_add_cyclic (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_119393 (h0 : functor.add_const (group ennreal) unsigned) : @is_cyclic.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119394 (h0 : add_monoid (id (semiring (semiring congr_arg_kind)))) : add_monoid.fg (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_119395 (h0 : filter (add_semigroup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119396 (h0 : group (add_cancel_monoid (boolean_algebra.core (boolean_algebra linarith.comp)))) : is_cyclic (add_cancel_monoid (boolean_algebra.core (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_119397 (h0 : topological_space (distrib_lattice (random_gen fun_info))) : locally_compact_space (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_119398 (h0 : ring (nondiscrete_normed_field (normed_field (mul_one_class char)))) : strong_rank_condition (nondiscrete_normed_field (normed_field (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_119399 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119400 (h0 : functor.add_const (ring (has_dist unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_119401 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) unsigned) : @is_domain.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119402 (h0 : function.extfun nat fin) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119403 (h0 : topological_space (has_inv string_imp)) : irreducible_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_119404 (h0 : ring (has_add fun_info)) : strong_rank_condition (has_add fun_info) := sorry --non-trivial
lemma new_lemma_119405 (h0 : group (has_top (has_inv fun_info))) : normalizer_condition (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_119406 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf (has_neg name))))) : preconnected_space (add_cancel_monoid (has_neg (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_119407 (h0 : list (with_bot (random_gen (random_gen (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119408 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119409 (h0 : group (id (linear_ordered_semiring linarith.comp))) : normalizer_condition (id (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_119410 (h0 : functor.add_const (topological_space (has_to_string Type)) (normed_comm_ring name)) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_119411 (h0 : ring (complete_distrib_lattice (option num))) : is_principal_ideal_ring (complete_distrib_lattice (option num)) := sorry --non-trivial
lemma new_lemma_119412 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_119413 (h0 : group (add_cancel_monoid (has_add (has_add (has_add (has_add Type)))))) : is_simple_group (add_cancel_monoid (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_119414 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string unsigned)))) : loc_path_connected_space (normed_comm_ring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_119415 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119416 (h0 : topological_space (semi_normed_ring (has_nnnorm linarith.ineq))) : t0_space (semi_normed_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119417 (h0 : complete_lattice (comm_monoid linarith.ineq)) : is_compactly_generated (comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_119418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_119419 (h0 : pseudo_metric_space (has_lt linarith.ineq)) (h1 : set (has_lt linarith.ineq)) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_119420 (h0 : topological_space (has_nnnorm fun_info)) (h1 : preorder (has_nnnorm fun_info)) : order_closed_topology (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_119421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119422 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : list.nodup (finset.pi.empty list (has_emptyc to_additive.value_type) h0) := sorry --non-trivial
lemma new_lemma_119423 (h0 : ring (has_zero pos)) : is_principal_ideal_ring (has_zero pos) := sorry --non-trivial
lemma new_lemma_119424 (h0 : topological_space (has_nndist (finset Type))) : preirreducible_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_119425 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_119426 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid num)) : is_compactly_generated (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_119427 (h0 : function.extfun Type (functor.add_const (uniform_space (left_cancel_semigroup empty)))) : @separated_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_119428 (h0 : functor.add_const (ring (has_to_string unsigned)) pos) : @rank_condition.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_119429 (h0 : complete_lattice (denumerable (has_nnnorm linarith.ineq))) : is_compactly_generated (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119430 (h0 : functor.add_const (list (has_zero linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119431 (h0 : functor.comp cancel_comm_monoid_with_zero has_add congr_arg_kind) : @unique_factorization_monoid.{0} (has_add.{0} congr_arg_kind) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_add.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_119432 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_119433 (h0 : list (with_bot (has_inv (has_norm (has_top linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119434 (h0 : topological_space (free_add_monoid (semiring (semiring num)))) : topological_space.separable_space (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_119435 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119436 (h0 : not (uniform_space (has_union unsigned) -> false)) : @complete_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119437 (h0 : functor.add_const (complete_lattice (ring Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_119438 (h0 : functor.add_const (topological_space (has_add ennreal)) unsigned) : @totally_separated_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119439 (h0 : group linarith.ineq) : normalizer_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_119440 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_119441 (h0 : topological_space (plift (option unsigned))) : totally_separated_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_119442 (h0 : functor.add_const (finset (finset linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119443 (h2 : complete_lattice (topological_space fun_info)) : complete_lattice.is_Sup_finite_compact (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_119444 (h0 : has_neg (add_comm_semigroup (add_comm_semigroup fun_info))) (h1 : measurable_space (add_comm_semigroup (add_comm_semigroup fun_info))) : has_measurable_neg (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_119445 (h0 : filter (has_nndist pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_119446 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_119447 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_119449 (h2 : complete_lattice (with_one to_additive.value_type)) : is_compactly_generated (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119450 (h0 : topological_space (has_zero (has_add (has_add (has_add linarith.comp))))) : t0_space (has_zero (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_119451 (h0 : topological_space (semigroup Type)) : totally_disconnected_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_119452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_119453 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119454 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119455 (h0 : ring (ring (has_pos_part pos))) : rank_condition (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_119456 (h0 : topological_space (with_one (has_norm (has_one linarith.comp)))) : preirreducible_space (with_one (has_norm (has_one linarith.comp))) := sorry --non-trivial
lemma new_lemma_119457 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_119458 (h0 : topological_space (has_zero (comm_group (cancel_monoid pos)))) : preirreducible_space (has_zero (comm_group (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_119459 (h0 : functor.add_const (topological_space (plift unsigned)) empty) : @t0_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_119460 (h0 : add_monoid (generalized_boolean_algebra (has_add (has_add Type)))) : add_monoid.fg (generalized_boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_119461 (h0 : topological_space (boolean_algebra.core (has_add name))) : topological_space.separable_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_119462 (h1 : ring (semiring to_additive.value_type)) : is_domain (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119463 (h0 : add_monoid (add_cancel_monoid (has_sub linarith.comp))) : add_monoid.fg (add_cancel_monoid (has_sub linarith.comp)) := sorry --non-trivial
lemma new_lemma_119464 (h0 : set (set (fintype linarith.comp_source))) (h1 : eq (filter.sets (filter.generate h0)) h0) : filter.ne_bot (filter.mk_of_closure h0 h1) := sorry --non-trivial
lemma new_lemma_119465 (h0 : ordered_add_comm_monoid (ordered_comm_monoid pos)) : archimedean (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_119466 (h0 : topological_space (finset (has_nndist name))) : locally_compact_space (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_119467 (h1 h2 : multiset (add_comm_semigroup reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_119468 (h0 : group (ring (finset pos))) : is_simple_group (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_119469 (h0 : functor.add_const Prop (complete_distrib_lattice pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_119470 (h0 : group (has_Sup unsigned)) : normalizer_condition (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_119471 (h0 : semiring (canonically_linear_ordered_monoid (has_Inf pos))) : is_noetherian_ring (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_119472 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : id_rel (function.extfun_app (function.extfun_app h0 (prod pos)) pos) := sorry --non-trivial
lemma new_lemma_119473 (h0 : topological_space (has_le (mul_one_class linarith.ineq))) (h1 : preorder (has_le (mul_one_class linarith.ineq))) : order_closed_topology (has_le (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119474 (h0 : uniform_space (has_star (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : separated_space (has_star (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_119475 (h0 : monoid (canonically_ordered_monoid (has_bot pos))) : monoid.fg (canonically_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_119476 (h0 : ordered_comm_monoid (has_add (option (option (option (option pos)))))) : has_exists_mul_of_le (has_add (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_119477 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119478 (h0 : ring (finset congr_arg_kind)) : is_domain (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119479 (h0 : set (has_ssubset (mul_one_class to_additive.value_type))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_119480 (h0 : functor.add_const (group (add_left_cancel_semigroup congr_arg_kind)) unsigned) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119481 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_119482 (h1 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_119483 (h0 : topological_space (has_norm (comm_ring linarith.ineq))) : totally_disconnected_space (has_norm (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119484 (h0 : topological_space (normed_group (has_norm empty))) : path_connected_space (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_119485 (h0 : monoid (boolean_algebra.core congr_arg_kind)) : monoid.fg (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119486 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_119487 (h0 : topological_space (has_inv (has_nnnorm (random_gen to_additive.value_type)))) : totally_disconnected_space (has_inv (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_119488 (h0 : complete_lattice (normed_group (has_nnnorm linarith.ineq))) : is_compactly_generated (normed_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119489 (h0 : add_monoid (metric_space (has_norm empty))) : add_monoid.fg (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_119490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_119491 (h0 : complete_lattice (has_add (semigroup (ring linarith.comp)))) : is_compactly_generated (has_add (semigroup (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_119492 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_119493 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119495 (h0 : topological_space (has_nndist (has_to_string (has_to_string Type)))) : loc_path_connected_space (has_nndist (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_119496 (h0 : ordered_add_comm_monoid ennreal) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_119497 (h0 : add_group (has_bot unsigned)) : is_add_cyclic (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_119498 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119499 (h0 : topological_space (normed_lattice_add_comm_group (has_pos_part pos))) : t0_space (normed_lattice_add_comm_group (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_119500 (h0 : ring (has_append (has_nnnorm linarith.comp_source))) : strong_rank_condition (has_append (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119501 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_119502 (h0 : functor.add_const (group (add_group empty)) empty) : @group.fg.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_119503 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_119504 (h0 : complete_lattice (canonically_linear_ordered_monoid (option name))) : is_compactly_generated (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_119505 (h0 : complete_lattice (semi_normed_comm_ring (has_ssubset reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_119506 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg name))))) : totally_separated_space (ordered_comm_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_119507 (h1 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) (h2 : preorder (linear_ordered_comm_group_with_zero to_additive.value_type)) : order_closed_topology (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119508 (h0 : functor.add_const (ordered_comm_monoid (finset Type)) (has_add (ring Type))) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (finset.{1} Type)) (has_add.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_119509 (h0 : function.extfun Type (functor.add_const (uniform_space (free_add_monoid empty)))) : @separated_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_119510 (h0 : add_group (canonically_ordered_comm_semiring unsigned)) : is_add_cyclic (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_119511 (h0 : functor.add_const (uniform_space (non_assoc_semiring num)) (semiring (semiring empty))) : @separated_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119512 (h0 : functor.add_const (group (linear_ordered_semiring unsigned)) congr_arg_kind) : @normalizer_condition.{0} (linear_ordered_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_119513 (h0 : not (topological_space (add_group empty) -> false)) : @preirreducible_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119514 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order unsigned)))) : @t1_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_119515 (h0 : topological_space (finset (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg name)))))))) : locally_compact_space (finset (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg name))))))) := sorry --non-trivial
lemma new_lemma_119516 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_119517 (h0 : topological_space (has_to_string (has_to_string (has_add ennreal)))) : path_connected_space (has_to_string (has_to_string (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_119518 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119519 (h0 : functor.add_const (group (has_Inf Type)) pos) : @is_cyclic.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_119520 (h0 : has_mem.mem (has_ssubset linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_ssubset.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_119521 (h0 : ring (linear_ordered_add_comm_group (has_norm fun_info))) : is_domain (linear_ordered_add_comm_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_119522 (h1 : topological_space (has_top to_additive.value_type)) : locally_compact_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119523 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_119524 (h1 : group (has_ssubset string.iterator_imp)) : is_cyclic (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_119525 (h0 : topological_space (distrib complex)) : t0_space (distrib complex) := sorry --non-trivial
lemma new_lemma_119526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119527 (h0 : topological_space (canonically_linear_ordered_monoid congr_arg_kind)) : irreducible_space (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119528 (h0 : functor.add_const (list (has_Inf name)) (ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119529 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_119530 (h0 : group (boolean_algebra real)) : normalizer_condition (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_119531 (h0 : semiring (sub_neg_monoid (boolean_algebra.core Type))) : is_noetherian_ring (sub_neg_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_119532 (h0 : ring (has_top (has_union (semiring (has_norm (semiring congr_arg_kind)))))) : is_domain (has_top (has_union (semiring (has_norm (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_119533 (h0 : topological_space (ring (has_nndist (finset linarith.comp)))) : discrete_topology (ring (has_nndist (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_119534 (h0 : functor.add_const Prop (finset (finset ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_119535 (h0 : topological_space (ring (finset linarith.comp))) : irreducible_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_119536 (h0 : functor.add_const (complete_lattice (add_comm_monoid num)) unsigned) : @is_atomistic.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119537 (h1 : set (has_nnnorm (has_nnnorm (mul_one_class fun_info)) -> string.iterator_imp)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_119538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_119539 (h0 : not (topological_space to_additive.value_type -> false)) : @discrete_topology.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_119540 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) unsigned) : @normal_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119541 (h1 : add_group (has_nnnorm (finset reducibility_hints))) : is_add_cyclic (has_nnnorm (finset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_119542 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @irreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119543 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119544 (h0 : functor.add_const (add_group pos) unsigned) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119545 (h0 : complete_lattice (has_norm (has_norm fun_info))) : is_compactly_generated (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_119546 (h0 : set (non_unital_non_assoc_semiring string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_119547 (h0 : complete_lattice (mul_zero_class (finset (has_neg_part Type)))) : is_atomistic (mul_zero_class (finset (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_119548 (h2 : topological_space (has_div to_additive.value_type)) : path_connected_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119549 (h0 : monoid (has_add (mul_one_class (has_add environment.implicit_infer_kind)))) : monoid.fg (has_add (mul_one_class (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_119550 (h0 : topological_space (ring (ring pos))) : topological_space.separable_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_119551 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119552 (h0 : function.extfun Type comm_ring) : @local_ring.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type comm_ring.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_119553 (h0 : prod (has_star (semiring (semiring empty))) (has_star (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_119554 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_119555 (h0 : topological_space (semiring num)) : irreducible_space (semiring num) := sorry --non-trivial
lemma new_lemma_119556 (h0 : ring (add_cancel_monoid congr_arg_kind)) : is_domain (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119557 (h0 : topological_space (has_compl (has_nnnorm fun_info))) : locally_compact_space (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_119558 (h0 : topological_space (option (semiring (semiring empty)))) : t0_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_119559 (h0 : ring (distrib linarith.ineq)) : is_domain (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_119560 (h0 : topological_space (finset (has_neg_part name))) : preirreducible_space (finset (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_119561 (h0 : ring (linear_ordered_semiring (has_top (has_inter (has_top congr_arg_kind))))) : is_domain (linear_ordered_semiring (has_top (has_inter (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_119562 (h0 : monoid (with_bot (random_gen congr_arg_kind))) : monoid.fg (with_bot (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119563 (h0 : list (generalized_boolean_algebra (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119564 (h0 : topological_space (ring (boolean_algebra environment.implicit_infer_kind))) : normal_space (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_119565 (h0 : ring (normed_group (random_gen (random_gen char)))) : is_domain (normed_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_119566 (h0 : bool) (h1 h2 : Prop) : cond h0 h1 h2 := sorry --non-trivial
lemma new_lemma_119567 (h0 : complete_lattice (normed_comm_ring (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119568 (h0 : complete_lattice (with_one (random_gen linarith.ineq))) : is_atomistic (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119569 (h0 : ring (with_zero (encodable (has_inv linarith.comp_source)))) : strong_rank_condition (with_zero (encodable (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_119570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119571 (h0 : topological_space (mul_zero_class num)) : preirreducible_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_119572 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option (option empty)))) : archimedean (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_119573 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119574 (h0 : list (with_one (dlist (with_bot (random_gen (random_gen (random_gen (random_gen string_imp)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119575 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_pos_part (finset pos)))) : unique_factorization_monoid (complete_distrib_lattice (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_119576 (h0 : ordered_comm_monoid (mul_zero_class name)) : has_exists_mul_of_le (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_119577 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group Type)) Type) : @archimedean.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_119578 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119579 (h0 : multiset (non_unital_non_assoc_semiring string.iterator_imp)) (h1 : not (multiset (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_119580 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_119581 (h0 : not (complete_lattice (has_norm linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_119582 (h0 : ring (ring (has_neg_part ennreal))) : strong_rank_condition (ring (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_119583 (h0 : group (with_one (has_top linarith.comp))) : group.fg (with_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_119584 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_119585 (h0 : filter (distrib_lattice (has_nnnorm (has_ssubset linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119586 (h0 : functor.comp topological_space boolean_algebra.core environment.implicit_infer_kind) : @totally_separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_119588 (h0 : functor.add_const (topological_space (semiring num)) empty) : @irreducible_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_119589 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_119590 (h0 : topological_space (mul_one_class (mul_one_class to_additive.value_type))) (h1 : add_group (mul_one_class (mul_one_class to_additive.value_type))) : topological_add_group (mul_one_class (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_119592 (h0 : functor.add_const (list (ordered_comm_ring pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119593 (h0 : topological_space (boolean_algebra (boolean_algebra (normed_comm_ring name)))) : discrete_topology (boolean_algebra (boolean_algebra (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_119594 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119595 (h0 : add_group (semigroup (boolean_algebra.core pos))) : is_add_cyclic (semigroup (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_119596 (h0 : finset (ordered_cancel_add_comm_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119597 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_119598 (h0 : add_monoid (finset (ordered_comm_monoid (has_Inf real)))) : add_monoid.fg (finset (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_119599 (h0 : topological_space (semi_normed_comm_ring (random_gen to_additive.value_type))) : t0_space (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119600 (h0 : function.extfun Type group) : @is_cyclic.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119601 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_119602 (h0 : not (ring (add_group unsigned) -> false)) : @rank_condition.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119603 (h0 : topological_space (normed_group (add_cancel_monoid string_imp))) : totally_disconnected_space (normed_group (add_cancel_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_119604 (h0 : topological_space (topological_space (topological_space (has_nnnorm reducibility_hints)))) : t0_space (topological_space (topological_space (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_119605 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @t0_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_119606 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @normalizer_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119607 (h0 : topological_space (normed_lattice_add_comm_group pos)) : totally_disconnected_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_119608 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid environment.implicit_infer_kind)) name) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_119609 (h0 : normed_field (add_cancel_comm_monoid char) -> normed_field (add_cancel_comm_monoid char) -> Prop) : is_trans (normed_field (add_cancel_comm_monoid char)) h0 := sorry --non-trivial
lemma new_lemma_119610 (h0 : functor.add_const (ring (plift unsigned)) (semiring unsigned)) : @is_principal_ideal_ring.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_119611 (h0 : ordered_add_comm_monoid (comm_group (comm_group environment.implicit_infer_kind))) : archimedean (comm_group (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_119612 (h0 : topological_space (has_bot (has_Inf real))) : topological_space.separable_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_119613 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid empty)) : archimedean (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_119614 (h0 h1 : multiset (has_norm string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_119615 (h0 : not (add_group (has_div linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_119616 (h0 : ring (bin_tree (semiring congr_arg_kind))) : is_domain (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119617 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_linear_ordered_group empty)) unsigned) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119618 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group (semiring empty))) : archimedean (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_119619 (h0 : topological_space (has_union (has_top (semiring unsigned)))) : discrete_topology (has_union (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_119620 (h0 : topological_space (has_inter congr_arg_kind)) : normal_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119621 (h1 : ring (has_append reducibility_hints)) : is_domain (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_119622 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid real))) : loc_path_connected_space (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_119623 (h2 : uniform_space (denumerable (has_inv string_imp))) : complete_space (denumerable (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_119624 (h0 : functor.add_const (semiring (ordered_ring empty)) num) : @is_noetherian_ring.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_119625 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119626 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_119627 (h0 : functor.add_const (ring (has_to_string name)) name) : @rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119628 (h0 : function.extfun Type topological_space) : @t1_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119630 (h0 : topological_space (has_nndist num)) : topological_space.separable_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_119631 (h0 : topological_space (has_bot (has_add (has_add (has_Inf (has_add linarith.comp)))))) : sequential_space (has_bot (has_add (has_add (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_119632 (h0 : ring (complete_semilattice_Sup (random_gen to_additive.value_type))) : is_domain (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119633 (h0 : topological_space (finset ennreal)) : preconnected_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_119634 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_Inf pos)) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_119635 (h0 : set (simple_graph (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_119636 (h0 : topological_space (partial_order (semiring unsigned))) : totally_separated_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_119637 (h0 : functor.add_const (add_group (has_nndist linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119638 (h0 : topological_space (denumerable (has_inv to_additive.value_type))) : path_connected_space (denumerable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119639 (h0 : functor.add_const (add_monoid (has_star unsigned)) empty) : @add_monoid.fg.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_119640 (h0 : functor.add_const (list (has_add Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_119642 (h0 : uniform_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : separated_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_119643 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) name) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_119644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_119645 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_ring congr_arg_kind)) (option unsigned)) : @archimedean.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} congr_arg_kind)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_119646 (h0 : complete_lattice (boolean_algebra (has_neg (has_to_string (ring pos))))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_neg (has_to_string (ring pos)))) := sorry --non-trivial
lemma new_lemma_119647 (h2 : topological_space (has_lt linarith.ineq)) : path_connected_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_119648 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_119649 (h0 : ring (partial_order (semiring num))) : is_principal_ideal_ring (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_119650 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid congr_arg_kind)) unsigned) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119652 (h0 : group (add_cancel_monoid (finset Type))) : is_simple_group (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_119653 (h1 : topological_space (fintype linarith.comp_source)) : t0_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_119654 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_119655 (h0 : ring (has_one linarith.comp)) : is_domain (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_119656 (h0 : functor.add_const Prop (option ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_119657 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid num)) : unique_factorization_monoid (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_119658 (h0 : finset (has_pos_part (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119659 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_119660 (h0 : ring (distrib string.iterator_imp)) : rank_condition (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_119661 (h0 : group (group_with_zero (has_to_string ennreal))) : group.fg (group_with_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_119662 (h1 : has_lt reducibility_hints) : no_max_order reducibility_hints := sorry --non-trivial
lemma new_lemma_119663 (h0 : functor.add_const (uniform_space (linear_order empty)) empty) : @separated_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_119664 (h1 : ring (has_nnnorm (add_comm_semigroup fun_info))) : strong_rank_condition (has_nnnorm (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_119665 (h0 : functor.add_const Prop (has_top (semiring unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_119666 (h0 : topological_space (has_to_string (option (option pos)))) : t0_space (has_to_string (option (option pos))) := sorry --non-trivial
lemma new_lemma_119667 (h0 : group (comm_monoid empty)) : normalizer_condition (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_119668 (h0 : topological_space (normed_comm_ring (has_neg linarith.comp))) : loc_path_connected_space (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_119669 (h0 : not (monoid (has_one empty) -> false)) : @monoid.fg.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119670 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119671 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119672 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_119673 (h0 : topological_space (filter empty)) : t0_space (filter empty) := sorry --non-trivial
lemma new_lemma_119674 (h0 : filter (has_nndist (option (option (option (option (option empty))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119675 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_119676 (h1 : ring (random_gen (random_gen (random_gen char)))) : is_domain (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_119677 (h0 : not (add_monoid (add_group empty) -> false)) : @add_monoid.fg.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119678 (h0 : set (environment.projection_info -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_119679 (h0 : topological_space (has_add (sub_neg_monoid (has_Inf name)))) : sequential_space (has_add (sub_neg_monoid (has_Inf name))) := sorry --non-trivial
lemma new_lemma_119680 (h0 : functor.add_const (ordered_comm_monoid (has_neg name)) name) : @has_exists_mul_of_le.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119681 (h0 : topological_space (semigroup (semigroup Type))) : locally_compact_space (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_119682 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_119683 (h0 : ring (add_comm_monoid (has_to_string name))) : is_principal_ideal_ring (add_comm_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_119684 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @preconnected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119685 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid (has_add (has_add real))))) : preconnected_space (ordered_comm_monoid (sub_neg_monoid (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_119686 (h0 : add_group (add_comm_monoid (has_add (has_add (has_add pos))))) : is_add_cyclic (add_comm_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_119687 (h0 : topological_space (measurable_space.dynkin_system (has_norm unsigned))) : totally_separated_space (measurable_space.dynkin_system (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_119688 (h0 : topological_space (with_bot (has_norm linarith.comp_source))) : irreducible_space (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119689 (h0 : has_mem.mem (linear_ordered_comm_ring empty) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_comm_ring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_119690 (h0 : topological_space (simple_graph unsigned)) : t1_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_119691 (h1 : group (has_nnnorm (has_nnnorm char))) : is_cyclic (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_119692 (h0 : ring (has_union (semiring num))) : strong_rank_condition (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_119693 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119694 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_119695 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : preirreducible_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_119696 (h0 : group (normed_group (has_top congr_arg_kind))) : group.fg (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119697 (h2 : ring (semi_normed_ring to_additive.value_type)) : strong_rank_condition (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119698 (h0 : functor.add_const (finset (cancel_monoid pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119699 (h0 : list (finset (has_pos_part (has_Inf (has_neg linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119700 (h0 : complete_lattice (semigroup (has_add Type))) : complete_lattice.is_Sup_finite_compact (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_119701 (h1 : complete_lattice (uniform_space char)) : is_compactly_generated (uniform_space char) := sorry --non-trivial
lemma new_lemma_119702 (h0 : group (complete_distrib_lattice (comm_group (comm_group pos)))) : is_simple_group (complete_distrib_lattice (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_119703 (h0 : complete_lattice (has_ssubset (random_gen (random_gen fun_info)))) : is_compactly_generated (has_ssubset (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_119704 (h0 : complete_lattice (normed_comm_ring Type)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_119705 (h0 : topological_space (finset (has_add (normed_comm_ring environment.implicit_infer_kind)))) : discrete_topology (finset (has_add (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_119706 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119707 (h1 : topological_space (normed_group string_imp)) : totally_disconnected_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_119708 (h0 : functor.add_const (topological_space (has_pos_part Type)) (has_add pos)) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_119709 (h0 : monoid (has_neg (finset Type))) : monoid.fg (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_119710 (h0 : function.extfun nat fin) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119711 (h0 : topological_space (add_cancel_monoid (has_to_string linarith.comp))) : preirreducible_space (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_119712 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup std_gen))) : t0_space (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_119713 (h0 : uniform_space (add_comm_monoid (has_pos_part pos))) : separated_space (add_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_119714 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119715 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) topological_space.{1} h0) Type)  := sorry --non-trivial
lemma new_lemma_119716 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @preirreducible_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_119717 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_119718 (h0 : list (finset (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119719 (h0 : topological_space (has_union empty)) : preirreducible_space (has_union empty) := sorry --non-trivial
lemma new_lemma_119720 (h0 : functor.add_const (add_group (has_neg_part name)) name) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119722 (h0 : list (ring (has_neg_part unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119723 (h0 : not (group (topological_space char) -> false)) : @group.fg.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_119724 (h0 : group (has_Inf (has_Inf pos))) : is_cyclic (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_119725 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_119726 (h0 : not (group (add_right_cancel_monoid unsigned) -> false)) : @group.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119727 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_119728 (h0 : not (add_group (distrib string_imp) -> false)) : @is_add_cyclic.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_119729 (h0 : topological_space (has_edist (option (option (option empty))))) : locally_compact_space (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_119730 (h0 : topological_space (normed_field enat)) : path_connected_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_119731 (h0 : functor.add_const (complete_lattice (has_nndist name)) pos) : @is_atomistic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_119732 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : path_connected_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_119733 (h0 : finset (add_cancel_monoid (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119734 (h0 : topological_space (comm_semigroup (has_bot pos))) : totally_disconnected_space (comm_semigroup (has_bot pos)) := sorry --non-trivial
lemma new_lemma_119735 (h1 : complete_lattice (uniform_space linarith.ineq)) : is_compactly_generated (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_119736 (h0 : functor.add_const (topological_space (has_zero name)) name) : @totally_separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119737 (h0 : monoid (id (semiring (semiring (semiring num))))) : monoid.fg (id (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_119738 (h0 : list (pseudo_metric_space (has_nndist pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_119739 (h0 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class (normed_field std_gen)))) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_119740 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_119741 (h0 : group (add_cancel_monoid (has_Inf name))) : normalizer_condition (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_119742 (h0 : functor.add_const (complete_lattice (comm_group name)) name) : @is_atomistic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119743 (h0 : ring (semi_normed_comm_ring linarith.ineq)) : strong_rank_condition (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_119744 (h1 : uniform_space (add_monoid (has_nnnorm (denumerable linarith.ineq)))) : complete_space (add_monoid (has_nnnorm (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_119745 (h0 : group (has_to_string (has_add linarith.comp))) : is_simple_group (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_119746 (h1 : ring (distrib (has_lt char))) : is_domain (distrib (has_lt char)) := sorry --non-trivial
lemma new_lemma_119747 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_119748 (h0 : functor.add_const (ordered_comm_monoid (finset Type)) Type) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_119749 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @locally_compact_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119750 (h0 : functor.add_const (group (has_neg linarith.comp)) (ring Type)) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_119751 (h0 : group (has_zero (has_add linarith.comp))) : normalizer_condition (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_119752 (h0 : topological_space (has_Inf (ring (has_add (ring pos))))) : preirreducible_space (has_Inf (ring (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_119753 (h0 : function.extfun nat fin) : @t0_space.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_119754 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119755 (h0 : topological_space (finset (semigroup pos))) : totally_disconnected_space (finset (semigroup pos)) := sorry --non-trivial
lemma new_lemma_119756 (h0 : topological_space (finset (has_nndist (ring pos)))) : irreducible_space (finset (has_nndist (ring pos))) := sorry --non-trivial
lemma new_lemma_119757 (h0 : topological_space (has_norm (has_norm linarith.ineq))) : irreducible_space (has_norm (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119758 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_119759 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_119760 (h0 : add_group (has_ssubset (has_nnnorm linarith.ineq))) : is_add_cyclic (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119762 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) unsigned) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119763 (h1 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup char)))) : t0_space (mul_one_class (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_119764 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119765 (h0 : not (list (has_star num) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_119766 (h1 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_119767 (h0 : uniform_space (has_norm empty)) : complete_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_119768 (h0 : functor.comp ring has_add name) : @is_domain.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_119769 (h0 : topological_space (has_nndist (canonically_linear_ordered_monoid name))) : irreducible_space (has_nndist (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_119770 (h0 : not (ring (with_bot congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119771 (h0 : list (dlist (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119772 (h0 : not (topological_space (fintype linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_119773 (h0 : topological_space (boolean_algebra (finset (finset (has_add (has_add (has_add pos))))))) : discrete_topology (boolean_algebra (finset (finset (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_119774 (h0 : functor.add_const (group (comm_monoid_with_zero unsigned)) (option (semiring empty))) : @is_cyclic.{0} (comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_monoid_with_zero.{0} unsigned)) (option.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_119775 (h0 : complete_lattice (distrib_lattice (has_nnnorm (encodable (has_nnnorm linarith.ineq))))) : is_compactly_generated (distrib_lattice (has_nnnorm (encodable (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_119776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119777 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) (has_neg pos)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_119778 (h0 : functor.add_const (group (ordered_comm_ring pos)) name) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_119779 (h0 : functor.add_const (uniform_space (has_add Type)) name) : @complete_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_119780 (h0 : topological_space (add_cancel_monoid (has_add (has_Inf (has_add name))))) : t1_space (add_cancel_monoid (has_add (has_Inf (has_add name)))) := sorry --non-trivial
lemma new_lemma_119781 (h0 : topological_space (has_add (mul_one_class environment.implicit_infer_kind))) : irreducible_space (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_119782 (h0 : ring nnreal) : strong_rank_condition nnreal := sorry --non-trivial
lemma new_lemma_119783 (h1 : group (distrib_lattice (random_gen (random_gen to_additive.value_type)))) : is_cyclic (distrib_lattice (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_119784 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119785 (h0 : functor.add_const (finset (generalized_boolean_algebra pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119786 (h0 : functor.comp add_group complete_distrib_lattice name) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_119787 (h0 : add_group (linear_ordered_add_comm_group (has_top (has_top linarith.ineq)))) : is_add_cyclic (linear_ordered_add_comm_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_119788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_119789 (h0 : ring (has_add (has_nnnorm to_additive.value_type))) : is_domain (has_add (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119790 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119791 (h0 : group (left_cancel_monoid (option (option unsigned)))) : normalizer_condition (left_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119792 (h0 : topological_space (finset (semigroup (comm_group (comm_group name))))) : irreducible_space (finset (semigroup (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_119793 (h0 : add_group (with_zero linarith.ineq)) : add_group.fg (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_119794 (h0 : function.extfun Type topological_space) : @t1_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_119795 (h0 : set (mul_one_class (mul_one_class std_gen) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_119796 (h0 : not (ring (has_norm num) -> false)) : @strong_rank_condition.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_119797 (h0 : not (topological_space (distrib_lattice char) -> false)) : @locally_compact_space.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_119798 (h0 : functor.add_const (ring (has_Inf name)) name) : @strong_rank_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_119799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_119800 (h0 : topological_space (add_cancel_monoid (has_neg name))) : discrete_topology (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_119801 (h0 : pnat) (h1 : nat) (h2 : fin (nat.succ h1) -> pnat) (h3 : fin h1) : pnat.coprime h0 (matrix.vec_tail h2 h3) := sorry --non-trivial
lemma new_lemma_119802 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_119803 (h0 : semiring (normed_linear_ordered_group empty)) : is_noetherian_ring (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_119804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119805 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_119806 (h0 : topological_space (has_union (has_norm linarith.comp))) : discrete_topology (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_119807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_119808 (h0 : group (linear_ordered_add_comm_group (has_ssubset fun_info))) : is_cyclic (linear_ordered_add_comm_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_119809 (h0 : topological_space (has_nnnorm (random_gen (random_gen char)))) : locally_compact_space (has_nnnorm (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_119810 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @preconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_119811 (h2 : set (std_gen -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_119812 (h1 : ring (has_append (has_ssubset (has_ssubset (has_ssubset (has_inv char)))))) : is_domain (has_append (has_ssubset (has_ssubset (has_ssubset (has_inv char))))) := sorry --non-trivial
lemma new_lemma_119813 (h0 : filter (has_Inf (has_pos_part (has_add (has_add (has_add (has_add pos))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_119814 (h1 : topological_space (distrib_lattice linarith.comp_source)) : totally_disconnected_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_119815 (h0 : group (comm_semigroup (has_Inf pos))) : is_simple_group (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_119816 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_119817 (h0 : topological_space (has_norm unsigned)) : path_connected_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_119818 (h0 : topological_space (boolean_algebra (has_neg_part (has_add name)))) : normal_space (boolean_algebra (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_119819 (h0 : topological_space (has_nndist (has_add (has_add ennreal)))) : totally_disconnected_space (has_nndist (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_119820 (h0 : complete_lattice (filter num)) : is_atomistic (filter num) := sorry --non-trivial
lemma new_lemma_119821 (h0 : topological_space (left_cancel_monoid (semiring empty))) : preirreducible_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_119822 (h0 : filter (semiring (measurable_space linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119823 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_119824 (h0 : group (has_zero (ring linarith.comp))) : group.fg (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_119825 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup (nondiscrete_normed_field char)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (nondiscrete_normed_field char))) := sorry --non-trivial
lemma new_lemma_119826 (h0 : group (boolean_algebra (has_to_string pos))) : is_simple_group (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_119827 (h0 : list (has_top (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119828 (h0 : ring (has_add (has_pos_part (has_Inf real)))) : strong_rank_condition (has_add (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_119829 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119830 (h0 : functor.comp group finset pos) : @group.fg.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} group.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_119831 (h0 : topological_space empty) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_119832 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_119833 (h0 : topological_space (has_add (has_add (has_add name)))) : discrete_topology (has_add (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_119834 (h1 : group (id (with_bot (random_gen (random_gen (with_bot (random_gen string_imp))))))) : group.fg (id (with_bot (random_gen (random_gen (with_bot (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_119835 (h0 : topological_space (comm_group (finset Type))) : locally_compact_space (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_119836 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @separated_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119837 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_119838 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_119839 (h0 : function.extfun Type (functor.add_const (group (normed_linear_ordered_group empty)))) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty))) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_119840 (h0 : ring (boolean_algebra Type)) : strong_rank_condition (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_119841 (h0 : has_zero (add_comm_monoid ennreal) -> has_zero (add_comm_monoid ennreal) -> Prop) : is_symm (has_zero (add_comm_monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_119842 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @t1_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_119843 (h0 : functor.comp topological_space semigroup name) : @totally_disconnected_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_119844 (h0 : functor.add_const Prop (add_right_cancel_monoid num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_119845 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_119846 (h0 : uniform_space (id real.angle)) : complete_space (id real.angle) := sorry --non-trivial
lemma new_lemma_119847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119848 (h0 : ring congr_arg_kind) : rank_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_119849 (h0 : ring (ordered_comm_group (option unsigned))) : strong_rank_condition (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_119850 (h0 : monoid (has_to_string (has_add (has_add (has_add Type))))) : monoid.fg (has_to_string (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_119851 (h0 : functor.add_const (topological_space (free_add_monoid empty)) unsigned) : @loc_path_connected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119852 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : t1_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_119853 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_119854 (h0 : functor.comp topological_space has_nndist environment.implicit_infer_kind) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119856 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119857 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_order.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_119858 (h0 : list (ordered_comm_monoid (comm_semigroup (comm_semigroup pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119859 (h0 : add_group (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : is_add_cyclic (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119860 (h0 : topological_space (normed_group (has_top num))) : locally_compact_space (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_119861 (h0 : uniform_space (denumerable (uniform_space string_imp))) : complete_space (denumerable (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_119862 (h0 : ring (add_cancel_monoid (has_add Type))) : rank_condition (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_119863 (h0 : functor.add_const (topological_space Type) pos) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_119864 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119865 (h1 : add_group (random_gen char)) : is_add_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_119866 (h1 : complete_lattice (semi_normed_ring (random_gen string_imp))) : is_compactly_generated (semi_normed_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_119867 (h0 : not (complete_lattice (fintype linarith.ineq) -> false)) : @is_compactly_generated.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_119868 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_119869 (h0 : complete_lattice (simple_graph (option (option unsigned)))) : is_compactly_generated (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_119870 (h0 : functor.comp topological_space has_to_string Type) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_119871 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_119872 (h0 : ring (add_right_cancel_monoid empty)) : is_domain (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_119873 (h0 : not (complete_lattice (option unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_119874 (h0 : ring (uniform_space (mul_one_class linarith.ineq))) : rank_condition (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_119875 (h0 : topological_space (has_to_string (has_to_string environment.implicit_infer_kind))) : path_connected_space (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_119876 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_119877 (h0 : functor.add_const (function.extfun Type filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_119878 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (has_zero (has_zero (add_cancel_monoid pos)))) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (has_zero.{0} (has_zero.{0} (add_cancel_monoid.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_119879 (h0 : functor.add_const (ring (mul_zero_class Type)) unsigned) : @is_principal_ideal_ring.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (mul_zero_class.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119880 (h0 : topological_space (has_to_string (boolean_algebra name))) : loc_path_connected_space (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_119881 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) pos) Type) : @separated_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (uniform_space.{0} linarith.comp) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_119882 (h1 : ring (has_add (has_append (has_ssubset (random_gen (has_nnnorm linarith.comp_source)))))) : rank_condition (has_add (has_append (has_ssubset (random_gen (has_nnnorm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_119883 (h0 : filter (add_cancel_monoid Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119884 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_119885 (h0 : topological_space (semigroup (has_neg Type))) : totally_disconnected_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_119886 (h0 : ring (has_to_string (has_to_string congr_arg_kind))) : strong_rank_condition (has_to_string (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119887 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_119888 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_119889 (h0 : monoid (comm_semigroup (has_bot (has_Inf name)))) : monoid.fg (comm_semigroup (has_bot (has_Inf name))) := sorry --non-trivial
lemma new_lemma_119890 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_119891 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_119892 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_119893 (h0 : cancel_comm_monoid_with_zero (semigroup congr_arg_kind)) : unique_factorization_monoid (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_119894 (h0 : group (complete_semilattice_Sup empty)) : is_cyclic (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_119895 (h0 : topological_space (has_norm fun_info)) : normal_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_119896 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @rank_condition.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119897 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_119898 (h0 : ring (normed_field (add_monoid char))) : strong_rank_condition (normed_field (add_monoid char)) := sorry --non-trivial
lemma new_lemma_119899 (h0 : not (uniform_space (semi_normed_ring (is_R_or_C reducibility_hints)) -> false)) : @complete_space.{0} (semi_normed_ring.{0} (is_R_or_C.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} (is_R_or_C.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_119900 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_119901 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_119902 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_119903 (h0 : ring (has_zero (has_add pos))) : is_domain (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_119904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119905 (h0 : topological_space (has_lt string.iterator_imp)) : path_connected_space (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_119906 (h0 : ordered_add_comm_monoid (has_neg (has_to_string Type))) : archimedean (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_119907 (h0 : group (has_add environment.implicit_infer_kind)) : is_simple_group (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_119908 (h0 : topological_space (has_zero (has_add name))) : loc_path_connected_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_119909 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_119910 (h0 : functor.add_const (filter (boolean_algebra.core Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119911 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : path_connected_space (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_119912 (h0 : topological_space (normed_lattice_add_comm_group real)) : t1_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_119913 (h0 : functor.add_const (ring (add_left_cancel_semigroup empty)) empty) : @rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_119914 (h0 : monoid (has_union (id num))) : monoid.fg (has_union (id num)) := sorry --non-trivial
lemma new_lemma_119915 (h0 : complete_lattice (has_lt (random_gen (random_gen reducibility_hints)))) : is_compactly_generated (has_lt (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_119916 (h0 : functor.add_const (topological_space (ring Type)) (ring (add_cancel_monoid pos))) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (ring.{0} (add_cancel_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_119917 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_119918 (h0 : ring (generalized_boolean_algebra (has_add pos))) : strong_rank_condition (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_119919 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_119920 (h0 : ring (measurable_space (linear_ordered_semiring (random_gen linarith.comp_source)))) : strong_rank_condition (measurable_space (linear_ordered_semiring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_119921 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_119922 (h0 : filter (add_right_cancel_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119923 (h0 : topological_space (monoid_with_zero (option pos))) : totally_disconnected_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_119924 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_119925 (h0 : functor.add_const (topological_space (monoid empty)) unsigned) : @t1_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119926 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : t0_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_119927 (h0 : monoid (has_ssubset (has_inv fun_info))) : monoid.fg (has_ssubset (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_119928 (h0 : topological_space (has_top (has_top (has_top (has_top (semiring unsigned)))))) : preirreducible_space (has_top (has_top (has_top (has_top (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_119929 (h0 : semiring (normed_lattice_add_comm_group pos)) : is_noetherian_ring (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_119930 (h0 : group (has_inv (random_gen (has_norm string_imp)))) : group.fg (has_inv (random_gen (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_119931 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @locally_compact_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_119932 (h0 : group (normed_group linarith.comp)) : normalizer_condition (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_119933 (h0 : finset (sub_neg_monoid Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_119934 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_119935 (h0 : list (random_gen (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_119936 (h0 : group (simple_graph (comm_ring reducibility_hints))) : is_cyclic (simple_graph (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_119937 (h0 : ring (has_compl linarith.comp_source)) : strong_rank_condition (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_119938 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (has_nndist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_nndist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_119939 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp)) : is_compactly_generated (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_119940 (h0 : group (add_comm_monoid unsigned)) : normalizer_condition (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_119941 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_119942 (h0 : semiring (finset ennreal)) : is_noetherian_ring (finset ennreal) := sorry --non-trivial
lemma new_lemma_119943 (h0 : function.extfun Type (prod (has_to_string name))) : id_rel (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_119944 (h0 : functor.add_const (topological_space (normed_comm_ring name)) (has_neg name)) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_119945 (h3 : topological_space (linear_ordered_semiring (random_gen (random_gen num)))) : path_connected_space (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_119946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119947 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_119948 (h0 : complete_lattice (has_le string_imp)) : complete_lattice.is_Sup_finite_compact (has_le string_imp) := sorry --non-trivial
lemma new_lemma_119949 (h1 : complete_lattice reducibility_hints) : complete_lattice.is_Sup_finite_compact reducibility_hints := sorry --non-trivial
lemma new_lemma_119950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_119951 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) environment.implicit_infer_kind) : @archimedean.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_119952 (h0 : topological_space (topological_space (has_top to_additive.value_type))) : totally_disconnected_space (topological_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119953 (h1 : preorder fun_info) (h2 : set fun_info) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_119954 (h0 : topological_space (generalized_boolean_algebra real)) : totally_separated_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_119955 (h0 : functor.add_const (group (has_neg_part Type)) Type) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_119956 (h0 : topological_space (topological_space (mul_one_class (comm_ring (comm_ring fun_info))))) : t0_space (topological_space (mul_one_class (comm_ring (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_119957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_119958 (h0 : topological_space (has_Inf (has_Inf (has_add (has_Inf pos))))) : t1_space (has_Inf (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_119959 (h0 : topological_space (ordered_comm_group unsigned)) : t0_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_119960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_119961 (h0 : topological_space (has_union linarith.comp)) : totally_separated_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_119962 (h0 : topological_space (has_le to_additive.value_type)) (h1 : preorder (has_le to_additive.value_type)) : order_closed_topology (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_119963 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_119964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_119965 (h0 : group (complete_semilattice_Sup (has_norm (has_norm (has_norm num))))) : group.fg (complete_semilattice_Sup (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_119966 (h0 : semiring (has_to_string (option unsigned))) : is_noetherian_ring (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_119967 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_119968 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_119969 (h0 : fin has_zero.zero) : @complete_space.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_119970 (h0 : uniform_space (random_gen (random_gen to_additive.value_type))) : complete_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119971 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_119972 (h1 : topological_space (add_comm_semigroup char)) (h2 : preorder (add_comm_semigroup char)) : order_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_119973 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_119974 (h0 : uniform_space ereal) : complete_space ereal := sorry --non-trivial
lemma new_lemma_119975 (h0 : functor.add_const (complete_lattice (group_with_zero empty)) unsigned) : @is_compactly_generated.{0} (group_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (group_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_119976 (h0 : topological_space (has_top (semiring unsigned))) : t0_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_119977 (h0 : topological_space (complete_distrib_lattice (has_neg Type))) : t1_space (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_119978 (h0 : num -> num -> num) : is_idempotent num h0 := sorry --non-trivial
lemma new_lemma_119979 (h0 : topological_space (has_neg (comm_group Type))) : totally_separated_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_119980 (h1 : topological_space (denumerable (random_gen reducibility_hints))) : t0_space (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_119981 (h0 : add_group (id (random_gen to_additive.value_type))) : is_add_cyclic (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_119982 (h1 : ring (has_nnnorm (random_gen char))) : is_domain (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_119983 (h0 : topological_space (ordered_comm_ring (has_neg (has_Inf pos)))) : t0_space (ordered_comm_ring (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_119984 (h0 : uniform_space (add_cancel_monoid (mul_one_class linarith.comp))) : separated_space (add_cancel_monoid (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_119985 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_119986 (h0 : topological_space (partial_order (semiring (semiring (semiring unsigned))))) : topological_space.separable_space (partial_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_119987 (h0 : functor.add_const (filter (has_neg pos)) (add_comm_monoid (add_cancel_monoid pos))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119988 (h0 : functor.add_const (finset (ordered_comm_ring linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119989 (h0 : filter (dlist (has_nnnorm (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_119990 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_119991 (h0 : complete_lattice (finset (has_Inf (has_Inf (ring Type))))) : complete_lattice.is_Sup_finite_compact (finset (has_Inf (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_119992 (h1 h2 h3 : int) : int.modeq h1 h2 h3 := sorry --non-trivial
lemma new_lemma_119993 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_119994 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring empty)) : archimedean (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_119995 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_119996 (h0 : group (option (semiring num))) : group.fg (option (semiring num)) := sorry --non-trivial
lemma new_lemma_119997 (h0 : functor.add_const (add_monoid (measurable_space.dynkin_system num)) num) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_119998 (h0 : add_monoid (linear_order unsigned)) : add_monoid.fg (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_119999 (h0 : topological_space (has_inv string_imp)) : totally_disconnected_space (has_inv string_imp) := sorry --non-trivial
