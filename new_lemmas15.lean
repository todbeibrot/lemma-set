import imports
lemma new_lemma_120000 (h0 : topological_space (has_nndist (finset (has_to_string environment.implicit_infer_kind)))) : preirreducible_space (has_nndist (finset (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_120001 (h0 : topological_space (has_one (semiring (semiring (semiring unsigned))))) : topological_space.separable_space (has_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_120002 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120003 (h0 : functor.add_const (complete_lattice (has_dist empty)) empty) : @is_atomistic.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_120004 (h0 : uniform_space (add_comm_monoid (ring pos))) : separated_space (add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_120005 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (option pos)))) : unique_factorization_monoid (has_add (has_add (option pos))) := sorry --non-trivial
lemma new_lemma_120006 (h1 : topological_space (semiring to_additive.value_type)) : locally_compact_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120007 (h0 : topological_space (with_one (complete_semilattice_Sup num))) : discrete_topology (with_one (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_120008 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : preconnected_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_120009 (h0 : function.extfun Type group) : @is_cyclic.{0} (distrib.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120010 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_120011 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero empty)) : archimedean (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_120012 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_120013 (h0 : filter (mul_zero_class (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_120014 (h0 : function.extfun nat fin) : @regular_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120015 (h0 : functor.add_const (topological_space (has_pos_part Type)) (has_neg Type)) : @irreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_120016 (h0 : group (has_inv (random_gen fun_info))) : normalizer_condition (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_120017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_120018 (h0 : not (uniform_space (dlist fun_info) -> false)) : @complete_space.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_120019 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_nndist (has_pos_part Type)))) : unique_factorization_monoid (has_pos_part (has_nndist (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_120020 (h1 : has_le (add_comm_semigroup std_gen)) (h2 : bounded_order (add_comm_semigroup std_gen)) : is_simple_order (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_120021 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_120022 (h0 : monoid (mul_zero_class (has_add Type))) : monoid.fg (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_120023 (h0 : add_group (random_gen (has_top fun_info))) : is_add_cyclic (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_120024 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_120025 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120026 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120027 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg Type)) : @preconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} Type) h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_120028 (h0 : topological_space (has_to_string (comm_group (comm_group environment.implicit_infer_kind)))) : preirreducible_space (has_to_string (comm_group (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_120029 (h3 : uniform_space (random_gen linarith.ineq)) : complete_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_120030 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_120031 (h0 : monoid (measurable_space fun_info)) : monoid.fg (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_120032 (h0 : complete_lattice (semiring (has_top (has_top fun_info)))) : is_atomistic (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_120033 (h0 : functor.comp topological_space has_neg_part (has_neg_part pos)) : @preirreducible_space.{0} (has_neg_part.{0} (has_neg_part.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120034 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @t1_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120035 (h0 : group (has_Inf (has_add (has_add linarith.comp)))) : normalizer_condition (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_120036 (h0 : uniform_space (plift unsigned)) : separated_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_120037 (h0 : topological_space (normed_comm_ring (comm_group environment.implicit_infer_kind))) : loc_path_connected_space (normed_comm_ring (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120038 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_120039 (h0 : semiring (ordered_cancel_comm_monoid (semiring congr_arg_kind))) : is_noetherian_ring (ordered_cancel_comm_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120040 (h0 : topological_space (has_Inf (has_nndist (has_nndist linarith.comp)))) : preirreducible_space (has_Inf (has_nndist (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_120041 (h0 : functor.add_const (topological_space (as_linear_order empty)) num) : @normal_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_120042 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) linarith.comp) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120043 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_120044 (h0 : finset (generalized_boolean_algebra Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_120045 (h0 : ring (normed_lattice_add_comm_group (finset linarith.comp))) : is_principal_ideal_ring (normed_lattice_add_comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_120046 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_120047 (h1 : has_lt (has_lt std_gen)) : no_max_order (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_120048 (h0 : filter (has_to_string (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_120049 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_120050 (h0 : complete_lattice (has_compl (has_nnnorm fun_info))) : is_compactly_generated (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_120051 (h0 : add_group (add_cancel_monoid (has_add Type))) : is_add_cyclic (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_120052 (h0 : topological_space (has_neg_part unsigned)) : locally_compact_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_120053 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t0_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_120054 (h0 : not (has_mem.mem (has_emptyc empty) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_120055 (h0 : functor.add_const (finset Type) (boolean_algebra Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120056 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) unsigned) : @rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120057 (h1 : not (topological_space (distrib_lattice char) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_120058 (h0 : group (simple_graph (ring (ring (ring Type))))) : is_cyclic (simple_graph (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_120059 (h0 : semiring (semiring (has_norm (has_norm (semiring linarith.comp))))) : is_noetherian_ring (semiring (has_norm (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_120060 (h0 : complete_lattice (has_nnnorm fun_info)) : complete_lattice.is_Sup_finite_compact (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_120061 (h1 : group (has_add to_additive.value_type)) : group.fg (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120062 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120063 (h0 : functor.comp add_monoid canonically_ordered_comm_semiring Type) : @add_monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} add_monoid.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_120064 (h0 : not (topological_space (topological_space linarith.comp_source) -> false)) : @t0_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_120065 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) pos) := sorry --non-trivial
lemma new_lemma_120066 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120067 (h0 : filter (linear_ordered_add_comm_group (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120068 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120069 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120070 (h0 : ring (comm_group (has_neg_part Type))) : is_domain (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_120071 (h0 : uniform_space (add_comm_semigroup std_gen)) : complete_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_120072 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120073 (h0 : ring (boolean_algebra.core (option (option (option pos))))) : strong_rank_condition (boolean_algebra.core (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_120074 (h1 : topological_space (dlist (has_ssubset to_additive.value_type))) : totally_disconnected_space (dlist (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120075 (h2 : ring (comm_ring to_additive.value_type)) : rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120076 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_120077 (h0 : ordered_comm_monoid (has_neg (has_add pos))) : has_exists_mul_of_le (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_120078 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120079 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) Type) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_120080 (h0 : semiring (simple_graph (finset linarith.comp))) : is_noetherian_ring (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_120081 (h0 : complete_lattice (distrib (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (distrib (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_120082 (h0 : filter (boolean_algebra (has_nndist name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120083 (h2 : ring (dlist to_additive.value_type)) : strong_rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120084 (h0 : list (distrib_lattice (random_gen (has_nnnorm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120085 (h0 : ring (has_zero (finset pos))) : rank_condition (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_120086 (h0 : topological_space (plift (has_inter empty))) : discrete_topology (plift (has_inter empty)) := sorry --non-trivial
lemma new_lemma_120087 (h0 : add_group (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_add_cyclic (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_120088 (h0 : ring (distrib (ordered_cancel_comm_monoid (random_gen string_imp)))) : strong_rank_condition (distrib (ordered_cancel_comm_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_120089 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_add name)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_120090 (h0 : functor.add_const (filter (boolean_algebra.core unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120091 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : totally_separated_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_120092 (h0 : uniform_space (free_add_monoid (option unsigned))) : complete_space (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_120093 (h1 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_120094 (h0 : topological_space (canonically_ordered_add_monoid (option (option num)))) : totally_disconnected_space (canonically_ordered_add_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_120095 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @discrete_topology.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_120096 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_120097 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120098 (h0 : ring (has_zero (has_neg (finset (semigroup Type))))) : strong_rank_condition (has_zero (has_neg (finset (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_120099 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_120100 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @regular_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_120101 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (ring (has_Inf Type)))) : unique_factorization_monoid (boolean_algebra.core (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_120102 (h0 : ring char) : rank_condition char := sorry --non-trivial
lemma new_lemma_120103 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) num) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_120104 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_120105 (h0 : topological_space (has_bot (has_Inf name))) : path_connected_space (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_120106 (h0 : add_group (has_Sup (option unsigned))) : is_add_cyclic (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_120107 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) pos) : @is_compactly_generated.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_120108 (h0 : list (has_star unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_120109 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_120110 (h0 : group (denumerable (has_top (has_top fun_info)))) : is_cyclic (denumerable (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_120111 (h0 : topological_space (ordered_comm_monoid (has_add (has_pos_part (has_add pos))))) : irreducible_space (ordered_comm_monoid (has_add (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_120112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_edist.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_edist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120113 (h0 : functor.add_const (semiring (has_add Type)) Type) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120114 (h0 : group (canonically_linear_ordered_monoid (has_Inf (has_pos_part (has_pos_part pos))))) : group.fg (canonically_linear_ordered_monoid (has_Inf (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_120115 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_120116 (h0 : fin has_zero.zero) : @sequential_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_120117 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_120118 (h0 : add_monoid (complete_semilattice_Sup linarith.comp)) : add_monoid.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_120119 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_120120 (h0 : topological_space (add_group (semiring linarith.comp))) : preirreducible_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_120121 (h0 : topological_space (boolean_algebra.core num)) : loc_path_connected_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_120122 (h1 : uniform_space ordering) : complete_space ordering := sorry --non-trivial
lemma new_lemma_120123 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @t1_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120125 : true := sorry --trivial
lemma new_lemma_120126 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_120127 (h0 : group (semigroup (finset linarith.comp))) : is_cyclic (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_120128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120129 (h0 : functor.add_const (topological_space (has_neg_part pos)) unsigned) : @totally_separated_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120130 (h0 : ring (bin_tree num)) : is_domain (bin_tree num) := sorry --non-trivial
lemma new_lemma_120131 (h0 : group (linear_ordered_field pos)) : normalizer_condition (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_120132 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @discrete_topology.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_120133 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0)) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_120134 (h0 : finset (partial_order empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_120135 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_120136 (h0 : filter (has_norm unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120137 (h0 : ring (semi_normed_comm_ring char)) : strong_rank_condition (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_120138 (h0 : filter (has_neg (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120139 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120140 (h0 : functor.add_const (complete_lattice pos) pos) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_120141 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120142 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_120143 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120144 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_120145 (h0 : functor.add_const (topological_space (filter name)) linarith.comp) : @preirreducible_space.{0} (filter.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120146 (h1 : functor.comp group id string_imp) : @is_cyclic.{0} (@id.{2} Type string_imp) (@functor.comp.run.{0 0 0} group.{0} (@id.{2} Type) string_imp h1)  := sorry --non-trivial
lemma new_lemma_120147 (h0 : functor.add_const (complete_lattice (option pos)) ennreal) : @is_compactly_generated.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_120148 (h0 : ring (distrib (has_compl (has_nnnorm enat)))) : rank_condition (distrib (has_compl (has_nnnorm enat))) := sorry --non-trivial
lemma new_lemma_120149 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring empty)) := sorry --non-trivial
lemma new_lemma_120150 (h0 : topological_space (comm_ring linarith.ineq)) : totally_disconnected_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_120151 (h0 : topological_space name) : t0_space name := sorry --non-trivial
lemma new_lemma_120152 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : irreducible_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120153 (h0 : group (comm_semigroup (canonically_linear_ordered_monoid real))) : group.fg (comm_semigroup (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_120154 (h0 : semiring (finset environment.implicit_infer_kind)) : is_noetherian_ring (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_120155 (h2 : set (set (has_nnnorm (has_nnnorm fun_info)))) : is_countably_spanning h2 := sorry --non-trivial
lemma new_lemma_120156 (h0 : group (with_one (random_gen (has_nnnorm to_additive.value_type)))) : group.fg (with_one (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_120157 (h0 : not (topological_space (complete_semilattice_Sup linarith.ineq) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_120158 (h0 : functor.add_const (uniform_space (ordered_comm_monoid name)) name) : @separated_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_120159 (h0 : functor.add_const (ordered_comm_monoid (semigroup name)) (has_add Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (semigroup.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_120160 (h0 : complete_lattice (has_dist (option (option (option (option empty)))))) : is_atomistic (has_dist (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_120161 (h1 : linarith.ineq -> linarith.ineq) (h2 : linarith.ineq) : function.is_fixed_pt h1 h2 := sorry --non-trivial
lemma new_lemma_120162 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_120163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120164 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120165 (h0 : topological_space (normed_group (has_ssubset to_additive.value_type))) : t0_space (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120166 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_120167 (h0 : ring (normed_field (has_nnnorm to_additive.value_type))) : rank_condition (normed_field (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120168 (h0 : list (has_pos_part (has_neg name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120169 (h0 : functor.add_const (cancel_comm_monoid_with_zero (measurable_space.dynkin_system unsigned)) empty) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_120170 (h0 : group (set.set_semiring linarith.ineq)) : group.fg (set.set_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_120171 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : t1_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_120172 (h0 : ring (ordered_comm_group empty)) : is_domain (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_120173 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120174 (h0 : topological_space (semigroup name)) : t1_space (semigroup name) := sorry --non-trivial
lemma new_lemma_120175 (h0 : group (comm_semigroup (generalized_boolean_algebra real))) : is_simple_group (comm_semigroup (generalized_boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_120176 (h0 : ring (has_zero (cancel_monoid unsigned))) : strong_rank_condition (has_zero (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_120177 (h1 h2 : multiset fun_info) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_120178 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add (sub_neg_monoid linarith.comp))))) : loc_path_connected_space (sub_neg_monoid (has_Inf (has_add (sub_neg_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_120179 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_120180 (h0 : topological_space (ring (normed_comm_ring (has_neg_part environment.implicit_infer_kind)))) : t0_space (ring (normed_comm_ring (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_120181 (h0 : functor.add_const (group (complete_distrib_lattice congr_arg_kind)) unsigned) : @group.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120182 (h0 : functor.add_const (semiring (option num)) (semiring (semiring (semiring unsigned)))) : @is_noetherian_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_120183 (h0 : functor.add_const (add_monoid (cancel_monoid pos)) ennreal) : @add_monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_120184 (h0 : topological_space (ordered_comm_monoid name)) : irreducible_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_120185 (h0 : functor.add_const (topological_space (has_zero pos)) (option pos)) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120186 (h0 : group (ring (has_neg_part (add_comm_monoid name)))) : is_simple_group (ring (has_neg_part (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_120187 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (option empty)) : @path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_120188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120189 (h1 : not (filter (denumerable linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_120190 (h0 : functor.add_const (topological_space (has_star num)) num) : @topological_space.separable_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_120191 (h0 : add_monoid (linear_order (option (option empty)))) : add_monoid.fg (linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_120192 (h0 : complete_lattice (complete_distrib_lattice (comm_group Type))) : is_atomistic (complete_distrib_lattice (comm_group Type)) := sorry --non-trivial
lemma new_lemma_120193 (h0 : group (generalized_boolean_algebra (finset (has_Inf linarith.comp)))) : is_simple_group (generalized_boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_120194 (h0 : group (has_neg (ring pos))) : group.fg (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_120195 (h0 : uniform_space (has_ssubset (random_gen to_additive.value_type))) : complete_space (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120196 (h0 : topological_space (option (has_top unsigned))) : topological_space.separable_space (option (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_120197 (h0 : filter (has_zero (has_neg_part Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120198 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_120199 (h1 h2 : multiset (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_120200 (h0 : add_group (has_add linarith.ineq)) : is_add_cyclic (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_120201 (h0 : topological_space (ring unsigned)) : t0_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_120202 (h0 : not (topological_space (has_compl char) -> false)) : @t0_space.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_120203 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_120204 (h0 : not (group (mul_zero_class congr_arg_kind) -> false)) : @normalizer_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_120205 (h0 : has_le (has_norm (linear_ordered_ring num))) (h1 : has_norm (linear_ordered_ring num)) : is_max h1 := sorry --non-trivial
lemma new_lemma_120206 (h0 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_120207 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120208 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120209 (h0 : complete_lattice (has_inner pos ennreal)) : complete_lattice.is_Sup_finite_compact (has_inner pos ennreal) := sorry --non-trivial
lemma new_lemma_120210 (h0 : complete_lattice (add_comm_monoid (add_comm_monoid Type))) : is_compactly_generated (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_120211 (h0 : complete_lattice (has_add (has_inv fun_info))) : is_compactly_generated (has_add (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_120212 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_120213 (h0 : topological_space (with_bot (has_inv (has_inv linarith.comp_source)))) : totally_separated_space (with_bot (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_120214 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120215 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120216 (h0 : comm_ring (denumerable to_additive.value_type) -> comm_ring (denumerable to_additive.value_type)) : function.involutive h0 := sorry --non-trivial
lemma new_lemma_120217 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_120218 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120219 (h0 : topological_space (mul_zero_class (ring (has_nndist (has_add pos))))) : preirreducible_space (mul_zero_class (ring (has_nndist (has_add pos)))) := sorry --non-trivial
lemma new_lemma_120220 (h0 : functor.add_const (complete_lattice (ring environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_120221 (h0 : topological_space (random_gen char)) : totally_disconnected_space (random_gen char) := sorry --non-trivial
lemma new_lemma_120222 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_120223 (h0 : complete_lattice (has_Inf (has_add name))) : is_compactly_generated (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_120224 (h0 : group (semi_normed_comm_ring (has_top linarith.comp_source))) : normalizer_condition (semi_normed_comm_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120225 (h0 : ring (option (has_add (has_add ennreal)))) : rank_condition (option (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_120226 (h0 : topological_space (with_one (random_gen num))) : totally_separated_space (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_120227 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : topological_space.separable_space (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_120228 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_120229 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) num) : @totally_disconnected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_120230 (h0 : ring char) (h1 : set (subring char -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_120231 (h0 : not (complete_lattice (measure_theory.measure_space empty) -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_120232 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120233 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_120234 (h0 : functor.add_const (topological_space (preorder num)) (semiring unsigned)) : @topological_space.separable_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_120235 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_120236 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @topological_space.separable_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120237 (h0 : ring (random_gen (has_inv (has_inv (has_inv linarith.comp_source))))) : is_domain (random_gen (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_120238 (h1 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120239 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120240 (h0 : ring (has_pos_part (has_nndist linarith.comp))) : is_principal_ideal_ring (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_120241 (h0 : not (uniform_space (semiring empty) -> false)) : @complete_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_120242 (h0 : ring (has_bot pos)) : is_domain (has_bot pos) := sorry --non-trivial
lemma new_lemma_120243 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_120244 (h0 : group (dlist char)) : group.fg (dlist char) := sorry --non-trivial
lemma new_lemma_120245 (h0 : functor.add_const (add_group (boolean_algebra pos)) (has_add (has_add pos))) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_120246 (h0 : complete_lattice bool) : complete_lattice.is_Sup_finite_compact bool := sorry --non-trivial
lemma new_lemma_120247 (h0 : topological_space (add_group unsigned)) : loc_path_connected_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_120248 (h0 : topological_space (finset (normed_comm_ring Type))) : totally_disconnected_space (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_120249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_dist.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_120250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_120251 (h0 : monoid (has_bot pos)) : monoid.fg (has_bot pos) := sorry --non-trivial
lemma new_lemma_120252 (h0 : has_neg (simple_graph string.iterator_imp)) (h1 : measurable_space (simple_graph string.iterator_imp)) : has_measurable_neg (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_120253 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_120254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_120255 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_120256 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_120257 (h0 : topological_space (has_add unsigned)) : discrete_topology (has_add unsigned) := sorry --non-trivial
lemma new_lemma_120258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_120259 (h1 : complete_lattice (add_left_cancel_monoid (add_monoid to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (add_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120260 (h0 : group (boolean_algebra (ring linarith.comp))) : is_cyclic (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_120261 (h0 : group (has_Inf (ordered_ring name))) : group.fg (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_120262 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) (has_nndist linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120263 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120264 (h0 : functor.comp topological_space finset name) : @path_connected_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_120265 (h0 : functor.add_const (ring (sub_neg_monoid linarith.comp)) pos) : @is_domain.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_120266 (h0 : ring (has_norm unsigned)) : rank_condition (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_120267 (h0 : functor.add_const (uniform_space (has_add environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120268 (h0 : topological_space (has_norm (has_norm linarith.comp))) : irreducible_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_120269 (h0 : add_monoid (comm_group (has_neg_part Type))) : add_monoid.fg (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_120270 (h0 : add_monoid (mul_zero_class congr_arg_kind)) : add_monoid.fg (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120271 (h2 : ring (distrib (semi_normed_ring fun_info))) : strong_rank_condition (distrib (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_120272 (h0 : complete_lattice (semigroup pos)) : is_compactly_generated (semigroup pos) := sorry --non-trivial
lemma new_lemma_120273 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_120274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120275 (h0 : not (topological_space (add_monoid linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (add_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_120276 (h0 : topological_space (finset num)) : t0_space (finset num) := sorry --non-trivial
lemma new_lemma_120277 (h0 : ordered_add_comm_monoid (has_add (finset name))) : archimedean (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_120278 (h0 : not (group (with_bot congr_arg_kind) -> false)) : @normalizer_condition.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_120279 (h0 : semiring (comm_semigroup (sub_neg_monoid real))) : is_noetherian_ring (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_120280 (h0 h1 : multiset (simple_graph string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_120281 (h0 : group (comm_ring (random_gen (random_gen (random_gen char))))) : is_cyclic (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_120282 (h0 : functor.comp group complete_distrib_lattice name) : @is_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_120283 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120284 (h0 : topological_space (random_gen (comm_ring (has_inv linarith.ineq)))) : totally_disconnected_space (random_gen (comm_ring (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120285 (h0 : group (has_neg_part (semigroup Type))) : is_cyclic (has_neg_part (semigroup Type)) := sorry --non-trivial
lemma new_lemma_120286 (h0 : monoid (add_cancel_monoid (boolean_algebra (has_zero (has_neg name))))) : monoid.fg (add_cancel_monoid (boolean_algebra (has_zero (has_neg name)))) := sorry --non-trivial
lemma new_lemma_120287 (h0 : monoid (option congr_arg_kind)) : monoid.fg (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120288 (h0 : not (ring (topological_space string.iterator_imp) -> false)) : @strong_rank_condition.{0} (topological_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_120289 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_bot real))))) : loc_path_connected_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_bot real)))) := sorry --non-trivial
lemma new_lemma_120290 (h0 : functor.add_const (ring (mul_zero_class pos)) name) : @rank_condition.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_120291 (h0 : topological_space (left_cancel_semigroup (semiring (semiring empty)))) : locally_compact_space (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_120292 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_120293 (h0 : add_group (with_bot (semiring unsigned))) : is_add_cyclic (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120294 (h0 : functor.add_const (group (option empty)) congr_arg_kind) : @group.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_120295 (h0 : functor.add_const (ordered_add_comm_monoid (has_star empty)) num) : @archimedean.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_120296 (h0 : complete_lattice (omega_complete_partial_order unsigned)) : is_compactly_generated (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_120297 (h0 : filter (linear_ordered_cancel_comm_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120298 (h0 : topological_space (simple_graph (has_add Type))) : regular_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_120299 (h0 : monoid (normed_comm_ring (comm_group ennreal))) : monoid.fg (normed_comm_ring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_120300 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) pos) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_120301 (h1 : add_group (denumerable char)) : is_add_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_120302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120303 (h0 : complete_lattice (has_pos_part pos)) : complete_lattice.is_Sup_finite_compact (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_120304 (h0 : ordered_comm_monoid fun_info -> std_gen) (h1 : coe_sort (set.range h0)) : @has_exists_mul_of_le.{0} fun_info (@set.range_splitting.{0 0} (ordered_comm_monoid.{0} fun_info) std_gen h0 h1)  := sorry --non-trivial
lemma new_lemma_120305 (h0 : fin has_zero.zero) : @archimedean.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_120306 (h0 : not (ring (semi_normed_ring fun_info) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_120307 (h0 : topological_space (id (random_gen num))) : totally_disconnected_space (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_120308 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) Type) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120309 (h0 : group (linear_ordered_comm_ring (semiring num))) : normalizer_condition (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_120310 (h0 : has_coe linarith.ineq Prop) (h1 : linarith.ineq) : @coe_b.{1 1} linarith.ineq Prop h0 h1  := sorry --non-trivial
lemma new_lemma_120311 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_120312 (h0 : topological_space (boolean_algebra.core (has_to_string (has_to_string ennreal)))) : loc_path_connected_space (boolean_algebra.core (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_120313 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120314 (h0 : functor.add_const (complete_lattice (has_to_string Type)) pos) : @is_atomistic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_120315 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_120316 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_120317 (h0 : ordered_add_comm_monoid (add_comm_monoid (add_cancel_monoid pos))) : archimedean (add_comm_monoid (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_120318 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) pos) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_120319 (h0 : functor.add_const (functor.add_const (option Prop) unsigned) unsigned) (h1 : coe_sort (option.is_some (functor.add_const.run (functor.add_const.run h0)))) : option.get h1 := sorry --non-trivial
lemma new_lemma_120320 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : t0_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120321 (h0 : ring (has_compl (has_ssubset fun_info))) : is_domain (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_120322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120323 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_120324 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120325 (h0 : filter (has_top (has_top congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120326 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) (ring pos)) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120327 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @preirreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_120328 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120329 (h0 : add_monoid (add_comm_monoid Type)) : add_monoid.fg (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_120330 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120331 (h0 : topological_space (linear_ordered_comm_ring num)) : totally_disconnected_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_120332 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_120333 (h0 : monoid (semiring num)) : monoid.fg (semiring num) := sorry --non-trivial
lemma new_lemma_120334 (h0 : not (add_group (semi_normed_ring reducibility_hints) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_120335 (h0 : topological_space (has_well_founded (has_to_string char))) : locally_compact_space (has_well_founded (has_to_string char)) := sorry --non-trivial
lemma new_lemma_120336 (h0 : not (monoid (metric_space linarith.comp) -> false)) : @monoid.fg.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_120337 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_120338 (h0 : functor.comp topological_space boolean_algebra linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120339 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) num) : @rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_120340 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120341 (h0 : topological_space (linear_ordered_field (option (option (option empty))))) : totally_separated_space (linear_ordered_field (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_120342 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) Type) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120343 (h0 : complete_lattice (measurable_space.dynkin_system num)) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_120344 (h1 : complete_lattice (has_lt linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120345 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : locally_compact_space (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_120346 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_120347 (h0 : list (has_norm (random_gen (random_gen (random_gen (random_gen string_imp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120348 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : topological_space.separable_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_120349 (h0 : uniform_space (canonically_ordered_comm_semiring (has_neg name))) : separated_space (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_120350 (h0 : ring (has_norm (has_norm to_additive.value_type))) : rank_condition (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120351 (h1 : ring (mul_one_class (mul_one_class ereal))) : strong_rank_condition (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_120352 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120353 (h2 : not (add_group (normed_group linarith.comp_source) -> false)) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_120354 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120355 (h0 : topological_space (measurable_space (has_norm unsigned))) : t0_space (measurable_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_120356 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : regular_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_120357 (h0 : group (topological_space (has_top (has_top (has_top fun_info))))) : group.fg (topological_space (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_120358 (h0 : functor.comp ring normed_comm_ring pos) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_120359 (h0 : not (complete_lattice (div_inv_monoid to_additive.value_type) -> false)) : @is_compactly_generated.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_120360 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120361 (h0 : filter (pseudo_emetric_space (option (option unsigned)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_120362 (h0 : add_group (ring (has_Inf Type))) : is_add_cyclic (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_120363 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120364 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift (semiring empty))) unsigned) : @unique_factorization_monoid.{1} (plift.{1} (semiring.{0} empty)) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} (semiring.{0} empty))) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120365 (h0 : ring (simple_graph linarith.ineq)) : rank_condition (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_120366 (h0 : functor.add_const (group (has_nndist Type)) name) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_120367 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_120368 (h1 : ring (normed_field (has_lt (uniform_space string.iterator_imp)))) : strong_rank_condition (normed_field (has_lt (uniform_space string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_120369 (h0 : finset (comm_semigroup (sub_neg_monoid real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_120370 (h0 : list (has_nndist name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_120371 (h0 : topological_space (has_one (semiring congr_arg_kind))) : irreducible_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120372 (h0 : group (linear_ordered_add_comm_group (random_gen fun_info))) : group.fg (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_120373 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_120374 (h0 : topological_space (simple_graph (ring Type))) : loc_path_connected_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_120375 (h0 : function.extfun Type (functor.add_const (ring environment.implicit_infer_kind))) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_120376 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120377 (h0 : topological_space (has_emptyc (has_top fun_info))) : path_connected_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_120378 (h0 : topological_space (normed_group (semiring (has_top empty)))) : irreducible_space (normed_group (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_120379 (h0 : complete_lattice (add_comm_monoid (add_cancel_monoid name))) : is_compactly_generated (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_120380 (h0 : complete_lattice (with_zero (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (with_zero (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_120381 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120382 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120383 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_120384 (h0 : topological_space (ring (finset (finset (has_add linarith.comp))))) : loc_path_connected_space (ring (finset (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_120385 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_120386 (h0 : functor.add_const (finset (canonically_ordered_add_monoid unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120387 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg Type)))) : discrete_topology (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_120388 (h0 : topological_space (normed_group (semiring unsigned))) : normal_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120389 (h0 : not (topological_space empty -> false)) : regular_space empty := sorry --non-trivial
lemma new_lemma_120390 (h0 : set (add_comm_semigroup linarith.ineq -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_120391 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120392 (h0 : topological_space (finset pos)) : t0_space (finset pos) := sorry --non-trivial
lemma new_lemma_120393 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring Type)) (boolean_algebra linarith.comp)) : @has_exists_mul_of_le.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_120394 (h0 : add_group (emetric_space to_additive.value_type)) : is_add_cyclic (emetric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120395 (h1 : not (ring (ordered_comm_ring char) -> false)) : @rank_condition.{0} (ordered_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (ordered_comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_120396 (h0 : functor.add_const (group (has_to_string name)) name) : @normalizer_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_120397 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120398 (h0 : topological_space (linear_ordered_add_comm_group_with_top empty)) : path_connected_space (linear_ordered_add_comm_group_with_top empty) := sorry --non-trivial
lemma new_lemma_120399 (h0 : ring (metric_space (semiring unsigned))) : rank_condition (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120400 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) pos) : @complete_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_120401 (h0 : functor.add_const (finset (partial_order num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120402 (h0 : has_le (normed_field (mul_one_class (mul_one_class char)))) (h1 : normed_field (mul_one_class (mul_one_class char))) : is_bot h1 := sorry --non-trivial
lemma new_lemma_120403 (h0 : group (has_to_string unsigned)) : normalizer_condition (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_120404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120405 (h0 : functor.add_const (topological_space (semigroup ennreal)) unsigned) : @t1_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120406 (h0 : functor.add_const (semiring (add_comm_monoid Type)) (comm_group pos)) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_comm_monoid.{1} Type)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120407 (h0 : has_lt (simple_graph (has_le reducibility_hints))) : no_max_order (simple_graph (has_le reducibility_hints)) := sorry --non-trivial
lemma new_lemma_120408 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_neg (has_add (ring name))))) : unique_factorization_monoid (boolean_algebra (has_neg (has_add (ring name)))) := sorry --non-trivial
lemma new_lemma_120409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120410 (h2 : topological_space (topological_space (has_nnnorm linarith.ineq))) : t0_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120411 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_120412 (h1 : uniform_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : complete_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120413 (h0 : functor.add_const (monoid (complete_distrib_lattice name)) pos) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_120414 (h0 : functor.add_const (filter (cancel_monoid ennreal)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120415 (h0 : list (semi_normed_comm_ring (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120416 (h0 : topological_space (has_to_string (option (option (option (option pos)))))) : topological_space.separable_space (has_to_string (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_120417 (h0 : topological_space (preorder (semiring unsigned))) : loc_path_connected_space (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120418 (h0 : topological_space (semigroup (has_to_string (has_to_string pos)))) : path_connected_space (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_120419 (h1 : complete_lattice (denumerable char)) : is_compactly_generated (denumerable char) := sorry --non-trivial
lemma new_lemma_120420 (h0 : functor.add_const (uniform_space (has_add pos)) linarith.comp) : @separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120421 (h1 : function.extfun Type ring) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} h1 empty)  := sorry --non-trivial
lemma new_lemma_120422 (h1 : topological_space (has_nnnorm reducibility_hints)) (h2 : preorder (has_nnnorm reducibility_hints)) : order_topology (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_120423 (h0 : functor.add_const (topological_space (has_to_string name)) (comm_group Type)) : @t1_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_120424 (h0 : uniform_space (has_compl (has_nnnorm fun_info))) : complete_space (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_120425 (h0 : topological_space (add_left_cancel_monoid fun_info)) : t0_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_120426 (h0 : semiring (plift occurrences)) (h1 : plift occurrences) : even h1 := sorry --non-trivial
lemma new_lemma_120427 (h0 : fin has_zero.zero) : @sequential_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120428 (h0 : topological_space (simple_graph (has_pos_part linarith.comp))) : regular_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_120429 (h0 : semiring std_gen) (h1 : star_ring std_gen) (h2 : sym2 (star_ring std_gen)) : sym2.mem h1 h2 := sorry --non-trivial
lemma new_lemma_120430 (h0 : function.extfun Type group) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} empty))  := sorry --non-trivial
lemma new_lemma_120431 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp)))) : irreducible_space (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_120432 (h0 : topological_space (simple_graph pos)) : sequential_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_120433 (h0 : add_group (has_nndist environment.implicit_infer_kind)) : is_add_cyclic (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_120434 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_120435 (h0 : topological_space (has_add num)) : t1_space (has_add num) := sorry --non-trivial
lemma new_lemma_120436 (h1 : add_group (denumerable reducibility_hints)) : is_add_cyclic (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_120437 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120438 (h0 : ordered_add_comm_monoid (has_nndist (has_neg environment.implicit_infer_kind))) : archimedean (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120439 (h0 : topological_space (finset (measurable_space.dynkin_system unsigned))) : t0_space (finset (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_120440 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : sequential_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_120441 (h0 : complete_lattice (has_add (finset (ring (finset linarith.comp))))) : complete_lattice.is_Sup_finite_compact (has_add (finset (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_120442 (h0 : function.extfun Type group) : @group.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_120443 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120444 (h0 : complete_lattice (semigroup (has_add name))) : complete_lattice.is_Sup_finite_compact (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_120445 (h0 : topological_space (has_nndist (boolean_algebra.core Type))) : path_connected_space (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_120446 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (finset pos)) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120447 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop unsigned))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_120448 (h0 : functor.add_const (add_monoid (has_Inf pos)) linarith.comp) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120449 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_120450 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120451 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : t1_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_120452 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_field.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_field.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_120453 (h0 : functor.add_const Prop (canonically_ordered_monoid Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_120454 (h0 : topological_space (semi_normed_comm_ring (random_gen fun_info))) : t0_space (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_120455 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_120456 (h0 : add_group (boolean_algebra (has_add (has_neg linarith.comp)))) : is_add_cyclic (boolean_algebra (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_120457 (h0 : function.extfun Type group) : @group.fg.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120458 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_120459 (h0 : functor.add_const (topological_space (comm_group Type)) (option pos)) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120460 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : preirreducible_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120461 (h0 : semiring (ordered_comm_ring (has_neg linarith.comp))) : is_noetherian_ring (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_120462 (h0 : group (with_one linarith.comp_source)) : normalizer_condition (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120463 (h0 : complete_lattice (sub_neg_monoid (has_bot (has_add (has_Inf (has_bot (has_bot Type))))))) : is_compactly_generated (sub_neg_monoid (has_bot (has_add (has_Inf (has_bot (has_bot Type)))))) := sorry --non-trivial
lemma new_lemma_120464 (h0 : topological_space (finset (has_add linarith.comp))) : path_connected_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_120465 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_120466 (h0 : functor.add_const (ring Type) (has_Inf pos)) : @strong_rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120467 (h0 : ring (nondiscrete_normed_field linarith.ineq)) : is_domain (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_120468 (h0 : uniform_space (normed_group num)) : separated_space (normed_group num) := sorry --non-trivial
lemma new_lemma_120469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_120470 (h0 : add_group (distrib (random_gen char))) : is_add_cyclic (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_120471 (h0 : uniform_space (finset (has_Inf real))) : complete_space (finset (has_Inf real)) := sorry --non-trivial
lemma new_lemma_120472 (h1 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_120473 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_120474 (h0 : topological_space (non_unital_non_assoc_semiring char)) : path_connected_space (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_120475 (h0 : functor.add_const (topological_space (semigroup unsigned)) empty) : @discrete_topology.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_120476 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120477 (h0 : functor.add_const (group (simple_graph linarith.comp)) pos) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_120478 (h0 : functor.add_const Prop (has_pos_part name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_120479 (h0 : not (group (with_bot unsigned) -> false)) : @group.fg.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_120480 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_120481 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120482 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_120483 (h0 : functor.add_const (add_group (complete_distrib_lattice name)) (has_neg pos)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_120484 (h0 : group (ordered_ring empty)) : is_cyclic (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_120485 (h0 : set (simple_graph enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_120486 (h0 : functor.add_const (complete_lattice (linear_ordered_field ennreal)) (mul_zero_class unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_field.{0} ennreal)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_120487 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_120488 (h0 : functor.add_const (functor.add_const (filter int) linarith.comp) linarith.comp) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_120489 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_120490 (h0 : ring (random_gen (mul_one_class (random_gen reducibility_hints)))) : is_domain (random_gen (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_120491 (h0 : topological_space (has_add (option (option pos)))) : preconnected_space (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_120492 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : discrete_topology (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_120493 (h0 : ring (omega_complete_partial_order (option empty))) : is_domain (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_120494 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_120495 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : regular_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_120496 (h0 : topological_space (has_zero (has_add environment.implicit_infer_kind))) : preirreducible_space (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_120498 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_120499 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_120500 (h0 : function.extfun Type ring) : @is_domain.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120501 (h0 : topological_space (mul_zero_class (has_add (cancel_monoid ennreal)))) : totally_disconnected_space (mul_zero_class (has_add (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_120502 (h0 : add_group (canonically_ordered_add_monoid num)) : is_add_cyclic (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_120503 (h0 : ring (has_pos_part (normed_lattice_add_comm_group (has_Inf (has_Inf Type))))) : rank_condition (has_pos_part (normed_lattice_add_comm_group (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_120504 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (has_to_string linarith.comp)) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_120505 (h0 : not (add_group (has_div (mul_one_class (mul_one_class enat))) -> false)) : @is_add_cyclic.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} enat))) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))) h0)  := sorry --non-trivial
lemma new_lemma_120506 (h1 : add_group (with_zero linarith.ineq)) : is_add_cyclic (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_120507 (h0 : nat) (h1 : fin (nat.succ (id h0)) -> filter Prop) (h2 : fin (id h0)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_tail.{0} (filter.{0} Prop) (@id.{1} nat h0) h1 h2))  := sorry --non-trivial
lemma new_lemma_120508 (h0 : cancel_monoid pos -> cancel_monoid pos -> Prop) : is_symm (cancel_monoid pos) h0 := sorry --non-trivial
lemma new_lemma_120509 (h0 : not (complete_lattice (mul_zero_class empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_120510 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120512 (h0 : topological_space (random_gen (has_norm empty))) : path_connected_space (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_120513 (h0 : functor.comp topological_space has_neg name) : @topological_space.separable_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_120514 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120515 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120516 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_120517 (h0 : group (has_to_string num)) : normalizer_condition (has_to_string num) := sorry --non-trivial
lemma new_lemma_120518 (h0 : complete_lattice (canonically_ordered_comm_semiring (option (option empty)))) : is_compactly_generated (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_120519 (h0 : not (topological_space (fintype to_additive.value_type) -> false)) : @t0_space.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_120520 (h0 : group (has_nndist (finset pos))) : is_cyclic (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_120521 (h0 : list (has_add (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120522 (h0 : functor.comp complete_lattice has_to_string pos) : @is_atomistic.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_120523 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @irreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_120524 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_120525 (h0 : function.extfun Type (functor.comp filter add_comm_monoid)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_120526 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @discrete_topology.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_120527 (h0 : topological_space (with_one (has_top linarith.comp_source))) : path_connected_space (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120528 (h0 : topological_space (ordered_comm_ring real)) : locally_compact_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_120529 (h0 : semiring (has_pos_part linarith.comp)) : is_noetherian_ring (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_120530 (h2 : prod (measurable_space string.iterator_imp) (measurable_space string.iterator_imp)) : set.diagonal (measurable_space string.iterator_imp) h2 := sorry --non-trivial
lemma new_lemma_120531 (h0 : ring (comm_ring (semi_normed_ring char))) : rank_condition (comm_ring (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_120532 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120533 (h0 : topological_space (has_sub empty)) : preirreducible_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_120534 (h0 : group (has_Sup num)) : is_cyclic (has_Sup num) := sorry --non-trivial
lemma new_lemma_120535 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120536 (h0 : ring (normed_comm_ring unsigned)) : strong_rank_condition (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_120537 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_120538 (h0 : ordered_comm_monoid (has_nndist (has_add pos))) : has_exists_mul_of_le (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_120539 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) Type) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120540 (h0 : fin has_zero.zero) : @is_simple_group.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_120541 (h0 : has_mem.mem (linear_ordered_semiring linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (linear_ordered_semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_120542 (h0 : group (complete_distrib_lattice (comm_group (comm_group (comm_group name))))) : is_simple_group (complete_distrib_lattice (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_120543 (h0 : group (add_comm_monoid (has_neg_part (comm_group (has_neg_part Type))))) : normalizer_condition (add_comm_monoid (has_neg_part (comm_group (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_120544 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @t0_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120545 (h0 : ring (has_div reducibility_hints)) : rank_condition (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_120546 (h0 : group (with_bot (has_norm (has_norm (semiring empty))))) : is_cyclic (with_bot (has_norm (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_120547 (h0 : not (ring (normed_field (metric_space to_additive.value_type)) -> false)) : @rank_condition.{0} (normed_field.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_120548 (h0 : topological_space (ordered_comm_ring (has_nndist pos))) : normal_space (ordered_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_120549 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.ineq))) : t0_space (complete_semilattice_Sup (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120550 (h0 : group (linear_ordered_comm_ring (semiring empty))) : normalizer_condition (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_120551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120552 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg name)) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_120553 (h0 : functor.add_const (group (has_neg_part name)) name) : @normalizer_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_120554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_120555 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120556 (h0 : topological_space (canonically_ordered_monoid real)) : totally_disconnected_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_120557 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_120558 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120559 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120560 (h0 : topological_space (distrib_lattice linarith.comp_source)) : locally_compact_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120561 (h0 : ring (has_div to_additive.value_type)) : rank_condition (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120562 (h0 : not (ring (normed_field fun_info) -> false)) : @is_domain.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_120563 (h0 : ring (has_dist (has_nnnorm (has_nnnorm linarith.comp_source)))) : strong_rank_condition (has_dist (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_120564 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_120565 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120566 (h0 : group (has_nndist (option ennreal))) : group.fg (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_120567 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120568 (h0 : thunk (topological_space std_gen)) (h1 : set std_gen) : @is_closed.{0} std_gen (@trace_call_stack.{0} (topological_space.{0} std_gen) h0) h1  := sorry --non-trivial
lemma new_lemma_120569 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : @preirreducible_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_120570 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_120572 (h0 : topological_space (topological_space linarith.comp_source)) : path_connected_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120573 (h0 : group (monoid empty)) : group.fg (monoid empty) := sorry --non-trivial
lemma new_lemma_120574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_120575 (h0 : topological_space (simple_graph (has_add linarith.comp))) : discrete_topology (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_120576 (h0 : topological_space (has_compl (mul_one_class string.iterator_imp))) : path_connected_space (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_120577 (h0 : complete_lattice (comm_ring (random_gen (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_120578 (h0 : topological_space (simple_graph (has_Inf name))) : totally_separated_space (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_120579 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_120580 (h0 : topological_space (has_to_string (has_neg_part (boolean_algebra name)))) : normal_space (has_to_string (has_neg_part (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_120581 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120582 (h0 : topological_space (comm_ring (has_inv (with_zero linarith.ineq)))) : totally_disconnected_space (comm_ring (has_inv (with_zero linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120583 (h0 : topological_space (has_Inf real)) : locally_compact_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_120584 (h0 : group (ring (option (option ennreal)))) : normalizer_condition (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_120585 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) (finset linarith.comp)) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_120586 (h0 : topological_space (comm_semigroup pos)) : totally_disconnected_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_120587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120588 (h0 : topological_space (partial_order num)) : path_connected_space (partial_order num) := sorry --non-trivial
lemma new_lemma_120589 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} empty (@function.extfun_app.{2 1} Type ring.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_120590 (h0 : add_monoid (has_neg (has_add environment.implicit_infer_kind))) : add_monoid.fg (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120591 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_120592 (h0 : functor.add_const (ordered_comm_monoid (ring unsigned)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_120593 (h0 : ring (random_gen (has_norm (has_norm (random_gen linarith.comp_source))))) : is_domain (random_gen (has_norm (has_norm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_120594 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120595 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : sequential_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_120596 (h0 : add_group (non_unital_non_assoc_ring congr_arg_kind)) : is_add_cyclic (non_unital_non_assoc_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120597 (h0 : topological_space (semigroup empty)) : discrete_topology (semigroup empty) := sorry --non-trivial
lemma new_lemma_120598 (h0 : uniform_space (complete_distrib_lattice (semiring empty))) : complete_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_120599 (h0 : semiring (partial_order (semiring empty))) : is_noetherian_ring (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_120600 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120601 (h0 : topological_space (with_bot (has_top (has_inv linarith.comp_source)))) : totally_separated_space (with_bot (has_top (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_120602 (h0 : ring (semiring (has_top (has_norm (with_bot congr_arg_kind))))) : rank_condition (semiring (has_top (has_norm (with_bot congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_120603 (h0 : function.extfun Type (prod (ring unsigned))) : id_rel (function.extfun_app h0 (ring unsigned)) := sorry --non-trivial
lemma new_lemma_120604 (h0 : function.extfun nat fin) : @is_domain.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_120605 (h0 : functor.add_const (list (finset linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120606 (h0 : list (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120607 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120608 (h0 : finset (has_bot pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_120609 (h0 : group (bin_tree empty)) : normalizer_condition (bin_tree empty) := sorry --non-trivial
lemma new_lemma_120610 (h1 : ring (has_top (has_inv string_imp))) : is_domain (has_top (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_120611 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_Inf (has_Inf pos))) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_120612 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_120614 (h0 : topological_space (complete_distrib_lattice (semigroup name))) : t1_space (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_120615 (h1 : topological_space (nondiscrete_normed_field reducibility_hints)) (h2 : add_group (nondiscrete_normed_field reducibility_hints)) : topological_add_group (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_120616 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_120617 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_nndist name)) := sorry --non-trivial
lemma new_lemma_120618 (h1 : not (complete_lattice (uniform_space char) -> false)) : is_compactly_generated (uniform_space char) := sorry --non-trivial
lemma new_lemma_120619 (h2 : complete_lattice (uniform_space linarith.ineq)) : is_compactly_generated (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_120620 (h0 : function.extfun nat fin) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120621 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_120622 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120623 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_120624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120625 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (pseudo_emetric_space.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (pseudo_emetric_space.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_120626 (h1 : uniform_space (has_norm (has_top linarith.comp_source))) : complete_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120627 (h0 : topological_space (nondiscrete_normed_field (normed_field (mul_one_class linarith.ineq)))) : t0_space (nondiscrete_normed_field (normed_field (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120628 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice pos)) Type) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_120629 (h0 : ring (has_ssubset (random_gen to_additive.value_type))) : is_domain (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120630 (h0 : topological_space (with_bot (has_norm linarith.comp_source))) : path_connected_space (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120631 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_120632 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) (has_Inf (has_neg Type))) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} pos)) (has_Inf.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_120633 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120634 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_120635 (h0 : group (has_star (semiring (semiring unsigned)))) : is_cyclic (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_120636 (h0 : add_group (normed_lattice_add_comm_group (has_bot Type))) : is_add_cyclic (normed_lattice_add_comm_group (has_bot Type)) := sorry --non-trivial
lemma new_lemma_120637 (h0 : ordered_comm_monoid (boolean_algebra.core linarith.comp)) : has_exists_mul_of_le (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_120638 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120639 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : t1_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_120640 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120642 (h0 : functor.add_const (list pos) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120643 (h0 : functor.add_const (add_group (ordered_comm_group empty)) empty) : @is_add_cyclic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_120644 (h3 : not (complete_lattice linarith.comp_source -> false)) : @is_atomistic.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h3)  := sorry --non-trivial
lemma new_lemma_120645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_120646 (h0 : fin has_zero.zero) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120647 (h0 : ring (has_union empty)) : strong_rank_condition (has_union empty) := sorry --non-trivial
lemma new_lemma_120648 (h0 : prod (group_with_zero (option ennreal)) (group_with_zero (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_120649 (h0 : uniform_space (option (semiring unsigned))) : separated_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120650 (h0 : fin has_zero.zero) : @archimedean.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_120651 (h1 : ring (semi_normed_ring (has_nnnorm (has_nnnorm (random_gen char))))) : rank_condition (semi_normed_ring (has_nnnorm (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_120652 (h0 : not (uniform_space (linear_ordered_comm_ring empty) -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_120653 (h0 : ordered_add_comm_monoid (has_Sup congr_arg_kind)) : archimedean (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120654 (h0 : uniform_space (has_dist enat)) : complete_space (has_dist enat) := sorry --non-trivial
lemma new_lemma_120655 (h0 : not (ring (comm_ring (has_nnnorm linarith.ineq)) -> false)) : @is_domain.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_120656 (h0 : group (linear_ordered_add_comm_group (has_nnnorm char))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_120657 (h1 : has_coe linarith.ineq Prop) (h2 : linarith.ineq) : @coe_b.{1 1} linarith.ineq Prop h1 h2  := sorry --non-trivial
lemma new_lemma_120658 (h0 : functor.add_const (ring (boolean_algebra unsigned)) name) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_120659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120660 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_120661 (h0 : metric_space (linear_ordered_semiring linarith.comp)) (h1 : function.extfun (linear_ordered_semiring linarith.comp) (fun (x : linear_ordered_semiring linarith.comp), Prop)) : euclidean_geometry.cospherical (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_120662 (h0 : functor.add_const (uniform_space (ordered_ring num)) num) : @complete_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_120663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_120664 (h0 : not (group (has_nnnorm fun_info) -> false)) : @group.fg.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_120665 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_120666 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_120667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120668 (h0 : function.extfun nat fin) : @separated_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_120669 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_120670 (h0 : ring (normed_group (random_gen linarith.ineq))) : is_domain (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120671 (h0 : filter (linear_ordered_comm_group congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_120672 (h0 : not (functor.add_const Prop (has_norm fun_info) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_120673 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_120674 (h0 : ring (has_nndist (comm_group unsigned))) : strong_rank_condition (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_120675 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @locally_compact_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120676 (h0 : ring (comm_ring (random_gen (random_gen linarith.comp_source)))) : rank_condition (comm_ring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_120677 (h0 : uniform_space (add_group (semiring unsigned))) : complete_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120678 (h0 : functor.add_const (ordered_add_comm_monoid (finset ennreal)) ennreal) : @archimedean.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_120679 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_120680 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : irreducible_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_120681 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.ineq) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_120682 (h0 : ring (with_bot (semiring (semiring linarith.comp_source)))) : is_domain (with_bot (semiring (semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_120683 (h0 : filter (complete_distrib_lattice unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120684 (h0 : add_group (has_inter (option ennreal))) : is_add_cyclic (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_120685 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : t0_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_120686 (h0 : ring (boolean_algebra.core (ring Type))) : is_principal_ideal_ring (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_120687 (h0 : ring (normed_field (random_gen (random_gen reducibility_hints)))) : is_domain (normed_field (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_120688 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : locally_compact_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_120689 (h0 : topological_space (has_nndist linarith.comp)) : loc_path_connected_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_120690 (h0 : semiring (measure_theory.measure_space (non_assoc_semiring congr_arg_kind))) : is_noetherian_ring (measure_theory.measure_space (non_assoc_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120691 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_120692 (h2 : topological_space empty) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_120693 (h0 : add_group (ring (has_neg environment.implicit_infer_kind))) : is_add_cyclic (ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120694 (h0 : complete_lattice (ordered_comm_ring name)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_120695 (h0 : topological_space (option (option congr_arg_kind))) : preirreducible_space (option (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_120697 (h0 : topological_space (encodable (random_gen string_imp))) : irreducible_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_120698 (h0 : topological_space (random_gen fun_info)) : locally_compact_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_120699 (h0 : group (metric_space (has_norm unsigned))) : group.fg (metric_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_120700 (h0 : topological_space (has_pos_part (has_neg Type))) : topological_space.separable_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_120701 (h0 : topological_space (add_cancel_monoid (has_neg_part name))) : preirreducible_space (add_cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_120702 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120703 (h0 : topological_space (normed_lattice_add_comm_group (has_neg Type))) : totally_separated_space (normed_lattice_add_comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_120704 (h0 : not (uniform_space (random_gen (metric_space (metric_space (add_cancel_comm_monoid char)))) -> false)) : @complete_space.{0} (random_gen.{0} (metric_space.{0} (metric_space.{0} (add_cancel_comm_monoid.{0} char)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (metric_space.{0} (metric_space.{0} (add_cancel_comm_monoid.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_120705 (h0 : not (list (linear_order empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_120706 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_add_comm_monoid_with_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120707 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : totally_disconnected_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120708 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_120709 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_120710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_120711 (h2 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h2) linarith.comp)  := sorry --non-trivial
lemma new_lemma_120712 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_120713 (h0 : topological_space (ring (ring (has_add name)))) : totally_disconnected_space (ring (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_120714 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_120715 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_120716 (h3 : ring (semi_normed_comm_ring reducibility_hints)) : rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_120717 (h0 : functor.add_const (finset (has_neg Type)) (has_neg (has_neg Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_120719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_120720 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120721 (h0 : topological_space (finset (ring (ring (has_neg environment.implicit_infer_kind))))) : totally_separated_space (finset (ring (ring (has_neg environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_120722 (h0 : functor.add_const (group (linear_ordered_comm_ring empty)) congr_arg_kind) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_120723 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_120724 (h1 : uniform_space (semiring (random_gen fun_info))) : complete_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_120725 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) Type) : @rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_120726 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @locally_compact_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_120727 (h0 : ring (has_Sup (semiring congr_arg_kind))) : strong_rank_condition (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120728 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} (semiring.{0} (semiring.{0} unsigned))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} (semiring.{0} (semiring.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_120729 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_120730 (h0 : topological_space (has_Sup empty)) : totally_separated_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_120731 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_120732 (h0 : ordered_add_comm_monoid (plift congr_arg_kind)) : archimedean (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120733 (h0 : function.extfun Type (prod empty)) : id_rel (function.extfun_app h0 empty) := sorry --non-trivial
lemma new_lemma_120734 (h0 : group (has_edist (semiring (semiring empty)))) : normalizer_condition (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_120735 (h0 : complete_lattice (has_emptyc (has_top (has_top (has_top fun_info))))) : is_compactly_generated (has_emptyc (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_120736 (h0 : ring (uniform_space num)) : is_principal_ideal_ring (uniform_space num) := sorry --non-trivial
lemma new_lemma_120737 (h0 : topological_space (has_one (has_norm (has_top unsigned)))) : discrete_topology (has_one (has_norm (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_120738 (h0 : list (canonically_linear_ordered_monoid (has_bot Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120739 (h0 : functor.comp uniform_space ring unsigned) : @complete_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_120740 (h0 : ring (normed_lattice_add_comm_group (has_Inf (boolean_algebra Type)))) : rank_condition (normed_lattice_add_comm_group (has_Inf (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_120741 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_120743 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120744 (h0 : list (semigroup (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_120745 (h0 : complete_lattice (has_append fun_info)) : complete_lattice.is_Sup_finite_compact (has_append fun_info) := sorry --non-trivial
lemma new_lemma_120746 (h0 : topological_space (denumerable (random_gen (random_gen (random_gen char))))) : path_connected_space (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_120747 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_120748 (h0 : add_group (partial_order (semiring empty))) : is_add_cyclic (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_120749 (h0 : list (comm_group (has_to_string pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_120750 (h0 : topological_space (simple_graph (has_add linarith.comp))) : totally_disconnected_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_120751 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring ennreal)) unsigned) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120752 (h0 : uniform_space (add_comm_semigroup char)) : complete_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_120753 (h0 : topological_space (normed_group (semiring unsigned))) : t0_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_120754 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_120755 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg Type)) := sorry --non-trivial
lemma new_lemma_120756 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup empty)))) : @path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_120757 (h0 : functor.add_const (list (mul_zero_class unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120758 (h0 : ring (topological_space (has_ssubset char))) : strong_rank_condition (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_120759 (h0 : not (add_group (has_ssubset string_imp) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_120760 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120761 (h0 : complete_lattice (sub_neg_monoid (has_neg (has_Inf name)))) : is_compactly_generated (sub_neg_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_120762 (h1 : topological_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class to_additive.value_type)))) : t0_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_120763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120764 (h0 : monoid (cancel_monoid (option (option unsigned)))) : monoid.fg (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_120765 (h0 : topological_space (id (semiring (semiring (semiring (semiring congr_arg_kind)))))) : preirreducible_space (id (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_120766 (h0 : functor.add_const (filter (normed_comm_ring pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120767 (h0 : topological_space (add_left_cancel_semigroup empty)) : t1_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_120768 (h0 : not (topological_space (has_one num) -> false)) : @locally_compact_space.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_120769 (h0 : function.extfun Type (functor.add_const (finset (free_add_monoid congr_arg_kind)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_120770 (h0 : functor.add_const (topological_space (ring name)) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_120771 (h0 : complete_lattice (has_top (semiring linarith.comp_source))) : is_compactly_generated (has_top (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120772 (h0 : topological_space (finset (option (option (option ennreal))))) : t1_space (finset (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_120773 (h0 : functor.add_const (monoid (normed_comm_ring pos)) pos) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_120774 (h0 : functor.add_const (ordered_add_comm_monoid (add_left_cancel_semigroup empty)) unsigned) : @archimedean.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_left_cancel_semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120775 (h1 : not (topological_space (distrib linarith.comp_source) -> false)) : @t0_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_120776 (h3 : ring (has_append (has_ssubset fun_info))) : rank_condition (has_append (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_120777 (h0 : not (ring (distrib_lattice (linear_ordered_add_comm_group linarith.comp_source)) -> false)) : @rank_condition.{0} (distrib_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_120778 (h0 : semiring (semigroup (normed_comm_ring (finset (add_comm_monoid name))))) : is_noetherian_ring (semigroup (normed_comm_ring (finset (add_comm_monoid name)))) := sorry --non-trivial
lemma new_lemma_120779 (h0 : topological_space (add_comm_monoid (mul_zero_class (mul_zero_class name)))) : t1_space (add_comm_monoid (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_120780 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120781 (h0 : functor.add_const (function.extfun Type group) (has_Inf (has_Inf name))) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_Inf.{0} (has_Inf.{0} name)) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120782 (h0 : ring (metric_space linarith.comp)) : is_domain (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_120783 (h0 : add_group (ordered_comm_ring (has_Inf pos))) : is_add_cyclic (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_120784 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_120785 (h1 : topological_space (has_compl std_gen)) : totally_disconnected_space (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_120786 (h0 : functor.add_const (semiring (has_nndist pos)) linarith.comp) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120787 (h0 : ring (semi_normed_ring enat)) (h1 : add_group (has_ssubset (ring.positive_cone (semi_normed_ring enat)))) : is_add_cyclic (has_ssubset (ring.positive_cone (semi_normed_ring enat))) := sorry --non-trivial
lemma new_lemma_120788 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_120789 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_120790 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120791 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_120792 (h1 : ring (linear_ordered_add_comm_group linarith.comp_source)) : is_domain (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120793 (h1 : has_mem.mem (id num) has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type num) h1)  := sorry --non-trivial
lemma new_lemma_120794 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_120795 (h0 : functor.add_const (topological_space (comm_group pos)) (option name)) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_120796 (h0 : topological_space (comm_group (has_neg_part (comm_group (comm_group (has_neg_part name)))))) : loc_path_connected_space (comm_group (has_neg_part (comm_group (comm_group (has_neg_part name))))) := sorry --non-trivial
lemma new_lemma_120797 (h0 : functor.comp ring linear_ordered_field ennreal) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_field.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_120798 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_120799 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120800 (h0 : topological_space (has_zero name)) : normal_space (has_zero name) := sorry --non-trivial
lemma new_lemma_120801 (h0 : ordered_comm_monoid (add_comm_monoid (add_comm_monoid Type))) : has_exists_mul_of_le (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_120802 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_120803 (h0 : list (ring congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_120804 (h0 : topological_space (has_lt enat)) (h1 : preorder (has_lt enat)) : order_closed_topology (has_lt enat) := sorry --non-trivial
lemma new_lemma_120805 (h0 : topological_space (has_norm linarith.comp_source)) : totally_separated_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120806 (h0 : topological_space (has_ssubset (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120807 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_120808 (h0 : complete_lattice (has_add unsigned)) : complete_lattice.is_Sup_finite_compact (has_add unsigned) := sorry --non-trivial
lemma new_lemma_120809 (h0 : topological_space (linear_order empty)) : discrete_topology (linear_order empty) := sorry --non-trivial
lemma new_lemma_120810 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_120811 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)))) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_120812 (h0 : fin has_zero.zero) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_120813 (h0 : topological_space (sub_neg_monoid (has_Inf name))) : topological_space.separable_space (sub_neg_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_120814 (h2 : ring (has_compl char)) : strong_rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_120815 (h0 : eq Prop linarith.comp_source) (h1 : linarith.comp_source) : eq.mpr h0 h1 := sorry --non-trivial
lemma new_lemma_120816 (h2 : complete_lattice (simple_graph to_additive.value_type)) : is_compactly_generated (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120817 (h0 : not (group (linear_ordered_semiring linarith.comp) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_120818 (h0 : ring (finset (complete_distrib_lattice (finset environment.implicit_infer_kind)))) : strong_rank_condition (finset (complete_distrib_lattice (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_120819 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_120820 (h0 : topological_space (ring (has_Inf (boolean_algebra Type)))) : path_connected_space (ring (has_Inf (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_120821 (h0 : monoid (complete_semilattice_Sup (semiring (semiring (has_norm empty))))) : monoid.fg (complete_semilattice_Sup (semiring (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_120822 (h0 : topological_space (normed_linear_ordered_group empty)) : locally_compact_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_120823 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_120824 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf pos)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_120825 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @normal_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_120826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_120827 (h0 : functor.add_const (topological_space (has_ssubset pos)) Type) : @t1_space.{0} (has_ssubset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_ssubset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_120828 (h0 : monoid (has_edist (option unsigned))) : monoid.fg (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_120829 (h0 : group (comm_semigroup (sub_neg_monoid (comm_semigroup pos)))) : normalizer_condition (comm_semigroup (sub_neg_monoid (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_120830 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup linarith.comp)) Type) : @unique_factorization_monoid.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_120831 (h0 : functor.add_const (group (comm_group pos)) pos) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_120832 (h0 : ring (group_with_zero ennreal)) : is_domain (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_120833 (h0 : monoid (complete_linear_order (has_top (semiring congr_arg_kind)))) : monoid.fg (complete_linear_order (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_120834 (h1 : add_group (id fun_info)) : is_add_cyclic (id fun_info) := sorry --non-trivial
lemma new_lemma_120835 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type add_group.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_120836 (h0 : not (filter linarith.ineq -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_120837 (h0 : ring (has_ssubset (metric_space reducibility_hints))) : rank_condition (has_ssubset (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_120838 (h0 : prod (has_Sup (semiring unsigned)) (has_Sup (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_120839 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @separated_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_120840 (h0 : function.extfun (random_gen linarith.ineq) (fun (x : random_gen linarith.ineq), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_120841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_120842 (h1 : ring (linear_ordered_comm_group_with_zero std_gen)) : rank_condition (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_120843 (h0 : topological_space (has_zero (finset (finset ennreal)))) : preirreducible_space (has_zero (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_120844 (h0 : topological_space (topological_space fun_info)) : t0_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_120845 (h1 : ring (dlist (has_nnnorm (random_gen char)))) : is_domain (dlist (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_120846 (h0 : topological_space (has_one (semiring linarith.comp))) : preirreducible_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_120847 (h0 : add_group (has_Inf (has_Inf linarith.comp))) : is_add_cyclic (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_120848 (h0 : finset (has_neg (complete_distrib_lattice (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_120849 (h0 : topological_space (metric_space (has_norm (semiring fun_info)))) : normal_space (metric_space (has_norm (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_120850 (h0 : cancel_comm_monoid_with_zero (cancel_monoid num)) : unique_factorization_monoid (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_120851 (h0 : topological_space (mul_zero_class Type)) : sequential_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_120852 (h0 : has_lt (semi_normed_comm_ring reducibility_hints)) : no_max_order (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_120853 (h0 : add_group (dlist (random_gen fun_info))) : is_add_cyclic (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_120854 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : preirreducible_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120855 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120856 (h0 : functor.add_const (group (has_neg_part pos)) linarith.comp) : @group.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120857 (h0 : semiring (with_one (semiring (semiring (semiring (semiring (semiring num))))))) : is_noetherian_ring (with_one (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_120858 (h0 : has_lt (normed_field enat)) : no_max_order (normed_field enat) := sorry --non-trivial
lemma new_lemma_120859 (h0 : ring (has_one (semiring (semiring empty)))) : is_principal_ideal_ring (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_120860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_120861 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_120862 (h0 : function.extfun Type topological_space) : @t0_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_120863 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120864 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (generalized_boolean_algebra.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_120865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_120866 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120867 (h0 : topological_space (has_inter (option (option num)))) : totally_separated_space (has_inter (option (option num))) := sorry --non-trivial
lemma new_lemma_120868 (h0 : thunk (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@trace_call_stack.{0} (@ulower.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_120869 (h0 : topological_space (comm_semigroup (has_Inf name))) : locally_compact_space (comm_semigroup (has_Inf name)) := sorry --non-trivial
lemma new_lemma_120870 (h3 : has_lt environment.projection_info) : no_max_order environment.projection_info := sorry --non-trivial
lemma new_lemma_120871 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_120872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120873 (h0 : uniform_space (add_cancel_monoid (has_Inf name))) : complete_space (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_120874 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring Type)) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_120875 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120876 (h0 : not (ring (has_lt (random_gen (semigroup (mul_one_class reducibility_hints)))) -> false)) : @strong_rank_condition.{0} (has_lt.{0} (random_gen.{0} (semigroup.{0} (mul_one_class.{0} reducibility_hints)))) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} (random_gen.{0} (semigroup.{0} (mul_one_class.{0} reducibility_hints))))) h0)  := sorry --non-trivial
lemma new_lemma_120877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120878 (h0 : add_group (measurable_space (semiring (semiring (semiring (semiring (semiring empty))))))) : is_add_cyclic (measurable_space (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_120879 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_120880 (h1 : measurable_space (add_cancel_comm_monoid string_imp)) (h2 : not (has_sup (add_cancel_comm_monoid string_imp) -> false)) : @has_measurable_sup₂.{0} (add_cancel_comm_monoid.{0} string_imp) h1 (@classical.by_contradiction'.{1} (has_sup.{0} (add_cancel_comm_monoid.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_120881 (h1 : monoid (denumerable (denumerable string_imp))) : monoid.fg (denumerable (denumerable string_imp)) := sorry --non-trivial
lemma new_lemma_120882 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @irreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_120883 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @strong_rank_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type ring.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_120884 (h0 : topological_space (add_group (semiring empty))) : topological_space.separable_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_120885 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120886 (h0 : ordered_add_comm_monoid (semigroup (comm_group Type))) : archimedean (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_120887 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_120888 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid num)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_120889 (h0 : topological_space (has_Sup empty)) : t1_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_120890 (h0 : ring (has_inter congr_arg_kind)) : is_domain (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_120891 (h0 : semiring (generalized_boolean_algebra (has_add pos))) : is_noetherian_ring (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_120892 (h0 : function.extfun Type ring) : @is_domain.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_120893 (h0 : topological_space (add_group (add_group (semiring congr_arg_kind)))) : preirreducible_space (add_group (add_group (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_120894 (h0 : topological_space (simple_graph (has_Inf pos))) : totally_disconnected_space (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_120895 (h0 : ring (ordered_comm_ring to_additive.value_type)) : is_domain (ordered_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120896 (h0 : topological_space (has_dist (option ennreal))) : irreducible_space (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_120897 (h0 : topological_space (boolean_algebra (ring (finset (finset Type))))) : normal_space (boolean_algebra (ring (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_120898 (h1 : topological_space (topological_space (random_gen (random_gen char)))) : path_connected_space (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_120899 (h0 : prod (has_to_string pos) (has_to_string pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_120900 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_120901 (h0 : topological_space (has_Inf linarith.comp)) : preirreducible_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_120902 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) (has_neg environment.implicit_infer_kind)) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_120903 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup empty)) (semiring empty)) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_120904 (h0 : group (add_cancel_monoid (option (option empty)))) : normalizer_condition (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_120905 (h1 : set (add_comm_semigroup fun_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_120906 (h0 : topological_space (has_norm (has_norm (semiring linarith.comp)))) : t0_space (has_norm (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_120907 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_120908 (h0 : topological_space (add_monoid (has_nnnorm linarith.ineq))) : totally_disconnected_space (add_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120909 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_120910 (h2 : group (id (has_top linarith.ineq))) : normalizer_condition (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120911 (h0 : function.extfun Type group) : @group.fg.{0} (div_inv_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (div_inv_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_120912 (h0 : group (add_right_cancel_monoid (semiring empty))) : group.fg (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_120913 (h0 : functor.add_const (filter (has_neg name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120914 (h0 : ordered_add_comm_monoid (finset (has_neg real))) : archimedean (finset (has_neg real)) := sorry --non-trivial
lemma new_lemma_120915 (h0 : functor.add_const (ring (boolean_algebra Type)) pos) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_120916 (h0 : add_group (boolean_algebra.core (has_add pos))) : is_add_cyclic (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_120917 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) num) : @discrete_topology.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_120918 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (finset (finset ennreal)))) : unique_factorization_monoid (mul_zero_class (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_120919 (h0 : group (left_cancel_semigroup unsigned)) : normalizer_condition (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_120920 (h0 : filter (has_inv (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120922 (h0 : list (semigroup (finset znum))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_120923 (h0 : ring (pseudo_metric_space unsigned)) : strong_rank_condition (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_120924 (h0 : not (group (linear_ordered_comm_ring congr_arg_kind) -> false)) : @group.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_120925 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120926 (h0 : ring (ring (cancel_monoid (semigroup name)))) : strong_rank_condition (ring (cancel_monoid (semigroup name))) := sorry --non-trivial
lemma new_lemma_120927 (h0 : functor.add_const (monoid (has_neg pos)) (boolean_algebra name)) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_120928 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_comm_monoid empty)))) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_120929 (h0 : functor.add_const (topological_space (finset pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_120930 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_120931 (h0 : set (add_comm_semigroup char -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_120932 (h0 : group (has_ssubset (has_ssubset to_additive.value_type))) : is_cyclic (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_120933 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_120934 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring (semiring (semiring empty))))) : unique_factorization_monoid (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_120935 (h0 : ring (has_nndist (has_add (has_neg linarith.comp)))) : is_principal_ideal_ring (has_nndist (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_120936 (h0 : monoid (with_one (has_top fun_info))) : monoid.fg (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_120937 (h0 : group (has_nndist (normed_comm_ring Type))) : is_simple_group (has_nndist (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_120938 (h1 : topological_space (with_one linarith.comp_source)) : t0_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_120939 (h0 : filter (add_comm_monoid (comm_group name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120940 (h0 : add_group (normed_lattice_add_comm_group (has_add real))) : is_add_cyclic (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_120941 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_120942 (h0 : ring (uniform_space (mul_one_class char))) : strong_rank_condition (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_120943 (h0 : functor.add_const (ring (ring linarith.comp)) pos) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_120944 (h0 : group (boolean_algebra.core (boolean_algebra.core (has_add ennreal)))) : group.fg (boolean_algebra.core (boolean_algebra.core (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_120945 (h0 : complete_lattice (id to_additive.value_type)) : is_atomistic (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_120946 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120947 (h0 : group (has_top (has_norm linarith.comp_source))) : is_cyclic (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_120948 (h0 : topological_space (semigroup name)) : topological_space.separable_space (semigroup name) := sorry --non-trivial
lemma new_lemma_120949 (h6 : ring (mul_one_class linarith.ineq)) : is_domain (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_120950 (h0 : add_group (linear_ordered_field empty)) : is_add_cyclic (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_120951 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @locally_compact_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_120952 (h0 : topological_space (random_gen (has_top (has_top fun_info)))) : locally_compact_space (random_gen (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_120953 (h1 : filter (add_group linarith.comp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_120954 (h0 : functor.add_const (finset (has_nndist pos)) (has_add linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_120955 (h0 : topological_space (generalized_boolean_algebra (has_add (ring (has_add (has_pos_part name)))))) : sequential_space (generalized_boolean_algebra (has_add (ring (has_add (has_pos_part name))))) := sorry --non-trivial
lemma new_lemma_120956 (h0 : fin has_zero.zero) : @path_connected_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120957 (h0 : ring (has_zero (comm_group (comm_group (comm_group name))))) : rank_condition (has_zero (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_120958 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_Inf (has_add pos)))) : archimedean (sub_neg_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_120959 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) Type) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_120960 (h0 : ordered_comm_monoid (has_add (add_cancel_monoid (has_add (has_add pos))))) : has_exists_mul_of_le (has_add (add_cancel_monoid (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_120961 (h0 : functor.add_const (complete_lattice (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_120962 (h0 : filter (normed_group string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_120963 (h0 : ring (add_left_cancel_semigroup empty)) : is_domain (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_120964 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_120965 (h0 : group (ring empty)) : group.fg (ring empty) := sorry --non-trivial
lemma new_lemma_120966 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_120967 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_120968 (h0 : ring (has_add (option (option unsigned)))) : strong_rank_condition (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_120969 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_120970 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_120971 (h1 : add_monoid (mul_one_class char)) : add_monoid.fg (mul_one_class char) := sorry --non-trivial
lemma new_lemma_120972 (h0 : ring (simple_graph (mul_one_class (mul_one_class string.iterator_imp))) -> Prop) (h1 : Exists (fun (x : ring (simple_graph (mul_one_class (mul_one_class string.iterator_imp)))), h0 x)) : @strong_rank_condition.{0} (simple_graph.{0} (mul_one_class.{0} (mul_one_class.{0} string.iterator_imp))) (@classical.some.{1} (ring.{0} (simple_graph.{0} (mul_one_class.{0} (mul_one_class.{0} string.iterator_imp)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_120973 (h0 : monoid (canonically_linear_ordered_monoid real)) : monoid.fg (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_120974 (h0 : group (normed_lattice_add_comm_group (has_bot real))) : is_cyclic (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_120975 (h0 : topological_space (boolean_algebra.core (finset name))) : t0_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_120976 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_120977 (h0 : functor.add_const (complete_lattice (group_with_zero ennreal)) ennreal) : @is_atomistic.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (group_with_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_120978 (h0 : functor.add_const (ring (has_zero Type)) (ring environment.implicit_infer_kind)) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_120979 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_120980 (h0 : complete_lattice (has_lt std_gen)) : is_compactly_generated (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_120981 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_120982 (h0 : group (has_emptyc (random_gen (random_gen linarith.ineq)))) : normalizer_condition (has_emptyc (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120983 (h0 : monoid (has_ssubset (has_inv string_imp))) : monoid.fg (has_ssubset (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_120984 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_120985 (h0 : complete_lattice (add_cancel_monoid Type)) : is_compactly_generated (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_120986 (h0 : ordered_comm_monoid (boolean_algebra.core (mul_zero_class environment.implicit_infer_kind))) : has_exists_mul_of_le (boolean_algebra.core (mul_zero_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_120987 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) num) : @totally_disconnected_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_120988 (h0 : preorder (add_comm_semigroup (mul_one_class char))) (h1 : set (add_comm_semigroup (mul_one_class char))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_120989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (finset.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_120990 (h0 : functor.comp ring add_cancel_monoid name) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_120991 (h0 : complete_lattice (normed_comm_ring (has_neg_part pos))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_120992 (h0 : group (complete_semilattice_Sup (has_nnnorm linarith.ineq))) : group.fg (complete_semilattice_Sup (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_120993 (h0 : topological_space (finset (has_pos_part linarith.comp))) : regular_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_120994 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) linarith.comp) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_120995 (h0 : not (uniform_space (has_union num) -> false)) : @complete_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_120996 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_120997 (h0 : group (add_cancel_comm_monoid (random_gen (denumerable linarith.ineq)))) : is_cyclic (add_cancel_comm_monoid (random_gen (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_120998 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @normal_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_120999 (h0 : topological_space (normed_group (random_gen fun_info))) : irreducible_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_121000 (h0 : topological_space (ordered_ring char)) (h1 : preorder (ordered_ring char)) : order_topology (ordered_ring char) := sorry --non-trivial
lemma new_lemma_121001 (h0 : uniform_space (complete_semilattice_Sup num)) : complete_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_121002 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (has_add name))) : unique_factorization_monoid (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_121003 (h0 : ring (semi_normed_ring (has_ssubset string_imp))) : strong_rank_condition (semi_normed_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_121004 (h0 : filter (has_neg_part (option (option (option pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121005 (h0 : list (ring (has_add (finset (ring Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121006 (h0 : topological_space (has_emptyc (has_top (has_top linarith.ineq)))) : path_connected_space (has_emptyc (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_121007 (h0 : group (add_group (semiring unsigned))) : normalizer_condition (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121008 (h0 : measurable_space (has_ssubset linarith.ineq)) (h1 : filter (has_ssubset linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_121009 (h1 : complete_lattice (distrib reducibility_hints)) : is_compactly_generated (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_121010 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_121011 (h0 : topological_space (is_R_or_C congr_arg_kind)) : preirreducible_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121012 (h1 : complete_lattice (has_one fun_info)) : complete_lattice.is_Sup_finite_compact (has_one fun_info) := sorry --non-trivial
lemma new_lemma_121013 (h0 : not (topological_space (bin_tree empty) -> false)) : @locally_compact_space.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_121014 (h0 : complete_lattice (normed_comm_ring Type)) : is_atomistic (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_121015 (h0 : topological_space (add_comm_monoid (has_pos_part (has_add real)))) : loc_path_connected_space (add_comm_monoid (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_121016 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @topological_space.separable_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_121017 (h0 : function.extfun nat fin) : @t1_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121018 (h0 : ring (semiring char)) : is_domain (semiring char) := sorry --non-trivial
lemma new_lemma_121019 (h0 : ring (has_append string.iterator_imp)) : rank_condition (has_append string.iterator_imp) := sorry --non-trivial
lemma new_lemma_121020 (h0 : topological_space (linear_ordered_comm_group ennreal)) : totally_separated_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_121021 (h0 : has_mem.mem (with_one (has_norm linarith.comp)) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} (has_norm.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_121022 (h0 : topological_space (has_add (ring (has_pos_part (ring pos))))) : discrete_topology (has_add (ring (has_pos_part (ring pos)))) := sorry --non-trivial
lemma new_lemma_121023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_121024 (h3 : topological_space linarith.comp) : totally_disconnected_space linarith.comp := sorry --non-trivial
lemma new_lemma_121025 (h0 : not (topological_space (with_bot num) -> false)) : @topological_space.separable_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_121026 (h0 : topological_space (has_nnnorm (mul_one_class reducibility_hints))) : path_connected_space (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_121027 (h0 : ordered_comm_monoid (add_comm_monoid (ring Type))) : has_exists_mul_of_le (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_121028 (h0 : add_monoid (canonically_ordered_monoid (simple_graph (has_add Type)))) : add_monoid.fg (canonically_ordered_monoid (simple_graph (has_add Type))) := sorry --non-trivial
lemma new_lemma_121029 (h0 : ring (ring (has_to_string linarith.comp))) : rank_condition (ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_121030 (h0 : preorder (mul_one_class (mul_one_class ereal))) (h1 : set (mul_one_class (mul_one_class ereal))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_121031 (h0 : ordered_add_comm_monoid (has_norm fun_info)) : archimedean (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_121032 (h0 : functor.add_const (finset (free_add_monoid empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121033 (h0 : not (nat -> false)) (h1 : nat) (h2 : thunk Prop) : scope_trace h2 := sorry --non-trivial
lemma new_lemma_121034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_121035 (h0 : topological_space (with_one num)) : topological_space.separable_space (with_one num) := sorry --non-trivial
lemma new_lemma_121036 (h0 : topological_space (free_add_monoid (semiring empty))) : path_connected_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_121037 (h0 : add_group (has_compl (has_nnnorm char))) : is_add_cyclic (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_121038 (h0 : functor.add_const (topological_space (has_inter num)) num) : @loc_path_connected_space.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_121039 (h0 : ordered_add_comm_monoid (cancel_monoid (option ennreal))) : archimedean (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_121040 (h0 : filter (boolean_algebra.core pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121041 (h0 : functor.add_const (group (comm_group name)) Type) : @is_simple_group.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_121042 (h0 : semiring (has_nndist empty)) : is_noetherian_ring (has_nndist empty) := sorry --non-trivial
lemma new_lemma_121043 (h0 : function.extfun (finset Type) (has_mem.mem (has_one num))) : @rank_condition.{0} (has_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121044 (h0 : functor.add_const (topological_space (ring pos)) Type) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_121045 (h0 : topological_space (has_nndist (has_to_string pos))) : t0_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_121046 (h0 : monoid (random_gen (has_top (has_top (bin_tree (has_top linarith.ineq)))))) : monoid.fg (random_gen (has_top (has_top (bin_tree (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_121047 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121048 (h0 : functor.add_const (ring (option unsigned)) (semiring num)) : @strong_rank_condition.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_121049 (h0 : complete_lattice (has_neg (comm_group Type))) : is_atomistic (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_121050 (h0 : group (comm_semigroup (has_bot (has_bot (has_bot (has_bot real)))))) : is_simple_group (comm_semigroup (has_bot (has_bot (has_bot (has_bot real))))) := sorry --non-trivial
lemma new_lemma_121051 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121052 (h0 : group (has_neg (option (option ennreal)))) : is_simple_group (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_121053 (h0 : group (with_bot (has_norm (has_norm linarith.comp)))) : normalizer_condition (with_bot (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_121054 (h0 : ring (ordered_ring num)) : is_domain (ordered_ring num) := sorry --non-trivial
lemma new_lemma_121055 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_121057 (h0 : group (pseudo_metric_space (finset pos))) : normalizer_condition (pseudo_metric_space (finset pos)) := sorry --non-trivial
lemma new_lemma_121058 (h0 : ring (ring Type)) : strong_rank_condition (ring Type) := sorry --non-trivial
lemma new_lemma_121059 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121060 (h0 : ordered_comm_monoid (semigroup unsigned)) : has_exists_mul_of_le (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_121061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_121062 (h0 : topological_space (has_pos_part real)) : path_connected_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_121063 (h0 : option (topological_space (distrib string.iterator_imp))) (h1 : coe_sort (option.is_some h0)) : @t0_space.{0} (distrib.{0} string.iterator_imp) (@option.get.{0} (topological_space.{0} (distrib.{0} string.iterator_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_121064 (h0 : topological_space (denumerable (has_inv linarith.ineq))) : path_connected_space (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121065 (h0 : complete_lattice (encodable (with_zero char))) : is_compactly_generated (encodable (with_zero char)) := sorry --non-trivial
lemma new_lemma_121066 (h0 : complete_lattice (has_top (has_norm num))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_121067 (h0 : semiring (has_Inf (has_add linarith.comp))) : is_noetherian_ring (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121068 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) pos) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_121069 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_121070 (h1 : uniform_space (has_compl (has_nnnorm char))) : complete_space (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_121071 (h0 : filter (linear_ordered_field (option (option (option (option ennreal)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121072 (h0 : complete_semilattice_Sup congr_arg_kind -> complete_semilattice_Sup congr_arg_kind -> Prop) : is_trans (complete_semilattice_Sup congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_121073 (h4 : set (add_comm_semigroup linarith.ineq -> linarith.ineq)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_121074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121075 (h1 : set (add_comm_semigroup char -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_121076 (h2 : group (with_one num)) : is_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_121077 (h0 : topological_space (add_cancel_monoid (option (option (option empty))))) : totally_separated_space (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_121078 (h0 : group (has_zero (finset nnreal))) : group.fg (has_zero (finset nnreal)) := sorry --non-trivial
lemma new_lemma_121079 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) unsigned) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121080 (h0 : list (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121081 (h0 : topological_space (with_one (semiring (semiring linarith.comp)))) : locally_compact_space (with_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_121082 (h0 h1 : multiset linarith.ineq) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_121083 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121084 (h0 : ring (normed_lattice_add_comm_group (has_add real))) : rank_condition (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_121085 (h0 : ring (topological_space (has_nnnorm (has_nnnorm char)))) : rank_condition (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_121086 (h0 : complete_lattice (with_bot (metric_space linarith.comp))) : complete_lattice.is_Sup_finite_compact (with_bot (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_121087 (h0 : ring (comm_semigroup Type)) : is_principal_ideal_ring (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_121088 (h0 : list (has_zero pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121089 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) name) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_121090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121091 (h0 : function.extfun nat fin) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121092 (h0 : topological_space (has_Inf (has_Inf (has_add pos)))) : regular_space (has_Inf (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_121093 (h3 : ring (normed_field char)) : strong_rank_condition (normed_field char) := sorry --non-trivial
lemma new_lemma_121094 (h0 : topological_space (has_zero (has_add pos))) : discrete_topology (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_121095 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121096 (h0 : uniform_space (simple_graph (ring (has_pos_part (has_pos_part (ring linarith.comp)))))) : separated_space (simple_graph (ring (has_pos_part (has_pos_part (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_121097 (h0 : topological_space (measurable_space (has_norm num))) : totally_disconnected_space (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_121098 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121099 (h0 : functor.add_const (filter (add_comm_monoid linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121100 (h0 : topological_space (semigroup (has_add (has_neg (finset pos))))) : preconnected_space (semigroup (has_add (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_121101 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @is_add_cyclic.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121102 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_neg linarith.comp))) : unique_factorization_monoid (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_121103 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_121104 (h0 : list (has_nndist (finset ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121105 (h0 : ring (linear_ordered_semiring (has_top fun_info))) : strong_rank_condition (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_121106 (h0 : functor.add_const (add_monoid (has_neg Type)) pos) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_121107 (h2 : has_mem.mem (topological_space linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} linarith.ineq (@multiset.inf.{0} (topological_space.{0} linarith.ineq) (@lattice.to_semilattice_inf.{0} (topological_space.{0} linarith.ineq) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} linarith.ineq) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} linarith.ineq) (@topological_space.complete_lattice.{0} linarith.ineq)))) (@bounded_order.to_order_top.{0} (topological_space.{0} linarith.ineq) (@preorder.to_has_le.{0} (topological_space.{0} linarith.ineq) (@partial_order.to_preorder.{0} (topological_space.{0} linarith.ineq) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} linarith.ineq) (@lattice.to_semilattice_inf.{0} (topological_space.{0} linarith.ineq) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} linarith.ineq) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} linarith.ineq) (@topological_space.complete_lattice.{0} linarith.ineq))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} linarith.ineq) (@topological_space.complete_lattice.{0} linarith.ineq))) (@finset.pi.empty.{1 0} Type multiset.{0} (topological_space.{0} linarith.ineq) h2))  := sorry --non-trivial
lemma new_lemma_121108 (h0 : ring (canonically_ordered_add_monoid (option (option (option (option empty)))))) : is_domain (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_121109 (h0 : add_group (linear_ordered_add_comm_group (has_norm to_additive.value_type))) : is_add_cyclic (linear_ordered_add_comm_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121110 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @t1_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121111 (h0 : topological_space (normed_comm_ring (option name))) : regular_space (normed_comm_ring (option name)) := sorry --non-trivial
lemma new_lemma_121112 (h0 : semiring (canonically_ordered_monoid (sub_neg_monoid real))) : is_noetherian_ring (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_121113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_121114 (h0 : semiring (simple_graph (has_nndist (has_add linarith.comp)))) : is_noetherian_ring (simple_graph (has_nndist (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_121115 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121116 (h0 : not (ring (has_inv fun_info) -> false)) : @is_domain.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_121117 (h0 : topological_space (has_top (has_nnnorm linarith.ineq))) : path_connected_space (has_top (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121118 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121119 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) linarith.comp) : @sequential_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121120 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_121121 (h0 : functor.add_const (ring (ring pos)) environment.implicit_infer_kind) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121122 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121123 (h0 : distrib (mul_one_class string.iterator_imp) -> linarith.comp_source) (h1 : linarith.comp_source -> distrib (mul_one_class string.iterator_imp)) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_121124 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_121126 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121127 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf name)))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_121128 (h0 : group (generalized_boolean_algebra Type)) : group.fg (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_121129 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @totally_separated_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_121130 (h0 : ring (normed_group (with_one empty))) : is_domain (normed_group (with_one empty)) := sorry --non-trivial
lemma new_lemma_121131 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121132 (h0 : complete_lattice (div_inv_monoid (random_gen linarith.ineq))) : is_compactly_generated (div_inv_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121133 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_121134 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @normal_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_121135 (h0 : topological_space (with_bot unsigned)) : locally_compact_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_121136 (h1 : function.extfun Type group) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} h1 fun_info)  := sorry --non-trivial
lemma new_lemma_121137 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_121138 (h0 : finset (add_comm_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_121139 (h0 : complete_lattice (finset (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_121140 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_Inf pos)) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121141 (h0 : topological_space (has_bot (has_bot (has_neg Type)))) : totally_separated_space (has_bot (has_bot (has_neg Type))) := sorry --non-trivial
lemma new_lemma_121142 (h0 : topological_space (with_bot (random_gen (random_gen string_imp)))) : locally_compact_space (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_121143 (h0 : group (has_top (has_top (has_norm fun_info)))) : normalizer_condition (has_top (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_121144 (h0 : add_group (has_div char)) : is_add_cyclic (has_div char) := sorry --non-trivial
lemma new_lemma_121145 (h0 : filter (topological_space to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121146 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_121147 (h0 : monoid (complete_distrib_lattice (comm_group unsigned))) : monoid.fg (complete_distrib_lattice (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_121148 (h0 : uniform_space (boolean_algebra pos)) : separated_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_121149 (h0 : complete_lattice (normed_comm_ring environment.implicit_infer_kind)) : is_compactly_generated (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_121150 (h0 : cancel_monoid (option pos) -> cancel_monoid (option pos) -> Prop) : is_symm (cancel_monoid (option pos)) h0 := sorry --non-trivial
lemma new_lemma_121151 (h0 : group (add_comm_monoid (has_to_string (comm_group pos)))) : group.fg (add_comm_monoid (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_121152 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121153 (h0 : not (add_group (distrib_lattice linarith.ineq) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121154 (h0 : topological_space (sub_neg_monoid (has_neg name))) : topological_space.separable_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_121155 (h0 : functor.add_const (semiring linarith.comp) (has_pos_part (finset linarith.comp))) : @is_noetherian_ring.{0} linarith.comp (@functor.add_const.run.{0 0} (semiring.{0} linarith.comp) (has_pos_part.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_121156 (h0 : topological_space (normed_comm_ring (finset (finset (has_add name))))) : loc_path_connected_space (normed_comm_ring (finset (finset (has_add name)))) := sorry --non-trivial
lemma new_lemma_121157 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : totally_separated_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_121158 (h0 : topological_space (plift (add_left_cancel_semigroup unsigned))) : locally_compact_space (plift (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_121159 (h0 : functor.add_const (uniform_space (bin_tree num)) empty) : @complete_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_121160 (h0 : group (fintype (has_ssubset to_additive.value_type))) : is_cyclic (fintype (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121161 (h0 : functor.add_const (finset (non_assoc_semiring num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121162 (h0 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : path_connected_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_121164 (h0 : functor.add_const (finset (bin_tree empty)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121165 (h0 : topological_space (semigroup (finset linarith.comp))) : discrete_topology (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_121166 (h0 : topological_space (add_comm_monoid (has_neg (has_add (finset name))))) : regular_space (add_comm_monoid (has_neg (has_add (finset name)))) := sorry --non-trivial
lemma new_lemma_121167 (h0 : monoid (add_comm_monoid (has_neg name))) : monoid.fg (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_121168 (h0 : topological_space (boolean_algebra (has_Inf Type))) : t0_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_121169 (h0 : functor.add_const (ring (normed_lattice_add_comm_group real)) (has_Inf Type)) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 1} (ring.{0} (normed_lattice_add_comm_group.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121170 (h0 : group (encodable (random_gen char))) : group.fg (encodable (random_gen char)) := sorry --non-trivial
lemma new_lemma_121171 (h0 : topological_space (has_Inf (ordered_comm_monoid pos))) : discrete_topology (has_Inf (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_121172 (h0 : functor.add_const (add_group (ordered_comm_ring linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121173 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_121174 (h0 : finset (cancel_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_121175 (h0 : filter (ring (boolean_algebra.core Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121176 (h0 : topological_space (has_bot (has_Inf (has_add (has_add pos))))) : preirreducible_space (has_bot (has_Inf (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_121177 (h0 : functor.add_const (topological_space (metric_space empty)) empty) : @t0_space.{0} (metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_121178 (h0 : topological_space (option pos)) : loc_path_connected_space (option pos) := sorry --non-trivial
lemma new_lemma_121179 (h0 : has_inter (option unsigned) -> has_inter (option unsigned) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_121180 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @t0_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_121181 (h0 : functor.add_const (list (normed_linear_ordered_group empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121182 (h1 : ring (normed_field std_gen)) : rank_condition (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_121183 (h0 : complete_lattice (has_bot name)) : complete_lattice.is_Sup_finite_compact (has_bot name) := sorry --non-trivial
lemma new_lemma_121184 (h0 : add_group (linear_ordered_add_comm_group (has_ssubset (power_series char)))) : is_add_cyclic (linear_ordered_add_comm_group (has_ssubset (power_series char))) := sorry --non-trivial
lemma new_lemma_121185 (h0 : list (has_Inf (ring (has_pos_part Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121186 (h0 : topological_space (has_nndist (has_neg linarith.comp))) : loc_path_connected_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_121187 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} (cancel_monoid.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (cancel_monoid.{0} pos)))  := sorry --non-trivial
lemma new_lemma_121188 (h0 : ring (preorder (option empty))) : is_domain (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_121189 (h0 : functor.add_const Prop (group_with_zero ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_121190 (h0 : filter (ordered_comm_ring (has_nndist Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121191 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : measurable_space (add_comm_semigroup fun_info)) : borel_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_121192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121193 (h0 : pnat) (h1 : thunk pnat) : pnat.coprime h0 (@id.{1} pnat (@trace_call_stack.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_121194 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121195 (h0 : topological_space (has_one (add_group (semiring congr_arg_kind)))) : locally_compact_space (has_one (add_group (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_121196 (h0 : ring (has_div string.iterator_imp)) : strong_rank_condition (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_121197 (h0 : linarith.comp_source -> Prop) (h1 : unit) (h2 : linarith.comp_source) : matrix.row h0 h1 h2 := sorry --non-trivial
lemma new_lemma_121198 (h0 : topological_space (has_Sup (option (option empty)))) : preirreducible_space (has_Sup (option (option empty))) := sorry --non-trivial
lemma new_lemma_121199 (h0 : cancel_comm_monoid_with_zero (has_nndist (mul_zero_class pos))) : unique_factorization_monoid (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_121200 (h1 : topological_space string_imp) : irreducible_space string_imp := sorry --non-trivial
lemma new_lemma_121201 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_121202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_121203 (h0 : functor.add_const (complete_lattice (has_neg pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121204 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121205 (h0 : functor.add_const (ordered_comm_monoid Type) name) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_121206 (h0 : topological_space (normed_comm_ring (boolean_algebra pos))) : preconnected_space (normed_comm_ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_121207 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : t0_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_121208 (h0 : group (has_emptyc (has_top linarith.comp_source))) : normalizer_condition (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121209 (h0 : not (complete_lattice num -> false)) : @is_compactly_generated.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_121210 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : preirreducible_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_121211 (h0 : topological_space (has_top (has_top congr_arg_kind))) : preirreducible_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121212 (h2 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h2 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121213 (h0 : function.extfun Type (functor.add_const (uniform_space (sub_neg_monoid linarith.comp)))) : @separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_121214 (h0 : group (boolean_algebra.core (finset ennreal))) : is_simple_group (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_121215 (h0 : complete_lattice (with_one (random_gen linarith.comp_source))) : is_compactly_generated (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121216 (h0 : topological_space (boolean_algebra (normed_comm_ring Type))) : path_connected_space (boolean_algebra (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_121217 (h0 : list (has_nndist (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121218 (h0 : functor.add_const (prod (semigroup unsigned) (semigroup unsigned)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121219 (h0 : ring (canonically_ordered_add_monoid congr_arg_kind)) : rank_condition (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121220 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup Type)) unsigned) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121221 (h0 : topological_space (comm_ring string_imp)) : irreducible_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_121222 (h0 : uniform_space (complete_distrib_lattice (sub_neg_monoid real))) : separated_space (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_121223 (h0 : complete_lattice (has_emptyc (has_norm num))) : is_compactly_generated (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_121224 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_121225 (h0 : ring (dlist char)) : is_domain (dlist char) := sorry --non-trivial
lemma new_lemma_121226 (h0 : ring (semiring (has_top linarith.comp_source))) : is_domain (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_121228 (h0 : fin has_zero.zero) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_121229 (h0 : functor.add_const (topological_space (finset Type)) Type) : @locally_compact_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_121230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_121231 (h0 : topological_space (has_to_string (boolean_algebra.core (semigroup name)))) : sequential_space (has_to_string (boolean_algebra.core (semigroup name))) := sorry --non-trivial
lemma new_lemma_121232 (h0 : functor.add_const (topological_space (comm_group Type)) (normed_comm_ring linarith.comp)) : @sequential_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_121233 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @locally_compact_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_121234 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_121235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_121236 (h0 : prod unsigned unsigned) : id_rel h0 := sorry --non-trivial
lemma new_lemma_121237 (h0 : topological_space (has_pos_part (has_Inf Type))) : loc_path_connected_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_121238 (h0 : not (ring (has_lt string_imp) -> false)) : @rank_condition.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_121239 (h0 : functor.add_const (topological_space (has_add real)) Type) : @loc_path_connected_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_121240 (h1 : complete_lattice (has_emptyc (has_emptyc congr_arg_kind))) : is_atomistic (has_emptyc (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121241 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class to_additive.value_type))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_121242 (h0 : functor.add_const (topological_space (mul_zero_class name)) (boolean_algebra Type)) : @preconnected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121243 (h0 : topological_space (has_add (has_add linarith.comp))) : path_connected_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121244 (h0 : function.extfun Type ring) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121245 (h5 : complete_lattice (nondiscrete_normed_field string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_121246 (h0 : functor.add_const (topological_space auto.case_option) (option empty)) : @preirreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_121247 (h0 : not (uniform_space (random_gen empty) -> false)) : @separated_space.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_121248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_121249 (h0 : add_group (dlist (random_gen (has_inv linarith.ineq)))) : is_add_cyclic (dlist (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_121250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_121251 (h0 : topological_space (has_div (mul_one_class (mul_one_class enat)))) : path_connected_space (has_div (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_121252 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_121253 (h0 : topological_space (measurable_space linarith.comp)) : totally_disconnected_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_121254 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) num) : @normal_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_121255 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @monoid.fg.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type monoid.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121256 (h0 : not (has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_121257 (h0 : add_group (boolean_algebra.core (add_comm_monoid name))) : is_add_cyclic (boolean_algebra.core (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_121258 (h0 : complete_lattice (add_group linarith.comp)) : is_atomistic (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_121259 (h0 : topological_space (has_bot pos)) : loc_path_connected_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_121260 (h1 : ring (denumerable (random_gen char))) : rank_condition (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_121261 (h0 : topological_space (normed_lattice_add_comm_group pos)) : t0_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_121262 (h0 : group (complete_linear_order (semiring (has_top empty)))) : group.fg (complete_linear_order (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_121263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_121264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_121265 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121266 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_121267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (div_inv_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (div_inv_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (div_inv_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (add_monoid.{0} (div_inv_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_121268 (h0 : topological_space (normed_field to_additive.value_type)) : t0_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121269 (h0 : fin has_zero.zero) : @group.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) group.{1}) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_121270 (h0 : ring (id (has_norm congr_arg_kind))) : strong_rank_condition (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121271 (h0 : complete_lattice (add_right_cancel_monoid (semiring unsigned))) : is_compactly_generated (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121272 (h0 : function.extfun Type (functor.add_const (add_group (plift unsigned)))) : @is_add_cyclic.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (add_group.{1} (plift.{1} unsigned)) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (add_group.{1} (plift.{1} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_121273 (h0 : not (topological_space (has_add fun_info) -> false)) : @path_connected_space.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_121274 (h0 : not (complete_lattice (semi_normed_ring reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_121275 (h0 : uniform_space (has_bot (has_Inf (has_neg name)))) : separated_space (has_bot (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_121276 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) (has_pos_part (has_pos_part (ring pos)))) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} linarith.comp)) (has_pos_part.{0} (has_pos_part.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_121277 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core unsigned)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121278 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121279 (h0 : list (has_to_string (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121280 (h0 : functor.comp complete_lattice complete_distrib_lattice name) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_121281 (h0 : multiset (add_comm_semigroup fun_info)) (h1 : list (multiset (add_comm_semigroup fun_info))) : multiset.le h0 (list.sum h1) := sorry --non-trivial
lemma new_lemma_121282 (h0 : topological_space (has_star (semiring (semiring empty)))) : irreducible_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_121283 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) (has_zero pos)) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121284 (h0 : functor.add_const (group (has_to_string name)) Type) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_121285 (h1 : ring (semi_normed_comm_ring char)) : is_domain (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_121286 (h0 : uniform_space (add_group unsigned)) : complete_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_121287 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (lex.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (lex.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121288 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @sequential_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121289 (h0 : list (denumerable linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121290 (h0 : functor.add_const (topological_space (has_edist empty)) (semiring (semiring (semiring empty)))) : @t0_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_121291 (h0 : topological_space (has_bot (has_add (has_add pos)))) : preconnected_space (has_bot (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_121292 (h0 : functor.add_const (finset (non_assoc_semiring empty)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121293 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_121294 (h0 : functor.add_const (semiring (simple_graph Type)) (boolean_algebra.core pos)) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (simple_graph.{1} Type)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121295 (h0 : group (add_right_cancel_monoid (option (option unsigned)))) : normalizer_condition (add_right_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_121296 (h0 : complete_lattice (add_comm_monoid unsigned)) : is_compactly_generated (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_121297 (h0 : group (has_one (has_norm (has_top (has_norm linarith.comp))))) : normalizer_condition (has_one (has_norm (has_top (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_121298 (h0 : semiring (ordered_ring (semiring empty))) : is_noetherian_ring (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_121299 (h0 : list (normed_comm_ring (comm_group Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121300 (h0 : complete_lattice (fintype (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (fintype (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_121301 (h0 : not (ring (dlist linarith.ineq) -> false)) : @strong_rank_condition.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121302 (h0 : functor.add_const (functor.add_const Prop name) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121303 (h0 : functor.add_const Prop (has_union (semiring empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_121304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_121305 (h0 : ring (with_zero (random_gen (random_gen (has_inv fun_info))))) : is_domain (with_zero (random_gen (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_121306 (h0 : filter (has_bot (ordered_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121307 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) pos) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121308 (h0 : has_le char) (h1 : char) : is_bot h1 := sorry --non-trivial
lemma new_lemma_121309 (h0 : topological_space (has_zero (normed_comm_ring Type))) : path_connected_space (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_121310 (h1 : complete_lattice (topological_space (random_gen string_imp))) : is_compactly_generated (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_121311 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121312 (h0 : functor.add_const (topological_space (mul_zero_class Type)) unsigned) : @topological_space.separable_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121313 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_121314 (h0 : functor.add_const (group (ring linarith.comp)) (has_neg (has_neg linarith.comp))) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_121315 (h0 : functor.add_const (add_group (ring pos)) pos) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121316 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (has_edist empty)))) : @unique_factorization_monoid.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_edist.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (has_edist.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_121317 (h0 : add_group (boolean_algebra.core (comm_group (comm_group (comm_group Type))))) : is_add_cyclic (boolean_algebra.core (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_121318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_121319 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_121320 (h0 : complete_lattice (semi_normed_comm_ring (has_top (has_nnnorm (random_gen linarith.ineq))))) : is_compactly_generated (semi_normed_comm_ring (has_top (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_121321 (h0 : not (complete_lattice (add_left_cancel_monoid linarith.ineq) -> false)) : @is_compactly_generated.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121322 (h0 : topological_space (boolean_algebra (has_add pos))) : normal_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_121323 (h0 : semiring (linear_ordered_comm_ring congr_arg_kind)) : is_noetherian_ring (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121324 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @preconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_121325 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} (with_bot.{0} (has_one.{0} (has_one.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} (with_bot.{0} (has_one.{0} (has_one.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_121326 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (bin_tree congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121327 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) Type) : @totally_separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_121328 (h0 : functor.add_const (topological_space (finset ennreal)) num) : @topological_space.separable_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_121329 (h0 : ring (has_edist (option empty))) : is_principal_ideal_ring (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_121330 (h0 : group (measurable_space (has_top fun_info))) : normalizer_condition (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_121331 (h0 : monoid (random_gen (semiring (has_top fun_info)))) : monoid.fg (random_gen (semiring (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_121332 (h0 : functor.add_const (add_group Type) (finset (finset (finset (finset linarith.comp))))) : @is_add_cyclic.{1} Type (@functor.add_const.run.{1 0} (add_group.{1} Type) (finset.{0} (finset.{0} (finset.{0} (finset.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_121333 (h0 : list (left_cancel_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121334 (h0 : cancel_comm_monoid_with_zero (simple_graph (comm_monoid (option unsigned)))) : unique_factorization_monoid (simple_graph (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_121335 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_121336 (h0 : ring (has_nnnorm (random_gen (random_gen char)))) : rank_condition (has_nnnorm (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_121337 (h0 : topological_space (has_nndist (has_to_string linarith.comp))) : t0_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_121338 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_121339 (h0 : option (functor.add_const (ordered_comm_monoid (option ennreal)) name)) (h1 : functor.add_const (ordered_comm_monoid (option ennreal)) name) : @has_exists_mul_of_le.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (option.{0} ennreal)) name (@option.get_or_else.{0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} (option.{0} ennreal)) name) h0 h1))  := sorry --non-trivial
lemma new_lemma_121340 (h0 : list (finset (has_pos_part (has_pos_part (has_pos_part pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121341 (h0 : list (semigroup (comm_group name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121342 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class enat))) : totally_disconnected_space (linear_ordered_comm_group_with_zero (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_121343 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) name) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_121344 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121345 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @t1_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_121346 (h0 : uniform_space (generalized_boolean_algebra (has_neg (has_bot Type)))) : complete_space (generalized_boolean_algebra (has_neg (has_bot Type))) := sorry --non-trivial
lemma new_lemma_121347 (h1 : not (ring (distrib char) -> false)) : @is_domain.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_121348 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_121349 (h0 : add_group (semi_normed_comm_ring (has_ssubset linarith.ineq))) : is_add_cyclic (semi_normed_comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121350 (h0 : not (monoid (measurable_space.dynkin_system num) -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_121351 (h0 : monoid (linear_ordered_field (has_to_string auto.case_option))) : monoid.fg (linear_ordered_field (has_to_string auto.case_option)) := sorry --non-trivial
lemma new_lemma_121352 (h0 : add_group (has_div (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : is_add_cyclic (has_div (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_121353 (h0 : semiring (has_mul linarith.comp) -> has_norm linarith.comp -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_121354 (h0 : uniform_space (id (semiring (has_norm empty)))) : complete_space (id (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_121355 (h0 : topological_space (boolean_algebra.core pos)) : locally_compact_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_121356 (h0 : topological_space linarith.ineq) (h1 : preorder linarith.ineq) : order_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_121357 (h0 : is_empty (has_append linarith.comp_source)) (h1 : not (has_append linarith.comp_source -> false)) : @is_add_cyclic.{0} (random_gen.{0} char) (@is_empty.elim'.{1 1} (has_append.{0} linarith.comp_source) (add_group.{0} (random_gen.{0} char)) h0 (@classical.by_contradiction'.{1} (has_append.{0} linarith.comp_source) h1))  := sorry --non-trivial
lemma new_lemma_121358 (h0 : set (semi_normed_comm_ring (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_121359 (h0 : complete_lattice (has_dist empty)) : complete_lattice.is_Sup_finite_compact (has_dist empty) := sorry --non-trivial
lemma new_lemma_121360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_121361 (h0 : functor.add_const (functor.add_const (function.extfun Type complete_lattice) linarith.comp) pos) : @is_compactly_generated.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp) pos h0)) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_121362 (h0 : add_monoid (simple_graph (has_add (ring Type)))) : add_monoid.fg (simple_graph (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_121363 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_121364 (h0 : functor.add_const (function.extfun Type list) (has_neg pos)) : palindrome (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_121365 (h0 : group (ordered_comm_ring (semilattice_inf (ring (has_pos_part Type))))) : is_simple_group (ordered_comm_ring (semilattice_inf (ring (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_121366 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_121367 (h1 : uniform_space (has_lt to_additive.value_type)) : complete_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121368 (h0 : group (ring (option unsigned))) : is_cyclic (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_121369 (h0 : functor.add_const (topological_space ennreal) num) : topological_space.separable_space ennreal := sorry --non-trivial
lemma new_lemma_121370 (h0 : topological_space (fintype (has_ssubset to_additive.value_type))) : locally_compact_space (fintype (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121371 (h0 : functor.add_const (monoid (non_assoc_semiring empty)) empty) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_121372 (h0 : functor.add_const (ring (has_nndist Type)) name) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_121373 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @loc_path_connected_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_121374 (h0 : filter (normed_group (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121375 (h0 : not (has_mem.mem reducibility_hints has_emptyc.emptyc -> false)) : @is_cyclic.{0} reducibility_hints (@finset.pi.empty.{1 0} Type group.{0} reducibility_hints (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) reducibility_hints (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_121376 (h0 : ring (has_to_string (ring linarith.comp))) : is_principal_ideal_ring (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_121377 (h0 : set (set (random_gen linarith.comp_source))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_121378 (h0 : topological_space (has_to_string (has_add (has_add name)))) : normal_space (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_121379 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @regular_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121380 (h0 : not (topological_space (linear_ordered_semiring fun_info) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_121381 (h0 : functor.add_const (add_group (has_nndist linarith.comp)) (has_pos_part pos)) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121382 (h0 : monoid (boolean_algebra (ring Type))) : monoid.fg (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_121383 (h0 : group (has_to_string (finset unsigned))) : is_simple_group (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_121384 (h1 : complete_lattice (semiring (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_121385 (h0 : ring (mul_zero_class (has_add name))) : strong_rank_condition (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_121386 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_121387 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_121388 (h0 : group (semiring (has_norm fun_info))) : normalizer_condition (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_121389 (h0 : group (has_norm (has_nnnorm (has_nnnorm fun_info)))) : group.fg (has_norm (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_121390 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp_source)) : is_atomistic (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121391 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : totally_disconnected_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_121392 (h0 : functor.add_const (topological_space (has_add name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121393 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121394 (h0 : function.extfun Type (functor.comp topological_space finset)) : @irreducible_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_121395 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121396 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : irreducible_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_121397 (h0 : not (topological_space (distrib_lattice num) -> false)) : @t0_space.{0} (distrib_lattice.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_121398 (h0 : list (normed_comm_ring (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121399 (h0 : complete_lattice (has_norm (has_top (has_top congr_arg_kind)))) : is_compactly_generated (has_norm (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_121400 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121401 (h0 : functor.add_const (list (comm_group environment.implicit_infer_kind)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121402 (h0 : ring (metric_space (mul_one_class char))) : strong_rank_condition (metric_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_121403 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_121404 (h0 : list (has_pos_part (ring (ordered_comm_monoid (has_neg (sub_neg_monoid (has_neg (has_neg Type)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121405 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_121406 (h0 : topological_space (dlist (has_top linarith.comp_source))) : t0_space (dlist (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121407 (h0 : monoid (random_gen fun_info)) : monoid.fg (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_121408 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @t0_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_121409 (h0 : ring (normed_comm_ring (semigroup unsigned))) : rank_condition (normed_comm_ring (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_121410 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_121411 (h0 : ring (has_compl (random_gen linarith.ineq))) : is_domain (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121412 (h0 : functor.add_const (ring (has_add name)) (ring linarith.comp)) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_121413 (h0 : add_group (comm_ring (random_gen (random_gen char)))) : is_add_cyclic (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_121414 (h0 : not (ring (add_left_cancel_monoid (measure_theory.measure_space fun_info)) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} (measure_theory.measure_space.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} (measure_theory.measure_space.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_121415 (h1 : topological_space (linear_ordered_comm_group_with_zero std_gen)) : path_connected_space (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_121416 (h0 : functor.add_const (ring (semigroup pos)) (comm_group (semigroup (comm_group Type)))) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) (comm_group.{1} (semigroup.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_121417 (h0 : list num) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121418 (h1 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h1 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_121419 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_121420 (h0 : is_empty (group (option congr_arg_kind) -> false)) : @group.fg.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (option.{0} congr_arg_kind)) (@is_empty.elim'.{0 0} (group.{0} (option.{0} congr_arg_kind) → false) false h0))  := sorry --non-trivial
lemma new_lemma_121421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_121422 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121423 (h0 : topological_space (normed_group (has_norm (has_inter empty)))) : t0_space (normed_group (has_norm (has_inter empty))) := sorry --non-trivial
lemma new_lemma_121424 (h0 : topological_space (has_one (has_norm (has_union (has_union linarith.comp))))) : irreducible_space (has_one (has_norm (has_union (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_121425 (h0 : topological_space (normed_field linarith.ineq)) (h1 : add_group (normed_field linarith.ineq)) : topological_add_group (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_121426 (h0 : complete_lattice (has_nndist (ring name))) : is_compactly_generated (has_nndist (ring name)) := sorry --non-trivial
lemma new_lemma_121427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121428 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_121429 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space num)) empty) : @archimedean.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_121430 (h0 : ring (has_bot empty)) : is_principal_ideal_ring (has_bot empty) := sorry --non-trivial
lemma new_lemma_121431 (h0 : list (with_one (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121432 (h0 : semiring (order_dual unsigned)) : is_noetherian_ring (order_dual unsigned) := sorry --non-trivial
lemma new_lemma_121433 (h0 : boolean_algebra.core Type -> boolean_algebra.core Type -> Prop) : is_antisymm (boolean_algebra.core Type) h0 := sorry --non-trivial
lemma new_lemma_121434 (h0 : complete_lattice (ring unsigned)) : is_atomistic (ring unsigned) := sorry --non-trivial
lemma new_lemma_121435 (h0 : topological_space (has_emptyc (semiring linarith.comp_source))) : path_connected_space (has_emptyc (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121436 (h0 : topological_space (has_neg (normed_linear_ordered_group Type))) : preconnected_space (has_neg (normed_linear_ordered_group Type)) := sorry --non-trivial
lemma new_lemma_121437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_121438 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121439 (h2 : monoid empty) : monoid.fg empty := sorry --non-trivial
lemma new_lemma_121440 (h0 : topological_space (add_monoid (has_nnnorm char))) : totally_disconnected_space (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_121441 (h0 : monoid (random_gen (with_one to_additive.value_type))) : monoid.fg (random_gen (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121442 (h0 : functor.add_const (add_monoid (finset pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121443 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) pos) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_121444 (h0 : add_monoid (has_pos_part (has_Inf (finset linarith.comp)))) : add_monoid.fg (has_pos_part (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_121445 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_121446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121447 (h0 : group (generalized_boolean_algebra (ring Type))) : is_cyclic (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_121448 (h1 : not (ring (normed_field string_imp) -> false)) : @is_domain.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_121449 (h1 : topological_space (uniform_space (mul_one_class linarith.ineq))) : totally_disconnected_space (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121450 (h0 : list (ordered_comm_ring (ring (ring Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121451 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @complete_space.{0} real.angle (@finset.pi.empty.{1 0} Type uniform_space.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_121452 (h0 : topological_space (semigroup (comm_group unsigned))) : irreducible_space (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_121453 (h0 : add_group (add_group_with_zero_nhd (option (option empty)))) : is_add_cyclic (add_group_with_zero_nhd (option (option empty))) := sorry --non-trivial
lemma new_lemma_121454 (h0 : topological_space (has_union (semiring linarith.comp))) : t0_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_121455 (h0 : functor.add_const (function.extfun Type group) (has_add (mul_one_class Type))) : @normalizer_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_add.{1} (mul_one_class.{1} Type)) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_121456 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_121457 (h0 : topological_space (bin_tree (semiring empty))) : totally_separated_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_121458 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_121459 (h1 : has_neg (nondiscrete_normed_field std_gen)) (h2 : measurable_space (nondiscrete_normed_field std_gen)) : has_measurable_neg (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_121460 (h1 : ring (semi_normed_comm_ring (has_ssubset (has_ssubset (random_gen char))))) : strong_rank_condition (semi_normed_comm_ring (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_121461 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_121462 (h0 : ring (partial_order num)) : strong_rank_condition (partial_order num) := sorry --non-trivial
lemma new_lemma_121463 (h0 : uniform_space (has_to_string (boolean_algebra.core Type))) : complete_space (has_to_string (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_121464 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (id (id (id h0))))) := sorry --non-trivial
lemma new_lemma_121465 (h0 : complete_lattice (has_to_string (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (has_to_string (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_121466 (h0 : group (mul_zero_class (semiring congr_arg_kind))) : is_cyclic (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121467 (h1 : topological_space (normed_field (topological_space (has_nnnorm linarith.ineq)))) : totally_disconnected_space (normed_field (topological_space (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_121468 (h0 : functor.add_const (list (has_neg pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121469 (h0 : function.extfun Type group) : @is_simple_group.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_121470 (h0 : add_group (linear_ordered_comm_group_with_zero linarith.ineq)) : is_add_cyclic (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_121471 (h0 : topological_space (semigroup (semiring (semiring empty)))) : normal_space (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_121472 (h0 : group (add_cancel_monoid (has_add (has_neg pos)))) : normalizer_condition (add_cancel_monoid (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_121473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121474 (h0 : cancel_comm_monoid_with_zero (ring linarith.comp)) : unique_factorization_monoid (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_121475 (h0 : comm_semiring fun_info) (h1 : polynomial fun_info) : polynomial.separable h1 := sorry --non-trivial
lemma new_lemma_121476 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_121477 (h0 : group (ring (has_neg Type))) : group.fg (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_121478 (h0 : ring (finset name)) : strong_rank_condition (finset name) := sorry --non-trivial
lemma new_lemma_121479 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_121480 (h0 : finset (finset (option (option (option (option (complete_distrib_lattice (option pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_121481 (h0 : filter (canonically_ordered_comm_semiring (option empty))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121482 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) (has_to_string (has_to_string (comm_group unsigned)))) : @is_atomistic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) (has_to_string.{0} (has_to_string.{0} (comm_group.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_121483 (h0 : uniform_space (linear_ordered_comm_ring empty)) : complete_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_121484 (h0 : topological_space (mul_zero_class (has_to_string ennreal))) : normal_space (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_121485 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121486 (h0 : group (monoid_with_zero ennreal)) : normalizer_condition (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_121487 (h0 : topological_space (finset (finset Type))) : sequential_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_121488 (h0 : topological_space (has_nndist (has_to_string (finset environment.implicit_infer_kind)))) : totally_separated_space (has_nndist (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_121489 (h0 : semiring (add_comm_semigroup (has_ssubset reducibility_hints))) (h1 : ideal (add_comm_semigroup (has_ssubset reducibility_hints))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_121490 (h0 : add_monoid (add_comm_monoid (ordered_comm_monoid pos))) : add_monoid.fg (add_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_121491 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_121492 (h0 : filter (with_zero (has_nnnorm (has_nnnorm to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121493 (h0 : topological_space (ring (has_Inf linarith.comp))) : topological_space.separable_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_121494 (h0 : complete_lattice (semiring empty)) : complete_lattice.is_Sup_finite_compact (semiring empty) := sorry --non-trivial
lemma new_lemma_121495 (h0 : group (semiring (random_gen (random_gen num)))) : group.fg (semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_121496 (h0 : add_group (cancel_monoid (has_nndist pos))) : is_add_cyclic (cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_121497 (h0 : topological_space (has_add (ordered_comm_monoid Type))) : irreducible_space (has_add (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_121498 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_neg Type)) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121499 (h0 : topological_space (left_cancel_monoid (option (comm_monoid (option (option empty)))))) : totally_separated_space (left_cancel_monoid (option (comm_monoid (option (option empty))))) := sorry --non-trivial
lemma new_lemma_121500 (h1 : measurable_space ereal) (h2 : set ereal) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_121501 (h0 : list (comm_ring (has_ssubset (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121502 (h0 : functor.add_const (ring (has_nndist Type)) (ring (ring (has_to_string Type)))) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_nndist.{1} Type)) (ring.{1} (ring.{1} (has_to_string.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_121503 (h0 : complete_lattice (has_zero (has_add pos))) : is_compactly_generated (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_121504 (h0 : add_monoid (semigroup (ring (option unsigned)))) : add_monoid.fg (semigroup (ring (option unsigned))) := sorry --non-trivial
lemma new_lemma_121505 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121506 (h0 : add_monoid (left_cancel_semigroup (semiring congr_arg_kind))) : add_monoid.fg (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121507 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_121508 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121509 (h0 : functor.comp add_group has_zero Type) : @is_add_cyclic.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_121510 (h0 : complete_lattice (has_to_string pos)) : is_compactly_generated (has_to_string pos) := sorry --non-trivial
lemma new_lemma_121511 (h0 : topological_space (ring (option (option (option num))))) : topological_space.separable_space (ring (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_121512 (h0 : topological_space (has_norm (has_norm fun_info))) : totally_separated_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_121513 (h0 : topological_space (monoid (random_gen (random_gen fun_info)))) : totally_separated_space (monoid (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_121514 (h0 : not (topological_space (semiring linarith.ineq) -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121515 (h0 : cancel_comm_monoid_with_zero (id (semiring num))) : unique_factorization_monoid (id (semiring num)) := sorry --non-trivial
lemma new_lemma_121516 (h0 : ring (has_top (random_gen (random_gen (has_ssubset (random_gen to_additive.value_type)))))) : rank_condition (has_top (random_gen (random_gen (has_ssubset (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_121517 (h0 : linear_ordered_comm_group_with_zero string.iterator_imp -> linear_ordered_comm_group_with_zero string.iterator_imp) : set.finite (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_121518 (h0 : functor.add_const (ring (add_cancel_monoid Type)) ennreal) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_121519 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_121520 (h0 : complete_lattice (non_unital_non_assoc_semiring enat)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_121521 (h0 : group (random_gen (has_top (has_top to_additive.value_type)))) : normalizer_condition (random_gen (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_121522 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @locally_compact_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121523 (h1 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : path_connected_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121524 (h0 : monoid (with_one (with_bot string_imp))) : monoid.fg (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_121525 (h1 : group (with_bot (random_gen linarith.ineq))) : is_cyclic (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121526 (h0 : ring (canonically_linear_ordered_monoid num)) : is_domain (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_121527 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) Type) : @group.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_121528 (h0 : function.extfun Type ring) : @is_domain.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121529 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @preconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_121530 (h0 : topological_space (semigroup (has_neg_part name))) : t1_space (semigroup (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_121531 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup enat))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_121532 (h0 : group (complete_distrib_lattice (cancel_monoid (comm_group (cancel_monoid pos))))) : is_simple_group (complete_distrib_lattice (cancel_monoid (comm_group (cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_121533 (h0 : add_group (add_comm_monoid (has_add Type))) : is_add_cyclic (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_121534 (h0 : list (cancel_monoid (has_add (has_add (has_neg (boolean_algebra.core pos)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121535 (h0 : topological_space (semigroup (has_to_string unsigned))) : path_connected_space (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_121536 (h0 : not (has_mem.mem (linear_ordered_semiring to_additive.value_type) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_121537 (h0 : ring (semi_normed_comm_ring name)) : rank_condition (semi_normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_121538 (h0 : uniform_space (has_to_string (has_pos_part (finset Type)))) : complete_space (has_to_string (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_121539 (h0 : topological_space (add_right_cancel_monoid num)) : discrete_topology (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_121540 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_121541 (h0 : topological_space (semiring char)) : topological_space.first_countable_topology (semiring char) := sorry --non-trivial
lemma new_lemma_121542 (h0 : complete_lattice (has_add (ordered_ring name))) : complete_lattice.is_Sup_finite_compact (has_add (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_121543 (h0 : has_neg (semi_normed_comm_ring std_gen)) (h1 : measurable_space (semi_normed_comm_ring std_gen)) : has_measurable_neg (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_121544 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist empty)) empty) : @archimedean.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_121545 (h0 : functor.add_const (ordered_comm_monoid (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121546 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_121547 (h0 : ring (ordered_comm_group (option empty))) : strong_rank_condition (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_121548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121549 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121550 (h0 : functor.comp uniform_space has_neg unsigned) : @complete_space.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_121551 (h0 : has_lt (simple_graph (mul_one_class environment.projection_info))) : no_max_order (simple_graph (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_121552 (h0 : functor.add_const (topological_space (has_add pos)) (finset pos)) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121553 (h0 : add_group (has_lt string_imp)) : is_add_cyclic (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_121554 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @archimedean.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_121556 (h0 : set (string.iterator_imp -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_121557 (h0 : topological_space (free_add_monoid (semiring num))) : discrete_topology (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_121558 (h1 : prod (add_group ereal) (add_group ereal)) : set.diagonal (add_group ereal) h1 := sorry --non-trivial
lemma new_lemma_121559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_121560 (h0 : topological_space (with_bot (semiring (semiring linarith.comp)))) : irreducible_space (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_121561 (h0 : functor.add_const (semiring (has_to_string pos)) (ring pos)) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121562 (h0 : functor.add_const (ring ennreal) num) : @is_domain.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num h0)  := sorry --non-trivial
lemma new_lemma_121563 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) Type) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_121564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_121565 (h0 : filter ereal) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121566 (h0 : not (ring (normed_field linarith.comp_source) -> false)) : @rank_condition.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_121567 (h0 : not (complete_lattice (metric_space empty) -> false)) : @is_compactly_generated.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_121568 (h0 : uniform_space (has_append (has_nnnorm (random_gen (topological_space linarith.ineq))))) : complete_space (has_append (has_nnnorm (random_gen (topological_space linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_121569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : has_mul Prop) : set.center Prop (preconnected_space real) := sorry --non-trivial
lemma new_lemma_121570 (h0 : topological_space (has_pos_part (has_add (has_Inf pos)))) : discrete_topology (has_pos_part (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_121571 (h0 : topological_space (semigroup (semigroup environment.implicit_infer_kind))) : totally_separated_space (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_121572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_121573 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_121574 (h0 : functor.add_const (function.extfun (Type 1) list) (has_neg (ring pos))) : list.nodup (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_121575 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @t1_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_121576 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @totally_separated_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_121577 (h0 : topological_space (with_one (comm_ring to_additive.value_type))) : path_connected_space (with_one (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121578 (h0 : filter (add_cancel_monoid (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121579 (h2 : has_mem.mem fun_info has_emptyc.emptyc) : @totally_disconnected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h2)  := sorry --non-trivial
lemma new_lemma_121580 (h1 : set (mul_one_class ereal)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_121581 (h0 : uniform_space (comm_group (has_add linarith.comp))) : separated_space (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121582 (h0 : topological_space (measurable_space (has_nnnorm fun_info))) : t0_space (measurable_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_121583 (h0 : topological_space (ring (ring linarith.comp))) : locally_compact_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_121584 (h0 : group (canonically_ordered_comm_semiring name)) : normalizer_condition (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_121585 (h0 : list (semigroup (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121586 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid linarith.comp))) : irreducible_space (canonically_ordered_monoid (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_121587 (h0 : uniform_space (semiring (normed_linear_ordered_group (normed_linear_ordered_group unsigned)))) : separated_space (semiring (normed_linear_ordered_group (normed_linear_ordered_group unsigned))) := sorry --non-trivial
lemma new_lemma_121588 (h0 : filter (add_cancel_monoid (semigroup (semigroup pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121589 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preirreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_121590 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h2 : filter (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_121591 (h0 : topological_space (ordered_comm_group (option empty))) : preirreducible_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_121592 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_121593 (h0 : topological_space (simple_graph std_gen)) : totally_disconnected_space (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_121594 (h0 : topological_space (add_cancel_monoid (comm_group (has_add (has_neg_part (has_add Type)))))) : t0_space (add_cancel_monoid (comm_group (has_add (has_neg_part (has_add Type))))) := sorry --non-trivial
lemma new_lemma_121595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_121596 (h0 : uniform_space (has_zero (ring (has_Inf Type)))) : complete_space (has_zero (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_121597 (h0 : list (normed_comm_ring (comm_group ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121598 (h0 : monoid (with_bot (random_gen (random_gen (random_gen fun_info))))) : monoid.fg (with_bot (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_121599 (h0 : ring (fintype (has_ssubset (random_gen to_additive.value_type)))) : strong_rank_condition (fintype (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_121600 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_121601 (h0 : functor.add_const (ring (ring Type)) name) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_121602 (h0 : topological_space (linear_ordered_field empty)) : preirreducible_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_121603 (h0 : filter (has_add (cancel_monoid (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121604 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @locally_compact_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_121605 (h0 : ring (measurable_space num)) : rank_condition (measurable_space num) := sorry --non-trivial
lemma new_lemma_121606 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : t0_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_121607 (h0 : functor.add_const (filter (ring pos)) (add_cancel_monoid (ring Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121608 (h1 : has_mul (ordered_add_comm_group string_imp)) (h2 : ordered_add_comm_group string_imp) : is_right_regular h2 := sorry --non-trivial
lemma new_lemma_121609 (h0 : finset (has_add (option pos)) -> Prop) : finset.nonempty (classical.epsilon h0) := sorry --non-trivial
lemma new_lemma_121610 (h0 : topological_space (id (semiring (semiring empty)))) : irreducible_space (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_121611 (h0 : topological_space (metric_space (has_top (has_top (semiring (has_top empty)))))) : topological_space.separable_space (metric_space (has_top (has_top (semiring (has_top empty))))) := sorry --non-trivial
lemma new_lemma_121612 (h0 : ring (normed_comm_ring linarith.ineq)) : is_domain (normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_121613 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_atomistic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_121614 (h0 : ring (has_append (has_nnnorm (comm_ring char)))) : is_domain (has_append (has_nnnorm (comm_ring char))) := sorry --non-trivial
lemma new_lemma_121615 (h0 : add_group (option (semiring num))) : is_add_cyclic (option (semiring num)) := sorry --non-trivial
lemma new_lemma_121616 (h0 : not (has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_121617 (h0 : semiring (complete_distrib_lattice (has_neg Type))) : is_noetherian_ring (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_121618 (h0 : topological_space (normed_lattice_add_comm_group (finset real))) : regular_space (normed_lattice_add_comm_group (finset real)) := sorry --non-trivial
lemma new_lemma_121619 (h0 : functor.comp topological_space semigroup pos) : @t1_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_121620 (h0 : topological_space (has_star congr_arg_kind)) : t1_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121621 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot empty)) (option empty)) : @unique_factorization_monoid.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_121622 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121623 (h0 : uniform_space (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg pos)))))) : separated_space (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_121624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_121625 (h0 : cancel_comm_monoid_with_zero (has_pos_part pos)) : unique_factorization_monoid (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_121626 (h0 : functor.add_const (filter (has_neg pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121627 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_121628 (h0 : list (non_assoc_semiring (semiring num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121629 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121630 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm to_additive.value_type))) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_121631 (h0 : not (ring (semi_normed_comm_ring string_imp) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_121632 (h0 : not (function.extfun Type list -> false)) : list.tfae (function.extfun_app (classical.by_contradiction' h0) Prop) := sorry --non-trivial
lemma new_lemma_121633 (h0 : complete_lattice (boolean_algebra.core (option empty))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_121634 (h0 : topological_space (has_append (semi_normed_ring (additive (random_gen char))))) : path_connected_space (has_append (semi_normed_ring (additive (random_gen char)))) := sorry --non-trivial
lemma new_lemma_121635 (h0 : functor.add_const (ring (has_nndist name)) name) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_121636 (h0 : add_group (semiring (semiring (semiring empty)))) : is_add_cyclic (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_121637 (h0 : topological_space (canonically_ordered_monoid Type)) : irreducible_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_121638 (h0 : group (simple_graph (ring (ring linarith.comp)))) : is_simple_group (simple_graph (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_121639 (h0 : topological_space (cancel_monoid (boolean_algebra.core Type))) : preirreducible_space (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_121640 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_121641 (h0 : complete_lattice (option (semiring empty))) : complete_lattice.is_Sup_finite_compact (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_121642 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_121643 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121644 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_121645 (h0 : topological_space (has_bot (option (option (option (option empty)))))) : t1_space (has_bot (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_121646 (h0 : filter (has_append linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121647 (h0 : topological_space (boolean_algebra.core (ring (has_add (has_add (has_add linarith.comp)))))) : preirreducible_space (boolean_algebra.core (ring (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_121648 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121649 (h0 : semiring (has_neg name)) : is_noetherian_ring (has_neg name) := sorry --non-trivial
lemma new_lemma_121650 (h0 : complete_lattice (left_cancel_monoid (option (option (option unsigned))))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_121651 (h0 : not (add_monoid (has_top num) -> false)) : @add_monoid.fg.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_121652 (h0 : list (dlist (has_ssubset (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121653 (h1 : topological_space (normed_field enat)) : path_connected_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_121654 (h0 : add_group (normed_linear_ordered_group (option empty))) : is_add_cyclic (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_121655 (h0 : list (add_cancel_monoid (boolean_algebra (boolean_algebra (boolean_algebra Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121656 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121657 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_121658 (h0 : topological_space (canonically_ordered_monoid real)) : t1_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_121659 (h0 : filter (distrib_lattice (random_gen (random_gen string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121660 (h0 : ereal -> ereal -> Prop) : nonempty (is_strict_order ereal h0) := sorry --non-trivial
lemma new_lemma_121661 (h0 : topological_space (add_right_cancel_monoid unsigned)) : preirreducible_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_121662 (h0 : ring (has_zero (finset (finset (finset pos))))) : is_domain (has_zero (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_121663 (h0 : functor.add_const (group (complete_distrib_lattice pos)) pos) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121664 (h0 : has_neg (has_nnnorm fun_info)) (h1 : measurable_space (has_nnnorm fun_info)) : has_measurable_neg (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_121665 (h0 : topological_space (linear_order empty)) : t1_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_121666 (h3 : add_group (with_one (has_nnnorm fun_info))) : is_add_cyclic (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_121667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121668 (h0 : prod (partial_order congr_arg_kind) (partial_order congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_121669 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121670 (h0 : ordered_comm_monoid (has_zero (has_to_string (has_to_string name)))) : has_exists_mul_of_le (has_zero (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_121671 (h0 : monoid (measurable_space.dynkin_system empty)) : monoid.fg (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_121672 (h0 : ring (has_bot (has_Inf (has_Inf (has_Inf linarith.comp))))) : is_principal_ideal_ring (has_bot (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_121673 (h0 : filter (has_add (random_gen (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121674 (h0 : topological_space (bin_tree num)) : irreducible_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_121675 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : discrete_topology (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_121678 (h0 : set string_imp) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_121679 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_121680 (h0 : ring (has_nnnorm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : rank_condition (has_nnnorm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_121681 (h0 : topological_space (has_nnnorm (mul_one_class linarith.comp_source))) (h1 : preorder (has_nnnorm (mul_one_class linarith.comp_source))) : order_closed_topology (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121682 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121683 (h0 : complete_lattice (has_one (has_norm linarith.comp))) : is_atomistic (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_121684 (h0 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @t0_space.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_121685 (h0 : has_le string.iterator_imp) (h2 : string.iterator_imp) : is_bot h2 := sorry --non-trivial
lemma new_lemma_121686 (h0 : group (has_nndist (finset unsigned))) : is_cyclic (has_nndist (finset unsigned)) := sorry --non-trivial
lemma new_lemma_121687 (h0 : functor.add_const (functor.add_const (topological_space Type) environment.implicit_infer_kind) name) : @preirreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind) name h0))  := sorry --non-trivial
lemma new_lemma_121688 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_121689 (h0 : filter (has_compl (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121690 (h0 : not (uniform_space (semiring linarith.ineq) -> false)) : @complete_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121691 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_121692 (h0 : group (comm_ring (has_nnnorm (mul_one_class fun_info)))) (h1 : subgroup (comm_ring (has_nnnorm (mul_one_class fun_info)))) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_121693 (h0 : topological_space (denumerable (linear_ordered_semiring string_imp))) : t0_space (denumerable (linear_ordered_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_121694 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_121695 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121696 (h0 : not (complete_lattice (id empty) -> false)) : @is_compactly_generated.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_121697 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121698 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : irreducible_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_121699 (h0 : complete_lattice (has_top (has_top (has_top linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_top (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_121700 (h0 : filter (boolean_algebra (has_to_string (has_to_string (has_to_string (finset pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121701 (h0 : topological_space (plift (option (semiring unsigned)))) : totally_separated_space (plift (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_121702 (h0 : functor.add_const (topological_space name) unsigned) : @loc_path_connected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121703 (h0 : functor.add_const (topological_space (has_neg pos)) (has_pos_part Type)) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121704 (h0 : functor.add_const (cancel_comm_monoid_with_zero auto.case_option) (option num)) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_121705 (h0 : semiring (normed_linear_ordered_group (semiring (semiring (semiring (semiring empty)))))) : is_noetherian_ring (normed_linear_ordered_group (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_121706 (h0 : topological_space (measurable_space empty)) : irreducible_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_121707 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121708 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @sequential_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_121709 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121710 (h0 : not (topological_space (has_norm empty) -> false)) : @preirreducible_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_121711 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_121712 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_121713 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring unsigned)))) : path_connected_space (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_121714 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_121715 (h0 : function.extfun nat fin) : @irreducible_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121716 (h0 : topological_space (add_right_cancel_monoid (semiring linarith.comp))) : discrete_topology (add_right_cancel_monoid (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_121717 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121718 (h0 : add_group (pseudo_metric_space ennreal)) : is_add_cyclic (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_121719 (h0 : functor.add_const (function.extfun Type uniform_space) (finset (has_neg pos))) : @complete_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} (has_neg.{0} pos)) h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_121720 (h1 : add_group (simple_graph linarith.comp_source)) : is_add_cyclic (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121721 (h0 : topological_space (has_pos_part (has_Inf (has_pos_part pos)))) : irreducible_space (has_pos_part (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_121722 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121723 (h0 : topological_space (has_union num)) : discrete_topology (has_union num) := sorry --non-trivial
lemma new_lemma_121724 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @preirreducible_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_121725 (h0 : topological_space (has_emptyc (has_norm empty))) : totally_disconnected_space (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_121726 (h0 : ring (non_unital_non_assoc_semiring reducibility_hints)) : is_domain (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_121727 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_121728 (h0 : complete_lattice (add_comm_semigroup (add_comm_semigroup enat))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_121729 (h0 : ring (with_zero (has_ssubset linarith.ineq))) : rank_condition (with_zero (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_121730 (h0 : uniform_space (canonically_ordered_monoid (has_Inf (has_Inf real)))) : complete_space (canonically_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_121731 (h0 : ring (canonically_ordered_comm_semiring (has_nndist environment.implicit_infer_kind))) : rank_condition (canonically_ordered_comm_semiring (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_121732 (h1 : topological_space (with_zero to_additive.value_type)) : path_connected_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121733 (h0 : ring (with_bot (semiring (semiring (has_norm unsigned))))) : rank_condition (with_bot (semiring (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_121734 (h0 : not (uniform_space (fintype char) -> false)) : @complete_space.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_121735 (h0 h1 : multiset (simple_graph reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_121736 (h0 : measurable_space (normed_field std_gen)) (h1 : topological_space (normed_field std_gen)) (h2 : measure_theory.measure (normed_field std_gen)) : measure_theory.measure.outer_regular h2 := sorry --non-trivial
lemma new_lemma_121737 (h2 : topological_space (measurable_space linarith.comp_source)) : totally_separated_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121738 (h0 : add_monoid (boolean_algebra (finset linarith.comp))) : add_monoid.fg (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_121739 (h0 : group (boolean_algebra (has_Inf (finset pos)))) : group.fg (boolean_algebra (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_121740 (h0 : topological_space (ordered_comm_monoid Type)) : normal_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_121741 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group num)) num) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_121742 (h0 : complete_lattice (bin_tree (semiring empty))) : complete_lattice.is_Sup_finite_compact (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_121743 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add linarith.comp))) : unique_factorization_monoid (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121744 (h0 : functor.add_const (add_group (normed_comm_ring linarith.comp)) pos) : @is_add_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_121745 (h0 : functor.comp list has_neg pos) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_121746 (h0 : functor.add_const (uniform_space (mul_zero_class name)) name) : @separated_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_121747 (h0 : fin has_zero.zero) : @preconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_121748 (h0 : functor.add_const (finset (canonically_linear_ordered_monoid pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121749 (h0 : functor.add_const (add_monoid (has_pos_part pos)) pos) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121750 (h0 : ring (measurable_space.dynkin_system (semiring (semiring (add_group empty))))) : rank_condition (measurable_space.dynkin_system (semiring (semiring (add_group empty)))) := sorry --non-trivial
lemma new_lemma_121751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_121752 (h0 : functor.add_const (complete_lattice (has_dist empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_121753 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121754 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @t0_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121755 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen (encodable (has_nnnorm linarith.ineq))))) : complete_space (linear_ordered_add_comm_group (random_gen (encodable (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_121756 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_121757 (h0 : set (with_bot (random_gen linarith.comp_source))) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_121758 (h0 : group (ordered_comm_ring (has_add (has_Inf Type)))) : is_simple_group (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_121759 (h0 : add_group (has_norm (has_top num))) : is_add_cyclic (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_121760 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @discrete_topology.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121761 (h0 : topological_space (sub_neg_monoid (finset (has_Inf (has_Inf (finset (finset pos))))))) : totally_disconnected_space (sub_neg_monoid (finset (has_Inf (has_Inf (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_121762 (h0 : group (has_to_string (has_nndist pos))) : group.fg (has_to_string (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_121763 (h0 : ring (uniform_space (normed_field enat))) : strong_rank_condition (uniform_space (normed_field enat)) := sorry --non-trivial
lemma new_lemma_121764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_121765 (h0 : group (boolean_algebra.core (has_add Type))) : normalizer_condition (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_121766 (h1 : topological_space (distrib (random_gen char))) : totally_disconnected_space (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_121767 (h0 : functor.add_const (group (boolean_algebra.core unsigned)) pos) : @normalizer_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_121768 (h0 : add_monoid (semigroup (has_add linarith.comp))) : add_monoid.fg (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121769 (h2 : topological_space (uniform_space to_additive.value_type)) : t0_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121770 (h0 : list (has_Inf (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121771 (h0 : topological_space (finset (finset (finset (finset (finset (finset (finset name)))))))) : irreducible_space (finset (finset (finset (finset (finset (finset (finset name))))))) := sorry --non-trivial
lemma new_lemma_121772 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_121773 (h0 : uniform_space (left_cancel_semigroup num)) : separated_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_121774 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_121775 (h1 : topological_space (has_le reducibility_hints)) : path_connected_space (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_121776 (h0 : functor.add_const (add_monoid (plift num)) empty) : @add_monoid.fg.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_121777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121778 (h0 : functor.add_const (add_group (ring pos)) (has_neg (finset (finset Type)))) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} pos)) (has_neg.{1} (finset.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_121779 (h0 : functor.add_const (add_monoid (bin_tree empty)) unsigned) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_121780 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) pos) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_121781 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : regular_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_121782 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg name))))) : irreducible_space (has_bot (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_121783 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_121784 (h0 : set (linear_ordered_comm_group_with_zero ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_121785 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) (has_pos_part linarith.comp)) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_121786 (h0 : topological_space (div_inv_monoid to_additive.value_type)) : totally_disconnected_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121787 (h0 : group (semigroup (has_zero pos))) : normalizer_condition (semigroup (has_zero pos)) := sorry --non-trivial
lemma new_lemma_121788 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121789 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121790 (h0 : group (boolean_algebra.core (option unsigned))) : is_cyclic (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_121791 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : preirreducible_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_121792 (h0 : filter (distrib_lattice (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121793 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_121794 (h0 : ring (add_comm_semigroup string.iterator_imp)) : is_domain (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_121795 (h0 : functor.add_const (function.extfun Type ring) real) : @is_domain.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) real h0) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_121796 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_121797 (h0 : functor.add_const (list (has_pos_part linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121798 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @regular_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_121799 (h0 : uniform_space (canonically_ordered_comm_semiring (has_add pos))) : separated_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_121800 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (has_top num)) := sorry --non-trivial
lemma new_lemma_121801 (h0 : group (generalized_boolean_algebra (has_neg name))) : normalizer_condition (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_121802 (h0 : prod (complete_distrib_lattice num) (complete_distrib_lattice num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_121803 (h0 : add_group (topological_space (has_nnnorm to_additive.value_type))) : is_add_cyclic (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121804 (h0 : not (ring (linear_ordered_comm_group_with_zero string_imp) -> false)) : @is_domain.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_121805 (h0 : filter (metric_space (has_norm (id congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121806 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg Type)) linarith.comp) : @archimedean.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_121807 (h0 : functor.add_const (ring (add_cancel_monoid name)) Type) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_121808 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_121809 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_121810 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121811 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121812 (h0 : semiring (measure_theory.measure_space (semiring unsigned))) : is_noetherian_ring (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121813 (h0 : group (canonically_ordered_comm_semiring empty)) : normalizer_condition (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_121814 (h0 : topological_space (has_neg_part (has_add (has_add name)))) : normal_space (has_neg_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_121815 (h0 : finset (finset (option (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_121816 (h0 : monoid (with_one (has_inv (has_inv (comm_ring string_imp))))) : monoid.fg (with_one (has_inv (has_inv (comm_ring string_imp)))) := sorry --non-trivial
lemma new_lemma_121817 (h2 : complete_lattice (with_zero (has_nnnorm to_additive.value_type))) : is_compactly_generated (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121818 (h0 : topological_space (denumerable (comm_ring reducibility_hints))) : totally_disconnected_space (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_121819 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_121820 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top (has_top num))))) : irreducible_space (linear_ordered_add_comm_group (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_121821 (h0 : filter (with_bot num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121822 (h0 : topological_space (topological_space linarith.comp_source)) : locally_compact_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121823 (h0 : functor.add_const (topological_space (has_to_string name)) (has_neg_part (has_neg pos))) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (has_neg_part.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_121824 (h0 : functor.add_const (group (cancel_monoid name)) environment.implicit_infer_kind) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121825 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_121826 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_neg name))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_121827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_121828 (h0 : ring (uniform_space (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (uniform_space (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_121829 (h0 : semiring (ordered_comm_monoid (has_neg Type))) : is_noetherian_ring (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_121830 (h0 : ring (option empty)) : is_principal_ideal_ring (option empty) := sorry --non-trivial
lemma new_lemma_121831 (h0 : add_group (ordered_comm_ring (has_pos_part pos))) : is_add_cyclic (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_121832 (h0 : uniform_space (boolean_algebra.core (option (option unsigned)))) : separated_space (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_121833 (h0 : ordered_add_comm_monoid (bin_tree congr_arg_kind)) : archimedean (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121834 (h0 : not (uniform_space (add_group fun_info) -> false)) : @separated_space.{0} (add_group.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_121835 (h0 : functor.add_const (group (comm_group unsigned)) pos) : @is_cyclic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_121836 (h0 : not (filter (normed_group congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_121837 (h0 : filter (mul_zero_class empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121838 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_121839 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h1 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121840 (h0 : list (semigroup (option name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121841 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring num)) : @locally_compact_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_121842 (h0 : group (has_add (has_Inf Type))) : normalizer_condition (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_121843 (h0 : list (has_neg (boolean_algebra name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121844 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : locally_compact_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121845 (h0 : prod (has_zero Type) (has_zero Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_121846 (h0 : function.extfun Type group) : @group.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_121847 (h0 : ring (has_nnnorm (random_gen (left_cancel_monoid (has_ssubset string_imp))))) : rank_condition (has_nnnorm (random_gen (left_cancel_monoid (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_121848 (h0 : function.extfun nat fin) : @rank_condition.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121849 (h0 : topological_space (has_add (has_to_string pos))) : preconnected_space (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_121850 (h0 : topological_space (has_top (has_norm (with_bot linarith.comp_source)))) : irreducible_space (has_top (has_norm (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_121851 (h0 : topological_space (dlist linarith.comp_source)) : path_connected_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121852 (h0 : ring (distrib (comm_ring reducibility_hints))) : rank_condition (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_121853 (h1 : ring (normed_field (semi_normed_ring (semi_normed_ring (add_cancel_comm_monoid char))))) : is_domain (normed_field (semi_normed_ring (semi_normed_ring (add_cancel_comm_monoid char)))) := sorry --non-trivial
lemma new_lemma_121854 (h0 : topological_space (measurable_space.dynkin_system num)) : preirreducible_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_121855 (h0 : add_group (has_emptyc (random_gen to_additive.value_type))) : is_add_cyclic (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121856 (h0 : topological_space (has_bot (has_pos_part real))) : t0_space (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_121857 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_121858 (h0 : group (has_pos_part (finset pos))) : is_cyclic (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_121859 (h0 : topological_space (semi_normed_ring (has_nnnorm linarith.comp_source))) : totally_disconnected_space (semi_normed_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121860 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_121861 (h0 : functor.add_const (group (has_to_string Type)) (rel name pos)) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) (rel.{0 0} name pos) h0)  := sorry --non-trivial
lemma new_lemma_121862 (h0 : functor.add_const (group (has_neg Type)) (ring Type)) : @group.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121863 (h0 : group (has_inv (random_gen (random_gen char)))) : group.fg (has_inv (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_121864 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) (has_neg Type)) : @separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (normed_comm_ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_121865 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : t1_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_121866 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring Type)) (ring (finset Type))) : @has_exists_mul_of_le.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) (ring.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_121867 (h0 : cancel_comm_monoid_with_zero (has_bot (has_bot Type))) : unique_factorization_monoid (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_121868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_121869 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121870 (h1 : filter (div_inv_monoid linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_121871 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_121872 (h0 : uniform_space (has_pos_part (boolean_algebra.core pos))) : separated_space (has_pos_part (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_121873 (h0 : ring (with_one empty)) : is_principal_ideal_ring (with_one empty) := sorry --non-trivial
lemma new_lemma_121874 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121875 (h0 : topological_space (linear_ordered_comm_ring (preorder congr_arg_kind))) : t1_space (linear_ordered_comm_ring (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_121876 (h0 : not (complete_lattice (has_compl char) -> false)) : @is_compactly_generated.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_121877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_121878 (h0 : complete_lattice (pseudo_metric_space (option (option pos)))) : is_atomistic (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_121879 (h0 : fin has_zero.zero) : @group.fg.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_121880 (h0 : filter (random_gen (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121881 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t1_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_121882 (h0 : group (has_pos_part (has_neg Type))) : normalizer_condition (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_121883 (h0 : topological_space (measurable_space congr_arg_kind)) : totally_separated_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121884 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid ennreal)) : archimedean (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_121885 (h0 : not (ring (linear_ordered_semiring linarith.comp_source) -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_121886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_121887 (h0 : monoid (has_neg (has_pos_part (has_add (has_pos_part pos))))) : monoid.fg (has_neg (has_pos_part (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_121888 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121889 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_121890 (h0 : ordered_comm_monoid (sub_neg_monoid (has_Inf linarith.comp))) : has_exists_mul_of_le (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_121891 (h1 : not (group (random_gen linarith.comp) -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_121892 (h0 : group (has_norm (has_norm empty))) : normalizer_condition (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_121893 (h0 : topological_space (has_bot (has_bot real))) : totally_disconnected_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_121894 (h0 : complete_lattice (pseudo_metric_space (option ennreal))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_121895 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_121896 (h1 : topological_space (nondiscrete_normed_field char)) (h2 : preorder (nondiscrete_normed_field char)) : order_closed_topology (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_121897 (h0 : filter (comm_group name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121898 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_121899 (h0 : ring (has_dist empty)) : is_domain (has_dist empty) := sorry --non-trivial
lemma new_lemma_121900 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @irreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_121901 (h0 : ring (simple_graph (has_Inf linarith.comp))) : is_principal_ideal_ring (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_121902 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_121903 (h0 : topological_space (id (semiring unsigned))) : totally_disconnected_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121904 (h0 : ring (measurable_space.dynkin_system (has_norm (semiring (semiring (semiring num)))))) : rank_condition (measurable_space.dynkin_system (has_norm (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_121905 (h0 : functor.add_const (group (has_neg linarith.comp)) name) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_121906 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121907 (h0 : monoid (is_R_or_C (option num))) : monoid.fg (is_R_or_C (option num)) := sorry --non-trivial
lemma new_lemma_121908 (h0 : topological_space (comm_group (ring pos))) : path_connected_space (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_121909 (h0 : ring (normed_group (has_inv (random_gen fun_info)))) : is_domain (normed_group (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_121910 (h0 : ring (has_div linarith.comp_source)) : rank_condition (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_121911 (h0 : uniform_space (has_to_string congr_arg_kind)) : separated_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121912 (h0 : not (ring (simple_graph string.iterator_imp) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_121913 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_121914 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_121915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_121916 (h0 : topological_space (has_pos_part (has_Inf pos))) : t0_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_121917 (h0 : ring (bin_tree unsigned)) : strong_rank_condition (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_121918 (h0 : group (linear_ordered_comm_ring (has_top num))) : normalizer_condition (linear_ordered_comm_ring (has_top num)) := sorry --non-trivial
lemma new_lemma_121919 (h0 : topological_space (normed_lattice_add_comm_group real)) : totally_disconnected_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_121920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_121921 (h0 : group (option (option ennreal))) : is_cyclic (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_121922 (h0 : topological_space (measurable_space.dynkin_system (linear_ordered_semiring unsigned))) : discrete_topology (measurable_space.dynkin_system (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121923 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_121924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_121925 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} (finset.{0} linarith.comp)) (@matrix.vec_empty.{0} (add_group.{0} (complete_distrib_lattice.{0} (finset.{0} linarith.comp))) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_121926 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : preirreducible_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_121927 (h0 : topological_space (normed_group (semiring empty))) : locally_compact_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_121928 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : topological_space.separable_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121929 (h0 : not (topological_space (has_emptyc (random_gen to_additive.value_type)) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_121930 (h0 : ring (has_neg (has_neg_part name))) : strong_rank_condition (has_neg (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_121931 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_121932 (h0 : functor.add_const (ring (mul_zero_class environment.implicit_infer_kind)) ennreal) : @strong_rank_condition.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_121933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_121934 (h0 : ring (distrib_lattice fun_info)) : is_domain (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_121935 (h0 : functor.add_const (add_group (ring pos)) (comm_group pos)) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_121936 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @t1_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_121937 (h0 : add_group (monoid congr_arg_kind)) : is_add_cyclic (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121938 (h0 : topological_space (add_right_cancel_monoid empty)) : topological_space.separable_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_121939 (h0 : topological_space (normed_comm_ring (has_to_string environment.implicit_infer_kind))) : path_connected_space (normed_comm_ring (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_121940 (h0 : filter (finset (has_add (has_Inf linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_121941 (h0 : monoid (has_zero (finset (finset linarith.comp)))) : monoid.fg (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_121942 (h0 : list (boolean_algebra.core Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_121943 (h0 : group (has_Inf name)) : normalizer_condition (has_Inf name) := sorry --non-trivial
lemma new_lemma_121944 (h0 : topological_space auto.case_option) : preconnected_space auto.case_option := sorry --non-trivial
lemma new_lemma_121945 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_121946 (h0 : topological_space (add_monoid string_imp)) : t0_space (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_121947 (h0 : add_monoid (add_cancel_comm_monoid num)) : add_monoid.fg (add_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_121948 (h0 : has_lt (has_nnnorm (mul_one_class (mul_one_class linarith.ineq)))) : no_max_order (has_nnnorm (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_121949 (h0 : functor.add_const (ring nnreal) (semiring (semiring congr_arg_kind))) : @is_principal_ideal_ring.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_121950 (h0 : list (has_pos_part (ordered_ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_121951 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_121952 (h0 : topological_space (has_nndist (mul_zero_class pos))) : totally_disconnected_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_121953 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_121954 (h0 : complete_lattice (add_comm_monoid (option (has_zero (option unsigned))))) : is_compactly_generated (add_comm_monoid (option (has_zero (option unsigned)))) := sorry --non-trivial
lemma new_lemma_121955 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) empty) : @t1_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_121956 (h0 : complete_lattice (is_R_or_C congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121957 (h0 : ring (has_neg (boolean_algebra.core pos))) : rank_condition (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_121958 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_121959 (h0 : functor.add_const (semiring (has_to_string Type)) name) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_121960 (h0 : has_mem.mem empty has_emptyc.emptyc) : @normalizer_condition.{0} empty (@finset.pi.empty.{1 0} Type group.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_121961 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @monoid.fg.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121962 (h0 : prod (has_union (semiring (semiring num))) (has_union (semiring (semiring num)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_121963 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_121964 (h0 : complete_lattice (semi_normed_comm_ring environment.projection_info)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_121965 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121966 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @t0_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_121967 (h0 : functor.add_const (filter (has_nndist environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121968 (h0 : topological_space (ring num)) : preirreducible_space (ring num) := sorry --non-trivial
lemma new_lemma_121969 (h0 : functor.add_const (list (has_Inf linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121970 (h0 : topological_space (option (semiring unsigned))) : totally_separated_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_121971 (h0 : functor.add_const (topological_space (ordered_ring empty)) (semiring empty)) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_121972 (h0 : filter (add_comm_monoid (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121973 (h0 : group (ordered_comm_group to_additive.value_type)) : group.fg (ordered_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_121974 (h0 : ring (has_top congr_arg_kind)) : is_domain (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_121975 (h0 : functor.comp ring comm_group Type) : @is_domain.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_121976 (h0 : topological_space (boolean_algebra.core num)) : normal_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_121977 (h0 : topological_space (has_add (has_Inf Type))) : t1_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_121978 (h0 : group (has_inter (option empty))) : is_cyclic (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_121979 (h0 : not (uniform_space (left_cancel_monoid congr_arg_kind) -> false)) : @separated_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_121980 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_121981 (h0 : cancel_comm_monoid_with_zero (boolean_algebra real)) : unique_factorization_monoid (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_121982 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_121983 (h0 : filter (has_zero (add_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_121984 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_121985 (h0 : functor.add_const (list (boolean_algebra pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_121986 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_121987 (h0 : not (topological_space (has_div enat) -> false)) : @t0_space.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_121988 (h0 : group (canonically_ordered_monoid (comm_semigroup (comm_semigroup pos)))) : group.fg (canonically_ordered_monoid (comm_semigroup (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_121989 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_121990 (h0 : not (topological_space (div_inv_monoid linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_121991 (h0 : has_mem.mem (has_to_string congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_to_string.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_to_string.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_121992 (h0 : add_group (has_neg (has_neg_part ennreal))) : is_add_cyclic (has_neg (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_121993 (h1 : group (add_cancel_comm_monoid (uniform_space char))) : is_cyclic (add_cancel_comm_monoid (uniform_space char)) := sorry --non-trivial
lemma new_lemma_121994 (h0 : ring (cancel_monoid (comm_group environment.implicit_infer_kind))) : rank_condition (cancel_monoid (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_121995 (h0 : group (group_with_zero (add_cancel_monoid num))) : group.fg (group_with_zero (add_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_121996 (h0 : plift num -> plift num -> Prop) : is_symm (plift num) h0 := sorry --non-trivial
lemma new_lemma_121997 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_121998 (h0 : functor.add_const (uniform_space (has_to_string unsigned)) Type) : @complete_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_121999 (h0 : functor.add_const (finset ennreal) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122000 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg Type)) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_122001 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_122002 (h0 : uniform_space (canonically_ordered_comm_semiring (has_Inf (finset pos)))) : separated_space (canonically_ordered_comm_semiring (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_122003 (h2 : complete_lattice (uniform_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_122004 (h0 : add_group (finset (has_neg_part Type))) : is_add_cyclic (finset (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_122005 (h0 : ordered_comm_monoid (has_neg_part (option (option name)))) : has_exists_mul_of_le (has_neg_part (option (option name))) := sorry --non-trivial
lemma new_lemma_122006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122007 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_122008 (h0 : finset (bin_tree congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122009 (h0 : fin has_zero.zero) (h1 : fin (nat.succ (matrix.vec_empty h0)) -> list Prop) (h2 : fin (matrix.vec_empty h0)) : list.head (matrix.vec_tail h1 h2) := sorry --non-trivial
lemma new_lemma_122010 (h0 : uniform_space (comm_semigroup (has_bot real))) : complete_space (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_122011 (h0 : filter (add_cancel_monoid (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122012 (h0 : ring (has_bot unsigned)) : is_principal_ideal_ring (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_122013 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @is_domain.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_122014 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122015 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} name (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_122016 (h0 : not (uniform_space (has_inv fun_info) -> false)) : @complete_space.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_122017 (h0 : complete_lattice (simple_graph (has_add linarith.comp))) : is_compactly_generated (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_122018 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @separated_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_122019 (h0 : topological_space (has_pos_part linarith.comp)) : normal_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_122020 (h1 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122021 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.ineq))) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122022 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122023 (h0 : functor.add_const (function.extfun (Type 1) monoid) pos) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_122024 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122025 (h0 : functor.add_const (ring (normed_comm_ring pos)) linarith.comp) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122026 (h0 : semiring (comm_group (has_add (has_add linarith.comp)))) : is_noetherian_ring (comm_group (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_122027 (h0 : functor.add_const (list (free_add_monoid unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122028 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_122029 (h0 : function.extfun nat fin) : @path_connected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_122030 (h0 : group (has_union (semiring (measurable_space.dynkin_system (with_bot unsigned))))) : group.fg (has_union (semiring (measurable_space.dynkin_system (with_bot unsigned)))) := sorry --non-trivial
lemma new_lemma_122031 (h0 : group (comm_group (has_neg (add_comm_monoid linarith.comp)))) : group.fg (comm_group (has_neg (add_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_122032 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_122033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_122034 (h0 : function.extfun Type ring) : @rank_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_122035 (h0 : functor.add_const (monoid (boolean_algebra.core name)) (has_neg_part (has_add (has_add (has_neg name))))) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} name)) (has_neg_part.{0} (has_add.{0} (has_add.{0} (has_neg.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_122036 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122037 (h0 : topological_space (linear_ordered_field unsigned)) : loc_path_connected_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_122038 (h0 : fin has_zero.zero) : @t1_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122039 (h0 : uniform_space (canonically_linear_ordered_monoid unsigned)) : separated_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_122040 (h0 : group (semigroup (has_nndist (has_add linarith.comp)))) : group.fg (semigroup (has_nndist (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_122041 (h0 : functor.add_const (topological_space (option unsigned)) congr_arg_kind) : @normal_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_122042 (h1 : topological_space (has_norm num)) : t0_space (has_norm num) := sorry --non-trivial
lemma new_lemma_122043 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_122044 (h0 : group (boolean_algebra (has_add environment.implicit_infer_kind))) : is_simple_group (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122045 (h1 : ring (measurable_space linarith.comp_source)) : is_domain (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122046 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_semigroup empty)))) : @is_atomistic.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_122047 (h0 : functor.add_const (finset (finset linarith.comp)) (finset (has_zero Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122048 (h0 : topological_space (boolean_algebra (has_Inf name))) : discrete_topology (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_122049 (h0 : ring (has_lt reducibility_hints)) : is_domain (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_122050 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot pos)) linarith.comp) : @unique_factorization_monoid.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122051 (h0 : functor.add_const (list (normed_comm_ring pos)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122052 (h0 : topological_space (has_div string.iterator)) : path_connected_space (has_div string.iterator) := sorry --non-trivial
lemma new_lemma_122053 (h0 : add_group (group_with_zero unsigned)) : is_add_cyclic (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_122054 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_122055 (h0 : functor.add_const (function.extfun Type group) (ring pos)) : @group.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} pos) h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_122056 (h0 : topological_space (add_comm_monoid (boolean_algebra name))) : irreducible_space (add_comm_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_122057 (h0 : topological_space (canonically_ordered_comm_semiring name)) : topological_space.separable_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_122058 (h0 : uniform_space (generalized_boolean_algebra (has_nndist name))) : separated_space (generalized_boolean_algebra (has_nndist name)) := sorry --non-trivial
lemma new_lemma_122059 (h0 : functor.add_const (topological_space (preorder unsigned)) num) : @irreducible_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_122060 (h0 : set (has_sdiff enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_122061 (h0 : ring (has_edist (option (option (option empty))))) : is_principal_ideal_ring (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_122062 (h0 : add_group (mul_zero_class (semiring num))) : is_add_cyclic (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_122063 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122064 (h0 : group (with_bot (has_top empty))) : group.fg (with_bot (has_top empty)) := sorry --non-trivial
lemma new_lemma_122065 (h0 : complete_lattice (has_append (has_nnnorm (random_gen reducibility_hints)))) : is_compactly_generated (has_append (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_122066 (h0 : ring (ordered_comm_ring (ordered_comm_ring (finset (has_add pos))))) : strong_rank_condition (ordered_comm_ring (ordered_comm_ring (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_122067 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_122068 (h0 : add_monoid (has_add (normed_comm_ring name))) : add_monoid.fg (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_122069 (h0 : topological_space (boolean_algebra (has_to_string pos))) : totally_disconnected_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_122070 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122071 (h0 : ring (comm_group (has_neg_part linarith.comp))) : rank_condition (comm_group (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_122072 (h0 : topological_space (has_nndist (finset Type))) : locally_compact_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_122073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_122074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_122075 (h0 : set (normed_group linarith.comp_source)) : set.nonempty h0 := sorry --non-trivial
lemma new_lemma_122076 (h0 : group (has_Inf real)) : is_simple_group (has_Inf real) := sorry --non-trivial
lemma new_lemma_122077 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) (ring linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122078 (h0 : complete_lattice (has_compl (has_lt char))) : complete_lattice.is_Sup_finite_compact (has_compl (has_lt char)) := sorry --non-trivial
lemma new_lemma_122079 (h2 : topological_space (add_monoid to_additive.value_type)) : totally_disconnected_space (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122080 (h0 : complete_lattice (semi_normed_comm_ring string_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_122081 (h0 : ring (semiring (with_bot (has_top linarith.ineq)))) : is_domain (semiring (with_bot (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122082 (h0 : ordered_comm_monoid (has_to_string (normed_comm_ring environment.implicit_infer_kind))) : has_exists_mul_of_le (has_to_string (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122083 (h0 : ring (semigroup pos)) : is_domain (semigroup pos) := sorry --non-trivial
lemma new_lemma_122084 (h0 : functor.add_const (group (complete_distrib_lattice empty)) empty) : @is_cyclic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_122085 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_122087 (h0 : ring (has_nndist (has_add unsigned))) : is_principal_ideal_ring (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_122088 (h1 : monoid (measurable_space (random_gen empty))) : monoid.fg (measurable_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_122089 (h0 : functor.add_const (add_group (finset name)) pos) : @is_add_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_122090 (h0 : functor.add_const (functor.add_const (topological_space empty) (semiring num)) (semiring empty)) : t0_space empty := sorry --non-trivial
lemma new_lemma_122091 (h1 : topological_space (complete_semilattice_Sup linarith.comp)) : t0_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_122092 (h0 : list (semigroup (has_add (boolean_algebra (boolean_algebra Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122093 (h0 : topological_space (has_pos_part (has_add real))) : preconnected_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_122094 (h0 : topological_space (simple_graph (ring pos))) : loc_path_connected_space (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_122095 (h0 : topological_space (with_one (random_gen (random_gen (random_gen fun_info))))) : irreducible_space (with_one (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_122096 (h0 : functor.comp topological_space comm_group Type) : @normal_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_122097 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_122098 (h0 : not (semiring (normed_group unsigned) -> false)) : @is_noetherian_ring.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_122099 (h2 : group (topological_space (normed_field (random_gen char)))) : is_cyclic (topological_space (normed_field (random_gen char))) := sorry --non-trivial
lemma new_lemma_122100 (h0 : function.extfun Type (functor.comp add_group complete_distrib_lattice)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_122101 (h0 : topological_space (distrib_lattice (comm_ring (comm_ring fun_info)))) : totally_disconnected_space (distrib_lattice (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_122102 (h0 : ring (add_comm_monoid name)) : is_principal_ideal_ring (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_122103 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122104 (h0 : topological_space (boolean_algebra (has_pos_part (finset linarith.comp)))) : preirreducible_space (boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_122105 (h0 : ring (metric_space (has_norm empty))) : is_domain (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_122106 (h0 : uniform_space (generalized_boolean_algebra (has_neg (has_neg (has_neg Type))))) : complete_space (generalized_boolean_algebra (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_122107 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_122108 (h0 : topological_space (has_zero (boolean_algebra.core (option ennreal)))) : preirreducible_space (has_zero (boolean_algebra.core (option ennreal))) := sorry --non-trivial
lemma new_lemma_122109 (h0 : functor.add_const (filter (has_neg name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122110 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core unsigned))) : path_connected_space (canonically_ordered_comm_semiring (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_122111 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_122112 (h2 : ring (distrib fun_info)) : is_domain (distrib fun_info) := sorry --non-trivial
lemma new_lemma_122113 (h0 : environment.projection_info -> environment.projection_info -> Prop) : is_linear_order environment.projection_info h0 := sorry --non-trivial
lemma new_lemma_122114 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : preconnected_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_122115 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) Type) : @is_compactly_generated.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_122116 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122117 (h0 : topological_space (boolean_algebra.core (has_add Type))) : topological_space.separable_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_122118 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_add Type))) : archimedean (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_122119 (h1 : uniform_space (with_one (with_bot linarith.comp_source))) : complete_space (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122120 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_122121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} (has_nnnorm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} (has_nnnorm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_122122 (h0 : topological_space (measurable_space (has_top (semiring unsigned)))) : normal_space (measurable_space (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_122123 (h0 : monoid (semiring (bin_tree ordering))) (h1 : semiring (bin_tree ordering)) : squarefree h1 := sorry --non-trivial
lemma new_lemma_122124 (h0 : functor.add_const (function.extfun Type group) (has_add Type)) : @normalizer_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_add.{1} Type) h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_122125 (h0 : ring (boolean_algebra (has_pos_part pos))) : is_domain (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_122126 (h0 : ring (has_union (semiring (has_top (semiring (semiring (has_norm (semiring linarith.comp)))))))) : is_domain (has_union (semiring (has_top (semiring (semiring (has_norm (semiring linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_122127 (h0 : complete_lattice (has_top (semiring empty))) : is_atomistic (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_122128 (h0 : finset (ordered_comm_monoid (has_add (finset (has_Inf linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122129 (h0 : topological_space (has_neg_part (has_add (has_neg_part unsigned)))) : loc_path_connected_space (has_neg_part (has_add (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_122130 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122131 (h0 : list (semi_normed_comm_ring (has_ssubset (has_nnnorm (random_gen string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122132 (h0 : functor.add_const (add_monoid (non_assoc_semiring unsigned)) unsigned) : @add_monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122133 (h0 : function.extfun Type (functor.add_const (topological_space (semiring num)))) : @preirreducible_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semiring.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_122134 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_122135 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122136 (h0 : cancel_comm_monoid_with_zero (simple_graph (sub_neg_monoid pos))) : unique_factorization_monoid (simple_graph (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_122137 (h1 : semiring (add_comm_semigroup string.iterator_imp)) (h2 : ideal (add_comm_semigroup string.iterator_imp)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_122138 (h0 : complete_lattice (id fun_info)) : complete_lattice.is_Sup_finite_compact (id fun_info) := sorry --non-trivial
lemma new_lemma_122139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122140 (h0 : add_group (with_bot (has_top (comm_ring (random_gen linarith.comp_source))))) : is_add_cyclic (with_bot (has_top (comm_ring (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_122141 (h0 : group (has_inv (has_top linarith.ineq))) : normalizer_condition (has_inv (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122142 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_122143 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122144 (h0 : functor.comp add_group has_add unsigned) : @is_add_cyclic.{0} (has_add.{0} unsigned) (@functor.comp.run.{0 0 0} add_group.{0} has_add.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_122145 (h0 : topological_space (has_pos_part linarith.comp)) : loc_path_connected_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_122146 (h0 : fin has_zero.zero) : @is_simple_group.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_122147 (h0 : function.extfun nat fin) : @monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122148 (h0 : not (add_monoid (left_cancel_semigroup unsigned) -> false)) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_122149 (h0 : group (id congr_arg_kind)) : is_cyclic (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122150 (h1 : ring (semi_normed_ring string_imp)) : rank_condition (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_122151 (h0 : function.extfun Type topological_space) : totally_separated_space bool := sorry --non-trivial
lemma new_lemma_122152 (h0 : function.extfun Type group) : @is_cyclic.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_122153 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid real))) : irreducible_space (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122154 (h0 : topological_space std_gen) : nonempty (t0_space std_gen) := sorry --non-trivial
lemma new_lemma_122155 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122156 (h0 : functor.add_const (topological_space (comm_group name)) (has_neg linarith.comp)) : @preirreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_122157 (h0 : topological_space (sub_neg_monoid linarith.comp)) : totally_disconnected_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_122158 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (normed_comm_ring (has_Inf (has_Inf pos)))) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (normed_comm_ring.{0} (has_Inf.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_122159 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (free_add_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_122160 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122162 (h0 : topological_space (add_cancel_monoid (finset pos))) : loc_path_connected_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_122163 (h0 : add_monoid (boolean_algebra.core (comm_group name))) : add_monoid.fg (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_122164 (h0 : cancel_comm_monoid_with_zero (has_nndist (ring unsigned))) : unique_factorization_monoid (has_nndist (ring unsigned)) := sorry --non-trivial
lemma new_lemma_122165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122166 (h0 : add_monoid (as_linear_order congr_arg_kind)) : add_monoid.fg (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122167 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122168 (h0 : uniform_space (add_group (has_norm fun_info))) : separated_space (add_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_122169 (h0 : topological_space (has_neg (ring pos))) : loc_path_connected_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_122170 (h0 : ring (generalized_boolean_algebra (has_bot real))) : is_principal_ideal_ring (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_122171 (h0 : complete_lattice (complete_distrib_lattice (option num))) : is_atomistic (complete_distrib_lattice (option num)) := sorry --non-trivial
lemma new_lemma_122172 (h0 : group (metric_space (has_top empty))) : normalizer_condition (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_122173 (h0 : functor.add_const (group (add_comm_monoid name)) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_122174 (h0 : topological_space (option (option empty))) : t1_space (option (option empty)) := sorry --non-trivial
lemma new_lemma_122175 (h0 : topological_space (has_norm (semiring (semiring unsigned)))) : topological_space.separable_space (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_122176 (h0 : filter (normed_lattice_add_comm_group (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122177 (h0 : fin has_zero.zero) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_122178 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) name) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_122179 (h0 : topological_space (preorder (option empty))) : locally_compact_space (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_122180 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_122181 (h0 : filter (has_to_string (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122182 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_122183 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring ennreal)) (option unsigned)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_122184 (h1 : ring (random_gen (comm_ring linarith.comp_source))) : rank_condition (random_gen (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122185 (h0 : topological_space (is_R_or_C (option empty))) : totally_separated_space (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_122186 (h1 : group (has_compl (random_gen char))) : is_cyclic (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_122187 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_122188 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_122189 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_122190 (h0 : group (measure_theory.measure_space empty)) : group.fg (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_122191 (h0 : ring (has_nndist ennreal)) : rank_condition (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_122192 (h0 : list (add_comm_monoid (finset (finset (finset pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122193 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add Type)) : @separated_space.{0} (add_semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{1} Type) h0) (add_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_122194 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_122195 (h0 : finset (has_add (mul_zero_class (has_nndist (mul_zero_class (option (mul_zero_class name))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122196 (h0 : functor.add_const (topological_space (has_add name)) Type) : @discrete_topology.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_122197 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add linarith.comp)) : @group.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} linarith.comp) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_122198 (h0 : filter (boolean_algebra (has_Inf Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122199 (h0 : topological_space (linear_ordered_comm_ring num)) : preirreducible_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_122200 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_122201 (h0 : topological_space (canonically_ordered_add_monoid (option empty))) : t0_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_122202 (h0 : topological_space (boolean_algebra (has_neg (has_neg linarith.comp)))) : totally_disconnected_space (boolean_algebra (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_122203 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring unsigned)))))) : path_connected_space (has_union (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_122204 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122205 (h0 : topological_space (has_inter (option (option unsigned)))) : normal_space (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_122206 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : totally_separated_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_122207 (h0 : add_monoid (has_inner empty congr_arg_kind)) : add_monoid.fg (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122208 (h0 : functor.add_const (finset (measure_theory.measure_space num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122209 (h1 : topological_space (uniform_space linarith.comp_source)) (h2 : preorder (uniform_space linarith.comp_source)) : order_topology (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122210 (h1 : group (add_left_cancel_monoid char)) : is_cyclic (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_122211 (h2 : uniform_space (has_nnnorm linarith.comp_source)) : complete_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122212 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_122213 (h0 : monoid (normed_group (random_gen linarith.comp_source))) (h2 : Prop) : yyy_to (monoid.fg (normed_group (random_gen linarith.comp_source))) h2 := sorry --non-trivial
lemma new_lemma_122214 (h0 : group (add_cancel_monoid ennreal)) : normalizer_condition (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_122215 (h2 : add_group (nondiscrete_normed_field (add_comm_semigroup (mul_one_class ordering)))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup (mul_one_class ordering))) := sorry --non-trivial
lemma new_lemma_122216 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add (sub_neg_monoid Type))))) : normal_space (normed_lattice_add_comm_group (has_add (has_add (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_122217 (h1 : ring (with_one char)) : is_domain (with_one char) := sorry --non-trivial
lemma new_lemma_122218 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_122219 (h0 : uniform_space (comm_ring rat)) : complete_space (comm_ring rat) := sorry --non-trivial
lemma new_lemma_122220 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122221 (h0 : uniform_space (complete_linear_order empty)) : complete_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_122222 (h0 : topological_space (comm_semigroup (has_pos_part (has_pos_part (has_bot linarith.comp))))) : totally_separated_space (comm_semigroup (has_pos_part (has_pos_part (has_bot linarith.comp)))) := sorry --non-trivial
lemma new_lemma_122223 (h0 : ring (metric_space (has_top congr_arg_kind))) : is_domain (metric_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122224 (h1 : complete_lattice (has_inv string_imp)) : complete_lattice.is_Sup_finite_compact (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_122225 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @normal_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_122226 (h0 : topological_space (has_pos_part (has_neg Type))) : discrete_topology (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_122227 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (has_bot.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_122228 (h0 : set (linear_ordered_add_comm_group linarith.ineq)) : set.nonempty h0 := sorry --non-trivial
lemma new_lemma_122229 (h0 : complete_lattice (group_with_zero (option (option (option ennreal))))) : complete_lattice.is_Sup_finite_compact (group_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_122230 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122231 (h0 : ring (canonically_ordered_comm_semiring empty)) : rank_condition (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_122232 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_122233 (h0 : group (has_zero (mul_zero_class name))) : is_simple_group (has_zero (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_122234 (h1 : uniform_space (uniform_space linarith.comp_source)) : complete_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122235 (h0 : topological_space (has_inter (has_norm fun_info))) : path_connected_space (has_inter (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_122236 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122237 (h0 : topological_space (random_gen (with_bot string_imp))) : path_connected_space (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_122238 (h0 : filter (ring (boolean_algebra (has_neg Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122239 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122240 (h0 : list (comm_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122241 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @t1_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122242 (h0 : topological_space (add_comm_monoid (complete_distrib_lattice unsigned))) : t0_space (add_comm_monoid (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_122243 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122244 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring linarith.comp)) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_122245 (h0 : finset (linear_ordered_cancel_comm_monoid (option (option (option empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122246 (h0 : monoid (normed_comm_ring environment.implicit_infer_kind)) : monoid.fg (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_122247 (h0 : add_group (sub_neg_monoid linarith.comp)) : is_add_cyclic (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_122248 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) (ring (ring Type))) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122249 (h0 : group (ordered_comm_ring (finset (has_Inf linarith.comp)))) : is_simple_group (ordered_comm_ring (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_122250 (h0 : group (plift num)) : is_cyclic (plift num) := sorry --non-trivial
lemma new_lemma_122251 (h0 : topological_space (boolean_algebra (has_add unsigned))) : preconnected_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_122252 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_122253 (h1 : uniform_space (mul_one_class ereal)) : complete_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_122254 (h0 : not (uniform_space (measurable_space congr_arg_kind) -> false)) : @separated_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_122255 (h0 : functor.add_const (fin has_zero.zero) (has_Inf real)) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_pos_part.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} real) h0))  := sorry --non-trivial
lemma new_lemma_122256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_122257 (h1 : complete_lattice (has_top (random_gen (with_bot string_imp)))) : is_compactly_generated (has_top (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_122258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_122259 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_122260 (h0 : uniform_space (has_nnnorm (random_gen (random_gen (random_gen reducibility_hints))))) : complete_space (has_nnnorm (random_gen (random_gen (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_122261 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_122262 (h0 : group (has_zero (option (option ennreal)))) : group.fg (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_122263 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122264 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122265 (h1 : ring (random_gen (has_nnnorm (metric_space linarith.ineq)))) : rank_condition (random_gen (has_nnnorm (metric_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122266 (h0 : measurable_space string.iterator) (h1 : filter string.iterator) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_122267 (h0 : ring (semi_normed_ring to_additive.value_type)) : rank_condition (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122268 (h0 : topological_space (has_union linarith.comp)) : normal_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_122269 (h0 : monoid (simple_graph (ring (has_add (boolean_algebra.core Type))))) : monoid.fg (simple_graph (ring (has_add (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_122270 (h0 : topological_space (has_inv (has_inv (has_nnnorm (random_gen char))))) : path_connected_space (has_inv (has_inv (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_122271 (h0 : list (linear_ordered_field (comm_group (cancel_monoid pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122272 (h1 : complete_lattice (has_emptyc congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122273 (h0 : function.extfun nat fin) : @normal_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122274 (h2 : complete_lattice linarith.comp_source) : is_atomistic linarith.comp_source := sorry --non-trivial
lemma new_lemma_122275 (h0 : topological_space (has_div linarith.comp_source)) (h1 : preorder (has_div linarith.comp_source)) : order_closed_topology (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122276 (h0 : ring (has_one (semiring (has_norm empty)))) : strong_rank_condition (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_122277 (h0 : ring (complete_distrib_lattice Type)) : is_principal_ideal_ring (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_122278 (h0 : not (topological_space (has_star num) -> false)) : @locally_compact_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_122279 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_122280 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @regular_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122281 (h0 : uniform_space (bin_tree (semiring num))) : separated_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_122282 (h0 : topological_space (with_one (add_group empty))) : t0_space (with_one (add_group empty)) := sorry --non-trivial
lemma new_lemma_122283 (h0 : uniform_space (simple_graph (mul_one_class (mul_one_class fun_info)))) : complete_space (simple_graph (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_122284 (h0 : functor.add_const (list (mul_zero_class empty)) (semiring empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122285 (h0 : ring (has_to_string ennreal)) : is_principal_ideal_ring (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_122286 (h0 : group (has_to_string (has_neg linarith.comp))) : is_cyclic (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_122287 (h0 : uniform_space (has_star (semiring num))) : complete_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_122288 (h0 : topological_space (has_div to_additive.value_type)) (h1 : preorder (has_div to_additive.value_type)) : order_topology (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122289 (h0 : ring (semiring (has_top (has_top (has_top linarith.comp_source))))) : strong_rank_condition (semiring (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_122290 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122291 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (matrix.vec_empty h0))))) := sorry --non-trivial
lemma new_lemma_122292 (h0 : not (uniform_space (has_top congr_arg_kind) -> false)) : @complete_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_122293 (h0 : topological_space (option (semiring congr_arg_kind))) : normal_space (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122294 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_122295 (h0 : functor.add_const (monoid (ring linarith.comp)) (has_add environment.implicit_infer_kind)) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_122296 (h0 : measurable_space enat) (h2 : measure_theory.measure enat) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_122297 (h0 : ring (dlist (encodable fun_info))) : is_domain (dlist (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_122298 (h0 : filter (has_to_string (add_cancel_monoid linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122299 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset (has_Inf pos))) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_122300 (h0 : filter (has_top (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122301 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg name)))) : totally_separated_space (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_122302 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_122303 (h0 : not (function.extfun Type (functor.add_const (topological_space num)) -> false)) : @totally_disconnected_space.{0} num (@functor.add_const.run.{0 0} (topological_space.{0} num) fun_info (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} num)) (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} num))) h0) fun_info))  := sorry --non-trivial
lemma new_lemma_122304 (h1 : topological_space (has_norm string_imp)) : locally_compact_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_122305 (h0 : ring (linear_ordered_field fun_info)) : rank_condition (linear_ordered_field fun_info) := sorry --non-trivial
lemma new_lemma_122306 (h0 : topological_space (normed_comm_ring unsigned)) : preirreducible_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_122307 (h0 : fin has_zero.zero) : id (matrix.vec_empty (matrix.vec_empty (id (id h0)))) := sorry --non-trivial
lemma new_lemma_122308 (h0 : ring (left_cancel_monoid (semiring unsigned))) : rank_condition (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_122309 (h0 : topological_space (linear_ordered_field (comm_group unsigned))) : loc_path_connected_space (linear_ordered_field (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_122310 (h0 : add_group (comm_ring (has_ssubset linarith.comp_source))) : is_add_cyclic (comm_ring (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122311 (h0 : functor.comp ring add_comm_monoid pos) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_122312 (h0 : ordered_add_comm_monoid (has_inner (option (option empty)) (semiring empty))) : archimedean (has_inner (option (option empty)) (semiring empty)) := sorry --non-trivial
lemma new_lemma_122313 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_122314 (h0 : filter (semigroup (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122315 (h0 : complete_lattice (dlist (random_gen char))) : is_compactly_generated (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_122316 (h0 : topological_space (boolean_algebra.core (option unsigned))) : topological_space.separable_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_122317 (h0 : ring (has_to_string (finset (finset (has_Inf environment.implicit_infer_kind))))) : rank_condition (has_to_string (finset (finset (has_Inf environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_122318 (h0 : ring (linear_ordered_field (comm_monoid num))) : is_domain (linear_ordered_field (comm_monoid num)) := sorry --non-trivial
lemma new_lemma_122319 (h0 : topological_space (has_zero (finset linarith.comp))) : path_connected_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_122320 (h0 : topological_space (add_comm_monoid (option ennreal))) : discrete_topology (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_122321 (h0 : topological_space (linear_ordered_comm_ring num)) : locally_compact_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_122322 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @discrete_topology.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122323 (h0 : not (ring (id congr_arg_kind) -> false)) : @rank_condition.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_122324 (h0 : topological_space (add_comm_semigroup char)) (h3 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_122325 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} (has_nndist.{0} name)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (pseudo_metric_space.{0} (has_nndist.{0} name)))  := sorry --non-trivial
lemma new_lemma_122326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122327 (h0 : group (topological_space linarith.comp_source)) : group.fg (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122328 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm char))))) : complete_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_122329 (h0 : topological_space (filter unsigned)) : locally_compact_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_122330 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_122331 (h0 : group (id (has_norm (has_norm (has_top (has_norm num)))))) : group.fg (id (has_norm (has_norm (has_top (has_norm num))))) := sorry --non-trivial
lemma new_lemma_122332 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 : set to_additive.value_type) : is_strong_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_122333 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_122334 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122335 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_122336 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_122337 (h0 : uniform_space (finset (finset (finset (finset Type))))) : complete_space (finset (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_122338 (h1 : uniform_space (div_inv_monoid (has_nnnorm char))) : complete_space (div_inv_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_122339 (h0 : topological_space (finset (has_neg (ring (has_neg (ring Type)))))) : regular_space (finset (has_neg (ring (has_neg (ring Type))))) := sorry --non-trivial
lemma new_lemma_122340 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122341 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) name) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_122342 (h0 : uniform_space (has_one (semiring num))) : separated_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_122343 (h0 : topological_space (has_neg (has_add (ring pos)))) : t1_space (has_neg (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_122344 (h0 : group (boolean_algebra.core (comm_group Type))) : normalizer_condition (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_122345 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_122346 (h0 : ordered_comm_monoid (add_cancel_monoid (option pos))) : has_exists_mul_of_le (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_122347 (h0 : monoid (normed_comm_ring (finset linarith.comp))) : monoid.fg (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_122348 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_122349 (h0 : function.extfun nat fin) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@matrix.vec_empty.{1} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122350 (h0 : finset (has_inter (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122351 (h0 h1 : Prop) : yyy_to h0 h1 := sorry --non-trivial
lemma new_lemma_122352 (h0 : semiring (finset Type)) : is_noetherian_ring (finset Type) := sorry --non-trivial
lemma new_lemma_122353 (h1 : measurable_space char) (h2 : measure_theory.measure char) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_122354 (h0 : topological_space (normed_comm_ring (has_add Type))) : locally_compact_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_122355 (h0 : finset (ordered_comm_ring (has_neg real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122356 (h0 : uniform_space (canonically_ordered_comm_semiring (finset (has_neg (ring linarith.comp))))) : complete_space (canonically_ordered_comm_semiring (finset (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_122357 (h0 : ordered_add_comm_monoid (add_semigroup (has_dist unsigned))) : archimedean (add_semigroup (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_122358 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_122359 (h0 : add_group (ring (has_to_string (add_comm_monoid pos)))) : is_add_cyclic (ring (has_to_string (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_122360 (h0 : ring (metric_space (semiring linarith.comp))) : rank_condition (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_122361 (h0 : functor.add_const (list (non_assoc_semiring unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122362 (h1 : group (normed_field (has_nnnorm (random_gen (comm_ring (random_gen reducibility_hints)))))) : is_cyclic (normed_field (has_nnnorm (random_gen (comm_ring (random_gen reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_122363 (h0 : topological_space (uniform_space enat)) : totally_disconnected_space (uniform_space enat) := sorry --non-trivial
lemma new_lemma_122364 (h0 : measurable_space (boolean_algebra (has_add environment.implicit_infer_kind))) (h1 : has_div (boolean_algebra (has_add environment.implicit_infer_kind))) : has_measurable_div₂ (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122365 (h0 : topological_space (option (option pos))) : normal_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_122366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_122367 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid Type)) unsigned) : @has_exists_mul_of_le.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122368 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122369 (h0 : ring (has_emptyc (has_norm linarith.ineq))) : is_domain (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122370 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_add_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_122371 (h0 : complete_lattice (monoid_with_zero (option ennreal))) : is_atomistic (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_122372 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_122374 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : normal_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_122375 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_122376 (h0 : not (complete_lattice (random_gen string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_122377 (h0 : functor.add_const (group (has_zero linarith.comp)) (finset pos)) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122378 (h0 : function.extfun Type (functor.comp list has_zero)) : list.nodup (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_122379 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122380 (h1 : add_group (denumerable (random_gen char))) : is_add_cyclic (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_122381 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (bin_tree num)) := sorry --non-trivial
lemma new_lemma_122382 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : sequential_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_122383 (h0 : functor.add_const (functor.add_const (monoid Type) pos) (ring Type)) : @monoid.fg.{1} Type (@functor.add_const.run.{1 0} (monoid.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (monoid.{1} Type) pos) (ring.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_122384 (h1 : topological_space std_gen) (h2 : add_group std_gen) : topological_add_group std_gen := sorry --non-trivial
lemma new_lemma_122385 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) (has_add pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122386 (h0 : topological_space (finset (has_to_string (has_to_string (has_to_string num))))) : loc_path_connected_space (finset (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_122387 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice Type)) pos) : @archimedean.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_122388 (h0 : group (denumerable (random_gen fun_info))) : is_cyclic (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_122389 (h0 : functor.add_const (topological_space (ring pos)) Type) : @totally_separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_122390 (h0 : group (simple_graph (has_add (has_add pos)))) : group.fg (simple_graph (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_122391 (h0 : ring (add_comm_monoid (has_neg_part (has_add pos)))) : is_domain (add_comm_monoid (has_neg_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_122392 (h0 : ring (normed_field char)) : is_domain (normed_field char) := sorry --non-trivial
lemma new_lemma_122393 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_122394 (h0 : topological_space (has_Inf (sub_neg_monoid Type))) : path_connected_space (has_Inf (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_122395 (h0 : ring (id linarith.comp)) : strong_rank_condition (id linarith.comp) := sorry --non-trivial
lemma new_lemma_122396 (h0 : topological_space (has_to_string (has_to_string (has_to_string (has_to_string (has_to_string unsigned)))))) : t1_space (has_to_string (has_to_string (has_to_string (has_to_string (has_to_string unsigned))))) := sorry --non-trivial
lemma new_lemma_122397 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122398 (h0 : topological_space (comm_group (has_add Type))) : locally_compact_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_122399 (h0 : topological_space (normed_comm_ring (ring (group_with_zero (has_add linarith.comp))))) : regular_space (normed_comm_ring (ring (group_with_zero (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_122400 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_122401 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122402 (h0 : topological_space (div_inv_monoid (has_ssubset string_imp))) : t0_space (div_inv_monoid (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_122403 (h2 : ring (add_cancel_comm_monoid to_additive.value_type)) : rank_condition (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122404 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122405 (h0 : functor.add_const (ring (normed_comm_ring Type)) linarith.comp) : @rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122406 (h0 : topological_space (has_ssubset (has_ssubset linarith.ineq))) : totally_disconnected_space (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122407 (h0 : group (complete_distrib_lattice (has_nndist (finset pos)))) : is_cyclic (complete_distrib_lattice (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_122408 (h0 : functor.add_const (group (finset linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_122409 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) (boolean_algebra environment.implicit_infer_kind)) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_122410 (h0 : list (linear_ordered_field (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122411 (h0 : topological_space (measure_theory.measure_space unsigned)) : totally_separated_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_122412 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_122413 (h0 : complete_lattice (lattice (semiring (semiring (semiring (semiring empty)))))) : is_compactly_generated (lattice (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_122414 (h0 : complete_lattice (comm_semigroup (has_bot real))) : is_compactly_generated (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_122415 (h0 : filter (has_neg (has_neg_part environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122416 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122417 (h0 : group (has_Inf (has_neg pos))) : normalizer_condition (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_122418 (h0 : uniform_space (comm_group (comm_group linarith.comp))) : separated_space (comm_group (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_122419 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg pos)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122420 (h0 : add_group (semi_normed_ring (mul_one_class to_additive.value_type))) : is_add_cyclic (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_122421 (h0 : ring (left_cancel_semigroup unsigned)) : is_domain (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_122422 (h0 : set (has_compl environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_122423 (h0 : group real.angle) : normalizer_condition real.angle := sorry --non-trivial
lemma new_lemma_122424 (h0 : functor.add_const (group (add_cancel_monoid Type)) (ring linarith.comp)) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_122425 (h0 : finset (semigroup (has_add (has_add pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122426 (h0 : topological_space (semi_normed_comm_ring (has_ssubset char))) : t0_space (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_122427 (h0 : functor.add_const (topological_space (finset unsigned)) pos) : @path_connected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_122428 (h0 : add_comm_semigroup (has_Inf char)) (h1 : sym2 (add_comm_semigroup (has_Inf char))) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_122429 (h0 : complete_lattice (has_one (semiring (semiring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_122430 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_122431 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122432 (h0 : complete_lattice (with_bot (semiring (has_top linarith.comp)))) : is_compactly_generated (with_bot (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_122433 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group (comm_group pos))))) : loc_path_connected_space (add_cancel_monoid (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_122434 (h0 : group (add_cancel_monoid (has_add (has_neg Type)))) : group.fg (add_cancel_monoid (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_122435 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_pos_part Type))) : unique_factorization_monoid (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_122436 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122437 (h0 : group (cancel_monoid (finset (has_add (has_add name))))) : is_cyclic (cancel_monoid (finset (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_122438 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (sub_neg_monoid real))) : unique_factorization_monoid (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122439 (h0 : ring (normed_comm_ring (ring (has_pos_part pos)))) : is_domain (normed_comm_ring (ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_122440 (h0 : topological_space (complete_linear_order (semiring num))) : t0_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_122441 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122442 (h0 : complete_lattice (nondiscrete_normed_field std_gen)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_122443 (h0 : topological_space (multiplicative ereal)) : totally_disconnected_space (multiplicative ereal) := sorry --non-trivial
lemma new_lemma_122444 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_122445 (h1 : complete_lattice (add_comm_semigroup char)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_122446 (h0 : complete_lattice (has_norm (semiring (semiring (semiring unsigned))))) : complete_lattice.is_Sup_finite_compact (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_122447 (h0 : group (random_gen (random_gen (random_gen fun_info)))) : is_cyclic (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_122448 (h0 : list (has_add (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122449 (h0 : topological_space (comm_group (has_to_string unsigned))) : t1_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_122450 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_122451 (h1 : filter (comm_ring string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_122452 (h0 : functor.add_const (ring (has_bot linarith.comp)) name) : @is_domain.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_122453 (h0 : complete_lattice (monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_122454 (h0 : add_monoid (normed_comm_ring (has_add pos))) : add_monoid.fg (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_122455 (h0 : nat) (h1 : topological_space (fin h0)) : path_connected_space (fin h0) := sorry --non-trivial
lemma new_lemma_122456 (h0 : monoid (has_neg name)) : monoid.fg (has_neg name) := sorry --non-trivial
lemma new_lemma_122457 (h0 : ring (semigroup (has_add ennreal))) : is_domain (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_122458 (h0 : topological_space (simple_graph congr_arg_kind)) : preconnected_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122459 (h0 : topological_space (has_top unsigned)) : preirreducible_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_122460 (h0 : function.extfun Type (functor.add_const (ring (semigroup empty)))) : @strong_rank_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (semigroup.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_122461 (h0 : functor.add_const (functor.comp topological_space has_nndist environment.implicit_infer_kind) unsigned) : @path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind) unsigned h0))  := sorry --non-trivial
lemma new_lemma_122462 (h0 : functor.add_const (filter (semigroup pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122463 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} (has_neg_part.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} (has_neg_part.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_122464 (h0 : semiring (comm_group (option unsigned))) : is_noetherian_ring (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_122465 (h0 : topological_space (has_neg (has_to_string unsigned))) : preirreducible_space (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_122466 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_122467 (h1 : not (complete_lattice (has_lt string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_122468 (h1 : topological_space (with_zero char)) : t0_space (with_zero char) := sorry --non-trivial
lemma new_lemma_122469 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @discrete_topology.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_122470 (h0 : topological_space (non_assoc_semiring unsigned)) : totally_separated_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_122471 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) name) : @complete_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_122472 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_122473 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid pos))) : loc_path_connected_space (ordered_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_122474 (h0 : group (finset (has_neg Type))) : is_cyclic (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_122475 (h0 : set (set (add_comm_semigroup fun_info))) (h1 : set (add_comm_semigroup fun_info)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_122476 (h0 : complete_lattice (with_one (has_top num))) : is_compactly_generated (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_122477 (h0 : topological_space (add_right_cancel_monoid num)) : t0_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_122478 (h0 : topological_space (has_nndist (finset pos))) : t1_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_122479 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) real.angle)  := sorry --non-trivial
lemma new_lemma_122480 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122481 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) (has_neg (finset name))) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} (finset.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_122482 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122483 (h0 : ring (complete_semilattice_Sup (has_norm fun_info))) : is_domain (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_122484 (h0 : topological_space (has_nndist (finset (has_neg name)))) : path_connected_space (has_nndist (finset (has_neg name))) := sorry --non-trivial
lemma new_lemma_122485 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122486 (h0 : topological_space (semi_normed_comm_ring string_imp)) : path_connected_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_122487 (h0 : topological_space (has_star (semiring num))) : t1_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_122488 (h0 : filter (canonically_linear_ordered_monoid (has_Inf real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122489 (h0 : functor.comp list has_add name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_122490 (h0 : group (linear_ordered_semiring (has_norm (semiring (semiring linarith.ineq))))) : normalizer_condition (linear_ordered_semiring (has_norm (semiring (semiring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_122491 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (ring (has_Inf Type))) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) (ring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122492 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_122493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122494 (h0 : function.extfun nat fin) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122495 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @totally_disconnected_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122496 (h0 : monoid (option (semiring congr_arg_kind))) : monoid.fg (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122497 (h0 h1 : pnat) : pnat.coprime h0 (id h1) := sorry --non-trivial
lemma new_lemma_122498 (h0 : function.extfun Type (functor.add_const (uniform_space Type))) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (uniform_space.{1} Type)) h0 pos))  := sorry --non-trivial
lemma new_lemma_122499 (h0 : add_group enat) : is_add_cyclic enat := sorry --non-trivial
lemma new_lemma_122500 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (with_bot.{0} (with_bot.{0} (has_top.{0} (has_top.{0} empty))))))) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_top.{0} (has_top.{0} (has_norm.{0} (with_bot.{0} (with_bot.{0} (has_top.{0} (has_top.{0} empty))))))))  := sorry --non-trivial
lemma new_lemma_122501 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_122502 (h0 : ring (normed_group (random_gen linarith.comp_source))) : strong_rank_condition (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122503 (h0 : group (complete_distrib_lattice (ring Type))) : is_cyclic (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_122504 (h0 : functor.add_const (topological_space (complete_semilattice_Sup num)) num) : @t1_space.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_semilattice_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_122505 (h0 : set (linear_ordered_comm_group_with_zero char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_122506 (h0 : complete_lattice (linear_ordered_add_comm_group num)) : is_atomistic (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_122507 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (pseudo_emetric_space ennreal)) := sorry --non-trivial
lemma new_lemma_122508 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} fun_info (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_122509 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : locally_compact_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122510 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semilattice_inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_122511 (h0 : complete_lattice (linear_ordered_add_comm_group linarith.ineq)) : is_compactly_generated (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_122512 (h0 : topological_space (complete_semilattice_Sup (comm_ring fun_info))) : t0_space (complete_semilattice_Sup (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_122513 (h0 : ring (fintype (random_gen fun_info))) : strong_rank_condition (fintype (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_122514 (h0 : semiring (simple_graph (has_Inf (has_add Type)))) : is_noetherian_ring (simple_graph (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_122515 (h0 : list (has_neg_part (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122516 (h0 : functor.add_const (topological_space (has_bot real)) linarith.comp) : @totally_disconnected_space.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122517 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_122518 (h0 : topological_space (comm_group (option (has_neg_part pos)))) : totally_disconnected_space (comm_group (option (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_122519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122520 (h0 : list (finset ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122521 (h0 : functor.add_const (topological_space (finset Type)) Type) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_122522 (h0 : function.extfun Type group) : @group.fg.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_122523 (h0 : complete_lattice (has_emptyc (random_gen linarith.comp_source))) : is_compactly_generated (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122524 (h0 : functor.add_const (topological_space (semigroup pos)) (finset Type)) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_122525 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122526 (h0 : topological_space (normed_comm_ring (finset ennreal))) : normal_space (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_122527 (h0 : add_group (has_nnnorm fun_info)) : is_add_cyclic (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_122528 (h2 : not (topological_space (has_norm char) -> false)) : @t0_space.{0} (has_norm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_122529 (h0 : prod (complete_distrib_lattice unsigned) (complete_distrib_lattice unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_122530 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_122531 (h0 : topological_space (topological_space (random_gen linarith.comp_source))) : totally_disconnected_space (topological_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122532 (h0 : uniform_space (has_union fun_info)) : separated_space (has_union fun_info) := sorry --non-trivial
lemma new_lemma_122533 (h0 : fin has_zero.zero) : @sequential_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122534 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_122535 (h0 : topological_space (dlist (random_gen fun_info))) : t0_space (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_122536 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @locally_compact_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_122537 (h0 : ordered_add_comm_monoid (monoid_with_zero (option ennreal))) : archimedean (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_122538 (h0 : topological_space (add_cancel_monoid (option pos))) : t1_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_122539 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) Type) : @is_atomistic.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_122540 (h0 : topological_space (semigroup (has_neg_part pos))) : locally_compact_space (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_122541 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_one.{0} (semiring.{0} (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp))))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} (semiring.{0} (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp))))))  := sorry --non-trivial
lemma new_lemma_122542 (h1 : ring (has_nnnorm string_imp)) : strong_rank_condition (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_122543 (h1 h2 : multiset (add_comm_semigroup environment.projection_info)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_122544 (h0 : functor.add_const (ring (normed_comm_ring pos)) pos) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_122545 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_122546 (h2 : ring reducibility_hints) : rank_condition reducibility_hints := sorry --non-trivial
lemma new_lemma_122547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_122548 (h1 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_122549 (h0 : finset (pseudo_metric_space (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122550 (h0 : group (has_nnnorm (has_top linarith.comp_source))) : group.fg (has_nnnorm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122551 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @preirreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_122552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_zero name)) := sorry --non-trivial
lemma new_lemma_122553 (h0 : topological_space (partial_order (semiring (semiring unsigned)))) : irreducible_space (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_122554 (h0 : functor.add_const (topological_space (semigroup unsigned)) unsigned) : @discrete_topology.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122555 (h0 : ring (has_lt (mul_one_class to_additive.value_type))) : strong_rank_condition (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_122556 (h0 : topological_space (add_cancel_monoid (has_add pos))) : regular_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_122557 (h0 : ring (mul_zero_class num)) : is_domain (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_122558 (h0 : semiring (linear_ordered_semiring (semiring (semiring (semiring num))))) : is_noetherian_ring (linear_ordered_semiring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_122559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_122560 (h0 : finset (canonically_linear_ordered_monoid (measurable_space.dynkin_system unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122561 (h0 : topological_space (has_pos_part (has_add (has_add Type)))) : path_connected_space (has_pos_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_122562 (h0 : topological_space (normed_lattice_add_comm_group (option (option ennreal)))) : path_connected_space (normed_lattice_add_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_122563 (h0 : ring (denumerable to_additive.value_type)) : rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122564 (h2 : monoid (with_one num)) : monoid.fg (with_one num) := sorry --non-trivial
lemma new_lemma_122565 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : path_connected_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_122566 (h0 : group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (has_add (has_add Type)))))) : is_simple_group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_122567 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_122568 (h3 : topological_space (has_append char)) : path_connected_space (has_append char) := sorry --non-trivial
lemma new_lemma_122569 (h0 : topological_space (semigroup (add_comm_monoid name))) : topological_space.separable_space (semigroup (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_122570 (h0 : group (preorder (option (option empty)))) : group.fg (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_122571 (h0 : complete_lattice (topological_space char)) : is_compactly_generated (topological_space char) := sorry --non-trivial
lemma new_lemma_122572 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : topological_space.separable_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122573 (h0 : group (id (random_gen linarith.ineq))) : is_cyclic (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122574 (h0 : functor.add_const (filter (boolean_algebra name)) (comm_group (comm_group (comm_group Type)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122575 (h0 : functor.add_const (finset (ring name)) (has_Inf name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122576 (h0 : set (has_le (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_122577 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_122578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_122579 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122580 (h1 : ring (has_ssubset (mul_one_class (uniform_space linarith.comp_source)))) : is_domain (has_ssubset (mul_one_class (uniform_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_122581 (h0 : complete_lattice (complete_semilattice_Sup linarith.ineq)) : is_compactly_generated (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_122582 (h0 : group (canonically_ordered_monoid pos)) : is_simple_group (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_122583 (h0 : topological_space (is_R_or_C empty)) : totally_disconnected_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_122584 (h0 : ring (has_nndist (has_to_string congr_arg_kind))) : rank_condition (has_nndist (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122585 (h0 : topological_space (finset (ring Type))) : topological_space.separable_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_122586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122587 (h0 : ring (normed_group (has_norm (has_norm (has_norm (has_norm fun_info)))))) : rank_condition (normed_group (has_norm (has_norm (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_122588 (h0 : group (has_inter num)) : normalizer_condition (has_inter num) := sorry --non-trivial
lemma new_lemma_122589 (h0 : ring (plift (non_assoc_semiring (option unsigned)))) : strong_rank_condition (plift (non_assoc_semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_122590 (h0 : uniform_space (add_semigroup (option (option (option (option unsigned)))))) : separated_space (add_semigroup (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_122591 (h1 : group (encodable string_imp)) : group.fg (encodable string_imp) := sorry --non-trivial
lemma new_lemma_122592 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122593 (h0 : semiring (has_sub (semiring (semiring unsigned)))) : is_noetherian_ring (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_122594 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_122595 (h0 : not (uniform_space (has_nnnorm linarith.ineq) -> false)) : @complete_space.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_122596 (h0 : functor.add_const (ring (ordered_comm_ring Type)) linarith.comp) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122597 (h0 : measurable_space ereal) (h1 : filter ereal) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_122598 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) pos) := sorry --non-trivial
lemma new_lemma_122599 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122600 (h0 : not (list (with_bot num) -> false)) : palindrome (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_122601 (h0 : topological_space (uniform_space (random_gen char))) : totally_disconnected_space (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_122602 (h0 : semiring (semigroup (finset (ring Type)))) : is_noetherian_ring (semigroup (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_122603 (h0 : has_zero (has_add name) -> has_zero (has_add name) -> Prop) : is_symm (has_zero (has_add name)) h0 := sorry --non-trivial
lemma new_lemma_122604 (h0 : function.extfun nat fin) : @rank_condition.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122605 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist unsigned)) ennreal) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_122606 (h0 : list (semiring (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122607 (h0 : option (topological_space (fintype fun_info))) (h1 : not (coe_sort (option.is_some h0) -> false)) : @totally_disconnected_space.{0} (fintype.{0} fun_info) (@option.get.{0} (topological_space.{0} (fintype.{0} fun_info)) h0 (@classical.by_contradiction'.{0} (@coe_sort.{1 1} bool Prop coe_sort_bool (@option.is_some.{0} (topological_space.{0} (fintype.{0} fun_info)) h0)) h1))  := sorry --non-trivial
lemma new_lemma_122608 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122609 (h1 : complete_lattice (normed_field std_gen)) : complete_lattice.is_Sup_finite_compact (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_122610 (h0 : prod (complete_linear_order unsigned) (complete_linear_order unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_122611 (h0 : ring (has_neg (comm_group Type))) : rank_condition (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_122612 (h0 : functor.add_const (finset (option name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122613 (h0 : group (has_inv (random_gen (add_group fun_info)))) : group.fg (has_inv (random_gen (add_group fun_info))) := sorry --non-trivial
lemma new_lemma_122614 (h0 : complete_lattice (mul_zero_class name)) : is_atomistic (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_122615 (h0 : add_monoid (random_gen (has_norm linarith.comp))) : add_monoid.fg (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_122616 (h0 : topological_space (semigroup (option name))) : t0_space (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_122617 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_122618 (h0 : list (monoid_with_zero (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122619 (h0 : functor.add_const (topological_space (has_add real)) real) : @totally_disconnected_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_122620 (h0 : topological_space (lattice congr_arg_kind)) : locally_compact_space (lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122621 (h0 : functor.add_const (group (has_zero name)) Type) : @is_simple_group.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_122622 (h0 : topological_space (add_comm_monoid (has_to_string unsigned))) : loc_path_connected_space (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_122623 (h0 : topological_space (option (option (partial_order congr_arg_kind)))) : totally_separated_space (option (option (partial_order congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_122624 (h0 : group (complete_distrib_lattice real)) : is_cyclic (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_122625 (h0 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : totally_separated_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_122626 (h0 : ring linarith.comp_source) : rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_122627 (h0 : ordered_add_comm_monoid (has_add (ring (finset (has_pos_part pos))))) : archimedean (has_add (ring (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_122628 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_122629 (h0 : not (uniform_space (add_comm_monoid char) -> false)) : @complete_space.{0} (add_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_122630 (h0 : list (boolean_algebra Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122631 (h0 : uniform_space (has_neg_part (option ennreal))) : complete_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_122632 (h0 : ring (with_bot (has_norm linarith.comp))) : rank_condition (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_122633 (h0 : not (topological_space (semi_normed_ring (mul_one_class reducibility_hints)) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_122634 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : totally_separated_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122635 (h0 : not (add_group (has_inv fun_info) -> false)) : @is_add_cyclic.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_122636 (h0 : functor.add_const (topological_space (boolean_algebra name)) (comm_group name)) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_122637 (h0 : add_monoid (canonically_ordered_monoid (has_add (has_pos_part (has_add pos))))) : add_monoid.fg (canonically_ordered_monoid (has_add (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_122638 (h4 : set (std_gen -> fun_info)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_122639 (h0 : topological_space (boolean_algebra (ring name))) : regular_space (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_122640 (h0 : topological_space (has_add (has_add environment.implicit_infer_kind))) : regular_space (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122641 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122642 (h0 : semiring empty) (h1 : semiring fun_info) (h2 : ring_hom empty fun_info) (h3 : has_mul (ring_hom (power_series empty) (power_series fun_info))) : id (set.center (ring_hom (power_series empty) (power_series fun_info)) (power_series.map h2)) := sorry --non-trivial
lemma new_lemma_122643 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_122644 (h0 : function.extfun nat fin) : @separated_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122645 (h0 : topological_space (has_zero (option pos))) : t1_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_122646 (h0 : has_lt (nondiscrete_normed_field (normed_field string.iterator_imp))) : no_max_order (nondiscrete_normed_field (normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_122647 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) empty) : @strong_rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_122648 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122649 (h0 : group (random_gen (mv_power_series string_imp linarith.ineq))) : is_cyclic (random_gen (mv_power_series string_imp linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122650 (h0 : monoid (has_star (semiring (semiring (semiring unsigned))))) : monoid.fg (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_122651 (h0 : complete_lattice (add_left_cancel_semigroup (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_122652 (h0 : ring (ring (ring environment.implicit_infer_kind))) : strong_rank_condition (ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122653 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_122654 (h0 : complete_lattice (free_add_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122655 (h0 : topological_space (random_gen (random_gen linarith.comp_source))) : totally_separated_space (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122656 (h0 : complete_lattice (ordered_comm_ring (has_add (has_Inf Type)))) : is_compactly_generated (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_122657 (h0 : fin has_zero.zero) : @monoid.fg.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_122658 (h0 : topological_space (has_norm (has_norm congr_arg_kind))) : discrete_topology (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122659 (h0 : complete_lattice (linear_ordered_field (finset (has_neg congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (finset (has_neg congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_122660 (h0 : not (complete_lattice (add_group congr_arg_kind) -> false)) : @is_atomistic.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_122661 (h0 : topological_space (has_inner empty congr_arg_kind)) : locally_compact_space (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122662 (h1 : topological_space (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) : totally_disconnected_space (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_122663 (h0 : group (has_add (complete_distrib_lattice name))) : is_simple_group (has_add (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_122664 (h1 : not (ring (with_bot congr_arg_kind) -> false)) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_122665 (h1 : complete_lattice (semi_normed_comm_ring (has_nnnorm (semigroup char)))) : is_compactly_generated (semi_normed_comm_ring (has_nnnorm (semigroup char))) := sorry --non-trivial
lemma new_lemma_122666 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_122667 (h0 : not (nat -> false)) (h1 : not (add_group (nat.partition (classical.by_contradiction' h0)) -> false)) : @is_add_cyclic.{0} (nat.partition (@classical.by_contradiction'.{1} nat h0)) (@classical.by_contradiction'.{1} (add_group.{0} (nat.partition (@classical.by_contradiction'.{1} nat h0))) h1)  := sorry --non-trivial
lemma new_lemma_122668 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_122669 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @sequential_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_122670 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_122671 (h0 : complete_lattice (boolean_algebra (semigroup unsigned))) : is_atomistic (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_122672 (h0 : group (has_top (semiring (semiring empty)))) : is_cyclic (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_122673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_122674 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_122675 (h0 : functor.comp list cancel_monoid name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_122676 (h0 : ring (boolean_algebra (has_bot real))) : rank_condition (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_122677 (h0 : complete_lattice (normed_group (semiring (semiring (semiring fun_info))))) : is_compactly_generated (normed_group (semiring (semiring (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_122678 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122679 (h0 : ring (has_add (ring name))) : rank_condition (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_122680 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_122681 (h0 : topological_space (simple_graph (has_Inf name))) : preirreducible_space (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_122682 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_122683 (h0 : not (complete_lattice (measure_theory.measure_space empty) -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_122684 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inf.{0} real))  := sorry --non-trivial
lemma new_lemma_122685 (h0 : functor.add_const (function.extfun (Type 1) finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_122686 (h0 : topological_space (has_bot (sub_neg_monoid real))) : t1_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122687 (h0 : functor.add_const (monoid (has_to_string Type)) (has_Inf pos)) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122688 (h0 : topological_space (boolean_algebra (has_add (comm_semigroup pos)))) : preirreducible_space (boolean_algebra (has_add (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_122689 (h0 : add_group (id (with_bot to_additive.value_type))) : is_add_cyclic (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_122690 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) name) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_122691 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122692 (h0 : functor.add_const (function.extfun Type add_group) environment.implicit_infer_kind) : @is_add_cyclic.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) environment.implicit_infer_kind h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_122693 (h0 : topological_space (finset (has_to_string environment.implicit_infer_kind))) : preconnected_space (finset (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122694 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_122695 (h1 : filter (topological_space (has_ssubset (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_122696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122697 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122698 (h0 : ring (normed_comm_ring (has_neg_part Type))) : is_domain (normed_comm_ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_122699 (h0 : functor.add_const (list (boolean_algebra.core pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122700 (h0 : not (function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop)) -> false)) : @complete_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop))) h0) (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122701 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_122702 (h0 : monoid (group_with_zero (option (option unsigned)))) : monoid.fg (group_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_122703 (h1 : complete_lattice (has_add linarith.ineq)) : is_compactly_generated (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_122704 (h0 : monoid (canonically_ordered_comm_semiring (option pos))) : monoid.exponent_exists (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_122705 (h0 : functor.add_const (filter (normed_comm_ring pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_122707 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @normal_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_122708 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_122709 (h0 : topological_space (has_bot (has_add real))) : sequential_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_122710 (h0 : has_add (nondiscrete_normed_field ereal)) (h1 : add_group (add_con (nondiscrete_normed_field ereal))) : is_add_cyclic (add_con (nondiscrete_normed_field ereal)) := sorry --non-trivial
lemma new_lemma_122711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122712 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_122713 (h0 : group (comm_ring char)) : is_cyclic (comm_ring char) := sorry --non-trivial
lemma new_lemma_122714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_122715 (h0 : ring (add_comm_monoid environment.implicit_infer_kind)) : strong_rank_condition (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_122716 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid Type)) Type) : @unique_factorization_monoid.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_122717 (h1 : filter (fintype fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_122718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_122719 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (comm_semigroup Type)))) : totally_disconnected_space (add_comm_monoid (sub_neg_monoid (comm_semigroup Type))) := sorry --non-trivial
lemma new_lemma_122720 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core linarith.comp))) : sequential_space (complete_distrib_lattice (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_122721 (h0 : add_group (option name)) : is_add_cyclic (option name) := sorry --non-trivial
lemma new_lemma_122722 (h0 : semiring (has_add (has_add (has_Inf linarith.comp)))) : is_noetherian_ring (has_add (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_122723 (h0 : not (topological_space (random_gen num) -> false)) : @path_connected_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_122724 (h0 : preorder linarith.comp_source) (h1 : function.extfun (linarith.comp_source -> Type) (function.extfun linarith.comp_source)) : bdd_below (function.extfun_app (function.extfun_app h1 (fun (x : linarith.comp_source), Prop))) := sorry --non-trivial
lemma new_lemma_122725 (h0 : list (has_to_string (ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122726 (h0 : topological_space (has_nndist num)) : path_connected_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_122727 (h0 : list (boolean_algebra (finset (finset linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122728 (h0 : add_monoid (linear_ordered_field (option (option (option num))))) : add_monoid.fg (linear_ordered_field (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_122729 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_122730 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) unsigned) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122731 (h0 : complete_lattice (boolean_algebra (has_Inf real))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_122732 (h0 : topological_space (partial_order congr_arg_kind)) : topological_space.separable_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122733 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_122734 (h0 : list (distrib_lattice (random_gen (random_gen (random_gen (random_gen fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122735 (h0 : group (has_nndist (comm_group (comm_group pos)))) : is_simple_group (has_nndist (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_122736 (h0 : topological_space (has_nndist (has_add Type))) : t0_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_122737 (h0 : uniform_space (ring (has_pos_part linarith.comp))) : separated_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_122738 (h0 : topological_space (canonically_ordered_add_monoid (option (option congr_arg_kind)))) : irreducible_space (canonically_ordered_add_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_122739 (h0 : topological_space (boolean_algebra.core (has_to_string Type))) : preconnected_space (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_122740 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (add_group empty)) := sorry --non-trivial
lemma new_lemma_122741 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) pos) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_122742 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_122743 (h0 : topological_space (with_bot unsigned)) : totally_disconnected_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_122744 (h0 : group (with_one (has_inv (has_inv linarith.ineq)))) : group.fg (with_one (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122745 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_122746 (h0 : complete_lattice (comm_ring (comm_ring fun_info))) : complete_lattice.is_Sup_finite_compact (comm_ring (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_122747 (h0 : has_neg std_gen) (h6 : measurable_space std_gen) : has_measurable_neg std_gen := sorry --non-trivial
lemma new_lemma_122748 (h0 : topological_space (has_top num)) : normal_space (has_top num) := sorry --non-trivial
lemma new_lemma_122749 (h0 : has_mem.mem (with_zero num) has_emptyc.emptyc) : @totally_separated_space.{0} (with_zero.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_zero.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_122750 (h0 : functor.add_const (finset (comm_group Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122751 (h0 : group (boolean_algebra (has_to_string linarith.comp))) : group.fg (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_122752 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_122753 (h0 : ring (has_neg (ordered_ring pos))) : is_domain (has_neg (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_122754 (h0 : topological_space (normed_group (semiring (semiring empty)))) : preirreducible_space (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_122755 (h0 : functor.add_const (finset (has_norm linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122756 (h1 : set (normed_field (semi_normed_ring std_gen))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_122757 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_122758 (h0 : add_group (has_nndist (has_neg_part name))) : is_add_cyclic (has_nndist (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_122759 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_122760 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122761 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_122762 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_122763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122764 (h0 : group (monoid (option empty))) : group.fg (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_122765 (h0 : topological_space (has_inv (random_gen (random_gen to_additive.value_type)))) : path_connected_space (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_122766 (h0 : topological_space (add_monoid (fintype (encodable (random_gen (add_monoid (random_gen char))))))) : t0_space (add_monoid (fintype (encodable (random_gen (add_monoid (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_122767 (h0 : function.extfun Type (prod (normed_comm_ring ennreal))) : id_rel (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_122768 (h0 : complete_lattice (cancel_monoid (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122769 (h0 : ring (add_comm_monoid (has_to_string (has_add (has_add (has_to_string pos)))))) : is_domain (add_comm_monoid (has_to_string (has_add (has_add (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_122770 (h0 : functor.add_const (group (boolean_algebra Type)) pos) : @group.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_122771 (h0 : uniform_space (semi_normed_comm_ring char)) : complete_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_122772 (h0 : topological_space (has_neg (has_add pos))) : normal_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_122773 (h0 : uniform_space (has_top (measurable_space empty))) : complete_space (has_top (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_122774 (h0 : option Type) (h1 : finset (option.get_or_else h0 unsigned)) : finset.nonempty h1 := sorry --non-trivial
lemma new_lemma_122775 (h1 : complete_lattice (div_inv_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_122776 (h0 : measurable_space (has_ssubset string.iterator_imp)) (h1 : filter (has_ssubset string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_122777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_122778 (h0 : topological_space (with_one (has_norm linarith.comp_source))) : t0_space (with_one (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122779 (h0 : topological_space ereal) (h2 : Prop) : is_path_connected (id (fun (h1 : ereal), h2)) := sorry --non-trivial
lemma new_lemma_122780 (h0 : topological_space (ordered_comm_ring linarith.comp)) : locally_compact_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_122781 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_122782 (h0 : filter (finset unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_122783 (h0 : topological_space (ring (has_neg (has_neg Type)))) : sequential_space (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_122784 (h0 : ring (has_compl (has_inv linarith.ineq))) : rank_condition (has_compl (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_122785 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_Inf pos)) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122786 (h0 : functor.add_const (uniform_space (comm_group Type)) linarith.comp) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122787 (h0 : ring (has_neg (finset linarith.comp))) : is_domain (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_122788 (h0 : function.extfun (finset Type) (has_mem.mem linarith.ineq)) : @totally_disconnected_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122789 (h1 : complete_lattice (with_zero fun_info)) : complete_lattice.is_Sup_finite_compact (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_122790 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_122791 (h0 : linarith.comp -> has_Inf linarith.comp -> has_Inf linarith.comp) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_122792 (h0 : function.extfun (finset Type) (has_mem.mem (semiring (has_norm linarith.ineq)))) : @totally_disconnected_space.{0} (semiring.{0} (has_norm.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_norm.{0} linarith.ineq)) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} (has_norm.{0} linarith.ineq))) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_122793 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_122794 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (ring (complete_distrib_lattice (has_nndist name)))) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) (ring.{0} (complete_distrib_lattice.{0} (has_nndist.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_122795 (h0 : add_monoid (pseudo_metric_space (option (option unsigned)))) : add_monoid.fg (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_122796 (h0 : group (finset (finset Type))) : normalizer_condition (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_122797 (h0 : uniform_space (has_pos_part (semigroup pos))) : separated_space (has_pos_part (semigroup pos)) := sorry --non-trivial
lemma new_lemma_122798 (h0 : topological_space (add_comm_monoid (has_pos_part (finset linarith.comp)))) : loc_path_connected_space (add_comm_monoid (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_122799 (h0 : complete_lattice (has_nndist (has_to_string unsigned))) : is_atomistic (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_122800 (h0 : functor.comp topological_space boolean_algebra.core Type) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_122801 (h0 : list (comm_ring (random_gen (random_gen (dlist (dlist (random_gen (dlist fun_info)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122802 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) (has_pos_part linarith.comp)) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_122803 (h0 : filter (canonically_linear_ordered_monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_122804 (h0 : topological_space (comm_semigroup (has_bot (has_bot pos)))) : preirreducible_space (comm_semigroup (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_122805 (h0 : functor.add_const (topological_space (boolean_algebra name)) (boolean_algebra pos)) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_122806 (h0 : ring (is_R_or_C (option (option unsigned)))) : is_domain (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_122807 (h0 : ring (normed_comm_ring (has_to_string unsigned))) : is_principal_ideal_ring (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_122808 (h0 : topological_space (add_cancel_monoid (option pos))) : discrete_topology (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_122809 (h0 : group (measurable_space (has_top linarith.comp_source))) : group.fg (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122810 (h0 : ring (comm_ring (has_nnnorm linarith.comp_source))) : strong_rank_condition (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122811 (h0 : set (mul_one_class char -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_122812 (h0 : has_neg (normed_field environment.projection_info)) (h1 : measurable_space (normed_field environment.projection_info)) : has_measurable_neg (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_122813 (h1 : group (has_inv (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : is_cyclic (has_inv (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_122814 (h0 : uniform_space (linear_ordered_comm_ring num)) : complete_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_122815 (h0 : monoid (random_gen linarith.ineq)) (h1 : random_gen linarith.ineq) : is_unit h1 := sorry --non-trivial
lemma new_lemma_122816 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : t0_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_122817 (h0 : group (has_Inf (sub_neg_monoid real))) : is_cyclic (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122818 (h0 : list (comm_group (comm_group pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122819 (h0 : topological_space (add_cancel_monoid (boolean_algebra pos))) : locally_compact_space (add_cancel_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_122820 (h0 : not (ring (has_repr to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_repr.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_repr.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_122821 (h0 : functor.add_const (ring (ring name)) environment.implicit_infer_kind) : @rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_122822 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122823 (h0 : topological_space (linear_ordered_field unsigned)) : totally_disconnected_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_122824 (h0 : list (has_norm (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122825 (h0 : functor.add_const (filter (comm_group unsigned)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122826 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_122827 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_122828 (h1 : list (topological_space to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_122829 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @t1_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_122830 (h0 : topological_space (comm_semigroup (has_Inf pos))) : preirreducible_space (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_122831 (h0 : function.extfun Type (functor.add_const (filter linarith.comp))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_122832 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122833 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add (has_add real))))) : totally_separated_space (canonically_ordered_monoid (has_Inf (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_122834 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122835 (h0 : topological_space (boolean_algebra (has_add (has_to_string linarith.comp)))) : path_connected_space (boolean_algebra (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_122836 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_122837 (h0 : topological_space (measurable_space (random_gen (random_gen (random_gen fun_info))))) : t0_space (measurable_space (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_122838 (h0 : add_left_cancel_semigroup (option empty) -> add_left_cancel_semigroup (option empty) -> Prop) : is_antisymm (add_left_cancel_semigroup (option empty)) h0 := sorry --non-trivial
lemma new_lemma_122839 (h0 : functor.add_const (topological_space (ordered_ring empty)) (semiring (semiring (semiring empty)))) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_122840 (h1 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h1) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_122841 (h1 : add_group (semi_normed_comm_ring (add_comm_semigroup environment.projection_info))) : is_add_cyclic (semi_normed_comm_ring (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_122842 (h0 : topological_space (semiring congr_arg_kind)) : topological_space.separable_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122843 (h0 : topological_space (sub_neg_monoid congr_arg_kind)) : totally_separated_space (sub_neg_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122844 (h0 : list (has_add environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122845 (h0 : uniform_space num) : separated_space num := sorry --non-trivial
lemma new_lemma_122846 (h0 : finset (ordered_comm_ring (ring (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_122848 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122849 (h0 : topological_space (has_bot (has_bot real))) : normal_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_122850 (h0 : complete_lattice (normed_group (has_inv (has_inv linarith.comp_source)))) : is_atomistic (normed_group (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_122851 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122852 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_122853 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_122854 (h0 : function.extfun nat fin) : @complete_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122855 (h0 : ring (with_bot (random_gen (random_gen linarith.ineq)))) : is_domain (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122856 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122857 (h0 : functor.add_const (topological_space (finset Type)) pos) : @totally_separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_122858 (h0 : functor.add_const (group (has_neg Type)) linarith.comp) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122859 (h0 : topological_space (has_Inf (has_Inf (has_neg (has_neg pos))))) : t0_space (has_Inf (has_Inf (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_122860 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_122861 (h0 : not (topological_space (add_group num) -> false)) : @t0_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_122862 (h0 : complete_lattice (ordered_comm_ring (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_122863 (h0 : functor.add_const (uniform_space (left_cancel_semigroup unsigned)) unsigned) : @complete_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122864 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_122865 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (finset Type))) : archimedean (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_122866 (h0 : finset (has_nndist (cancel_monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122867 (h0 : monoid (linear_ordered_semiring linarith.comp)) : monoid.fg (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_122868 (h1 : has_lt (mul_one_class (add_comm_semigroup string.iterator_imp))) : no_max_order (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_122869 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_122870 (h0 : ring (uniform_space (has_append (random_gen (comm_ring linarith.comp_source))))) : strong_rank_condition (uniform_space (has_append (random_gen (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_122871 (h0 : list ordering) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122872 (h0 : group (random_gen (random_gen (has_nnnorm char)))) : is_cyclic (random_gen (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_122873 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) linarith.comp) : @is_compactly_generated.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122874 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_122875 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122876 (h0 : functor.add_const (uniform_space pos) pos) : @complete_space.{0} pos (@functor.add_const.run.{0 0} (uniform_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_122877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_122878 (h0 : functor.add_const (add_group (has_Sup empty)) empty) : @is_add_cyclic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_122879 (h0 : complete_lattice (has_nndist (option (option ennreal)))) : is_compactly_generated (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_122880 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122881 (h0 : group (has_bot (has_add pos))) : normalizer_condition (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_122882 (h0 : empty -> empty -> empty) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_122883 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122884 (h0 : functor.comp topological_space boolean_algebra Type) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_122885 (h0 : group (omega_complete_partial_order empty)) : normalizer_condition (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_122886 (h0 : cancel_comm_monoid_with_zero (semigroup (finset environment.implicit_infer_kind))) : unique_factorization_monoid (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_122887 (h2 : uniform_space (uniform_space (random_gen linarith.comp_source))) : complete_space (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_122888 (h0 h1 : list ereal) : list.is_prefix h0 h1 := sorry --non-trivial
lemma new_lemma_122889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122890 (h0 : uniform_space (monoid (comm_monoid (option empty)))) : complete_space (monoid (comm_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_122891 (h0 : functor.add_const (function.extfun Type topological_space) (ring pos)) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_122892 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122893 (h0 : functor.add_const (add_monoid (ring linarith.comp)) pos) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_122894 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @discrete_topology.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_122895 (h0 : complete_lattice (mul_zero_class pos)) : complete_lattice.is_Sup_finite_compact (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_122896 (h0 : complete_lattice (random_gen string_imp)) : complete_lattice.is_Sup_finite_compact (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_122897 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_122898 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122899 (h1 : uniform_space (measurable_space (random_gen (with_bot string_imp)))) : complete_space (measurable_space (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_122900 (h1 : topological_space (normed_field linarith.comp_source)) : t0_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_122901 (h0 : add_monoid (finset (finset (finset linarith.comp)))) : add_monoid.fg (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_122902 (h0 : not (uniform_space (semi_normed_ring (has_nnnorm linarith.comp_source)) -> false)) : @complete_space.{0} (semi_normed_ring.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_122903 (h0 : prod linarith.comp_source linarith.comp_source) : set.diagonal linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_122904 (h0 : function.extfun nat fin) : @t1_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122905 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_122906 (h4 : set (semi_normed_comm_ring linarith.ineq)) : set.finite h4 := sorry --non-trivial
lemma new_lemma_122907 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122908 (h2 : group congr_arg_kind) : normalizer_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_122909 (h0 : semiring ereal) (h1 : polynomial ereal) : polynomial.monic h1 := sorry --non-trivial
lemma new_lemma_122910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122911 (h0 : topological_space (finset (generalized_boolean_algebra Type))) : preirreducible_space (finset (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_122912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_122913 (h1 : monoid (with_bot linarith.ineq)) : monoid.fg (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_122914 (h0 : monoid unsigned) : monoid.fg unsigned := sorry --non-trivial
lemma new_lemma_122915 (h0 : topological_space (ordered_ring empty)) : normal_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_122916 (h0 : functor.add_const (filter (ordered_comm_monoid linarith.comp)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122917 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) unsigned) : @is_atomistic.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_122918 (h0 : complete_lattice (with_bot (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_122919 (h0 : group (add_cancel_monoid (semiring (semiring (semiring empty))))) : group.fg (add_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_122920 (h1 : set (string.iterator_imp -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_122921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122922 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_122923 (h0 : ring (metric_space num)) : is_principal_ideal_ring (metric_space num) := sorry --non-trivial
lemma new_lemma_122924 (h0 : not (topological_space (with_bot unsigned) -> false)) : @t1_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_122925 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_122926 (h0 : functor.add_const (list (normed_linear_ordered_group num)) (semiring congr_arg_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122927 (h1 : filter (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_122928 (h0 : ring (div_inv_monoid linarith.ineq)) : rank_condition (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_122929 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : irreducible_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_122930 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : totally_disconnected_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_122931 (h0 : complete_lattice (with_bot (has_emptyc congr_arg_kind))) : is_atomistic (with_bot (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_122932 (h0 : functor.comp topological_space add_cancel_monoid name) : @preirreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_122933 (h0 : complete_lattice (uniform_space string.iterator_imp)) : is_compactly_generated (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_122934 (h0 : topological_space (with_one (random_gen (has_inv linarith.comp_source)))) : totally_separated_space (with_one (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_122935 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_122936 (h0 : list (non_assoc_semiring (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122937 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semiring num)) congr_arg_kind) : @unique_factorization_monoid.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_122938 (h0 : add_monoid (add_comm_monoid pos)) : add_monoid.fg (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_122939 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_122940 (h0 : list (finset (add_cancel_monoid pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122941 (h0 : complete_lattice (has_neg Type)) : complete_lattice.is_Sup_finite_compact (has_neg Type) := sorry --non-trivial
lemma new_lemma_122942 (h0 : topological_space (measurable_space.dynkin_system empty)) : t0_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_122943 (h0 : functor.comp topological_space add_cancel_monoid name) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_122944 (h0 : finset (non_assoc_semiring (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122945 (h0 : ring (simple_graph (finset (finset linarith.comp)))) : is_domain (simple_graph (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_122946 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) pos) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_122947 (h0 : ring (semiring (with_bot unsigned))) : is_domain (semiring (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_122948 (h0 : has_mem.mem unsigned has_zero.zero) : @is_compactly_generated.{0} unsigned (@multiset.pi.empty.{1 0} Type complete_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_122949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_122950 (h0 : finset (linear_order (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_122951 (h0 : not (add_group (linear_ordered_comm_ring empty) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_122952 (h0 : ring (measurable_space.dynkin_system congr_arg_kind)) : rank_condition (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_122953 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_122954 (h3 : field char) (h4 : polynomial char) (h5 : topological_space (tree (polynomial.splitting_field h4))) : t0_space (tree (polynomial.splitting_field h4)) := sorry --non-trivial
lemma new_lemma_122955 (h0 : ring (normed_lattice_add_comm_group (has_Inf Type))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_122956 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_122957 (h0 : functor.add_const (group (finset Type)) Type) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_122958 (h0 : add_monoid (linear_ordered_semiring empty)) : add_monoid.fg (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_122959 (h1 : ring (is_R_or_C reducibility_hints)) : strong_rank_condition (is_R_or_C reducibility_hints) := sorry --non-trivial
lemma new_lemma_122960 (h0 : ring (has_ssubset (metric_space (comm_ring (metric_space to_additive.value_type))))) : rank_condition (has_ssubset (metric_space (comm_ring (metric_space to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_122961 (h0 : ring (has_union (has_one (has_one (has_one (has_one linarith.comp)))))) : rank_condition (has_union (has_one (has_one (has_one (has_one linarith.comp))))) := sorry --non-trivial
lemma new_lemma_122962 (h1 : ring (distrib_lattice linarith.ineq)) : rank_condition (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_122963 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm (random_gen linarith.comp_source)))) : path_connected_space (add_cancel_comm_monoid (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_122964 (h0 : list (add_cancel_monoid (comm_group Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_122965 (h0 : list (boolean_algebra (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_122966 (h0 : set (set congr_arg_kind)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_122967 (h0 : functor.add_const (list (boolean_algebra.core pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122968 (h0 : topological_space (finset (has_add pos))) : locally_compact_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_122969 (h0 : has_lt (nondiscrete_normed_field (normed_field (normed_field linarith.ineq)))) : no_max_order (nondiscrete_normed_field (normed_field (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_122970 (h0 : preorder (add_comm_semigroup (mul_one_class (nondiscrete_normed_field ereal)))) (h1 : set (add_comm_semigroup (mul_one_class (nondiscrete_normed_field ereal)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_122971 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} name (@function.extfun_app.{2 1} Type semiring.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_122972 (h0 : monoid (generalized_boolean_algebra (has_bot name))) : monoid.fg (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_122973 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_122974 (h0 : group (has_dist unsigned)) : is_cyclic (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_122975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_122976 (h0 : topological_space (dlist (comm_ring fun_info))) : irreducible_space (dlist (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_122977 (h0 : complete_lattice (add_right_cancel_monoid empty)) : is_atomistic (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_122978 (h0 : topological_space (has_zero (has_add unsigned))) : totally_separated_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_122979 (h0 : topological_space (has_to_string (ring linarith.comp))) : t0_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_122980 (h0 : add_group (linear_ordered_add_comm_group (random_gen string_imp))) : is_add_cyclic (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_122981 (h0 : ring (with_bot (semiring (semiring unsigned)))) : rank_condition (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_122982 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) name) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_122983 (h0 : functor.add_const (filter (comm_group ennreal)) (option pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_122984 (h0 : group (has_nndist (has_add (add_cancel_monoid pos)))) : normalizer_condition (has_nndist (has_add (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_122985 (h0 : function.extfun Type (functor.add_const (ring (add_cancel_comm_monoid num)))) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_122986 (h0 : functor.comp topological_space normed_comm_ring name) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_122987 (h0 : functor.comp topological_space has_nndist pos) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_122988 (h0 : functor.add_const (topological_space (has_pos_part pos)) (ring name)) : @regular_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_122989 (h1 : add_group (has_emptyc to_additive.value_type)) : is_add_cyclic (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_122990 (h2 : topological_space (complete_semilattice_Sup num)) : totally_disconnected_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_122991 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122992 (h0 : function.extfun Type (functor.add_const (topological_space (ring Type)))) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (ring.{1} Type))) h0 pos))  := sorry --non-trivial
lemma new_lemma_122993 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_122994 (h0 : functor.comp list complete_distrib_lattice environment.implicit_infer_kind) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_122995 (h0 : topological_space (complete_distrib_lattice (comm_group pos))) : totally_separated_space (complete_distrib_lattice (comm_group pos)) := sorry --non-trivial
lemma new_lemma_122996 (h0 : nat) (h1 : fin (nat.succ h0) -> Prop) (h2 : fin h0) : matrix.vec_tail h1 (id h2) := sorry --non-trivial
lemma new_lemma_122997 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_122998 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_122999 (h0 : topological_space (has_to_string (has_add (has_to_string name)))) : normal_space (has_to_string (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_123000 (h0 : ordered_comm_monoid (finset (option pos))) : has_exists_mul_of_le (finset (option pos)) := sorry --non-trivial
lemma new_lemma_123001 (h0 : cancel_comm_monoid_with_zero (plift congr_arg_kind)) : unique_factorization_monoid (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123002 (h0 : group (has_pos_part (finset (has_add (has_add pos))))) : normalizer_condition (has_pos_part (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_123003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_123004 (h0 : uniform_space (with_one (has_norm (has_norm (semiring fun_info))))) : separated_space (with_one (has_norm (has_norm (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_123005 (h1 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h1) add_group.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_123007 (h0 : functor.add_const (functor.add_const Prop linarith.comp) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123008 (h0 : complete_lattice (normed_lattice_add_comm_group (finset linarith.comp))) : is_compactly_generated (normed_lattice_add_comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_123009 (h0 : topological_space (has_nndist (option pos))) : normal_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_123010 (h0 : filter (ring (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_123011 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_123012 (h0 : ordered_add_comm_monoid (has_Inf (finset (has_nndist (has_add linarith.comp))))) : archimedean (has_Inf (finset (has_nndist (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123013 (h0 : not (group (has_one congr_arg_kind) -> false)) : @group.fg.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123014 (h0 : functor.add_const Prop (simple_graph congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_123015 (h0 : ring (sub_neg_monoid (has_Inf (has_Inf (has_Inf real))))) : strong_rank_condition (sub_neg_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_123016 (h0 : complete_lattice (has_nndist unsigned)) : is_atomistic (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_123017 (h0 : complete_lattice (canonically_ordered_comm_semiring ennreal)) : is_atomistic (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_123018 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (boolean_algebra.core pos))) : unique_factorization_monoid (cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_123019 (h0 : function.extfun Type (functor.add_const (ring (canonically_ordered_add_monoid empty)))) : @is_domain.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (canonically_ordered_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_123020 (h0 : ring (has_nndist name)) : is_principal_ideal_ring (has_nndist name) := sorry --non-trivial
lemma new_lemma_123021 (h0 : topological_space (pseudo_metric_space (has_add (finset name)))) : normal_space (pseudo_metric_space (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_123022 (h0 : functor.add_const (complete_lattice (semigroup Type)) (finset linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_123023 (h0 : topological_space (has_zero (finset linarith.comp))) : sequential_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_123024 (h0 : topological_space (random_gen (has_norm empty))) : normal_space (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_123025 (h0 : topological_space (cancel_monoid (ring (option (option (option pos)))))) : locally_compact_space (cancel_monoid (ring (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_123026 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123027 (h0 : not (monoid (normed_group num) -> false)) : @monoid.fg.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123028 (h0 : group (semigroup Type)) : group.fg (semigroup Type) := sorry --non-trivial
lemma new_lemma_123029 (h0 : ring (has_bot (has_Inf pos))) : is_principal_ideal_ring (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_123030 (h1 : topological_space (add_monoid (fintype to_additive.value_type))) : totally_disconnected_space (add_monoid (fintype to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123031 (h0 : functor.add_const (list (boolean_algebra name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123032 (h0 : set (semi_normed_comm_ring (mul_one_class (simple_graph (mul_one_class fun_info))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_123033 (h0 : add_monoid (mul_zero_class (mul_zero_class name))) : add_monoid.fg (mul_zero_class (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_123034 (h0 : topological_space (linear_order empty)) : locally_compact_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_123035 (h0 : uniform_space (has_nndist (has_add (has_neg_part pos)))) : complete_space (has_nndist (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_123036 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) real.angle)  := sorry --non-trivial
lemma new_lemma_123037 (h0 : monoid (add_group linarith.comp)) : monoid.fg (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_123038 (h0 : topological_space (comm_monoid_with_zero (option (option (option (option (option unsigned))))))) : normal_space (comm_monoid_with_zero (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_123039 (h0 : topological_space (linear_ordered_field (ring ordering))) : totally_disconnected_space (linear_ordered_field (ring ordering)) := sorry --non-trivial
lemma new_lemma_123040 (h0 : topological_space char) (h1 : set char) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_123041 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option ennreal)))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_123042 (h0 : topological_space (has_neg_part (has_add Type))) : normal_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_123043 (h0 : uniform_space (ordered_comm_ring (ring (has_add linarith.comp)))) : separated_space (ordered_comm_ring (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_123044 (h0 : functor.add_const (add_group (comm_group pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123045 (h0 : functor.add_const (topological_space (has_neg ennreal)) num) : @t1_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_123046 (h0 : topological_space (boolean_algebra (comm_semigroup pos))) : regular_space (boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_123047 (h0 : not (monoid (non_assoc_semiring num) -> false)) : @monoid.fg.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123048 (h0 : functor.add_const (group (has_dist unsigned)) empty) : @group.fg.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_123049 (h0 : functor.add_const (complete_lattice (boolean_algebra.core linarith.comp)) name) : @is_atomistic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_123050 (h0 : functor.add_const (add_monoid (has_neg_part environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123051 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_123052 (h0 : functor.add_const (group nnreal) num) : @group.fg.{0} nnreal (@functor.add_const.run.{0 0} (group.{0} nnreal) num h0)  := sorry --non-trivial
lemma new_lemma_123053 (h0 : finset (canonically_linear_ordered_monoid (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123054 (h0 : functor.add_const (ring (mul_zero_class num)) empty) : @is_domain.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_123055 (h0 : complete_lattice (complete_distrib_lattice name)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_123056 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @preirreducible_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123057 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_neg name))) : unique_factorization_monoid (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_123058 (h0 : list (linear_ordered_cancel_comm_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123059 (h0 : complete_lattice (semi_normed_comm_ring (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_123060 (h0 : group (linear_order empty)) : normalizer_condition (linear_order empty) := sorry --non-trivial
lemma new_lemma_123061 (h1 : has_lt (mul_one_class (add_comm_semigroup char))) : no_max_order (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_123062 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : totally_separated_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123063 (h1 : not (has_mem.mem (has_emptyc num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_123064 (h0 : topological_space (boolean_algebra (has_neg (has_pos_part Type)))) : totally_separated_space (boolean_algebra (has_neg (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_123065 (h0 : functor.add_const (complete_lattice (canonically_ordered_add_monoid num)) unsigned) : @is_compactly_generated.{0} (canonically_ordered_add_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_add_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123066 (h0 : topological_space (add_group num)) : discrete_topology (add_group num) := sorry --non-trivial
lemma new_lemma_123067 (h0 : list (linear_ordered_add_comm_group (has_norm (random_gen (has_ssubset linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123068 (h0 : topological_space (simple_graph empty)) : path_connected_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_123069 (h0 : topological_space (has_dist ennreal)) : preconnected_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_123070 (h0 : ring (group_with_zero (option ennreal))) : is_principal_ideal_ring (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_123071 (h0 : group (encodable (random_gen (has_nnnorm char)))) : group.fg (encodable (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_123072 (h0 : group (has_Inf (finset linarith.comp))) : is_simple_group (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_123073 (h0 : ring (cancel_monoid (boolean_algebra.core name))) : strong_rank_condition (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_123074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_123075 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : locally_compact_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_123076 (h0 : complete_lattice (has_norm (random_gen to_additive.value_type))) : is_atomistic (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123077 (h0 : ring (ordered_cancel_add_comm_monoid (has_top (has_top to_additive.value_type)))) : strong_rank_condition (ordered_cancel_add_comm_monoid (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123078 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_lattice_add_comm_group name)))) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name))) h0 name))  := sorry --non-trivial
lemma new_lemma_123079 (h0 : topological_space (ring (has_neg Type))) : sequential_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_123080 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_123081 (h0 : topological_space (has_pos_part (finset Type))) : totally_separated_space (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_123082 (h1 : set (ereal -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_123083 (h0 : topological_space (semigroup (ring (ring (has_add linarith.comp))))) : sequential_space (semigroup (ring (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123084 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_123085 (h0 : add_monoid (semigroup (has_nndist environment.implicit_infer_kind))) : add_monoid.fg (semigroup (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_123086 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123087 (h1 : set (set to_additive.value_type)) (h2 : set to_additive.value_type) : topological_space.generate_open h1 h2 := sorry --non-trivial
lemma new_lemma_123088 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_123089 (h0 : ring (with_one (has_inv fun_info))) : strong_rank_condition (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_123090 (h0 : function.extfun Type group) : @is_cyclic.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_123091 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123092 (h0 : complete_lattice (has_to_string (option empty))) : complete_lattice.is_Sup_finite_compact (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_123093 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} unsigned (@function.extfun_app.{2 1} Type semiring.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_123094 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : path_connected_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_123095 (h0 : functor.add_const (topological_space (has_zero pos)) (finset Type)) : @path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_123096 (h0 : add_group (complete_linear_order (semiring (semiring unsigned)))) : is_add_cyclic (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_123097 (h0 : topological_space (monoid_with_zero unsigned)) : normal_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_123098 (h0 : ring (boolean_algebra.core pos)) : is_domain (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_123099 (h0 : filter (add_comm_monoid (add_cancel_monoid pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123100 (h0 : functor.add_const (functor.comp topological_space finset name) pos) : @t0_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} finset.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_123101 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_123102 (h0 : monoid (finset (finset (has_add name)))) : monoid.fg (finset (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_123103 (h0 : ring (finset (has_neg_part pos))) : strong_rank_condition (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_123104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_123105 (h2 : topological_space (has_lt string.iterator_imp)) (h3 : preorder (has_lt string.iterator_imp)) : order_closed_topology (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_123106 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123107 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_123108 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space.dynkin_system num)) := sorry --non-trivial
lemma new_lemma_123109 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123110 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123111 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_123112 (h0 : add_monoid (semigroup (finset Type))) : add_monoid.fg (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_123113 (h0 : topological_space (has_union (semiring (has_top (add_group unsigned))))) : totally_disconnected_space (has_union (semiring (has_top (add_group unsigned)))) := sorry --non-trivial
lemma new_lemma_123114 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_semigroup pos)) name) : @archimedean.{0} (left_cancel_semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_123115 (h0 : topological_space (semigroup (normed_comm_ring name))) : t1_space (semigroup (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_123116 (h0 : topological_space (ring (has_add linarith.comp))) : topological_space.separable_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123117 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_123118 (h0 : topological_space (has_Inf real)) : totally_disconnected_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_123119 (h0 : topological_space (has_dist (option (option empty)))) : totally_separated_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_123120 (h0 : topological_space (boolean_algebra.core unsigned)) : totally_disconnected_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_123121 (h0 : topological_space (measurable_space (semiring congr_arg_kind))) : totally_separated_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123122 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (non_assoc_semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_123123 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123124 (h0 : topological_space (comm_monoid unsigned)) : preirreducible_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_123125 (h0 : ordered_comm_monoid (has_Inf linarith.comp)) : has_exists_mul_of_le (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_123126 (h0 : complete_lattice (mul_one_class to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123127 (h0 : topological_space (measurable_space.dynkin_system (non_assoc_semiring congr_arg_kind))) : locally_compact_space (measurable_space.dynkin_system (non_assoc_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123128 (h0 : group (has_emptyc (has_top (has_top (random_gen linarith.ineq))))) : is_cyclic (has_emptyc (has_top (has_top (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_123129 (h0 : monoid (has_neg unsigned)) : monoid.fg (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_123130 (h0 : ring (normed_comm_ring (has_nndist Type))) : strong_rank_condition (normed_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_123131 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_123132 (h0 : topological_space (has_top to_additive.value_type)) : totally_separated_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123133 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123134 (h0 : functor.comp ordered_add_comm_monoid has_add (option (option unsigned))) : @archimedean.{0} (has_add.{0} (option.{0} (option.{0} unsigned))) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_add.{0} (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_123135 (h0 : ring (add_right_cancel_monoid (semiring empty))) : is_principal_ideal_ring (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_123136 (h0 : monoid (ordered_comm_monoid (has_Inf (boolean_algebra.core (has_Inf (has_Inf pos)))))) : monoid.fg (ordered_comm_monoid (has_Inf (boolean_algebra.core (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_123137 (h0 : topological_space (complete_distrib_lattice (option (option ennreal)))) : totally_separated_space (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_123138 (h0 : complete_lattice (random_gen (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_123139 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_123140 (h0 : group stieltjes_function) : is_cyclic stieltjes_function := sorry --non-trivial
lemma new_lemma_123141 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_add pos)) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_123142 (h0 : add_group (mul_one_class char)) : is_add_cyclic (mul_one_class char) := sorry --non-trivial
lemma new_lemma_123143 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_123144 (h0 : topological_space (has_add (has_add (has_Inf linarith.comp)))) : preirreducible_space (has_add (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_123145 (h0 : uniform_space (canonically_linear_ordered_monoid (mul_zero_class name))) : complete_space (canonically_linear_ordered_monoid (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_123146 (h0 : functor.add_const (function.extfun nat fin) (has_Inf Type)) : @totally_disconnected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) (has_Inf.{1} Type) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_123147 (h1 : topological_space (normed_field linarith.comp_source)) : path_connected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_123148 (h0 : ring (has_neg (finset (ring pos)))) : strong_rank_condition (has_neg (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_123149 (h0 : topological_space (bin_tree (semiring empty))) : normal_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_123150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_123151 (h0 : functor.add_const (topological_space ennreal) (option unsigned)) : t1_space ennreal := sorry --non-trivial
lemma new_lemma_123152 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @preirreducible_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_123153 (h0 : ring (linear_ordered_field environment.implicit_infer_kind)) : rank_condition (linear_ordered_field environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_123154 (h0 : complete_lattice (with_bot (random_gen string_imp))) : is_compactly_generated (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123155 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) Type) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_123156 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @preirreducible_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_123157 (h0 : not (group environment.implicit_infer_kind -> false)) : @is_cyclic.{0} environment.implicit_infer_kind (@classical.by_contradiction'.{1} (group.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_123158 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_bot linarith.comp)))) : group.fg (normed_lattice_add_comm_group (has_Inf (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_123159 (h0 : filter (has_neg_part (comm_group environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123160 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_123161 (h2 : topological_space (add_comm_semigroup linarith.ineq)) : t0_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_123162 (h0 : filter (has_one (has_top (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123163 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123164 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123165 (h0 : ring (normed_group (random_gen fun_info))) : is_domain (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_123166 (h0 : add_group (distrib (random_gen to_additive.value_type))) : is_add_cyclic (distrib (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123167 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123168 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123169 (h0 : complete_lattice (add_right_cancel_monoid unsigned)) : is_atomistic (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_123170 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : path_connected_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_123171 (h0 : functor.add_const (ring (has_Inf pos)) (ring (has_add linarith.comp))) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (ring.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_123172 (h0 : topological_space (is_R_or_C num)) : discrete_topology (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_123173 (h0 : set (set (with_bot to_additive.value_type))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_123174 (h0 : ring (add_cancel_monoid (has_neg pos))) : is_domain (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_123175 (h0 : multiset (has_div linarith.ineq)) (h1 : has_div linarith.ineq) (h2 : multiset (has_div linarith.ineq) -> Prop) (h3 : Exists (fun (x : multiset (has_div linarith.ineq)), h2 x)) : multiset.disjoint h0 (multiset.cons h1 (classical.some h3)) := sorry --non-trivial
lemma new_lemma_123176 (h0 : ordered_add_comm_monoid (has_zero (option (option ennreal)))) : archimedean (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_123177 (h0 : topological_space (semi_normed_comm_ring (mul_one_class linarith.comp_source))) (h1 : preorder (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : order_topology (semi_normed_comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123178 (h0 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h2 : measure_theory.measure (nondiscrete_normed_field linarith.ineq)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_123179 (h0 : not (complete_lattice (with_one (has_norm linarith.comp_source)) -> false)) : @is_atomistic.{0} (with_one.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_123180 (h0 : topological_space (linear_ordered_add_comm_group (random_gen fun_info))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_123181 (h0 : ring (has_neg (has_neg (has_neg Type)))) : is_principal_ideal_ring (has_neg (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_123182 (h0 : group (comm_semigroup (comm_semigroup (comm_semigroup (sub_neg_monoid real))))) : group.fg (comm_semigroup (comm_semigroup (comm_semigroup (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_123183 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @loc_path_connected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123184 (h0 : functor.add_const (finset (ring num)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123185 (h0 : topological_space (filter unsigned)) : preirreducible_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_123186 (h1 : group (id (has_top string_imp))) : normalizer_condition (id (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_123187 (h0 : topological_space (preorder unsigned)) : preirreducible_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_123188 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) Type) : @is_cyclic.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_123189 (h0 : uniform_space (linear_ordered_add_comm_monoid_with_top linarith.ineq)) : complete_space (linear_ordered_add_comm_monoid_with_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_123190 (h0 : filter (has_nndist (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_123191 (h0 : topological_space (semigroup (has_pos_part pos))) : normal_space (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_123192 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_123193 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : discrete_topology (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_123194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_123195 (h0 : is_empty (topological_space (plift num) -> false)) : @totally_disconnected_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) (@is_empty.elim'.{0 0} (topological_space.{1} (plift.{1} num) → false) false h0))  := sorry --non-trivial
lemma new_lemma_123196 (h0 : complete_lattice (has_bot empty)) : is_atomistic (has_bot empty) := sorry --non-trivial
lemma new_lemma_123197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_123198 (h0 : not (add_monoid (measurable_space to_additive.value_type) -> false)) : @add_monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_123199 (h0 : add_monoid (has_nndist (has_to_string (comm_group (comm_group pos))))) : add_monoid.fg (has_nndist (has_to_string (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_123200 (h0 : add_monoid (add_cancel_comm_monoid unsigned)) : add_monoid.fg (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_123201 (h0 : topological_space (id (option empty))) : irreducible_space (id (option empty)) := sorry --non-trivial
lemma new_lemma_123202 (h0 : topological_space (id (semiring linarith.ineq))) : totally_separated_space (id (semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_123203 (h0 : ring (topological_space (has_ssubset (random_gen linarith.ineq)))) : rank_condition (topological_space (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_123204 (h0 : set (set linarith.ineq)) (h1 : set linarith.ineq) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_123205 (h0 : ring (add_cancel_comm_monoid (option empty))) : strong_rank_condition (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_123206 (h0 : group (with_one (random_gen (semiring (semiring congr_arg_kind))))) : normalizer_condition (with_one (random_gen (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_123207 (h0 : ring (ordered_comm_monoid (has_pos_part (has_add linarith.comp)))) : is_principal_ideal_ring (ordered_comm_monoid (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_123208 (h0 : functor.add_const (ordered_add_comm_monoid pos) ennreal) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_123209 (h0 : topological_space (boolean_algebra.core (finset name))) : totally_separated_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_123210 (h0 : complete_lattice (canonically_ordered_comm_semiring empty)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_123211 (h0 : functor.add_const (ring (add_comm_monoid pos)) Type) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_123212 (h0 : ring (linear_ordered_semiring (has_top (has_top to_additive.value_type)))) : rank_condition (linear_ordered_semiring (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123213 (h0 : group (has_top (has_nnnorm linarith.comp_source))) : is_cyclic (has_top (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123214 (h0 : add_monoid (plift (semiring num))) : add_monoid.fg (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_123215 (h0 : prod (has_neg pos) (has_neg pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_123216 (h0 : complete_lattice (has_one num)) : complete_lattice.is_Sup_finite_compact (has_one num) := sorry --non-trivial
lemma new_lemma_123217 (h0 : functor.add_const (complete_lattice (add_comm_monoid environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123218 (h0 : group (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : group.fg (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_123219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123220 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123222 (h0 : fin has_zero.zero) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_123223 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) (h1 : preorder (semi_normed_comm_ring string.iterator_imp)) : order_closed_topology (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_123224 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset (finset (has_nndist (finset (finset ennreal))))))) : unique_factorization_monoid (has_nndist (finset (finset (has_nndist (finset (finset ennreal)))))) := sorry --non-trivial
lemma new_lemma_123225 (h0 : group (has_neg (has_add pos))) : is_simple_group (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_123226 (h0 : complete_lattice (comm_group_with_zero (semiring congr_arg_kind))) : is_compactly_generated (comm_group_with_zero (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123227 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : t0_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_123228 (h0 : complete_lattice (semigroup linarith.comp)) : is_atomistic (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_123229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123230 (h0 : functor.add_const (add_monoid (has_neg_part name)) name) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_123231 (h2 : topological_space enat) : t0_space enat := sorry --non-trivial
lemma new_lemma_123232 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_123233 (h0 : add_group (has_one (has_top linarith.comp))) : is_add_cyclic (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_123234 (h0 : set (has_compl (has_compl environment.projection_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_123235 (h0 : functor.add_const (ordered_add_comm_monoid (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123236 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_123237 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123238 (h0 : topological_space (has_inner unsigned unsigned)) : locally_compact_space (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_123239 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) Type) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_123240 (h0 : complete_lattice (monoid pos)) : complete_lattice.is_Sup_finite_compact (monoid pos) := sorry --non-trivial
lemma new_lemma_123241 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_123242 (h0 : finset (free_add_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123243 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123244 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_123245 (h0 : topological_space (monoid (option (option unsigned)))) : normal_space (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_123246 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123247 (h0 : topological_space (mul_zero_class (semiring (with_zero congr_arg_kind)))) : normal_space (mul_zero_class (semiring (with_zero congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_123248 (h0 : set (has_top string_imp)) (h1 : has_top string_imp -> has_top string_imp -> Prop) : set.well_founded_on h0 h1 := sorry --non-trivial
lemma new_lemma_123249 (h0 : ring (measurable_space.dynkin_system (semiring num))) : rank_condition (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_123250 (h0 h1 : set real) (h2 : list complex) : set.re_prod_im h0 h1 (list.head h2) := sorry --non-trivial
lemma new_lemma_123251 (h0 : not (ring (normed_group num) -> false)) : @is_domain.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_123254 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_123255 (h0 : complete_lattice (uniform_space (metric_space reducibility_hints))) : complete_lattice.is_Sup_finite_compact (uniform_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_123256 (h0 : function.extfun Type (functor.add_const (topological_space (complete_distrib_lattice pos)))) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_123257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123258 (h0 : complete_lattice (canonically_ordered_comm_semiring (option (option unsigned)))) : is_atomistic (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_123259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123260 (h0 : not (uniform_space (has_norm num) -> false)) : @complete_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123261 (h0 : functor.add_const (group auto.case_option) (option unsigned)) : @normalizer_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_123262 (h0 : ring (free_add_monoid congr_arg_kind)) : rank_condition (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123263 (h0 : complete_lattice (topological_space (group_with_zero string_imp))) : is_compactly_generated (topological_space (group_with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_123264 (h0 : ring (normed_linear_ordered_group (option (option (option unsigned))))) : rank_condition (normed_linear_ordered_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_123265 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @totally_separated_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_123266 (h0 : topological_space (add_comm_monoid (has_add Type))) : locally_compact_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_123267 (h0 : group (comm_ring (has_inv (random_gen fun_info)))) : is_cyclic (comm_ring (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_123268 (h0 : topological_space (add_comm_monoid linarith.comp)) : t1_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_123269 (h0 : finset (finset name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123270 (h1 : filter (dlist (random_gen (random_gen (random_gen (random_gen string_imp)))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_123271 (h0 : not (list (random_gen fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_123272 (h0 : topological_space (add_comm_monoid (has_pos_part Type))) : path_connected_space (add_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_123273 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123274 (h0 : monoid (has_to_string (ring (ring (complete_semilattice_Sup (finset linarith.comp)))))) : monoid.fg (has_to_string (ring (ring (complete_semilattice_Sup (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_123275 (h0 : group (has_nnnorm char)) : group.fg (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_123276 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_123277 (h0 : not (ring (has_union empty) -> false)) : @rank_condition.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_123278 (h0 : functor.add_const (group (has_nndist unsigned)) unsigned) : @normalizer_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123279 (h0 : not (ulower (fin has_zero.zero) -> false)) : matrix.vec_empty (id (ulower.up (classical.by_contradiction' h0))) := sorry --non-trivial
lemma new_lemma_123280 (h0 : list (semigroup (finset (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123281 (h0 : add_group (add_monoid linarith.ineq)) : is_add_cyclic (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_123282 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_123283 (h0 : filter (has_zero (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123284 (h0 : set (has_div (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_123285 (h0 : topological_space (has_nnnorm reducibility_hints)) (h1 : add_group (has_nnnorm reducibility_hints)) : topological_add_group (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_123286 (h0 : group (monoid (option (option (option (option ennreal)))))) : normalizer_condition (monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_123287 (h0 : topological_space (has_Inf (has_neg pos))) : totally_separated_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_123288 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_123289 (h0 : ordered_comm_ring real -> ordered_comm_ring real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_123290 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @preirreducible_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_123291 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part pos)) unsigned) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123292 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid Type))) : preconnected_space (sub_neg_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_123293 (h0 : functor.add_const (ring (boolean_algebra pos)) (has_neg Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_123294 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) name) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_123295 (h0 : monoid (distrib_lattice to_additive.value_type) -> Prop) (h1 : Exists (fun (x : monoid (distrib_lattice to_additive.value_type)), h0 x)) : @monoid.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.some.{1} (monoid.{0} (distrib_lattice.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_123296 (h0 : not (ring (has_compl (mul_one_class string_imp)) -> false)) : @strong_rank_condition.{0} (has_compl.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_123297 (h0 : cancel_comm_monoid_with_zero (has_neg (option (option (option (option unsigned)))))) : unique_factorization_monoid (has_neg (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_123298 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid real)) : unique_factorization_monoid (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_123299 (h0 : functor.add_const (topological_space (simple_graph pos)) (boolean_algebra.core (has_Inf pos))) : @discrete_topology.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) (boolean_algebra.core.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_123300 (h0 : topological_space (semigroup (ordered_ring unsigned))) : irreducible_space (semigroup (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_123301 (h2 : ring environment.projection_info) : rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_123302 (h0 : function.extfun Type topological_space) : @t1_space.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_123303 (h0 : ring (has_ssubset (mul_one_class char))) : is_domain (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_123304 (h0 : uniform_space (has_star unsigned)) : complete_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_123305 (h0 : topological_space enat) (h2 : preorder enat) : order_topology enat := sorry --non-trivial
lemma new_lemma_123306 (h0 : group (has_bot (sub_neg_monoid pos))) : is_cyclic (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_123307 (h0 : topological_space (dlist (has_nnnorm string_imp))) : totally_disconnected_space (dlist (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_123308 (h0 : topological_space (boolean_algebra.core (option unsigned))) : t0_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_123309 (h0 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_123310 (h0 : functor.add_const (topological_space (ring empty)) num) : @locally_compact_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_123311 (h0 : functor.comp filter finset Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_123312 (h0 : fin has_zero.zero) : @separated_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_123313 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_123314 (h0 : simple_graph fun_info) (h1 : sym2 fun_info) : simple_graph.edge_set h0 h1 := sorry --non-trivial
lemma new_lemma_123315 (h0 : function.extfun Type group) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123316 (h0 : uniform_space (has_nndist (option empty))) : separated_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_123317 (h0 : list (has_edist (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123318 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) name) : @normalizer_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123319 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_123320 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123321 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123322 (h0 : topological_space (add_cancel_monoid (comm_group linarith.comp))) : loc_path_connected_space (add_cancel_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_123323 (h2 : topological_space (add_left_cancel_monoid linarith.comp_source)) : t0_space (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_123324 (h0 : functor.add_const Prop (monoid (option (option (option ennreal))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_123325 (h0 : cancel_comm_monoid_with_zero (has_neg Type)) : unique_factorization_monoid (has_neg Type) := sorry --non-trivial
lemma new_lemma_123326 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) : @discrete_topology.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123327 (h0 : topological_space (has_Inf (ring (has_neg name)))) : regular_space (has_Inf (ring (has_neg name))) := sorry --non-trivial
lemma new_lemma_123328 (h0 : topological_space (cancel_monoid (add_comm_monoid (finset environment.implicit_infer_kind)))) : preirreducible_space (cancel_monoid (add_comm_monoid (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_123329 (h0 : ring (has_dist to_additive.value_type)) : is_domain (has_dist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123330 (h0 : function.extfun Type metric_space) (h1 : set (mul_zero_class ennreal)) : @euclidean_geometry.cospherical.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type metric_space.{0} h0 (mul_zero_class.{0} ennreal)) h1  := sorry --non-trivial
lemma new_lemma_123331 (h1 : ring (non_unital_non_assoc_semiring (has_lt string_imp))) : strong_rank_condition (non_unital_non_assoc_semiring (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_123332 (h0 : topological_space (comm_group unsigned)) : preconnected_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_123333 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123334 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @strong_rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123335 : subsingleton enat := sorry --non-trivial
lemma new_lemma_123336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_123337 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_123338 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @t0_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_123339 (h0 : topological_space (has_bot (sub_neg_monoid (add_comm_monoid real)))) : preirreducible_space (has_bot (sub_neg_monoid (add_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_123340 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_123341 (h0 : ordered_semiring linarith.ineq) (h1 : set (set (floor_semiring linarith.ineq))) (h2 : set (floor_semiring linarith.ineq)) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_123342 (h0 : complete_lattice (denumerable to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123343 (h0 : topological_space (finset (has_add (boolean_algebra.core Type)))) : normal_space (finset (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_123344 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_123345 (h0 : measurable_space (linear_ordered_field empty)) (h1 : has_add (linear_ordered_field empty)) : has_measurable_add (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_123346 (h0 : topological_space (has_sub unsigned)) : normal_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_123347 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_123348 (h0 : topological_space (boolean_algebra (boolean_algebra Type))) : topological_space.separable_space (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_123349 (h0 : complete_lattice (add_comm_semigroup (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_123350 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123351 (h0 : ring (has_pos_part (has_Inf linarith.comp))) : rank_condition (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_123352 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_123353 (h0 : ereal -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) ereal h0  := sorry --non-trivial
lemma new_lemma_123354 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : preirreducible_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_123355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123356 (h0 : semiring (complete_distrib_lattice (option ennreal))) : is_noetherian_ring (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_123357 (h0 : ring (mul_one_class (mul_one_class linarith.comp_source))) : rank_condition (mul_one_class (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123358 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123360 (h0 : function.extfun nat fin) : @rank_condition.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_123361 (h0 : with_bot (topological_space (metric_space string_imp))) (h1 : ne h0 has_bot.bot) : @totally_disconnected_space.{0} (metric_space.{0} string_imp) (@with_bot.unbot.{0} (topological_space.{0} (metric_space.{0} string_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_123362 (h0 : not (group (normed_group congr_arg_kind) -> false)) : @group.fg.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123363 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_123364 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_123365 (h0 : complete_lattice (cancel_monoid (option (option empty)))) : is_compactly_generated (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_123366 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123367 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) unsigned) : @irreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123368 (h0 : semiring (has_neg (comm_group (has_neg (has_neg linarith.comp))))) : is_noetherian_ring (has_neg (comm_group (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123369 (h2 : uniform_space (topological_space (denumerable (denumerable (denumerable (denumerable char)))))) : complete_space (topological_space (denumerable (denumerable (denumerable (denumerable char))))) := sorry --non-trivial
lemma new_lemma_123370 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123371 (h2 : ring (comm_ring linarith.comp_source)) : rank_condition (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_123372 (h0 : functor.comp topological_space monoid (option pos)) : @loc_path_connected_space.{0} (monoid.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} monoid.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_123373 (h0 : uniform_space (has_neg_part (ring pos))) : complete_space (has_neg_part (ring pos)) := sorry --non-trivial
lemma new_lemma_123374 (h1 : topological_space (comm_ring char)) : totally_disconnected_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_123375 (h0 : topological_space (has_nndist name)) : normal_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_123376 (h0 : group (distrib_lattice (random_gen (random_gen to_additive.value_type)))) : group.fg (distrib_lattice (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123377 (h0 : topological_space (canonically_linear_ordered_monoid (random_gen congr_arg_kind))) : t0_space (canonically_linear_ordered_monoid (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123378 (h0 : topological_space enat) (h2 : preorder enat) : order_closed_topology enat := sorry --non-trivial
lemma new_lemma_123379 (h0 : has_nnnorm (random_gen linarith.ineq) -> has_nnnorm (random_gen linarith.ineq) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_123380 (h0 : add_group (semiring empty)) : is_add_cyclic (semiring empty) := sorry --non-trivial
lemma new_lemma_123381 (h0 : ring (has_union congr_arg_kind)) : is_principal_ideal_ring (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123382 (h0 : topological_space (has_star (semiring linarith.comp_source))) : path_connected_space (has_star (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123383 (h0 : uniform_space (comm_semigroup Type)) : separated_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_123384 (h0 : topological_space (canonically_linear_ordered_monoid real)) : totally_disconnected_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_123385 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_123386 (h0 : uniform_space (has_append (random_gen char))) : complete_space (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_123387 (h0 : topological_space (ordered_comm_monoid (ring (has_add linarith.comp)))) : t1_space (ordered_comm_monoid (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_123388 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_123389 (h0 : uniform_space (pseudo_metric_space ennreal)) : complete_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_123390 (h1 : group (has_ssubset (random_gen (random_gen (has_nnnorm (random_gen string_imp)))))) : is_cyclic (has_ssubset (random_gen (random_gen (has_nnnorm (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_123391 (h0 : topological_space (boolean_algebra.core (finset (has_add pos)))) : irreducible_space (boolean_algebra.core (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_123392 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_123393 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_123394 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_123395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123396 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) num) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_123397 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup empty)) : unique_factorization_monoid (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_123398 (h0 : group (add_semigroup (option empty))) : is_cyclic (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_123399 (h0 : topological_space (metric_space unsigned)) : irreducible_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_123400 (h0 : function.extfun (Type 1) (functor.comp topological_space comm_group)) : @t0_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_123401 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero empty)) := sorry --non-trivial
lemma new_lemma_123402 (h1 : topological_space (has_emptyc (random_gen string_imp))) : locally_compact_space (has_emptyc (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123403 (h0 : ordered_add_comm_monoid (semigroup (has_add (has_Inf Type)))) : archimedean (semigroup (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_123404 (h0 : topological_space (comm_group (has_add Type))) : preconnected_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_123405 (h0 : not (topological_space (encodable linarith.ineq) -> false)) : @locally_compact_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_123406 (h0 : functor.add_const (topological_space (ring name)) (has_neg pos)) : @topological_space.separable_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_123407 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123408 (h0 : functor.add_const (ring (comm_group unsigned)) congr_arg_kind) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123409 (h0 : filter (has_to_string (has_zero name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123410 (h0 : ring (uniform_space (mul_one_class char))) : rank_condition (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_123411 (h0 : group (ring pos)) : group.fg (ring pos) := sorry --non-trivial
lemma new_lemma_123412 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp))) : archimedean (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_123413 (h0 : uniform_space (mul_zero_class (finset ennreal))) : separated_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_123414 (h0 : uniform_space (random_gen (semiring empty))) : separated_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_123415 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_123416 (h0 : has_mem.mem linarith.ineq has_emptyc.emptyc) : @path_connected_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_123417 (h0 : topological_space (semigroup (semiring (option (semiring (semiring empty)))))) : preirreducible_space (semigroup (semiring (option (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_123418 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : normal_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123420 (h0 : topological_space (uniform_space congr_arg_kind)) : locally_compact_space (uniform_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123421 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_123422 (h1 : uniform_space (mul_one_class reducibility_hints)) : complete_space (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_123423 (h1 : uniform_space (complete_semilattice_Sup (with_bot string_imp))) : complete_space (complete_semilattice_Sup (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_123424 (h0 : functor.add_const (list (complete_linear_order unsigned)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123425 (h0 : list (normed_comm_ring Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123426 (h0 : functor.add_const (finset (semigroup empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123427 (h0 : ordered_add_comm_monoid (sub_neg_monoid (ordered_comm_monoid (has_add Type)))) : archimedean (sub_neg_monoid (ordered_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_123428 (h0 : complete_lattice (with_one (has_top congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123429 (h0 : topological_space (has_nndist (add_comm_monoid Type))) : normal_space (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_123430 (h0 : topological_space (cancel_monoid (comm_group pos))) : t0_space (cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_123431 (h0 : uniform_space (ring linarith.comp)) : complete_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_123432 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_123433 (h0 : topological_space (has_zero (boolean_algebra pos))) : preirreducible_space (has_zero (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_123434 (h0 : functor.add_const (filter (has_nndist Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123435 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) (normed_comm_ring name)) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_123436 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_123437 (h0 : list (ordered_cancel_add_comm_monoid (add_comm_monoid ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123438 (h3 : complete_lattice (semi_normed_comm_ring linarith.ineq)) : is_compactly_generated (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_123439 (h0 : functor.add_const (uniform_space (ordered_comm_group empty)) empty) : @complete_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_123440 (h0 : function.extfun Type topological_space) : @regular_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_123441 (h0 : add_group (has_pos_part linarith.comp)) : is_add_cyclic (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_123442 (h0 : topological_space (has_top (has_top char))) : t0_space (has_top (has_top char)) := sorry --non-trivial
lemma new_lemma_123443 (h0 : topological_space (ordered_ring (option unsigned))) : t0_space (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_123444 (h0 : functor.add_const (functor.add_const (ring Type) linarith.comp) (has_neg_part linarith.comp)) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) linarith.comp) (has_neg_part.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_123445 (h0 : not (topological_space (has_emptyc to_additive.value_type) -> false)) : @discrete_topology.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_123446 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123447 (h0 : function.extfun Type (functor.add_const (topological_space (has_bot empty)))) : @discrete_topology.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_123448 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_123449 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (comm_semigroup (comm_semigroup pos))))) : preirreducible_space (ordered_comm_ring (sub_neg_monoid (comm_semigroup (comm_semigroup pos)))) := sorry --non-trivial
lemma new_lemma_123450 (h0 : group (has_to_string (option pos))) : is_cyclic (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_123451 (h0 : topological_space (normed_field (random_gen string_imp))) : t0_space (normed_field (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123452 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : totally_disconnected_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_123453 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} name))  := sorry --non-trivial
lemma new_lemma_123454 (h0 : not (ring (option num) -> false)) : @strong_rank_condition.{0} (option.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123455 (h0 : add_group (id fun_info)) : is_add_cyclic (id fun_info) := sorry --non-trivial
lemma new_lemma_123456 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : preorder (add_comm_semigroup linarith.ineq)) : order_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_123457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123458 (h0 : not (topological_space (denumerable (random_gen reducibility_hints)) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_123459 (h0 : topological_space (simple_graph pos)) : preirreducible_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_123460 (h0 : ring (cancel_monoid congr_arg_kind)) : is_domain (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123461 (h0 : topological_space (semigroup pos)) : regular_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_123462 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) pos) : @is_atomistic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_123463 (h0 : functor.add_const (finset (pseudo_metric_space pos)) (has_neg_part unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123464 (h0 : topological_space (has_nndist (option (option name)))) : locally_compact_space (has_nndist (option (option name))) := sorry --non-trivial
lemma new_lemma_123465 (h0 : semiring (add_semigroup name)) : is_noetherian_ring (add_semigroup name) := sorry --non-trivial
lemma new_lemma_123466 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @totally_separated_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_123467 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123468 (h0 : complete_lattice (with_bot (has_top fun_info))) : is_atomistic (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_123469 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_123470 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_123471 (h0 : group (normed_group (has_inv (has_inv to_additive.value_type)))) : normalizer_condition (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123472 (h0 : functor.add_const (group (cancel_monoid name)) Type) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_123473 (h0 : ring (simple_graph num)) : strong_rank_condition (simple_graph num) := sorry --non-trivial
lemma new_lemma_123474 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_123475 (h0 : ordered_comm_monoid (has_add (has_add Type))) : has_exists_mul_of_le (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_123476 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123477 (h2 : ring (linear_ordered_add_comm_group to_additive.value_type)) : strong_rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123478 (h0 : uniform_space (has_one (has_top (has_top (has_top unsigned))))) : separated_space (has_one (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_123479 (h0 : filter (canonically_ordered_comm_semiring (option (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123480 (h0 : topological_space (has_Inf (has_neg (has_neg name)))) : discrete_topology (has_Inf (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_123481 (h0 : ring (has_ssubset (has_nnnorm (comm_ring char)))) : is_domain (has_ssubset (has_nnnorm (comm_ring char))) := sorry --non-trivial
lemma new_lemma_123482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_123483 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123484 (h0 : functor.add_const (function.extfun Type topological_space) (has_add name)) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} name) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123485 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_123486 (h0 : add_group (has_one unsigned)) : is_add_cyclic (has_one unsigned) := sorry --non-trivial
lemma new_lemma_123487 (h0 : function.extfun Type (functor.add_const (complete_lattice (measurable_space.dynkin_system empty)))) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_123488 (h0 : functor.comp ring has_zero ennreal) : @rank_condition.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_123489 (h0 : filter (has_norm fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123490 (h0 : complete_lattice (has_edist congr_arg_kind)) : is_compactly_generated (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123492 (h0 : Prop -> char) (h1 : set (coe_sort (set.range h0))) (h2 : set.nonempty h1) : set.range_splitting h0 (set.nonempty.some h2) := sorry --non-trivial
lemma new_lemma_123493 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_neg name))) : archimedean (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_123494 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123495 (h0 : complete_lattice (linear_order congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123496 (h0 : finset (measurable_space.dynkin_system empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123497 (h0 : functor.add_const (functor.add_const (ring (linear_order num)) congr_arg_kind) num) : @is_principal_ideal_ring.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} num)) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (linear_order.{0} num)) congr_arg_kind) num h0))  := sorry --non-trivial
lemma new_lemma_123498 (h0 : ring (linear_ordered_comm_ring (semiring empty))) : strong_rank_condition (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_123499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_123500 (h0 : comm_ring char) (h1 : local_ring char) : nonempty (local_ring.residue_field char) := sorry --simp
lemma new_lemma_123501 (h0 : group (distrib_lattice (has_nnnorm (random_gen fun_info)))) : group.fg (distrib_lattice (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_123502 (h0 : ring (has_nnnorm (normed_field reducibility_hints))) : is_domain (has_nnnorm (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_123503 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_123504 (h0 : functor.add_const Prop (has_to_string ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_123505 (h0 : functor.add_const (ring (is_R_or_C num)) congr_arg_kind) : @rank_condition.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123506 (h0 : list (option (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123507 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123508 (h0 : ring (complete_distrib_lattice congr_arg_kind)) : rank_condition (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123509 (h0 : ring (normed_comm_ring (normed_comm_ring (boolean_algebra Type)))) : rank_condition (normed_comm_ring (normed_comm_ring (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_123510 (h0 : functor.add_const (complete_lattice (has_neg_part name)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123511 (h0 : ring (finset (ring (add_cancel_monoid (has_neg (has_add pos)))))) : is_domain (finset (ring (add_cancel_monoid (has_neg (has_add pos))))) := sorry --non-trivial
lemma new_lemma_123512 (h0 : canonically_ordered_add_monoid (option empty) -> canonically_ordered_add_monoid (option empty) -> Prop) : is_total_preorder (canonically_ordered_add_monoid (option empty)) h0 := sorry --non-trivial
lemma new_lemma_123513 (h0 : function.extfun Type ring) : @is_domain.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123514 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123515 (h0 : list (normed_comm_ring (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123516 (h0 : add_monoid (non_assoc_semiring congr_arg_kind)) : add_monoid.fg (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123517 (h0 : complete_lattice (cancel_monoid (finset name))) : is_atomistic (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_123518 (h0 : group (metric_space (semiring (has_norm congr_arg_kind)))) : group.fg (metric_space (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_123519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123520 (h0 : topological_space (metric_space (semiring (semiring empty)))) : irreducible_space (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_123521 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_123522 (h0 : semiring (add_cancel_monoid (comm_group Type))) : is_noetherian_ring (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_123523 (h0 : topological_space (with_bot (has_norm congr_arg_kind))) : totally_separated_space (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123524 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123525 (h0 : ring (has_Sup (option empty))) : rank_condition (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_123526 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_123527 (h0 : functor.add_const (add_group (semigroup Type)) (ring Type)) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (semigroup.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_123528 (h0 : functor.add_const (topological_space (semigroup Type)) (has_Inf pos)) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_123529 (h0 : ordered_add_comm_monoid (ring (option ennreal))) : archimedean (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_123530 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123531 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_123532 (h0 : ring (canonically_ordered_comm_semiring name)) : rank_condition (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_123533 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_123534 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring pos)) name) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_123535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_123536 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123537 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : totally_disconnected_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_123538 (h0 : group (canonically_linear_ordered_monoid num)) : normalizer_condition (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_123539 (h0 : functor.add_const (topological_space (has_star empty)) unsigned) : @t1_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123540 (h0 : topological_space (semigroup (finset (has_neg Type)))) : t0_space (semigroup (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_123541 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123542 (h0 : topological_space (has_star (semiring (semiring (semiring empty))))) : preirreducible_space (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_123543 (h0 : group (with_one (has_union linarith.comp))) : is_cyclic (with_one (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_123544 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @preirreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_123545 (h0 : topological_space (cancel_monoid (has_add (normed_comm_ring name)))) : irreducible_space (cancel_monoid (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_123546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123547 (h0 : topological_space (option ennreal)) : irreducible_space (option ennreal) := sorry --non-trivial
lemma new_lemma_123548 : nonempty (omega_complete_partial_order std_gen) := sorry --non-trivial
lemma new_lemma_123549 (h0 : functor.add_const (uniform_space (has_neg_part linarith.comp)) Type) : @complete_space.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_123550 (h0 : filter (option (semiring (semiring (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123551 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123552 (h0 : topological_space (random_gen num)) : locally_compact_space (random_gen num) := sorry --non-trivial
lemma new_lemma_123553 (h0 : semiring (complete_linear_order empty)) : is_noetherian_ring (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_123554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123555 (h0 : topological_space (has_add num)) : topological_space.separable_space (has_add num) := sorry --non-trivial
lemma new_lemma_123556 (h0 : functor.add_const (topological_space (has_dist empty)) congr_arg_kind) : @locally_compact_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123557 (h0 : group (has_pos_part (has_Inf linarith.comp))) : group.fg (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_123558 (h0 : complete_lattice (boolean_algebra.core (has_add (cancel_monoid name)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_123559 (h0 : set (add_comm_semigroup (mul_one_class ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_123560 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_123561 (h3 : complete_lattice (has_div char)) : is_compactly_generated (has_div char) := sorry --non-trivial
lemma new_lemma_123562 (h0 : topological_space (cancel_monoid (comm_group (has_add name)))) : t1_space (cancel_monoid (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_123563 (h0 : topological_space (pseudo_metric_space (finset (has_add ennreal)))) : totally_disconnected_space (pseudo_metric_space (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_123564 (h1 h2 : list char) (h3 : list Prop) : list.ilast' (list.is_infix h1 h2) h3 := sorry --non-trivial
lemma new_lemma_123565 (h0 : topological_space (linear_ordered_add_comm_group (semiring linarith.comp_source))) : totally_disconnected_space (linear_ordered_add_comm_group (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123566 (h0 : functor.add_const (finset (has_Inf Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123567 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg (has_neg pos))) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_123568 (h1 : not (complete_lattice (comm_ring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_123569 (h0 : topological_space (semigroup (has_to_string (has_to_string pos)))) : loc_path_connected_space (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_123570 (h0 : group (ordered_comm_monoid (finset Type))) : normalizer_condition (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_123571 (h0 : uniform_space (preorder (has_bot (option empty)))) : separated_space (preorder (has_bot (option empty))) := sorry --non-trivial
lemma new_lemma_123572 (h0 : group (generalized_boolean_algebra (has_bot Type))) : group.fg (generalized_boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_123573 (h0 : ring (linear_ordered_add_comm_group reducibility_hints)) : rank_condition (linear_ordered_add_comm_group reducibility_hints) := sorry --non-trivial
lemma new_lemma_123574 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_123575 (h0 : functor.add_const (semiring (add_cancel_monoid name)) Type) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_123576 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123577 (h0 : add_group (add_comm_semigroup string.iterator_imp)) : is_add_cyclic (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_123578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (lex.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (lex.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (lex.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (lex.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_123579 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset linarith.comp)) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_123580 (h0 : ordered_comm_monoid (has_zero (boolean_algebra Type))) : has_exists_mul_of_le (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_123581 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add linarith.comp))) : has_exists_mul_of_le (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123582 (h4 : topological_space (mul_one_class (mul_one_class (add_comm_semigroup enat)))) : totally_disconnected_space (mul_one_class (mul_one_class (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_123583 (h0 : topological_space (generalized_boolean_algebra (has_nndist linarith.comp))) : discrete_topology (generalized_boolean_algebra (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_123584 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_123585 (h0 : functor.add_const (ring (boolean_algebra Type)) environment.implicit_infer_kind) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123586 (h0 : functor.add_const (complete_lattice (has_pos_part Type)) linarith.comp) : @is_compactly_generated.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123587 (h0 : topological_space (ordered_comm_ring (has_bot pos))) : topological_space.separable_space (ordered_comm_ring (has_bot pos)) := sorry --non-trivial
lemma new_lemma_123588 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_123589 (h0 : ring (non_assoc_semiring num)) : is_domain (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_123590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123591 (h0 : uniform_space (has_nnnorm (has_nnnorm (random_gen string_imp)))) : complete_space (has_nnnorm (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_123592 (h0 : complete_lattice (boolean_algebra name)) : is_compactly_generated (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_123593 (h0 : topological_space (has_sub congr_arg_kind)) : normal_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123594 (h0 : semiring (monoid (option ennreal))) : is_noetherian_ring (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_123595 (h0 h1 : multiset (has_compl (mul_one_class enat))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_123596 (h0 : group (denumerable (random_gen string_imp))) : group.fg (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123597 (h0 : topological_space (linear_ordered_field (option ennreal))) : topological_space.separable_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_123598 (h0 : group (random_gen (has_inv to_additive.value_type))) : normalizer_condition (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123599 (h0 : uniform_space (filter unsigned)) : separated_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_123600 (h0 : group (denumerable (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (denumerable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_123601 (h0 : monoid (cancel_monoid (option (option empty)))) : monoid.fg (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_123602 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : sequential_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_123603 (h0 : ordered_comm_monoid (boolean_algebra.core (option (ring pos)))) : has_exists_mul_of_le (boolean_algebra.core (option (ring pos))) := sorry --non-trivial
lemma new_lemma_123604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123605 (h0 : not (uniform_space real.angle -> false)) : @separated_space.{0} real.angle (@classical.by_contradiction'.{1} (uniform_space.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_123606 (h0 : not (function.extfun Type complete_lattice -> false)) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_123607 (h0 : list Prop) : @id.{1} Prop (@list.head.{0} Prop sort.inhabited.{0} (@list.erase_dup.{0} Prop (λ (a b : Prop), @eq.decidable.{0} Prop Prop.linear_order a b) h0))  := sorry --non-trivial
lemma new_lemma_123608 (h0 : topological_space (finset linarith.comp)) : totally_separated_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_123609 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_123610 (h0 : filter (has_norm (has_ssubset fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123611 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123612 (h0 : not (complete_lattice unsigned -> false)) : @is_atomistic.{0} unsigned (@classical.by_contradiction'.{1} (complete_lattice.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_123613 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_123614 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring name)) (finset environment.implicit_infer_kind)) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_123615 (h0 : functor.comp complete_lattice has_add name) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_123616 (h0 : ordered_add_comm_monoid (has_to_string (has_pos_part (ring (ring pos))))) : archimedean (has_to_string (has_pos_part (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_123617 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) unsigned) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123618 (h0 : fin has_zero.zero) : @group.fg.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_123619 (h0 : topological_space (cancel_monoid (comm_group Type))) : preirreducible_space (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_123620 (h0 : uniform_space (canonically_ordered_comm_semiring pos)) : complete_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_123621 (h0 : prod (linear_ordered_semiring unsigned) (linear_ordered_semiring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_123622 (h0 : function.extfun nat fin) : @regular_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_123623 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_123624 (h0 : add_group (filter (option (option empty)))) : is_add_cyclic (filter (option (option empty))) := sorry --non-trivial
lemma new_lemma_123625 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : totally_disconnected_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_123626 (h1 : ring (distrib_lattice (random_gen (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (distrib_lattice (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_123627 (h0 : topological_space (metric_space (linear_ordered_semiring congr_arg_kind))) : totally_separated_space (metric_space (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123628 (h0 : function.extfun Type topological_space) : @t1_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_123629 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_123630 (h0 : ordered_add_comm_monoid (ordered_ring unsigned)) : archimedean (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_123631 (h0 : topological_space (with_bot pos)) : regular_space (with_bot pos) := sorry --non-trivial
lemma new_lemma_123632 (h0 : complete_lattice (partial_order unsigned)) : is_compactly_generated (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_123633 (h0 : topological_space (complete_linear_order (semiring empty))) : irreducible_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_123634 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option unsigned))) : separated_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_123635 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_123636 (h0 : complete_lattice (has_norm (has_top (has_top (random_gen linarith.comp_source))))) : is_compactly_generated (has_norm (has_top (has_top (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_123637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123638 (h0 : not (ring (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_123639 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg real))) : regular_space (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_123640 (h0 : complete_lattice (finset (option ennreal))) : is_atomistic (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_123641 (h1 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_123642 (h0 : functor.add_const (group (has_zero Type)) Type) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_123643 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) pos) name) : @strong_rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) pos) name h0))  := sorry --non-trivial
lemma new_lemma_123644 (h0 : not (complete_lattice (has_sub unsigned) -> false)) : @is_compactly_generated.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_123645 (h0 : complete_lattice (ordered_comm_semiring linarith.comp_source)) : is_compactly_generated (ordered_comm_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_123646 (h0 : topological_space (add_cancel_monoid linarith.comp)) : discrete_topology (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_123647 (h0 : functor.add_const (monoid (add_comm_monoid pos)) linarith.comp) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123648 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_123649 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) pos) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_123650 (h0 : measurable_space (semi_normed_ring reducibility_hints)) (h1 : filter (semi_normed_ring reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_123651 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123652 (h0 : topological_space (has_pos_part Type)) : preirreducible_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_123653 (h0 : ordered_add_comm_monoid (ordered_ring (semiring (semiring (semiring (semiring (semiring empty))))))) : archimedean (ordered_ring (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_123654 (h0 : topological_space (dlist (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_123655 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) (ring linarith.comp)) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_123656 (h0 : topological_space (add_comm_monoid (has_add Type))) : loc_path_connected_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_123657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@id.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_123658 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) congr_arg_kind) : @loc_path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123659 (h0 : complete_lattice (add_comm_monoid linarith.ineq)) : is_compactly_generated (add_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_123660 (h0 : ring (simple_graph (mul_one_class ereal))) : rank_condition (simple_graph (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_123661 (h0 : list (option (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123662 (h0 : complete_lattice (linear_ordered_add_comm_group fun_info)) : is_compactly_generated (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_123663 (h0 : complete_lattice (add_comm_semigroup (add_comm_semigroup ereal))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_123664 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : @group.fg.{0} real.angle (@finset.pi.empty.{1 0} Type group.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_123665 (h0 h1 : multiset (distrib linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_123666 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_neg Type)) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_123667 (h0 : uniform_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : separated_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_123668 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop ennreal))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_123669 (h0 : uniform_space (add_comm_monoid unsigned)) : separated_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_123670 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (has_neg Type)) : @unique_factorization_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_123671 (h0 : topological_space (add_cancel_monoid (has_to_string ennreal))) : path_connected_space (add_cancel_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_123672 (h0 : ring (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : strong_rank_condition (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_123673 (h0 : set (distrib (mul_one_class (mul_one_class (has_compl string_imp))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_123674 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_123675 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (finset (finset Type))) : @complete_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (finset.{1} (finset.{1} Type)) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_123676 (h0 : topological_space (canonically_ordered_monoid name)) : path_connected_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_123677 (h0 : uniform_space (add_cancel_monoid (ring pos))) : complete_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_123678 (h0 : functor.add_const (group (has_Inf pos)) (has_neg Type)) : @normalizer_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_123679 (h0 : add_monoid (has_star (semiring (semiring (semiring (semiring (semiring unsigned))))))) : add_monoid.fg (has_star (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_123680 (h0 : ring (has_union empty)) : rank_condition (has_union empty) := sorry --non-trivial
lemma new_lemma_123681 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_123682 (h0 : monoid (linear_ordered_cancel_comm_monoid unsigned)) : monoid.fg (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_123683 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (finset linarith.comp)))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_123684 (h0 : quotient (list.is_setoid (linear_ordered_field (option empty)))) : palindrome (quotient.out h0) := sorry --non-trivial
lemma new_lemma_123685 (h0 : functor.add_const (finset (ring linarith.comp)) (boolean_algebra Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123686 (h0 : add_group (has_add (finset (has_Inf (has_add (has_Inf pos)))))) : is_add_cyclic (has_add (finset (has_Inf (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_123687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_123689 (h0 : list (partial_order (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123690 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_123691 (h0 : topological_space (add_comm_monoid (option unsigned))) : discrete_topology (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_123692 (h0 : add_group (linear_ordered_comm_group_with_zero (random_gen string_imp))) : is_add_cyclic (linear_ordered_comm_group_with_zero (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : totally_disconnected_space int := sorry --non-trivial
lemma new_lemma_123694 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123695 (h0 : ring (with_bot (has_norm to_additive.value_type))) : is_domain (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123696 (h0 : complete_lattice (semigroup (finset pos))) : complete_lattice.is_Sup_finite_compact (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_123697 (h1 : metric_space (random_gen num)) (h2 : set (random_gen num)) : euclidean_geometry.cospherical h2 := sorry --non-trivial
lemma new_lemma_123698 (h0 : set (has_le (mul_one_class (simple_graph to_additive.value_type)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_123699 (h0 : topological_space (normed_group (random_gen congr_arg_kind))) : discrete_topology (normed_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123700 (h0 : complete_lattice (measurable_space (has_top fun_info))) : is_atomistic (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_123701 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_123702 (h0 : topological_space (semiring (random_gen num))) : totally_disconnected_space (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_123703 (h0 : topological_space (has_top fun_info)) : path_connected_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_123704 (h0 : semiring linarith.comp_source) (h1 : linarith.comp_source) : even h1 := sorry --non-trivial
lemma new_lemma_123705 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_123706 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123707 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : discrete_topology (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123708 (h0 : list (add_cancel_monoid (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123709 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123710 (h0 : group (has_edist (option empty))) : normalizer_condition (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_123711 (h0 : topological_space (measurable_space (random_gen string_imp))) : locally_compact_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_123712 (h0 : functor.add_const Prop (boolean_algebra.core num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_123713 (h0 : topological_space (has_nndist (comm_group (add_cancel_monoid Type)))) : regular_space (has_nndist (comm_group (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_123714 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123715 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_123716 (h0 : list (topological_space (normed_field environment.projection_info))) (h1 : nat) (h2 : preorder (normed_field environment.projection_info)) : @order_closed_topology.{0} (normed_field.{0} environment.projection_info) (@list.inth.{0} (topological_space.{0} (normed_field.{0} environment.projection_info)) (@inhabited_topological_space.{0} (normed_field.{0} environment.projection_info)) h0 h1) h2  := sorry --non-trivial
lemma new_lemma_123717 (h0 : topological_space (has_to_string (comm_group unsigned))) : normal_space (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_123718 (h0 : with_bot (topological_space (has_emptyc string_imp))) (h1 : function.extfun (eq h0 has_bot.bot) (fun (x : eq h0 has_bot.bot), false)) : @totally_disconnected_space.{0} (has_emptyc.{0} string_imp) (@with_bot.unbot.{0} (topological_space.{0} (has_emptyc.{0} string_imp)) h0 (@function.extfun_app.{0 0} (@eq.{1} (with_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))) h0 (@has_bot.bot.{0} (with_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))) (@with_bot.has_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))))) (λ (x : @eq.{1} (with_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))) h0 (@has_bot.bot.{0} (with_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))) (@with_bot.has_bot.{0} (topological_space.{0} (has_emptyc.{0} string_imp))))), false) h1))  := sorry --non-trivial
lemma new_lemma_123719 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_123720 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core Type))) : discrete_topology (ordered_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_123721 (h0 : monoid (id (semiring unsigned))) : monoid.fg (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_123722 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : totally_separated_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_123723 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_123724 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123725 (h0 : functor.add_const (topological_space (option ennreal)) ennreal) : @normal_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_123726 (h1 : group (complete_distrib_lattice string_imp)) : is_cyclic (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_123727 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : loc_path_connected_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_123728 (h0 : topological_space (normed_linear_ordered_group (option (option (option (option empty)))))) : locally_compact_space (normed_linear_ordered_group (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_123729 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_123730 (h0 : cancel_comm_monoid_with_zero (has_neg_part name)) : unique_factorization_monoid (has_neg_part name) := sorry --non-trivial
lemma new_lemma_123731 (h0 : topological_space (semigroup (ring Type))) : normal_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_123732 (h0 : ordered_add_comm_monoid (has_add num)) : archimedean (has_add num) := sorry --non-trivial
lemma new_lemma_123733 (h0 : not (has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc -> false)) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_123734 (h2 : uniform_space (has_inv linarith.ineq)) : complete_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_123735 (h0 : uniform_space (has_ssubset string_imp)) : complete_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_123736 (h0 : ring (has_norm (has_norm empty))) : strong_rank_condition (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_123737 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_123738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123739 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_123740 (h0 : topological_space (has_add (has_neg environment.implicit_infer_kind))) : sequential_space (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_123741 (h0 : list (id (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123742 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_123743 (h0 : functor.add_const (topological_space (with_bot num)) empty) : @preirreducible_space.{0} (with_bot.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (with_bot.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_123744 (h0 : ring (comm_ring linarith.comp_source)) : rank_condition (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_123745 (h0 : set (has_nnnorm (simple_graph (normed_field linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_123746 (h0 : group (canonically_ordered_comm_semiring Type)) : is_simple_group (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_123747 (h0 : not (function.extfun Type topological_space -> false)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_123748 (h0 : not (topological_space (with_bot unsigned) -> false)) : @irreducible_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_123749 (h1 : uniform_space (has_emptyc (has_emptyc (has_top fun_info)))) : complete_space (has_emptyc (has_emptyc (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_123750 (h0 : not (topological_space (id to_additive.value_type) -> false)) : @locally_compact_space.{0} (@id.{2} Type to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_123751 (h1 : topological_space (semiring (random_gen (has_top to_additive.value_type)))) : irreducible_space (semiring (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123752 (h0 : ring (boolean_algebra.core ennreal)) : invariant_basis_number (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_123753 (h1 : topological_space ereal) (h2 : preorder ereal) : order_closed_topology ereal := sorry --non-trivial
lemma new_lemma_123754 (h1 : topological_space (with_bot (with_bot to_additive.value_type))) : locally_compact_space (with_bot (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123755 (h0 : topological_space (has_nndist (has_add ennreal))) : irreducible_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_123756 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123757 (h0 : group (semigroup (option unsigned))) : group.fg (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_123758 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123759 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_123760 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_123761 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_123762 (h0 : functor.comp complete_lattice has_neg_part name) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) name (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg_part.{0} name h0))  := sorry --non-trivial
lemma new_lemma_123763 (h0 : fin has_zero.zero) : @archimedean.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_123764 (h0 : uniform_space (add_right_cancel_monoid congr_arg_kind)) : complete_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123765 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123766 (h0 : ring (canonically_ordered_comm_semiring (has_neg_part name))) : strong_rank_condition (canonically_ordered_comm_semiring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_123767 (h0 : monoid (has_neg (has_neg_part environment.implicit_infer_kind))) : monoid.fg (has_neg (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_123768 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) (has_to_string pos)) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_123769 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_123770 (h0 : topological_space (has_add (has_pos_part real))) : discrete_topology (has_add (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_123771 (h0 : not (ring (with_one linarith.ineq) -> false)) : @rank_condition.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_123772 (h0 : group (normed_comm_ring (has_add (has_add unsigned)))) : is_simple_group (normed_comm_ring (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_123773 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_123774 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_123775 (h0 : topological_space (boolean_algebra (has_Inf Type))) : preconnected_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_123776 (h0 : ordered_comm_monoid (has_nndist (has_to_string unsigned))) : has_exists_mul_of_le (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_123777 (h0 : topological_space (cancel_monoid (add_comm_monoid name))) : totally_disconnected_space (cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_123778 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @discrete_topology.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123779 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123780 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_123781 (h0 : group (add_left_cancel_semigroup (option (option empty)))) : normalizer_condition (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_123782 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_123783 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup name)) linarith.comp) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123784 (h0 : group (comm_group (has_add name))) : is_simple_group (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_123785 (h0 : functor.add_const (ring (semigroup Type)) linarith.comp) : @is_domain.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123786 (h0 : list (has_emptyc (random_gen (has_top linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123787 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_123788 (h0 : not (add_group (linear_ordered_comm_group_with_zero string_imp) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_123789 (h0 : finset (boolean_algebra.core (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123790 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_123791 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : locally_compact_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_123792 (h1 : add_group (has_norm num)) : is_add_cyclic (has_norm num) := sorry --non-trivial
lemma new_lemma_123793 (h0 : topological_space (boolean_algebra (add_cancel_monoid pos))) : discrete_topology (boolean_algebra (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_123794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_123795 (h0 : functor.add_const (group (comm_group name)) environment.implicit_infer_kind) : @group.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123796 (h0 : functor.add_const (finset (has_Inf Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123797 (h0 : Type) (h1 : id (division_ring (id h0))) : @trace_call_stack.{0} Prop (@heq.{1} (@id.{2} Type (division_ring.{0} (@id.{2} Type h0))) h1 unit)  := sorry --non-trivial
lemma new_lemma_123798 (h0 : topological_space (has_le (mul_one_class (mul_one_class reducibility_hints)))) : totally_disconnected_space (has_le (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_123799 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid Type)))) : is_cyclic (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_123800 (h0 : group (has_top (has_nnnorm (has_ssubset (random_gen linarith.ineq))))) : group.fg (has_top (has_nnnorm (has_ssubset (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_123801 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_123802 (h0 : uniform_space (simple_graph empty)) : separated_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_123803 (h0 : ring (has_Inf (has_Inf (metric_space linarith.comp)))) : is_principal_ideal_ring (has_Inf (has_Inf (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_123804 (h0 : list (has_star num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_123805 (h0 : ring (monoid (option pos))) : strong_rank_condition (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_123806 (h1 : topological_space (add_comm_semigroup enat)) (h2 : set (add_comm_semigroup enat)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_123807 (h0 : functor.add_const (monoid (has_neg ennreal)) Type) : @monoid.fg.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_123808 (h0 : filter (distrib_lattice (has_norm (has_inv fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123809 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_123810 (h0 : group (has_Inf real)) : normalizer_condition (has_Inf real) := sorry --non-trivial
lemma new_lemma_123811 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_123812 (h0 : group (filter num)) : is_cyclic (filter num) := sorry --non-trivial
lemma new_lemma_123813 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_123814 (h0 : topological_space (random_gen (has_vadd empty congr_arg_kind))) : path_connected_space (random_gen (has_vadd empty congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_123815 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_123816 (h0 : group (metric_space (metric_space (metric_space (metric_space num))))) : group.fg (metric_space (metric_space (metric_space (metric_space num)))) := sorry --non-trivial
lemma new_lemma_123817 (h0 : complete_lattice (add_group num)) : complete_lattice.is_Sup_finite_compact (add_group num) := sorry --non-trivial
lemma new_lemma_123818 (h0 : topological_space (plift num)) : locally_compact_space (plift num) := sorry --non-trivial
lemma new_lemma_123819 (h0 : topological_space (partial_order (has_top (has_top empty)))) : topological_space.separable_space (partial_order (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_123820 (h0 : complete_lattice (has_append (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_append (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_123821 (h0 : ring (add_right_cancel_monoid congr_arg_kind)) : strong_rank_condition (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123822 (h0 : semiring (monoid_with_zero (option pos))) : is_noetherian_ring (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_123823 (h0 : ring (non_assoc_semiring empty)) : is_principal_ideal_ring (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_123824 (h0 : topological_space (normed_group string_imp)) : totally_separated_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_123825 (h0 : topological_space (pseudo_metric_space pos)) : topological_space.separable_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_123826 (h0 : list (uniform_space (has_inv to_additive.value_type))) (h1 : ne h0 list.nil) : @complete_space.{0} (has_inv.{0} to_additive.value_type) (@list.last.{0} (uniform_space.{0} (has_inv.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_123827 (h0 : ring (generalized_boolean_algebra pos)) : strong_rank_condition (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_123828 (h0 : ring (linear_ordered_semiring (has_norm (semiring congr_arg_kind)))) : is_domain (linear_ordered_semiring (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_123829 (h0 : topological_space (has_nndist (ring (finset (ring linarith.comp))))) : preconnected_space (has_nndist (ring (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123830 (h0 : topological_space (fintype (random_gen linarith.ineq))) : locally_compact_space (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_123831 (h0 : complete_lattice (semigroup name)) : is_compactly_generated (semigroup name) := sorry --non-trivial
lemma new_lemma_123832 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123833 (h0 : functor.add_const (group (has_neg_part Type)) linarith.comp) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123834 (h1 : not (topological_space (topological_space to_additive.value_type) -> false)) : @path_connected_space.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_123835 (h0 : topological_space (mul_zero_class (ordered_cancel_comm_monoid num))) : topological_space.separable_space (mul_zero_class (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_123836 (h0 : topological_space (simple_graph (has_add (finset linarith.comp)))) : totally_separated_space (simple_graph (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_123837 (h0 : topological_space (add_comm_monoid (has_add (has_neg (has_neg linarith.comp))))) : irreducible_space (add_comm_monoid (has_add (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123838 (h0 : topological_space (has_nndist (ring linarith.comp))) : irreducible_space (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_123839 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_123840 (h0 : functor.add_const (ordered_add_comm_monoid (plift empty)) unsigned) : @archimedean.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (plift.{1} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123841 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : topological_space.separable_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_123842 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_neg (has_neg (has_neg pos)))) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_123843 (h0 : ring (has_inter (option empty))) : rank_condition (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_123844 (h0 : functor.add_const (finset (canonically_ordered_add_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123845 (h0 : functor.add_const (ring (semigroup Type)) name) : @is_domain.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_123846 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_123847 (h0 : list (has_top (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123848 (h0 : not (group (add_group congr_arg_kind) -> false)) : @normalizer_condition.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123849 (h0 : topological_space (has_add (has_pos_part pos))) : loc_path_connected_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_123850 (h0 : list (boolean_algebra (finset (finset (finset environment.implicit_infer_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123851 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm empty))))) : discrete_topology (random_gen (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_123852 (h0 : uniform_space (boolean_algebra (has_add (has_add (finset linarith.comp))))) : complete_space (boolean_algebra (has_add (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_123853 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123854 (h2 : topological_space (normed_field (random_gen char))) : t0_space (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_123855 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123856 (h0 : ring (uniform_space (mul_one_class (mul_one_class linarith.comp_source)))) : strong_rank_condition (uniform_space (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_123857 (h0 : ring (distrib (has_nnnorm (has_ssubset linarith.comp_source)))) : rank_condition (distrib (has_nnnorm (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_123858 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add (has_add linarith.comp))) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{0} (has_add.{0} linarith.comp)) h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_123859 (h0 : functor.add_const (ring (has_nndist unsigned)) Type) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_123860 (h0 : topological_space (mul_one_class std_gen)) : path_connected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_123861 (h0 : ring (has_to_string (has_to_string (finset pos)))) : is_principal_ideal_ring (has_to_string (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_123862 (h0 : preorder (set unsigned)) (h1 : topological_space (locally_finite_order (set unsigned))) : discrete_topology (locally_finite_order (set unsigned)) := sorry --non-trivial
lemma new_lemma_123863 (h0 : functor.add_const (complete_lattice (boolean_algebra.core linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_123864 (h1 : add_group (distrib (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (distrib (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123865 (h0 : functor.add_const (list (preorder empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123866 (h0 : complete_lattice (has_to_string (option ennreal))) : complete_lattice.is_Sup_finite_compact (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_123867 (h0 : measurable_space (add_comm_semigroup enat)) (h1 : filter (add_comm_semigroup enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_123868 (h0 : functor.add_const (group (ring linarith.comp)) pos) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_123869 (h0 : functor.add_const (ring (has_nndist ennreal)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_123870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_123871 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123872 (h0 : cancel_comm_monoid_with_zero (comm_group (ring name))) : unique_factorization_monoid (comm_group (ring name)) := sorry --non-trivial
lemma new_lemma_123873 (h0 : topological_space (has_neg_part linarith.comp)) : t0_space (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_123874 (h0 : finset (canonically_ordered_comm_semiring pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_123875 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_123876 (h0 : topological_space (has_to_string (has_add pos))) : path_connected_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_123877 (h0 : functor.add_const (topological_space (ring name)) name) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_123878 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_123879 (h0 : ring unsigned) : rank_condition unsigned := sorry --non-trivial
lemma new_lemma_123880 (h0 : topological_space (has_neg_part (has_nndist (option (option name))))) : preirreducible_space (has_neg_part (has_nndist (option (option name)))) := sorry --non-trivial
lemma new_lemma_123881 (h0 : topological_space (complete_distrib_lattice empty)) : path_connected_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_123882 (h0 : functor.add_const (ring (option empty)) (option num)) : @strong_rank_condition.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_123883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_123884 (h0 : topological_space (random_gen (has_norm num))) : path_connected_space (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_123885 (h0 : list (complete_distrib_lattice unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_123886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_123887 (h0 : group (comm_semigroup (sub_neg_monoid (has_Inf (has_add (has_Inf (has_Inf Type))))))) : group.fg (comm_semigroup (sub_neg_monoid (has_Inf (has_add (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_123888 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_123889 (h0 : not (topological_space (has_sub unsigned) -> false)) : @topological_space.separable_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_123890 (h0 : function.extfun Type topological_space) : @normal_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_123891 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @normal_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_123892 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @normal_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123893 (h0 : filter (normed_comm_ring ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123894 (h0 : ring (id (random_gen linarith.ineq))) : is_domain (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_123895 (h0 : not (topological_space (partial_order num) -> false)) : @totally_separated_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_123896 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_123897 (h0 : functor.comp topological_space finset Type) : @regular_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_123898 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_123899 (h0 : uniform_space (random_gen string_imp)) : complete_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_123900 (h0 : set (prod (semiring empty) (semiring empty))) (h1 : functor.add_const (prod (semiring empty) (semiring empty)) empty) : symmetrize_rel h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_123901 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string_imp))))) : rank_condition (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_123902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_123903 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_123904 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) Type) : @is_compactly_generated.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_123905 (h0 : filter (simple_graph pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_123906 (h0 : ring (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_123907 (h0 : topological_space (has_pos_part (has_add pos))) : t0_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_123908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_123909 (h1 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_123910 (h0 : functor.comp topological_space ring Type) : @preirreducible_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_123911 (h0 : has_lt (has_lt fun_info)) : no_max_order (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_123912 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system (semiring empty))) : unique_factorization_monoid (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_123913 (h0 : ring (generalized_boolean_algebra (ring linarith.comp))) : strong_rank_condition (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_123914 (h0 : topological_space (with_bot (has_inv to_additive.value_type))) : t0_space (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123915 (h0 : topological_space (plift (is_R_or_C empty))) : preirreducible_space (plift (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_123916 (h1 : add_group (id (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (id (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_123917 (h0 : uniform_space (ordered_comm_monoid (has_Inf pos))) : separated_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_123918 (h0 : topological_space (left_cancel_semigroup (option (option (option num))))) : loc_path_connected_space (left_cancel_semigroup (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_123919 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123920 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_123921 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : topological_space.separable_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_123922 (h3 : topological_space (mul_one_class enat)) : path_connected_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_123923 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_123924 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_edist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_123925 (h0 : topological_space (has_pos_part name)) : regular_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_123926 (h0 : complete_lattice (has_sub (semiring unsigned))) : is_compactly_generated (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_123927 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_linear_ordered_group empty)) := sorry --non-trivial
lemma new_lemma_123928 (h0 : group (boolean_algebra (comm_group environment.implicit_infer_kind))) : normalizer_condition (boolean_algebra (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_123929 (h0 : functor.add_const (group (has_zero linarith.comp)) name) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_123930 (h0 : group (sub_neg_monoid (has_Inf (has_neg (finset pos))))) : is_simple_group (sub_neg_monoid (has_Inf (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_123931 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_123932 (h0 : group (encodable fun_info)) : is_cyclic (encodable fun_info) := sorry --non-trivial
lemma new_lemma_123933 (h0 : functor.add_const (list (free_add_monoid empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_123934 (h0 : group (has_Inf (add_cancel_monoid pos))) : is_simple_group (has_Inf (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_123935 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_123936 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_123937 (h2 : set (ereal -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_123938 (h0 : set (has_dist reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_123939 (h0 : topological_space (has_add (has_add name))) : topological_space.separable_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_123940 (h0 : group (has_add (has_neg_part Type))) : group.fg (has_add (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_123941 (h0 : group (canonically_ordered_monoid (ordered_comm_monoid (has_bot (has_pos_part Type))))) : is_cyclic (canonically_ordered_monoid (ordered_comm_monoid (has_bot (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_123942 (h0 : functor.add_const (function.extfun Type ring) congr_arg_kind) : @strong_rank_condition.{0} (left_cancel_monoid.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind h0) (left_cancel_monoid.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_123943 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @sequential_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123944 (h0 : filter (random_gen (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123945 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : sequential_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_123946 (h0 : ordered_add_comm_monoid (has_to_string (finset linarith.comp))) : archimedean (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_123947 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid environment.implicit_infer_kind)) unsigned) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_123948 (h0 : group (left_cancel_semigroup congr_arg_kind)) : normalizer_condition (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123949 (h0 : topological_space (normed_linear_ordered_group unsigned)) : topological_space.separable_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_123950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_123951 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero ennreal)) name) : @archimedean.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_123952 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @discrete_topology.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_123953 (h0 : filter (has_norm (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123954 (h0 : complete_lattice (add_right_cancel_monoid empty)) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_123955 (h0 : ring (has_Inf real)) : strong_rank_condition (has_Inf real) := sorry --non-trivial
lemma new_lemma_123956 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_nndist (has_nndist (finset ennreal))))) : unique_factorization_monoid (has_neg_part (has_nndist (has_nndist (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_123957 (h0 : ring (boolean_algebra.core (has_add Type))) : rank_condition (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_123958 (h0 : distrib (semi_normed_comm_ring linarith.comp_source) -> std_gen -> Prop) : relator.left_unique h0 := sorry --non-trivial
lemma new_lemma_123959 (h0 : topological_space (measurable_space congr_arg_kind)) : t0_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_123960 (h0 : semiring (has_pos_part (has_add (has_to_string Type)))) : is_noetherian_ring (has_pos_part (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_123961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_123962 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123963 (h0 : functor.add_const (topological_space (mul_zero_class pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_123964 (h0 : ring (add_cancel_monoid ennreal)) : is_principal_ideal_ring (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_123965 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) congr_arg_kind) : @preirreducible_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_123966 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @add_monoid.fg.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_123967 (h0 : topological_space (has_norm to_additive.value_type)) : irreducible_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_123968 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_123969 (h0 : filter (has_neg (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123970 (h0 : topological_space (topological_space (has_nnnorm fun_info))) : locally_compact_space (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_123971 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) empty) : @is_compactly_generated.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_123972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (fintype.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (fintype.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_123973 (h0 : group (comm_monoid (omega_complete_partial_order (option unsigned)))) : normalizer_condition (comm_monoid (omega_complete_partial_order (option unsigned))) := sorry --non-trivial
lemma new_lemma_123974 (h0 : fin has_zero.zero) : @separated_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_123975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_123976 (h1 : not (ring (with_zero linarith.comp_source) -> false)) : @rank_condition.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_123977 (h0 : ring (has_ssubset (add_cancel_comm_monoid to_additive.value_type))) : strong_rank_condition (has_ssubset (add_cancel_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_123978 (h0 : filter (random_gen (has_norm (has_norm (has_norm congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123979 (h0 : functor.comp topological_space normed_comm_ring pos) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_123980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_123981 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_to_string unsigned))) : archimedean (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_123982 (h0 : semiring (has_add unsigned)) : is_noetherian_ring (has_add unsigned) := sorry --non-trivial
lemma new_lemma_123983 (h0 : filter (has_one (has_top congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_123984 (h0 : uniform_space (ordered_comm_ring (has_pos_part linarith.comp))) : separated_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_123985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_123986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_123987 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) name) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_123988 (h0 : monoid (has_add (canonically_linear_ordered_monoid (has_Inf real)))) : monoid.fg (has_add (canonically_linear_ordered_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_123989 (h0 : add_monoid (has_nndist (finset (has_add ennreal)))) : add_monoid.fg (has_nndist (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_123990 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (order_dual.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (order_dual.{0} empty))  := sorry --non-trivial
lemma new_lemma_123991 (h0 : topological_space (has_nndist (has_Inf (has_Inf linarith.comp)))) : preconnected_space (has_nndist (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_123992 (h1 : ring char) : is_domain char := sorry --non-trivial
lemma new_lemma_123993 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_123994 (h0 : topological_space (mul_zero_class (has_neg_part ennreal))) : t0_space (mul_zero_class (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_123995 (h0 : functor.add_const (group (has_Inf pos)) linarith.comp) : @normalizer_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_123996 (h0 : not (group (comm_ring linarith.ineq) -> false)) : @group.fg.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_123997 (h0 : has_lt (has_lt (mul_one_class char))) : no_max_order (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_123998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Sup.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_123999 (h0 : add_group (random_gen (has_norm (has_norm (has_norm linarith.comp))))) : is_add_cyclic (random_gen (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124000 (h0 : list (simple_graph (ring (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124001 (h0 : ring (semi_normed_comm_ring (random_gen linarith.ineq))) : strong_rank_condition (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124002 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.ineq))) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_124003 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_124004 (h5 : complete_lattice fun_info) : is_compactly_generated fun_info := sorry --non-trivial
lemma new_lemma_124005 (h0 : functor.add_const (ordered_add_comm_monoid (has_inter unsigned)) congr_arg_kind) : @archimedean.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_inter.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_124006 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124007 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124008 (h0 : uniform_space (has_neg_part (has_neg_part (has_neg_part environment.implicit_infer_kind)))) : separated_space (has_neg_part (has_neg_part (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_124009 (h0 : functor.add_const (ring (bin_tree congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124010 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_124011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_124012 (h0 : functor.add_const (ordered_add_comm_monoid (ring pos)) name) : @archimedean.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_124013 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : loc_path_connected_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_124014 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf Type)))) : sequential_space (boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_124015 (h0 : add_group (add_comm_monoid ennreal)) : is_add_cyclic (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_124016 (h0 : topological_space (semigroup (has_to_string congr_arg_kind))) : topological_space.separable_space (semigroup (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124017 (h0 : complete_lattice (ordered_ring congr_arg_kind)) : is_compactly_generated (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124018 (h0 : uniform_space (mul_one_class (normed_field (normed_field char)))) : complete_space (mul_one_class (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_124019 (h0 : functor.add_const (group (add_cancel_monoid pos)) linarith.comp) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124020 (h0 : topological_space (ordered_comm_group (semiring (semiring (semiring (semiring num)))))) : discrete_topology (ordered_comm_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_124021 (h0 : complete_lattice (measurable_space unsigned)) : is_compactly_generated (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_124022 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124023 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_124024 (h1 : add_group (has_ssubset (add_comm_semigroup string.iterator_imp))) : is_add_cyclic (has_ssubset (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_124025 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_124026 (h0 : add_group (has_le (normed_field (mul_one_class linarith.ineq)))) : is_add_cyclic (has_le (normed_field (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_124027 (h0 : group (complete_semilattice_Sup to_additive.value_type)) : group.fg (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124028 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_124029 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid pos)) (has_to_string pos)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_124030 (h1 : topological_space (with_zero linarith.ineq)) : path_connected_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_124031 (h0 : functor.add_const (add_group (semigroup name)) (has_add pos)) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_124032 (h0 : set (simple_graph std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124033 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124034 (h1 : filter (with_one (random_gen (random_gen (denumerable string_imp))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_124035 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_124036 (h0 : topological_space (has_add (has_neg name))) : preconnected_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_124037 (h0 : topological_space (has_edist unsigned)) : irreducible_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_124038 (h0 : complete_lattice (ring (finset (has_neg (ring linarith.comp))))) : complete_lattice.is_Sup_finite_compact (ring (finset (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124039 (h0 : ring (with_one to_additive.value_type)) : rank_condition (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124040 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124041 (h0 : topological_space (semigroup (has_pos_part (add_left_cancel_monoid (finset linarith.comp))))) : t1_space (semigroup (has_pos_part (add_left_cancel_monoid (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124042 (h0 : uniform_space (has_bot (semiring empty))) : complete_space (has_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_124043 (h0 : set (simple_graph (mul_one_class to_additive.value_type))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_124044 (h0 : group (has_add (has_add pos))) : is_cyclic (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_124045 (h0 : group (ring (has_neg (has_add (has_add name))))) : group.fg (ring (has_neg (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_124046 (h0 : uniform_space (complete_linear_order num)) : separated_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_124047 (h0 : not (group (measurable_space.dynkin_system congr_arg_kind) -> false)) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_124048 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124049 (h0 : complete_lattice (partial_order congr_arg_kind)) : is_compactly_generated (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124050 (h0 : function.extfun Type (functor.add_const (ring (mul_zero_class unsigned)))) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (mul_zero_class.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124051 (h0 : finset (preorder empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124052 (h0 : topological_space (add_comm_monoid (normed_comm_ring (finset Type)))) : totally_separated_space (add_comm_monoid (normed_comm_ring (finset Type))) := sorry --non-trivial
lemma new_lemma_124053 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_124054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} (has_norm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_124055 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg_part name)) : @t1_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_124056 (h0 : has_add congr_arg_kind) (h1 : topological_space (add_con congr_arg_kind)) : totally_disconnected_space (add_con congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124057 (h0 : monoid (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : monoid.fg (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_124058 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_124059 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124060 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_124061 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124062 (h0 : functor.add_const (complete_lattice (has_neg Type)) pos) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124063 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_124064 (h0 : list (semigroup name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124065 (h3 : not (add_group (denumerable to_additive.value_type) -> false)) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} to_additive.value_type)) h3)  := sorry --non-trivial
lemma new_lemma_124066 (h0 : topological_space (has_one (has_norm unsigned))) : totally_separated_space (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_124067 (h0 : ring (has_Inf (has_neg (has_neg (ring Type))))) : is_domain (has_Inf (has_neg (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_124068 (h0 : filter (ordered_comm_group (has_dist (has_dist (comm_monoid (comm_monoid (has_dist (has_dist num)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124069 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @discrete_topology.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124070 (h0 : measurable_space (has_le char)) (h1 : filter (has_le char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_124071 (h0 : not (complete_lattice real.angle -> false)) : @complete_lattice.is_Sup_finite_compact.{0} real.angle (@classical.by_contradiction'.{1} (complete_lattice.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_124072 (h0 : ring (with_bot (has_top to_additive.value_type))) : is_domain (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124073 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124074 (h0 : complete_lattice (add_group congr_arg_kind)) : is_compactly_generated (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124075 (h0 : topological_space (random_gen (has_norm linarith.comp))) : t0_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_124076 (h0 : function.extfun Type uniform_space) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_124077 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_124078 (h0 : list (cancel_monoid (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124079 (h0 : measurable_space std_gen) (h1 : set std_gen) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_124080 (h0 : topological_space (ring (option empty))) : path_connected_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_124081 (h0 : uniform_space (with_one unsigned)) : separated_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_124082 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @monoid.fg.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_124083 (h0 : set (set (has_inv (has_top fun_info)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_124084 (h0 : group (has_nndist unsigned)) : is_simple_group (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_124085 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_124086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_124087 (h0 : uniform_space (canonically_ordered_monoid (has_Inf linarith.comp))) : complete_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_124088 (h0 : ring (has_append linarith.comp_source)) : is_domain (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_124089 (h0 : group (complete_distrib_lattice num)) : is_cyclic (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_124090 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : totally_disconnected_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_124091 (h0 : group (has_top (semiring (has_top unsigned)))) : normalizer_condition (has_top (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_124092 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_124093 (h2 : ring (normed_field (metric_space (metric_space char)))) : rank_condition (normed_field (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_124094 (h0 : topological_space (add_cancel_monoid name)) : locally_compact_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_124095 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (uniform_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (uniform_space.{0} num))  := sorry --non-trivial
lemma new_lemma_124096 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124097 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm char)))) : complete_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_124098 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_124099 (h0 : functor.comp topological_space add_comm_monoid name) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_124100 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_124101 (h0 : topological_space (cancel_monoid num)) : t1_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_124102 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_zero (has_zero (has_zero (has_zero pos))))) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} (has_zero.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_124103 (h0 : ring (add_semigroup empty)) : strong_rank_condition (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_124104 (h0 : filter (add_cancel_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124105 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_124106 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124107 (h0 : uniform_space (add_cancel_monoid (has_neg linarith.comp))) : complete_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_124108 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_124109 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124110 (h0 : topological_space (metric_space (has_top empty))) : totally_disconnected_space (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_124111 (h0 : functor.add_const (topological_space znum) (option empty)) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_124112 (h0 : group (random_gen (linear_ordered_semiring empty))) : normalizer_condition (random_gen (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_124113 (h0 : functor.add_const (group (simple_graph Type)) pos) : @is_simple_group.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124115 (h0 : group (random_gen (semiring congr_arg_kind))) : group.fg (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124116 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : t0_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124117 (h0 : functor.add_const (finset (has_nndist Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124118 (h0 : not (topological_space (has_sub empty) -> false)) : @normal_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_124119 (h0 : ring (has_zero (finset (finset name)))) : is_domain (has_zero (finset (finset name))) := sorry --non-trivial
lemma new_lemma_124120 (h0 : add_comm_monoid (linear_ordered_field pos) -> add_comm_monoid (linear_ordered_field pos) -> Prop) : is_symm (add_comm_monoid (linear_ordered_field pos)) h0 := sorry --non-trivial
lemma new_lemma_124121 (h0 : complete_lattice (normed_group (has_top empty))) : is_compactly_generated (normed_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_124122 (h0 : finset (complete_distrib_lattice (option (option (option empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124123 (h0 : complete_lattice (has_div fun_info)) : is_compactly_generated (has_div fun_info) := sorry --non-trivial
lemma new_lemma_124124 (h0 : topological_space (simple_graph (ring linarith.comp))) : totally_disconnected_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_124125 (h0 : list (finset (finset (finset (finset (finset pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124126 (h0 : functor.add_const (group (normed_comm_ring Type)) pos) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124127 (h0 : functor.add_const (ring (has_add name)) linarith.comp) : @is_domain.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124128 (h0 : ring (distrib (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_124129 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (add_cancel_monoid.{1} (has_to_string.{1} Type)) (@functor.comp.run.{1 1 1} ring.{1} add_cancel_monoid.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} add_cancel_monoid.{1}) (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 (functor.comp.{1 1 1} ring.{1} add_cancel_monoid.{1})) (has_to_string.{1} Type)))  := sorry --non-trivial
lemma new_lemma_124130 (h0 : list (ulower pnat)) (h1 : fin has_zero.zero) (h2 : list (fin has_zero.zero)) : pnat.coprime (ulower.up (list.head h0)) (matrix.vec_empty (list.ilast' h1 h2)) := sorry --non-trivial
lemma new_lemma_124131 (h0 : functor.add_const (complete_lattice (finset num)) unsigned) : @is_compactly_generated.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124132 (h0 : complete_lattice (ring Type)) : complete_lattice.is_Sup_finite_compact (ring Type) := sorry --non-trivial
lemma new_lemma_124133 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_order.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_124134 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (ring name)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_124135 (h0 : topological_space (has_norm string_imp)) (h1 : list (comm_ring (measure_theory.content (has_norm string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_124136 (h0 : not (topological_space (random_gen linarith.comp_source) -> false)) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_124137 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_124138 (h0 : functor.add_const (ordered_comm_monoid (has_neg name)) Type) : @has_exists_mul_of_le.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_124139 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_124140 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : normal_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_124141 (h0 : functor.add_const (topological_space (finset Type)) name) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_124142 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : loc_path_connected_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_124143 (h1 : uniform_space (with_zero fun_info)) : complete_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_124144 (h0 : uniform_space (mul_zero_class (linear_ordered_comm_group (has_neg pos)))) : complete_space (mul_zero_class (linear_ordered_comm_group (has_neg pos))) := sorry --non-trivial
lemma new_lemma_124145 (h0 : functor.add_const (ring (metric_space num)) empty) : @rank_condition.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (metric_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_124146 (h0 : add_group (add_monoid (has_append (random_gen (has_nnnorm linarith.comp_source))))) : is_add_cyclic (add_monoid (has_append (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_124147 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_124148 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : locally_compact_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_124149 (h0 : ordered_comm_monoid (normed_comm_ring (semigroup pos))) : has_exists_mul_of_le (normed_comm_ring (semigroup pos)) := sorry --non-trivial
lemma new_lemma_124150 (h0 : monoid (with_bot (has_inv (has_inv string_imp)))) : monoid.fg (with_bot (has_inv (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_124151 (h0 : add_group (has_top (has_top linarith.comp_source))) : is_add_cyclic (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_124152 (h0 : topological_space (linear_order unsigned)) : irreducible_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_124153 (h0 : nat) (h1 : add_group (array (nat.factorial h0) linarith.comp_source)) : is_add_cyclic (array (nat.factorial h0) linarith.comp_source) := sorry --non-trivial
lemma new_lemma_124154 (h0 : functor.add_const (ring (finset pos)) name) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_124155 (h0 : topological_space (boolean_algebra (has_pos_part Type))) : topological_space.separable_space (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_124156 (h0 h1 : list (has_norm linarith.comp)) : list.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_124157 (h1 : list (comm_ring string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_124158 (h0 : fin has_zero.zero) : @rank_condition.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_124159 (h0 : finset (semiring (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124160 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124161 (h0 : topological_space (has_add (ring name))) : preirreducible_space (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_124162 (h0 : add_group (has_add (has_add pos))) : is_add_cyclic (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_124163 (h0 : has_compl linarith.comp_source) : set.subsingleton (is_distinct (has_compl linarith.comp_source) h0) := sorry --non-trivial
lemma new_lemma_124164 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_124165 (h0 : set (semi_normed_comm_ring reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_124166 (h0 : list (has_inv (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124167 (h0 : topological_space (measure_theory.measure_space empty)) : irreducible_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_124168 (h0 : ring (semi_normed_ring (mul_one_class string.iterator_imp))) : rank_condition (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_124169 (h0 : functor.add_const (group (boolean_algebra Type)) linarith.comp) : @group.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124170 (h0 : functor.add_const (topological_space (has_zero Type)) (comm_group name)) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_124171 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_add Type))) : archimedean (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_124172 (h0 : ring (mul_one_class char)) : strong_rank_condition (mul_one_class char) := sorry --non-trivial
lemma new_lemma_124173 (h0 : topological_space (has_nndist (has_to_string Type))) : path_connected_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_124174 (h0 : not (monoid (measurable_space.dynkin_system unsigned) -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_124175 (h0 : ring (has_nndist (comm_group (comm_group environment.implicit_infer_kind)))) : is_domain (has_nndist (comm_group (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_124176 (h0 : topological_space (finset (normed_comm_ring name))) : path_connected_space (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_124177 (h0 : functor.add_const (topological_space (has_bot name)) linarith.comp) : @locally_compact_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124178 (h1 : complete_lattice (distrib to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124179 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_124180 (h0 : group (bin_tree (semiring (semiring (semiring empty))))) : is_cyclic (bin_tree (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_124181 (h0 : semiring (add_comm_semigroup ereal)) (h1 : ideal (add_comm_semigroup ereal)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_124182 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124183 (h0 : filter (ordered_cancel_add_comm_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124184 (h0 : ring (has_nndist (has_to_string name))) : rank_condition (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_124185 (h0 : functor.add_const (topological_space (has_star unsigned)) congr_arg_kind) : @normal_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_124186 (h0 : topological_space (simple_graph reducibility_hints)) : t0_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_124187 (h0 : fin has_zero.zero) : @t1_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124188 (h0 : function.extfun nat fin) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124189 (h0 : complete_lattice (random_gen (has_top num))) : is_atomistic (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_124190 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_124191 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) pos) : @rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_124192 (h0 : ring (has_bot (has_pos_part (has_Inf (sub_neg_monoid real))))) : strong_rank_condition (has_bot (has_pos_part (has_Inf (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_124193 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_124194 (h0 : topological_space (semiring (random_gen (random_gen fun_info)))) : locally_compact_space (semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_124195 (h1 : set (has_compl string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_124196 (h0 : topological_space (mul_one_class enat)) (h1 : preorder (mul_one_class enat)) : order_topology (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_124197 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_124198 (h0 : functor.add_const (group (add_cancel_monoid name)) linarith.comp) : @group.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124199 (h0 : topological_space (linear_ordered_field (has_nndist (has_to_string name)))) : totally_disconnected_space (linear_ordered_field (has_nndist (has_to_string name))) := sorry --non-trivial
lemma new_lemma_124200 (h2 : add_group (comm_ring (comm_ring (topological_space (comm_ring (comm_ring reducibility_hints)))))) : is_add_cyclic (comm_ring (comm_ring (topological_space (comm_ring (comm_ring reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_124201 (h0 : filter (ring (has_Inf (has_neg (has_neg Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_124202 (h0 : topological_space (complete_semilattice_Sup char)) : locally_compact_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_124203 (h0 : filter (boolean_algebra (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124204 (h0 : functor.add_const (topological_space (finset pos)) (has_neg (has_pos_part linarith.comp))) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_neg.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_124205 (h0 : cancel_comm_monoid_with_zero (monoid empty)) : unique_factorization_monoid (monoid empty) := sorry --non-trivial
lemma new_lemma_124206 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_124207 (h1 : ring (has_append char)) : strong_rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_124208 (h0 : group (pseudo_metric_space pos)) : is_cyclic (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_124209 (h0 : uniform_space (has_emptyc linarith.comp)) : separated_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_124210 (h0 : ring (has_div (mul_one_class string.iterator_imp))) : is_domain (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_124211 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.ineq))) : @monoid.fg.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_124212 (h0 : ring (with_bot (semiring empty))) : is_principal_ideal_ring (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_124213 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_124214 (h0 : ulower (list Prop)) : @list.head.{0} Prop sort.inhabited.{0} (@ulower.up.{0} (list.{0} Prop) (@encodable.list.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_124215 (h0 : functor.add_const (filter (has_nndist name)) (has_add ennreal)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124216 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124217 (h0 : complete_lattice (pseudo_metric_space (option ennreal))) : is_atomistic (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_124218 (h0 : ring (has_zero unsigned)) : is_domain (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_124219 (h0 : functor.add_const (add_group (generalized_boolean_algebra Type)) linarith.comp) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124220 (h0 : topological_space (complete_semilattice_Sup (semiring empty))) : locally_compact_space (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_124221 (h0 : group (has_neg (finset pos))) : is_cyclic (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_124222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_124223 (h0 : functor.add_const (group (left_cancel_monoid num)) congr_arg_kind) : @is_cyclic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_124224 (h0 : equiv.perm fun_info) : equiv.perm.is_cycle h0 := sorry --non-trivial
lemma new_lemma_124225 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_ring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_124226 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option (option pos)))) : unique_factorization_monoid (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_124227 (h0 : list (canonically_ordered_comm_semiring unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124228 (h0 : functor.add_const (list (has_neg linarith.comp)) (boolean_algebra Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124229 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124230 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124231 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @locally_compact_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_124232 (h0 : functor.add_const (monoid (comm_group pos)) name) : @monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_124233 (h0 : ring (ordered_comm_monoid (has_add linarith.comp))) : rank_condition (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_124234 (h0 : topological_space (random_gen reducibility_hints)) : path_connected_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_124235 (h0 : finset (has_neg (canonically_linear_ordered_monoid name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124236 (h0 : uniform_space (normed_group (has_nnnorm (has_nnnorm (has_nnnorm char))))) : complete_space (normed_group (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_124237 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_124238 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (has_Sup empty)))) : @unique_factorization_monoid.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124239 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124240 (h0 : function.extfun Type group) : @group.fg.{0} (ring.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} name)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} name)))))))  := sorry --non-trivial
lemma new_lemma_124241 (h0 : group (metric_space (has_norm (has_norm empty)))) : group.fg (metric_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_124242 (h0 : uniform_space (canonically_linear_ordered_monoid num)) : complete_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_124243 (h0 : uniform_space (semi_normed_comm_ring (random_gen (random_gen linarith.comp_source)))) : complete_space (semi_normed_comm_ring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_124244 (h1 : add_monoid (has_emptyc linarith.comp)) : add_monoid.fg (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_124245 (h0 : ordered_comm_monoid (ring (option (option (option (option unsigned)))))) : has_exists_mul_of_le (ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_124246 (h0 : add_monoid (has_zero (pseudo_metric_space (option pos)))) : add_monoid.fg (has_zero (pseudo_metric_space (option pos))) := sorry --non-trivial
lemma new_lemma_124247 (h2 : filter linarith.ineq) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_124248 (h0 : uniform_space (has_top (semiring (ordered_comm_semiring congr_arg_kind)))) : complete_space (has_top (semiring (ordered_comm_semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_124249 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @t1_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_124250 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_124251 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_124252 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_pos_part linarith.comp))) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_pos_part.{0} linarith.comp)) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124253 (h0 : topological_space (has_to_string (finset ennreal))) : sequential_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_124254 (h2 : add_group (non_unital_non_assoc_semiring to_additive.value_type)) : is_add_cyclic (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124255 (h0 : semiring (semigroup pos)) : is_noetherian_ring (semigroup pos) := sorry --non-trivial
lemma new_lemma_124256 (h0 : functor.add_const (ring pos) pos) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_124257 (h0 : not (topological_space (has_union num) -> false)) : @preirreducible_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_124258 (h0 : fin has_zero.zero) : @is_domain.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_124259 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_124260 (h0 : ring (canonically_ordered_comm_semiring (finset Type))) : strong_rank_condition (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_124261 (h0 : finset (ordered_cancel_add_comm_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124262 (h0 : functor.add_const (topological_space (finset num)) pos) : @preirreducible_space.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} num)) pos h0)  := sorry --non-trivial
lemma new_lemma_124263 (h0 : list (left_cancel_semigroup unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124264 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_add pos))) : archimedean (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_124265 (h0 : ring (sub_neg_monoid (finset pos))) : is_domain (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_124266 (h0 : topological_space (canonically_ordered_monoid (has_pos_part (has_Inf Type)))) : normal_space (canonically_ordered_monoid (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_124267 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_124268 (h0 : set (simple_graph (mul_one_class (mul_one_class (mul_one_class enat))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124269 (h0 : add_monoid (comm_group linarith.comp)) : add_monoid.fg (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_124270 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_124271 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_124272 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) Type) : @separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_124273 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124274 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @t0_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_124275 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_124276 (h0 : measure_theory.outer_measure (comm_ring (comm_ring fun_info))) (h1 : has_inf (comm_ring (comm_ring fun_info))) : @has_measurable_inf.{0} (comm_ring.{0} (comm_ring.{0} fun_info)) (@measure_theory.outer_measure.caratheodory.{0} (comm_ring.{0} (comm_ring.{0} fun_info)) h0) h1  := sorry --non-trivial
lemma new_lemma_124277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124278 (h0 : ring (ring (option (option (option (option (option (option unsigned)))))))) : is_principal_ideal_ring (ring (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_124279 (h0 : topological_space (random_gen (random_gen string_imp))) : t0_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_124280 (h0 : topological_space (has_bot (has_pos_part pos))) : path_connected_space (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_124281 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_124282 (h0 : ordered_comm_monoid (has_neg (finset Type))) : has_exists_mul_of_le (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_124283 (h0 : function.extfun Type topological_space) : @regular_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_124284 (h0 : complete_lattice (distrib_lattice (random_gen linarith.ineq))) : is_compactly_generated (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124285 (h0 : complete_lattice (has_emptyc (has_norm (has_norm to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_124286 (h0 : topological_space (has_add (normed_comm_ring Type))) : totally_disconnected_space (has_add (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_124287 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) (ring Type)) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_124288 (h1 : complete_lattice (linear_ordered_add_comm_group fun_info)) : is_compactly_generated (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_124289 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order unsigned)) empty) : @unique_factorization_monoid.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_124290 (h0 : semiring (boolean_algebra.core (comm_monoid (option unsigned)))) : is_noetherian_ring (boolean_algebra.core (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_124291 (h0 : topological_space (denumerable (denumerable char))) : t0_space (denumerable (denumerable char)) := sorry --non-trivial
lemma new_lemma_124292 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_124293 (h0 : functor.add_const (topological_space (normed_comm_ring empty)) unsigned) : @preirreducible_space.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124294 (h0 : functor.add_const (finset (cancel_monoid ennreal)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124295 (h0 : functor.add_const (ring (has_star unsigned)) unsigned) : @strong_rank_condition.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124296 (h0 : topological_space (has_add (complete_distrib_lattice environment.implicit_infer_kind))) : regular_space (has_add (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124297 (h0 : topological_space (has_nndist linarith.comp)) : discrete_topology (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_124298 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_124299 (h0 : functor.add_const (function.extfun Type topological_space) (finset name)) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} name) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_124300 (h0 : functor.add_const (topological_space pos) (option (option (option (option (option pos)))))) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_124301 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_124302 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124303 (h0 : group (has_ssubset fun_info)) : group.fg (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_124304 (h0 : function.extfun (add_monoid (ring unsigned)) (fun (x : add_monoid (ring unsigned)), Prop)) (h1 : Exists (fun (x : add_monoid (ring unsigned)), function.extfun_app h0 x)) : @add_monoid.fg.{0} (ring.{0} unsigned) (@classical.some.{1} (add_monoid.{0} (ring.{0} unsigned)) (@function.extfun_app.{1 1} (add_monoid.{0} (ring.{0} unsigned)) (λ (x : add_monoid.{0} (ring.{0} unsigned)), Prop) h0) h1)  := sorry --non-trivial
lemma new_lemma_124305 (h0 : topological_space (linear_ordered_semiring num)) : discrete_topology (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_124306 (h0 : functor.add_const (uniform_space (has_nndist unsigned)) linarith.comp) : @complete_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124307 (h0 : topological_space (has_bot (has_neg (has_neg name)))) : topological_space.separable_space (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_124308 (h1 : complete_lattice (with_zero (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (with_zero (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_124309 (h0 : add_group (pseudo_metric_space (option (option (finset (option pos)))))) : is_add_cyclic (pseudo_metric_space (option (option (finset (option pos))))) := sorry --non-trivial
lemma new_lemma_124310 (h0 : complete_lattice (has_to_string (finset (finset (finset pos))))) : is_compactly_generated (has_to_string (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_124311 (h0 : semiring (has_top (add_group empty))) : is_noetherian_ring (has_top (add_group empty)) := sorry --non-trivial
lemma new_lemma_124312 (h1 : complete_lattice (encodable (fintype (functor.const (has_ssubset char) char)))) : complete_lattice.is_Sup_finite_compact (encodable (fintype (functor.const (has_ssubset char) char))) := sorry --non-trivial
lemma new_lemma_124313 (h0 : function.extfun Type (functor.comp ring canonically_ordered_comm_semiring)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} (option.{0} ennreal)) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0}) h0 (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_124314 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @locally_compact_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_124315 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class reducibility_hints)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_124316 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124317 (h0 : fin has_zero.zero) : @t0_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@matrix.vec_empty.{2} (function.extfun.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type))) h0) (function.extfun.{2 1} Type)) topological_space.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_124318 (h0 : add_monoid (option empty)) : add_monoid.fg (option empty) := sorry --non-trivial
lemma new_lemma_124319 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124320 (h0 : group (ordered_comm_monoid (has_Inf real))) : is_cyclic (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_124321 (h0 : function.extfun nat fin) : @separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124322 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_124323 (h0 : group (has_neg (ring (has_add Type)))) : normalizer_condition (has_neg (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_124324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_124325 (h0 : topological_space (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : discrete_topology (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124326 (h0 : complete_lattice (has_ssubset (random_gen reducibility_hints))) : is_compactly_generated (has_ssubset (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_124327 (h0 : topological_space (simple_graph name)) : regular_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_124328 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} (has_add.{0} (has_add.{0} (has_add.{0} (add_cancel_monoid.{0} (has_add.{0} name)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} (has_add.{0} (has_add.{0} (has_add.{0} (add_cancel_monoid.{0} (has_add.{0} name)))))))  := sorry --non-trivial
lemma new_lemma_124329 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_124330 (h0 : topological_space (add_semigroup (option empty))) : t1_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_124331 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124332 (h0 : function.extfun Type (functor.comp group canonically_linear_ordered_monoid)) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} canonically_linear_ordered_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} canonically_linear_ordered_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_124333 (h0 : finset (filter (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124334 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid pos)) : archimedean (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_124335 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124336 (h1 : topological_space (semiring fun_info)) : irreducible_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_124337 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) (ordered_comm_ring Type)) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) (ordered_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_124338 (h0 : has_mem.mem (random_gen (has_inv to_additive.value_type)) has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} (has_inv.{0} to_additive.value_type)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_124339 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_124340 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_124341 (h0 : topological_space (comm_monoid (semiring empty))) : normal_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_124342 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : irreducible_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124343 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_124344 (h0 : group (cancel_monoid pos)) : group.fg (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_124345 (h0 : finset (has_star (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124346 (h1 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.ineq) h1)  := sorry --non-trivial
lemma new_lemma_124347 (h1 : group (topological_space (mul_one_class to_additive.value_type))) : is_cyclic (topological_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124348 (h0 : topological_space (id (random_gen to_additive.value_type))) : irreducible_space (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124349 (h0 : group (normed_linear_ordered_group string_imp)) : group.fg (normed_linear_ordered_group string_imp) := sorry --non-trivial
lemma new_lemma_124350 (h6 : ring (add_cancel_comm_monoid char)) : strong_rank_condition (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_124351 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_124352 (h4 : not (ring (distrib char) -> false)) : @rank_condition.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h4)  := sorry --non-trivial
lemma new_lemma_124353 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) pos) : @totally_separated_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_124354 (h0 : topological_space (ring (boolean_algebra (boolean_algebra Type)))) : sequential_space (ring (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_124355 (h0 : not (topological_space (has_emptyc fun_info) -> false)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_124356 (h0 : semiring (has_bot (has_Inf Type))) : is_noetherian_ring (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_124357 (h0 : finset (complete_linear_order (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124358 (h0 : add_group (canonically_ordered_comm_semiring (has_neg_part (has_neg (comm_group Type))))) : is_add_cyclic (canonically_ordered_comm_semiring (has_neg_part (has_neg (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_124359 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_124360 (h2 : uniform_space (add_left_cancel_monoid (has_ssubset linarith.ineq))) : complete_space (add_left_cancel_monoid (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124361 (h0 : monoid (finset (finset Type))) : monoid.fg (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_124362 (h1 h2 : add_comm_semigroup (add_comm_semigroup char)) : is_distinct (add_comm_semigroup (add_comm_semigroup char)) h1 h2 := sorry --non-trivial
lemma new_lemma_124363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124364 (h0 : functor.add_const (topological_space (finset Type)) pos) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124366 (h0 : topological_space (denumerable (random_gen reducibility_hints))) : totally_disconnected_space (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_124367 (h0 : not (ring (has_emptyc linarith.comp_source) -> false)) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_124368 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_124369 (h0 : functor.comp uniform_space comm_group Type) : @complete_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_124370 (h0 : topological_space (has_inv linarith.comp_source)) : locally_compact_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_124371 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124372 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_124373 (h0 : group (has_neg_part (has_add pos))) : normalizer_condition (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_124374 (h1 : topological_space (with_one (with_one (with_bot linarith.comp_source)))) : locally_compact_space (with_one (with_one (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_124375 (h0 : topological_space (boolean_algebra (boolean_algebra.core name))) : irreducible_space (boolean_algebra (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_124376 (h0 : not (filter (encodable char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_124377 (h0 : functor.add_const (functor.add_const (ring Type) linarith.comp) linarith.comp) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_124378 (h0 : not (ring (with_zero char) -> false)) : @strong_rank_condition.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_124379 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_124380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_124381 (h0 h1 : multiset (has_div string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_124382 (h0 : group (measurable_space (has_inv (random_gen (has_top linarith.comp_source))))) : normalizer_condition (measurable_space (has_inv (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_124383 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_124385 (h0 : topological_space (finset (ring linarith.comp))) : discrete_topology (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_124386 (h0 : semiring (add_comm_semigroup string.iterator_imp)) (h1 : ideal (add_comm_semigroup string.iterator_imp)) : ideal.is_maximal h1 := sorry --non-trivial
lemma new_lemma_124387 (h0 : complete_lattice (add_comm_monoid (has_to_string unsigned))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_124388 (h0 : topological_space (monoid (option unsigned))) : locally_compact_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_124389 (h0 : group (with_one (has_ssubset to_additive.value_type))) : is_cyclic (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124390 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_124391 (h0 : function.extfun Type topological_space) : @t0_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_124392 (h0 : functor.add_const (ring (free_add_monoid unsigned)) congr_arg_kind) : @strong_rank_condition.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_124393 (h0 : topological_space (add_cancel_monoid pos)) : irreducible_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_124394 (h0 : add_monoid (normed_comm_ring (has_add (comm_group (comm_group unsigned))))) : add_monoid.fg (normed_comm_ring (has_add (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_124395 (h0 : topological_space (cancel_monoid (add_cancel_monoid name))) : discrete_topology (cancel_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_124396 (h0 : uniform_space (has_nnnorm (has_nnnorm reducibility_hints))) : complete_space (has_nnnorm (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_124397 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_add_comm_group_with_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_add_comm_group_with_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124398 (h0 : not (uniform_space (has_div string_imp) -> false)) : @complete_space.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_124399 (h0 : topological_space (has_nndist (has_to_string (finset linarith.comp)))) : regular_space (has_nndist (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_124400 (h0 : topological_space (has_nndist (has_nndist (comm_group (finset pos))))) : discrete_topology (has_nndist (has_nndist (comm_group (finset pos)))) := sorry --non-trivial
lemma new_lemma_124401 (h0 : ordered_add_comm_monoid (add_cancel_monoid linarith.comp)) : archimedean (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_124402 (h0 : uniform_space (has_inv (has_ssubset linarith.ineq))) : complete_space (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124403 (h0 : topological_space (add_group (semiring (semiring (has_union (has_union congr_arg_kind)))))) : discrete_topology (add_group (semiring (semiring (has_union (has_union congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_124404 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @separated_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_124405 (h0 : complete_lattice (has_top unsigned)) : complete_lattice.is_Sup_finite_compact (has_top unsigned) := sorry --non-trivial
lemma new_lemma_124406 (h1 : topological_space (measurable_space linarith.ineq)) : totally_separated_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_124407 (h0 : not (topological_space (order_dual congr_arg_kind) -> false)) : @path_connected_space.{0} (order_dual.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (order_dual.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_124408 (h0 : complete_lattice (has_neg (option (option (option (option (option (option num)))))))) : is_compactly_generated (has_neg (option (option (option (option (option (option num))))))) := sorry --non-trivial
lemma new_lemma_124409 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_124410 (h0 : set char) (h1 : char) : set.up h0 h1 := sorry --non-trivial
lemma new_lemma_124411 (h0 : comm_ring (comm_ring (random_gen linarith.ineq)) -> comm_ring (comm_ring (random_gen linarith.ineq)) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_124412 (h0 : empty) : @rank_condition.{0} (semi_normed_comm_ring.{0} (random_gen.{0} to_additive.value_type)) (@empty.elim.{1} (ring.{0} (semi_normed_comm_ring.{0} (random_gen.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_124413 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @totally_disconnected_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124414 (h0 : topological_space (sub_neg_monoid (boolean_algebra.core linarith.comp))) : regular_space (sub_neg_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_124415 (h0 : list (add_cancel_monoid (boolean_algebra.core (has_add Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124416 (h0 : group (add_cancel_monoid (has_add (finset (has_add (has_add Type)))))) : normalizer_condition (add_cancel_monoid (has_add (finset (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_124417 : infinite std_gen := sorry --non-trivial
lemma new_lemma_124418 (h0 : functor.comp complete_lattice normed_comm_ring Type) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_124419 (h0 : uniform_space (has_to_string (has_neg (has_neg linarith.comp)))) : separated_space (has_to_string (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_124420 (h1 : set (mul_one_class (normed_field linarith.ineq))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_124421 (h1 : uniform_space (id (with_bot (with_bot (with_bot (random_gen (with_bot to_additive.value_type))))))) : complete_space (id (with_bot (with_bot (with_bot (random_gen (with_bot to_additive.value_type)))))) := sorry --non-trivial
lemma new_lemma_124422 (h0 : topological_space (semiring (random_gen linarith.comp))) : locally_compact_space (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_124423 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_124424 (h0 : topological_space (ring (option unsigned))) : preconnected_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_124425 (h0 : ring (has_pos_part (ordered_comm_monoid (sub_neg_monoid Type)))) : rank_condition (has_pos_part (ordered_comm_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_124426 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @t0_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_124427 (h0 : topological_space (metric_space (semiring empty))) : normal_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_124428 (h0 : complete_lattice (complete_distrib_lattice (has_to_string unsigned))) : is_atomistic (complete_distrib_lattice (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_124429 (h0 : set (add_comm_semigroup linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124430 (h0 : functor.add_const (list (add_comm_monoid pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124431 (h0 : monoid (measurable_space (random_gen string_imp))) : monoid.fg (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_124432 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (ring (has_neg Type))) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_124433 (h0 : uniform_space (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : separated_space (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_124434 (h0 : topological_space (has_nnnorm char)) (h1 : uniform_space (topological_space.nonempty_compacts (has_nnnorm char))) : complete_space (topological_space.nonempty_compacts (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_124435 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_124436 (h0 : topological_space (cancel_monoid empty)) : path_connected_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_124437 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_124438 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124439 (h0 : group (dlist (random_gen char))) : group.fg (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_124440 (h0 : function.extfun Type ordered_add_comm_monoid) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_124441 (h0 : list (has_neg congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_124442 (h0 : complete_lattice (boolean_algebra (has_Inf pos))) : is_compactly_generated (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_124443 (h0 : ring (simple_graph (mul_one_class (mul_one_class (mul_one_class fun_info))))) : rank_condition (simple_graph (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_124444 (h0 : topological_space (dlist (random_gen fun_info))) : locally_compact_space (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_124445 (h0 : functor.add_const (topological_space (finset name)) pos) : @irreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_124446 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_pos_part (has_Inf (has_add real))))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_pos_part (has_Inf (has_add real)))) := sorry --non-trivial
lemma new_lemma_124447 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124448 (h0 : functor.comp cancel_comm_monoid_with_zero has_nndist pos) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_124449 (h0 : topological_space (ordered_comm_ring (finset Type))) : locally_compact_space (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_124450 (h0 : ring (has_zero (has_neg (has_to_string (ring Type))))) : rank_condition (has_zero (has_neg (has_to_string (ring Type)))) := sorry --non-trivial
lemma new_lemma_124451 (h0 : functor.add_const (add_group unsigned) (option (option (option (option unsigned))))) : @is_add_cyclic.{0} unsigned (@functor.add_const.run.{0 0} (add_group.{0} unsigned) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_124452 (h0 : group (simple_graph linarith.comp)) : group.fg (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_124453 (h0 : group (semi_normed_comm_ring (random_gen string_imp))) : is_cyclic (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_124454 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) linarith.comp) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124455 (h0 : topological_space (has_inter (option (option num)))) : path_connected_space (has_inter (option (option num))) := sorry --non-trivial
lemma new_lemma_124456 (h0 : functor.add_const (ring (add_cancel_comm_monoid empty)) empty) : @is_principal_ideal_ring.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_124457 (h0 : function.extfun Type topological_space) : @t1_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_124458 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @discrete_topology.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124459 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @preirreducible_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_124460 (h0 : complete_lattice (ordered_comm_semiring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (ordered_comm_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124461 (h0 : functor.add_const (finset (option congr_arg_kind)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124462 (h0 : functor.add_const (finset (plift num)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124463 (h0 : complete_lattice (has_nndist (finset (boolean_algebra (has_neg linarith.comp))))) : is_atomistic (has_nndist (finset (boolean_algebra (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124464 (h0 : ring (partial_order unsigned)) : rank_condition (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_124465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_124466 (h0 : functor.add_const (topological_space (has_neg_part pos)) unsigned) : @totally_disconnected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124467 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_124468 (h0 : topological_space (finset (has_zero linarith.comp))) : preconnected_space (finset (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_124469 (h0 : add_group (has_le (mul_one_class to_additive.value_type))) : is_add_cyclic (has_le (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124470 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf Type)))) : locally_compact_space (normed_lattice_add_comm_group (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_124471 (h0 : topological_space (comm_semigroup (ordered_comm_monoid (has_Inf (ordered_comm_monoid pos))))) : locally_compact_space (comm_semigroup (ordered_comm_monoid (has_Inf (ordered_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_124472 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_124473 (h0 : group (has_inter congr_arg_kind)) : group.fg (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124474 (h0 : functor.add_const (uniform_space (linear_ordered_comm_ring num)) num) : @complete_space.{0} (linear_ordered_comm_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_124475 (h2 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h2 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124476 (h0 : monoid (has_norm (has_top (has_top linarith.comp_source)))) : monoid.fg (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_124477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_124478 (h0 : has_lt (semi_normed_comm_ring linarith.ineq)) : no_max_order (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_124479 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_124480 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @t0_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124481 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_124482 (h0 : filter (has_nndist (option (option (option unsigned))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_124483 (h0 : functor.add_const (filter (ring name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124484 (h0 : topological_space (with_one num)) : locally_compact_space (with_one num) := sorry --non-trivial
lemma new_lemma_124485 (h1 : group (comm_ring (metric_space char))) : is_cyclic (comm_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_124486 (h0 : functor.add_const (functor.add_const Prop (normed_comm_ring Type)) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124487 (h0 : add_group (ring (has_Inf (ring (has_Inf linarith.comp))))) : is_add_cyclic (ring (has_Inf (ring (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124488 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124489 (h0 : monoid (has_norm congr_arg_kind)) : monoid.fg (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_124491 (h0 : topological_space (finset (finset (finset (finset (ring linarith.comp)))))) : regular_space (finset (finset (finset (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_124492 (h0 : topological_space (normed_linear_ordered_group num)) : t0_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_124493 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (has_to_string unsigned)) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) (has_to_string.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_124494 (h0 : uniform_space (has_Inf (has_Inf linarith.comp))) : complete_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_124495 (h0 : finset (normed_group (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124496 (h0 : prod (has_Sup (semiring (semiring empty))) (has_Sup (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_124497 (h0 : group (with_bot (has_norm (semiring (semiring empty))))) : is_cyclic (with_bot (has_norm (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_124498 (h0 : group (has_neg (normed_comm_ring pos))) : is_simple_group (has_neg (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_124499 (h0 : topological_space (boolean_algebra.core (finset (finset (finset (finset pos)))))) : topological_space.separable_space (boolean_algebra.core (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_124500 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_124501 (h0 : functor.add_const (filter (has_to_string linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124502 (h0 : set (non_unital_non_assoc_semiring (has_inv enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124503 (h0 : topological_space (has_add (random_gen to_additive.value_type))) : t0_space (has_add (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124504 (h0 : topological_space (simple_graph linarith.comp)) : preconnected_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_124505 (h0 : topological_space (semigroup (has_nndist pos))) : discrete_topology (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_124506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_124507 (h0 : monoid (metric_space (random_gen unsigned))) : monoid.fg (metric_space (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_124508 (h0 : group (random_gen (semiring num))) : normalizer_condition (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_124509 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) name) : @archimedean.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_124510 (h0 : functor.add_const (uniform_space (finset linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_124511 (h0 : functor.add_const (topological_space (ring name)) pos) : @t1_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_124512 (h0 : function.extfun Type group) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_124513 (h0 : topological_space (has_nndist (has_add unsigned))) : t1_space (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_124514 (h0 : ring (add_zero_class linarith.ineq)) : rank_condition (add_zero_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_124515 (h0 : semiring (generalized_boolean_algebra (has_neg (has_Inf (has_neg name))))) : is_noetherian_ring (generalized_boolean_algebra (has_neg (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_124516 (h0 : topological_space (ring (semigroup Type))) : preconnected_space (ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_124517 (h2 : add_group (has_nnnorm (random_gen to_additive.value_type))) : is_add_cyclic (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124518 (h0 : functor.add_const (list (has_Inf linarith.comp)) (has_neg name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124519 (h0 : ring (boolean_algebra (comm_group unsigned))) : strong_rank_condition (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_124520 (h0 : monoid (has_Inf (has_Inf pos))) : monoid.fg (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_124521 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_union empty)) := sorry --non-trivial
lemma new_lemma_124522 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @normal_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124523 (h0 : functor.add_const (uniform_space (ring Type)) Type) : @complete_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124524 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_124525 (h0 : topological_space (has_inv (random_gen string_imp))) : locally_compact_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_124526 (h1 : uniform_space (with_one (has_norm congr_arg_kind))) : separated_space (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124527 (h0 : functor.add_const (complete_lattice (has_to_string environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_124528 (h0 : set (enat -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_124529 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : t1_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_124530 (h1 : topological_space (has_norm num)) : discrete_topology (has_norm num) := sorry --non-trivial
lemma new_lemma_124531 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_124532 (h0 : topological_space (has_union num)) : preirreducible_space (has_union num) := sorry --non-trivial
lemma new_lemma_124533 (h0 : ring (with_bot (random_gen to_additive.value_type))) : is_domain (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124534 (h0 : topological_space (has_emptyc fun_info)) : locally_compact_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_124535 (h0 : not (group (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) -> false)) : @is_cyclic.{0} (distrib_lattice.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_124536 (h0 : topological_space (add_comm_monoid (finset pos))) : locally_compact_space (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_124537 (h0 : prod (canonically_ordered_add_monoid unsigned) (canonically_ordered_add_monoid unsigned)) : set.diagonal (canonically_ordered_add_monoid unsigned) h0 := sorry --non-trivial
lemma new_lemma_124538 (h0 : group (has_compl (has_nnnorm (random_gen (random_gen (random_gen char)))))) : group.fg (has_compl (has_nnnorm (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_124539 (h0 : functor.add_const (monoid (has_to_string Type)) linarith.comp) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124540 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup pos)) linarith.comp) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124541 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124542 (h0 : list (non_assoc_semiring (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124543 (h0 : ring (has_add (finset linarith.comp))) : is_principal_ideal_ring (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_124544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_124545 (h0 : uniform_space (has_Inf (complete_distrib_lattice name))) : separated_space (has_Inf (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_124546 (h0 : ring (ring (finset pos))) : rank_condition (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_124547 (h0 : ring (group_with_zero (sub_neg_monoid name))) : is_principal_ideal_ring (group_with_zero (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_124548 (h0 : functor.add_const (function.extfun Type complete_lattice) (finset (finset environment.implicit_infer_kind))) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (finset.{0} (finset.{0} environment.implicit_infer_kind)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124549 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124550 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : totally_disconnected_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124551 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124552 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124553 (h0 : ring (has_compl (has_nnnorm linarith.comp_source))) : rank_condition (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_124554 (h0 : functor.add_const (topological_space (has_add real)) Type) : @totally_disconnected_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_124555 (h0 : complete_lattice (random_gen (random_gen fun_info))) : is_atomistic (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_124556 (h0 : topological_space (has_top (has_one (has_one linarith.comp)))) : normal_space (has_top (has_one (has_one linarith.comp))) := sorry --non-trivial
lemma new_lemma_124557 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124558 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_124559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)))) (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_124560 (h0 : topological_space Type) : preconnected_space Type := sorry --non-trivial
lemma new_lemma_124561 (h0 : topological_space (with_one (semiring (semiring (semiring num))))) : preirreducible_space (with_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_124562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124563 (h0 : ring (ordered_comm_monoid real)) : is_principal_ideal_ring (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_124564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124565 (h0 : topological_space (semigroup (ring Type))) : preconnected_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_124566 (h0 : ring (complete_distrib_lattice unsigned)) : rank_condition (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_124567 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124568 (h0 : topological_space (has_bot real)) : totally_separated_space (has_bot real) := sorry --non-trivial
lemma new_lemma_124569 (h0 : function.extfun Type (functor.add_const (filter (add_cancel_monoid empty)))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_124570 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : preconnected_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_124571 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_124572 (h0 : functor.add_const (topological_space (option num)) pos) : @topological_space.separable_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) pos h0)  := sorry --non-trivial
lemma new_lemma_124573 (h0 : ring (has_neg (has_pos_part linarith.comp))) : strong_rank_condition (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_124574 (h0 : topological_space (ring pos)) : sequential_space (ring pos) := sorry --non-trivial
lemma new_lemma_124575 (h0 : topological_space (measurable_space.dynkin_system empty)) : topological_space.separable_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_124576 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124577 (h0 : set (non_unital_non_assoc_semiring reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124578 (h0 : fin has_zero.zero) : @regular_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_124579 (h0 : complete_lattice (comm_ring (random_gen char))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_124580 (h0 : cancel_comm_monoid_with_zero (has_zero pos)) : unique_factorization_monoid (has_zero pos) := sorry --non-trivial
lemma new_lemma_124581 (h0 : has_add (mul_one_class linarith.ineq)) (h1 : has_lt (add_con (mul_one_class linarith.ineq))) : no_max_order (add_con (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124582 (h0 : group (canonically_ordered_add_monoid (comm_monoid (comm_monoid unsigned)))) : normalizer_condition (canonically_ordered_add_monoid (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_124583 (h0 : topological_space (simple_graph (option unsigned))) : locally_compact_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_124584 (h1 : group (has_emptyc congr_arg_kind)) : is_cyclic (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124585 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124586 (h0 : topological_space (partial_order congr_arg_kind)) : discrete_topology (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124587 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124588 (h0 : add_monoid (ring (has_add (has_add Type)))) : add_monoid.fg (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_124589 (h0 : not (complete_lattice (has_star unsigned) -> false)) : @is_compactly_generated.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_124590 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @loc_path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_124591 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124592 (h0 : filter (finset (normed_comm_ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_124593 (h1 : ring (distrib reducibility_hints)) : rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_124594 (h0 : group (ring (has_nndist (has_Inf name)))) : group.fg (ring (has_nndist (has_Inf name))) := sorry --non-trivial
lemma new_lemma_124595 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_124596 (h0 : group (has_to_string (finset name))) : is_simple_group (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_124597 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_124598 (h0 : filter (mul_zero_class congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124599 (h0 : topological_space (has_neg (option (option (option (option (option pos))))))) : preconnected_space (has_neg (option (option (option (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_124600 (h0 : topological_space (normed_comm_ring (comm_group name))) : loc_path_connected_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_124601 (h0 : group (has_norm (random_gen fun_info))) : group.fg (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_124602 (h0 : set (random_gen char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_124603 (h0 : group (comm_group (has_add (has_add name)))) : normalizer_condition (comm_group (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_124604 (h0 : fin has_zero.zero) : @archimedean.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_124605 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_124606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_124607 (h0 : group (free_add_monoid num)) : is_cyclic (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_124608 (h0 : ring (sub_neg_monoid name)) : rank_condition (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_124609 (h0 : ring (has_inner unsigned congr_arg_kind)) : is_principal_ideal_ring (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124610 (h1 : ring (with_bot (has_inv linarith.ineq))) : is_domain (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124611 (h0 : ring (has_norm fun_info)) : is_domain (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_124612 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_124613 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : normal_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124614 (h1 : group (has_append (comm_ring char))) : is_cyclic (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_124615 (h0 : not (topological_space (has_compl reducibility_hints) -> false)) : @path_connected_space.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_124616 (h0 : ring (ring (add_comm_monoid name))) : strong_rank_condition (ring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_124617 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (has_add (has_add linarith.comp))) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_124618 (h0 : group (ordered_comm_group (semiring (option empty)))) : normalizer_condition (ordered_comm_group (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_124619 (h0 : monoid (metric_space (has_top unsigned))) : monoid.fg (metric_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_124620 (h0 : uniform_space (with_one (semiring num))) : complete_space (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_124621 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124622 (h0 : add_group (has_le (mul_one_class (linear_ordered_comm_monoid_with_zero linarith.comp_source)))) : is_add_cyclic (has_le (mul_one_class (linear_ordered_comm_monoid_with_zero linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_124623 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124624 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124625 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_124626 (h0 : functor.add_const Prop (add_cancel_monoid (has_to_string (boolean_algebra Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_124627 (h0 : ordered_comm_monoid (has_add (mul_one_class (has_neg (has_neg linarith.comp))))) : has_exists_mul_of_le (has_add (mul_one_class (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_124628 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : sequential_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_124629 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : topological_space.separable_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_124630 (h0 : topological_space (complete_distrib_lattice ennreal)) : regular_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_124631 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_124632 (h0 : uniform_space (semi_normed_ring (has_ssubset char))) : complete_space (semi_normed_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_124633 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124634 (h0 : add_monoid (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : add_monoid.fg (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124635 (h0 : functor.add_const (finset (has_neg linarith.comp)) (finset linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124636 (h0 : topological_space (fintype (has_nnnorm linarith.ineq))) : t0_space (fintype (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124637 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp_source)))) : path_connected_space (semiring (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_124638 (h0 : group (bin_tree (semiring unsigned))) : group.fg (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_124639 (h0 : complete_lattice (add_cancel_monoid (has_nndist (has_nndist pos)))) : is_atomistic (add_cancel_monoid (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_124640 (h2 : has_lt (add_comm_semigroup (linear_ordered_semiring linarith.ineq))) : no_max_order (add_comm_semigroup (linear_ordered_semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124641 (h0 : monoid (has_emptyc (has_emptyc congr_arg_kind))) : monoid.fg (has_emptyc (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124642 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring Type)) : has_exists_mul_of_le (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_124643 (h0 : group (finset num)) : is_cyclic (finset num) := sorry --non-trivial
lemma new_lemma_124644 (h0 : fin has_zero.zero) : @group.fg.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_124645 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_124646 (h0 : functor.comp topological_space has_add pos) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)))))  := sorry --non-trivial
lemma new_lemma_124647 (h0 : topological_space (semigroup (mul_one_class pos))) : sequential_space (semigroup (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_124648 (h0 h1 : list (has_top string_imp)) : list.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_124649 (h0 : ring (measurable_space.dynkin_system (semiring congr_arg_kind))) : rank_condition (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124650 (h0 : topological_space (has_nndist (has_add Type))) : irreducible_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_124651 (h1 : group (denumerable (random_gen (has_norm to_additive.value_type)))) : is_cyclic (denumerable (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_124652 (h0 : functor.add_const (complete_lattice (cancel_monoid environment.implicit_infer_kind)) name) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_124653 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_neg name)))) : locally_compact_space (canonically_linear_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_124654 (h0 : linear_ordered_cancel_comm_monoid congr_arg_kind -> linear_ordered_cancel_comm_monoid congr_arg_kind -> Prop) : is_trans (linear_ordered_cancel_comm_monoid congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_124655 (h0 : function.extfun Type (prod (has_sub unsigned))) : id_rel (function.extfun_app h0 (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_124656 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_124657 (h0 : functor.add_const (ring (has_to_string Type)) Type) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124658 (h3 : ring (has_div string.iterator_imp)) : rank_condition (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_124659 (h0 : list (has_emptyc (random_gen (has_inv (has_inv linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124660 (h0 : complete_lattice (has_le enat)) : complete_lattice.is_Sup_finite_compact (has_le enat) := sorry --non-trivial
lemma new_lemma_124661 (h0 : topological_space (normed_comm_ring (finset (finset Type)))) : loc_path_connected_space (normed_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_124662 (h0 : ring (has_neg_part (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124663 (h0 : add_group (has_emptyc (has_norm congr_arg_kind))) : is_add_cyclic (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124664 (h0 : not (ring (has_lt to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_124665 (h0 : functor.add_const (add_monoid (ordered_ring unsigned)) unsigned) : @add_monoid.fg.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124667 (h0 : topological_space (boolean_algebra.core (has_to_string congr_arg_kind))) : discrete_topology (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124668 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @totally_separated_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_124669 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) linarith.comp) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124670 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124671 (h0 : uniform_space (normed_field (mul_one_class environment.projection_info))) : complete_space (normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_124672 (h0 : not (uniform_space (random_gen to_additive.value_type) -> false)) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_124673 (h0 : topological_space (has_zero (option (mul_zero_class (option (mul_zero_class (mul_zero_class pos))))))) : normal_space (has_zero (option (mul_zero_class (option (mul_zero_class (mul_zero_class pos)))))) := sorry --non-trivial
lemma new_lemma_124674 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_124675 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124676 (h0 : not (topological_space (has_nnnorm (has_nnnorm reducibility_hints)) -> false)) : @t0_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_124677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_124678 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124679 (h0 : ring (simple_graph string.iterator_imp)) : is_domain (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_124680 (h0 : topological_space (finset (cancel_monoid (has_add name)))) : preirreducible_space (finset (cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_124681 (h0 : topological_space (ring (has_neg linarith.comp))) : totally_disconnected_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_124682 (h0 : group (denumerable (has_nnnorm (random_gen char)))) : is_cyclic (denumerable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_124683 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124684 (h1 : topological_space (normed_group (has_union linarith.comp))) : path_connected_space (normed_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_124685 (h0 : normed_comm_ring ennreal -> normed_comm_ring ennreal -> Prop) : is_symm (normed_comm_ring ennreal) h0 := sorry --non-trivial
lemma new_lemma_124686 (h0 : topological_space (mul_zero_class unsigned)) : sequential_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_124687 (h0 : list (complete_semilattice_Sup (encodable to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124688 (h0 : ring (linear_ordered_field ennreal)) : strong_rank_condition (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_124689 (h0 : functor.comp monoid complete_distrib_lattice linarith.comp) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.comp.run.{0 0 0} monoid.{0} complete_distrib_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124690 (h0 : function.extfun Type (functor.comp ring has_add)) : @rank_condition.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_add.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_124691 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_124692 (h3 h4 : multiset fun_info) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_124693 (h0 : topological_space (linear_ordered_field empty)) : irreducible_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_124694 (h0 : functor.add_const (ring (has_nndist unsigned)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_124695 (h0 : ring (denumerable char)) : rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_124696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124697 (h0 : topological_space (with_bot (has_ssubset linarith.ineq))) : t0_space (with_bot (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124698 (h0 : ring (has_nndist environment.implicit_infer_kind)) : rank_condition (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_124699 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124700 (h0 : not (ring congr_arg_kind -> false)) : @is_domain.{0} congr_arg_kind (@classical.by_contradiction'.{1} (ring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_124701 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124702 (h0 : topological_space (boolean_algebra (boolean_algebra (boolean_algebra Type)))) : discrete_topology (boolean_algebra (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_124703 (h1 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124704 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_124705 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_124706 (h0 : topological_space (has_dist num)) : normal_space (has_dist num) := sorry --non-trivial
lemma new_lemma_124707 (h0 : ring (complete_distrib_lattice (comm_semigroup (has_bot (comm_semigroup real))))) : is_domain (complete_distrib_lattice (comm_semigroup (has_bot (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_124708 (h0 : functor.add_const (group (left_cancel_monoid empty)) (option unsigned)) : @is_cyclic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_124709 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid name)))) : regular_space (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_124710 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type))))) : sequential_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_124711 (h0 : topological_space (distrib_lattice (comm_ring fun_info))) : t0_space (distrib_lattice (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_124712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_124713 (h0 : list (is_R_or_C (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124714 (h0 : not (complete_lattice (has_nnnorm linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_124715 (h0 : setoid Prop) (h1 : quotient h0) : quotient.out' h1 := sorry --non-trivial
lemma new_lemma_124716 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124717 (h0 : topological_space (has_add ennreal)) : regular_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_124718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_124719 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @discrete_topology.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124720 (h0 : topological_space (has_neg (option (has_add (has_add name))))) : normal_space (has_neg (option (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_124721 (h0 : ring (complete_distrib_lattice (option empty))) : is_principal_ideal_ring (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_124722 (h0 : complete_lattice (has_Inf real)) : is_atomistic (has_Inf real) := sorry --non-trivial
lemma new_lemma_124723 (h0 : complete_lattice (random_gen num)) : is_compactly_generated (random_gen num) := sorry --non-trivial
lemma new_lemma_124724 (h0 : complete_lattice (has_ssubset enat)) : is_compactly_generated (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_124725 (h1 h2 : multiset stieltjes_function) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_124726 (h0 : filter (cancel_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_124727 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @strong_rank_condition.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_124728 (h0 : list (has_neg (option (option (option (option (option ennreal))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_124729 (h1 : add_group (semi_normed_ring (mul_one_class string.iterator_imp))) : is_add_cyclic (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_124730 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_124731 (h0 : not (cancel_comm_monoid_with_zero (non_assoc_semiring num) -> false)) : @unique_factorization_monoid.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_124732 (h0 : functor.add_const (topological_space (has_to_string ennreal)) Type) : @regular_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_124733 (h0 : topological_space (boolean_algebra (has_neg (has_Inf Type)))) : totally_separated_space (boolean_algebra (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_124734 (h0 : ordered_add_comm_monoid (left_cancel_semigroup num)) : archimedean (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_124735 (h0 : ring (ring (comm_group name))) : rank_condition (ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_124736 (h0 : add_group (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind))) : is_add_cyclic (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124737 (h1 : list (dlist string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_124738 (h0 : functor.add_const (topological_space (semigroup empty)) (option empty)) : @locally_compact_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_124739 (h0 : topological_space (comm_group (has_add unsigned))) : totally_disconnected_space (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_124740 : subsingleton (has_to_string fun_info) := sorry --non-trivial
lemma new_lemma_124741 (h0 : topological_space (linear_ordered_comm_group_with_zero char)) (h1 : preorder (linear_ordered_comm_group_with_zero char)) : order_closed_topology (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_124742 (h2 : ring (has_lt linarith.comp_source)) : strong_rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_124743 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_124744 (h0 : ring (linear_ordered_comm_group empty)) : strong_rank_condition (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_124745 (h0 : topological_space (normed_field string.iterator_imp)) : t0_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_124746 (h0 : complete_lattice (has_union (semiring (semiring unsigned)))) : is_atomistic (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_124747 (h0 : complete_lattice (has_pos_part (has_bot name))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_bot name)) := sorry --non-trivial
lemma new_lemma_124748 (h0 : ring (linear_ordered_comm_group (linear_ordered_comm_group num))) : strong_rank_condition (linear_ordered_comm_group (linear_ordered_comm_group num)) := sorry --non-trivial
lemma new_lemma_124749 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : path_connected_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_124750 (h0 : group (ring (option (option (option unsigned))))) : normalizer_condition (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_124751 (h0 : functor.add_const (monoid (normed_comm_ring Type)) unsigned) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (normed_comm_ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124752 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_124753 (h0 : monoid (simple_graph (option (option empty)))) : monoid.fg (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_124754 (h0 h1 : multiset (distrib string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_124755 (h0 : cancel_comm_monoid_with_zero (has_neg num)) : unique_factorization_monoid (has_neg num) := sorry --non-trivial
lemma new_lemma_124756 (h0 : monoid (with_bot (has_inv (has_inv (random_gen linarith.ineq))))) : monoid.fg (with_bot (has_inv (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_124757 (h0 : topological_space (boolean_algebra.core (finset (semigroup Type)))) : totally_disconnected_space (boolean_algebra.core (finset (semigroup Type))) := sorry --non-trivial
lemma new_lemma_124758 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup empty)) := sorry --non-trivial
lemma new_lemma_124759 (h0 : topological_space (non_unital_non_assoc_semiring (has_div (mul_one_class string.iterator_imp)))) : t0_space (non_unital_non_assoc_semiring (has_div (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_124760 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124761 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp)))) : t0_space (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_124762 (h0 : topological_space (has_nndist (finset (finset pos)))) : t0_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_124763 (h0 : group (add_cancel_monoid (option (option (option unsigned))))) : group.fg (add_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_124764 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_124765 (h0 : list (has_bot congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_124766 (h0 : filter (with_one (random_gen (random_gen string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124767 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_124768 (h0 : uniform_space (ordered_comm_monoid (has_Inf name))) : separated_space (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_124769 (h0 : semiring (has_inter (option (option (option ennreal))))) : is_noetherian_ring (has_inter (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_124770 (h0 : add_monoid (simple_graph unsigned)) : add_monoid.fg (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_124771 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_124772 (h1 : add_group (add_comm_semigroup (mul_one_class fun_info))) : is_add_cyclic (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_124773 (h0 : add_group (id string_imp)) : is_add_cyclic (id string_imp) := sorry --non-trivial
lemma new_lemma_124774 (h0 : group (mul_zero_class environment.implicit_infer_kind)) : group.fg (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_124775 (h0 : topological_space (has_add (has_Inf (has_pos_part linarith.comp)))) : discrete_topology (has_add (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_124776 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_add pos)))))) : preirreducible_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_124777 (h0 : complete_lattice (has_well_founded empty)) : is_atomistic (has_well_founded empty) := sorry --non-trivial
lemma new_lemma_124778 (h0 : measurable_space (non_unital_non_assoc_semiring string.iterator_imp)) (h1 : filter (non_unital_non_assoc_semiring string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_124779 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_124780 (h0 : fin has_zero.zero) : @is_simple_group.{0} pos (@matrix.vec_empty.{0} (group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_124781 (h0 : filter (encodable to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124782 (h0 : functor.comp add_monoid measurable_space.dynkin_system empty) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@functor.comp.run.{0 0 0} add_monoid.{0} measurable_space.dynkin_system.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_124783 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_124784 (h0 : ring (normed_lattice_add_comm_group name)) : is_domain (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_124785 (h0 : topological_space (linear_ordered_add_comm_group (has_norm (comm_ring linarith.ineq)))) : path_connected_space (linear_ordered_add_comm_group (has_norm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_124786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124787 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_124788 (h1 : ring (has_top (has_norm fun_info))) : rank_condition (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_124789 (h0 : functor.add_const (topological_space (plift empty)) empty) : @totally_separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_124790 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : irreducible_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_124791 (h0 : complete_lattice (dlist (random_gen linarith.comp_source))) : is_compactly_generated (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_124792 (h0 : to_additive.value_type -> has_top linarith.ineq -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_124793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_124794 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_124795 (h0 : monoid (boolean_algebra.core Type)) : monoid.fg (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_124796 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_124797 (h0 : complete_lattice (has_ssubset (random_gen char))) : is_compactly_generated (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_124798 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_neg_part name)) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_124799 (h0 : complete_lattice (has_neg_part Type)) : is_compactly_generated (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_124800 (h0 : topological_space (has_add (has_nndist (option (ring (finset pos)))))) : t1_space (has_add (has_nndist (option (ring (finset pos))))) := sorry --non-trivial
lemma new_lemma_124801 (h0 : functor.add_const (topological_space (ring unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_124802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_124803 (h0 : group (has_zero (comm_group name))) : is_cyclic (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_124804 (h0 : group (has_zero (option name))) : normalizer_condition (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_124805 (h0 : ordered_add_comm_monoid (has_add (has_add real))) : archimedean (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_124806 (h0 : topological_space (has_to_string (boolean_algebra.core name))) : locally_compact_space (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_124807 (h0 : group (has_top (has_norm (has_inv fun_info)))) : is_cyclic (has_top (has_norm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_124808 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @t1_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124809 (h1 : add_group (normed_field string_imp)) : is_add_cyclic (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_124810 (h0 : functor.add_const (uniform_space (has_nndist name)) (ring Type)) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_124811 (h0 : not (topological_space (has_ssubset char) -> false)) : @t0_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_124812 (h0 : filter (monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124813 (h0 : functor.add_const (list (ordered_comm_ring Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124814 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_124815 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124816 (h0 : uniform_space (has_add ennreal)) : separated_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_124817 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_124818 (h0 : topological_space (has_Inf (has_add pos))) : topological_space.separable_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_124819 (h1 : not (topological_space (has_nnnorm linarith.comp_source) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_124820 (h0 : group (topological_space (random_gen (random_gen char)))) : is_cyclic (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_124821 (h0 : add_group (finset (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) : is_add_cyclic (finset (has_Inf (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_124822 (h0 : add_group (uniform_space (mul_one_class linarith.comp_source))) : is_add_cyclic (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_124823 (h0 : add_monoid (preorder unsigned)) : add_monoid.fg (preorder unsigned) := sorry --non-trivial
lemma new_lemma_124824 (h0 : not (add_group (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_124825 (h0 : list (linear_order congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124826 (h0 : topological_space (comm_monoid congr_arg_kind)) : normal_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124827 (h0 : functor.add_const (add_group (add_cancel_monoid unsigned)) linarith.comp) : @is_add_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124828 (h0 : topological_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) : path_connected_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_124829 (h0 : complete_lattice (linear_ordered_add_comm_group_with_top (random_gen num))) : is_atomistic (linear_ordered_add_comm_group_with_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_124830 (h0 : function.extfun Type (functor.add_const (ring (ordered_comm_group empty)))) : @is_domain.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_124831 (h0 : set (enat -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_124832 (h0 : group (complete_semilattice_Sup (has_top (measurable_space (has_norm fun_info))))) : normalizer_condition (complete_semilattice_Sup (has_top (measurable_space (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_124833 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124834 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124835 (h0 : functor.add_const (ring (has_nndist pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_124836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124837 (h0 : group (with_one (with_bot string_imp))) : normalizer_condition (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_124838 (h0 : topological_space (id string_imp)) : totally_separated_space (id string_imp) := sorry --non-trivial
lemma new_lemma_124839 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : t0_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124840 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (ordered_comm_monoid pos))) : archimedean (normed_lattice_add_comm_group (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_124841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_124842 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124843 (h0 : topological_space (comm_semigroup (ordered_comm_monoid (has_pos_part linarith.comp)))) : path_connected_space (comm_semigroup (ordered_comm_monoid (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_124844 (h0 : topological_space (distrib_lattice linarith.ineq)) : totally_separated_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_124845 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : normal_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_124846 (h0 : ring (comm_group (option (ring ennreal)))) : is_principal_ideal_ring (comm_group (option (ring ennreal))) := sorry --non-trivial
lemma new_lemma_124847 (h0 : uniform_space (uniform_space (random_gen to_additive.value_type))) : complete_space (uniform_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124848 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_124849 (h0 : topological_space (has_nndist (finset (has_zero pos)))) : regular_space (has_nndist (finset (has_zero pos))) := sorry --non-trivial
lemma new_lemma_124850 (h0 : topological_space (boolean_algebra.core (has_to_string congr_arg_kind))) : t0_space (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124851 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_124852 (h0 : complete_lattice (complete_distrib_lattice Type)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_124853 (h0 : topological_space (with_one fun_info)) : irreducible_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_124854 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) : id (id (with_bot.unbot h0 h1)) := sorry --non-trivial
lemma new_lemma_124855 (h0 : filter (add_cancel_monoid (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124856 (h0 : not (topological_space (normed_group unsigned) -> false)) : @normal_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_124857 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_124858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_124859 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_124860 (h0 : add_monoid (add_cancel_monoid (has_add pos))) : add_monoid.fg (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_124861 (h0 : ring (add_comm_monoid (boolean_algebra (comm_group pos)))) : strong_rank_condition (add_comm_monoid (boolean_algebra (comm_group pos))) := sorry --non-trivial
lemma new_lemma_124862 (h0 : not (add_group (left_cancel_semigroup num) -> false)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_124863 (h0 : functor.add_const (ring (plift num)) empty) : @is_domain.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_124864 (h0 : topological_space (semigroup congr_arg_kind)) : discrete_topology (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124865 (h1 : list (encodable to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_124866 (h0 : add_monoid (with_one (semiring (semiring (semiring empty))))) : add_monoid.fg (with_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_124867 (h0 : not (function.extfun (Type 1) complete_lattice -> false)) : @is_compactly_generated.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_124868 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : regular_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_124869 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_124870 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) unsigned) : @locally_compact_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124871 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_Inf Type))) : archimedean (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_124872 (h0 : topological_space (complete_semilattice_Sup (with_bot linarith.ineq))) : irreducible_space (complete_semilattice_Sup (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124873 (h1 : complete_lattice (add_comm_semigroup (mul_one_class (mul_one_class enat)))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_124874 (h0 : ring (ring (boolean_algebra environment.implicit_infer_kind))) : strong_rank_condition (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_124875 (h0 : group (has_inv string_imp)) : group.fg (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_124876 (h0 : monoid (has_zero (ring (has_neg linarith.comp)))) : monoid.fg (has_zero (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_124877 (h0 : ring (ring name)) : is_principal_ideal_ring (ring name) := sorry --non-trivial
lemma new_lemma_124878 (h0 : finset (has_add (ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_124879 (h0 : functor.add_const (functor.comp group has_neg_part ennreal) pos) : @group.fg.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_neg_part.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} has_neg_part.{0} ennreal) pos h0))  := sorry --non-trivial
lemma new_lemma_124880 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_add linarith.comp)) : @t1_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_124881 (h0 : add_monoid (measurable_space.dynkin_system num)) : add_monoid.fg (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_124882 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_inf.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_inf.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124883 (h0 : functor.comp ring semigroup pos) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_124884 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_124885 (h0 h1 : multiset (add_comm_semigroup enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_124886 (h0 : filter (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_124888 (h0 : functor.comp complete_lattice has_add pos) : @is_atomistic.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_124889 (h0 : topological_space (boolean_algebra (has_add Type))) : topological_space.separable_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_124890 (h0 : uniform_space (distrib std_gen)) (h1 : add_group (distrib std_gen)) : uniform_add_group (distrib std_gen) := sorry --non-trivial
lemma new_lemma_124891 (h0 : add_group (semiring (semiring (semiring (semiring (semiring unsigned)))))) : is_add_cyclic (semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_124892 (h0 : ring (semiring (has_norm (has_norm (has_norm (has_norm (has_norm to_additive.value_type))))))) : is_domain (semiring (has_norm (has_norm (has_norm (has_norm (has_norm to_additive.value_type)))))) := sorry --non-trivial
lemma new_lemma_124893 (h0 : topological_space (plift (semiring (semiring unsigned)))) : path_connected_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_124894 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_124895 (h0 : functor.add_const (uniform_space (ring Type)) Type) : @separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_124896 (h0 : functor.add_const (finset (has_nndist environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_124897 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @locally_compact_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 name))  := sorry --non-trivial
lemma new_lemma_124898 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @t0_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124899 (h0 : topological_space (option congr_arg_kind)) : preconnected_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_124900 (h0 : ring (complete_semilattice_Sup empty)) : is_principal_ideal_ring (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_124901 (h0 : functor.add_const (topological_space (finset Type)) ennreal) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_124902 (h0 : not (group (distrib_lattice linarith.ineq) -> false)) : @group.fg.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_124903 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string name)) (has_add Type)) : @archimedean.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_to_string.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_124904 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_124905 (h3 : has_lt string.iterator_imp) : no_max_order string.iterator_imp := sorry --non-trivial
lemma new_lemma_124906 (h0 : not (topological_space (div_inv_monoid linarith.ineq) -> false)) : @locally_compact_space.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_124907 (h0 : topological_space (linear_ordered_add_comm_group (normed_group linarith.ineq))) : t0_space (linear_ordered_add_comm_group (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124908 (h0 : add_group (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : is_add_cyclic (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_124909 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124910 (h0 : not (multiset (has_div reducibility_hints) -> false)) (h1 : multiset (has_div reducibility_hints)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_124911 (h0 : group (with_bot (semiring (semiring (semiring unsigned))))) : group.fg (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_124912 (h0 : group (ordered_ring (option (option (option (option empty)))))) : group.fg (ordered_ring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_124913 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_neg (has_neg linarith.comp))) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_neg.{0} (has_neg.{0} linarith.comp)) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_124914 (h1 : not (topological_space (has_lt linarith.comp_source) -> false)) : @t0_space.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_124915 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (fintype fun_info)))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm (fintype fun_info))) := sorry --non-trivial
lemma new_lemma_124916 (h0 : filter (option (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124917 (h0 : topological_space (semigroup (cancel_monoid name))) : preirreducible_space (semigroup (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_124918 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_124919 (h0 : add_group (has_append (mul_one_class char))) : is_add_cyclic (has_append (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_124920 (h0 : add_monoid (semiring (semiring (semiring (semiring (semiring unsigned)))))) : add_monoid.fg (semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_124921 (h0 : topological_space (with_one (has_ssubset to_additive.value_type))) : locally_compact_space (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124922 (h0 : filter (has_star congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124923 (h0 : topological_space (finset (has_neg Type))) : locally_compact_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_124924 (h0 : topological_space (has_to_string (add_right_cancel_monoid Type))) : path_connected_space (has_to_string (add_right_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_124925 (h0 : functor.comp complete_lattice add_cancel_monoid name) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_124926 (h0 : topological_space (boolean_algebra (boolean_algebra (has_to_string linarith.comp)))) : loc_path_connected_space (boolean_algebra (boolean_algebra (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_124927 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_124928 (h0 : ring (add_group pos)) : is_principal_ideal_ring (add_group pos) := sorry --non-trivial
lemma new_lemma_124929 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_124930 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : normal_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_124931 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (has_add pos))) : unique_factorization_monoid (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_124932 (h0 : functor.add_const (topological_space (has_Inf environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_124933 (h0 : filter (canonically_ordered_add_monoid (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124934 (h0 : prod (has_Sup (option (option empty))) (has_Sup (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_124935 (h1 : ring (has_norm (has_top (has_top to_additive.value_type)))) : is_domain (has_norm (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_124936 (h0 : group (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.comp_source))))) : is_cyclic (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_124937 (h0 : functor.add_const (group (boolean_algebra.core Type)) pos) : @group.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_124938 (h0 : ring (complete_linear_order (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_124939 (h0 : topological_space (has_Inf (has_add pos))) : path_connected_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_124940 (h0 : ring (cancel_monoid (comm_group (comm_group name)))) : strong_rank_condition (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_124941 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) ennreal) : @preconnected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_124942 (h0 : measurable_space (denumerable char)) (h1 : filter (denumerable char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_124943 (h0 : option Type) (h1 : ring (option.lhoare std_gen h0)) : rank_condition (option.lhoare std_gen h0) := sorry --non-trivial
lemma new_lemma_124944 (h0 : complete_lattice (complete_distrib_lattice (option (option ennreal)))) : is_atomistic (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_124945 (h0 : not (add_group (add_right_cancel_monoid num) -> false)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_124946 (h0 : topological_space (mul_zero_class (finset Type))) : t1_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_124947 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_124948 (h0 : ring (semi_normed_comm_ring fun_info)) : rank_condition (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_124949 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : irreducible_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_124950 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg name)) (comm_group name)) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_124951 (h0 : add_group (with_bot (has_norm linarith.comp))) : is_add_cyclic (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_124952 (h0 : not (complete_lattice (linear_ordered_semiring empty) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_124953 (h0 : topological_space (complete_distrib_lattice pos)) : discrete_topology (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_124954 (h1 : topological_space (nondiscrete_normed_field (normed_field (mul_one_class ereal)))) (h2 : preorder (nondiscrete_normed_field (normed_field (mul_one_class ereal)))) : order_topology (nondiscrete_normed_field (normed_field (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_124955 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) unsigned) : @discrete_topology.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124956 (h0 : list (normed_group (has_top (has_inv linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124957 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_124958 (h0 : topological_space (simple_graph (finset (finset pos)))) : discrete_topology (simple_graph (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_124959 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @normal_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_124960 (h0 : group (canonically_linear_ordered_monoid ennreal)) : normalizer_condition (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_124961 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_124962 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) linarith.comp) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_124963 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : topological_space.separable_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_124964 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_124965 (h0 : group (has_emptyc (random_gen fun_info))) : is_cyclic (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_124966 (h0 : semiring (add_comm_monoid (has_neg_part Type))) : is_noetherian_ring (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_124967 (h0 : ring (distrib_lattice (distrib char))) : strong_rank_condition (distrib_lattice (distrib char)) := sorry --non-trivial
lemma new_lemma_124968 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_124969 (h0 : add_group (normed_comm_ring linarith.comp_source)) : is_add_cyclic (normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_124970 (h0 : ring (denumerable (has_inv linarith.ineq))) : rank_condition (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124971 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) (finset pos)) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_124972 (h0 : topological_space (comm_ring to_additive.value_type)) : totally_disconnected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_124973 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_124974 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : discrete_topology (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_124975 (h0 : cancel_comm_monoid_with_zero (semigroup (ordered_comm_ring pos))) : unique_factorization_monoid (semigroup (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_124976 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : path_connected_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_124977 (h0 : functor.add_const (add_monoid (semigroup pos)) (has_neg environment.implicit_infer_kind)) : @add_monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_124978 (h0 : topological_space (complete_distrib_lattice ennreal)) : loc_path_connected_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_124979 (h0 : topological_space (has_neg std_gen)) : path_connected_space (has_neg std_gen) := sorry --non-trivial
lemma new_lemma_124980 (h0 : list (has_Inf (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_124981 (h0 : topological_space (boolean_algebra (has_add name))) : regular_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_124982 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_124983 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_124984 (h0 : topological_space (has_zero (has_neg_part pos))) : preirreducible_space (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_124985 (h0 : ring (dlist (has_ssubset to_additive.value_type))) : rank_condition (dlist (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124986 (h0 : list (distrib_lattice to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_124987 (h0 : filter (normed_group (has_nnnorm (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_124988 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_124989 (h0 : group (add_comm_monoid (has_add unsigned))) : group.fg (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_124990 (h1 : not (topological_space linarith.comp -> false)) : @locally_compact_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_124991 (h0 : functor.comp topological_space normed_comm_ring Type) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_124992 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_124993 (h0 : functor.add_const (group (has_Sup unsigned)) empty) : @normalizer_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_124994 (h0 : group (ring (finset (finset name)))) : normalizer_condition (ring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_124995 (h0 : topological_space (has_dist (option (option ennreal)))) : preirreducible_space (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_124996 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_124997 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_124998 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_124999 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_125000 (h0 : functor.comp topological_space has_neg_part Type) : @totally_disconnected_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_125001 (h0 : finset (has_add (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125002 (h0 : not (complete_lattice (measurable_space.dynkin_system empty) -> false)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125003 (h0 : ordered_add_comm_monoid (semigroup environment.implicit_infer_kind)) : archimedean (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_125004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_125005 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_125006 (h0 : set (mul_one_class string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_125007 (h0 : has_mem.mem (with_bot (has_top (has_top (has_top (has_top linarith.comp_source))))) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_125008 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_125009 (h0 : functor.add_const (topological_space (monoid empty)) unsigned) : @totally_separated_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125010 (h0 : topological_space (is_R_or_C (option (option (option unsigned))))) : normal_space (is_R_or_C (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_125011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_125012 (h0 : group (add_cancel_monoid (semiring (option empty)))) : group.fg (add_cancel_monoid (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_125013 (h0 : semiring (add_comm_semigroup linarith.ineq)) (h1 : ideal (add_comm_semigroup linarith.ineq)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_125014 (h0 : group (monoid (option ennreal))) : normalizer_condition (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_125015 (h0 : uniform_space (dlist (has_inv fun_info))) : complete_space (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_125016 (h0 : topological_space (has_norm (has_norm linarith.comp))) : preirreducible_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_125017 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : t0_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125018 (h0 : finset (normed_lattice_add_comm_group linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125019 (h0 : ring (linear_ordered_semiring (has_top congr_arg_kind))) : rank_condition (linear_ordered_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125020 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_125021 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (measurable_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125022 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : totally_separated_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_125023 (h1 : add_group (metric_space to_additive.value_type)) : is_add_cyclic (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125024 (h0 : ring (dlist (random_gen (random_gen to_additive.value_type)))) : strong_rank_condition (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_125025 (h0 : ring (has_compl char)) : strong_rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_125026 (h0 : topological_space (has_neg (finset linarith.comp))) : discrete_topology (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_125027 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125028 (h0 : ring (pseudo_metric_space empty)) : strong_rank_condition (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_125029 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_125030 (h0 : topological_space (has_star (semiring unsigned))) : totally_disconnected_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_125031 (h0 : group (has_emptyc (has_norm linarith.ineq))) : normalizer_condition (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125032 (h0 : topological_space (semigroup (has_to_string Type))) : regular_space (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_125033 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125034 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125035 (h0 : complete_lattice (add_cancel_monoid (has_neg pos))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_125036 (h0 : functor.add_const (ordered_comm_monoid (monoid pos)) pos) : @has_exists_mul_of_le.{0} (monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_125037 (h0 : ring ennreal) : strong_rank_condition ennreal := sorry --non-trivial
lemma new_lemma_125038 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup char))) : path_connected_space (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_125039 (h0 : uniform_space (metric_space congr_arg_kind)) : complete_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125040 (h1 : not (complete_lattice (semi_normed_comm_ring string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_125041 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125042 (h0 : ring (with_one (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : rank_condition (with_one (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_125043 (h0 : functor.add_const (filter (comm_group unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125044 (h0 : ring (random_gen (comm_ring linarith.ineq))) : rank_condition (random_gen (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125045 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_125046 (h0 : function.extfun Type group) : @group.fg.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_125047 (h0 : ring (semigroup (has_zero Type))) : rank_condition (semigroup (has_zero Type)) := sorry --non-trivial
lemma new_lemma_125048 (h0 : ring (distrib reducibility_hints)) : rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_125049 (h0 : functor.add_const (group (normed_comm_ring ennreal)) linarith.comp) : @group.fg.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125050 (h0 : topological_space (boolean_algebra (normed_comm_ring (has_add environment.implicit_infer_kind)))) : preconnected_space (boolean_algebra (normed_comm_ring (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_125051 (h0 : group (boolean_algebra.core (has_to_string (has_to_string (has_to_string num))))) : is_simple_group (boolean_algebra.core (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_125052 (h1 : not (topological_space (has_lt to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_125053 (h0 : prod (option ennreal) (option ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_125054 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : t0_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_125055 (h0 : add_group (measure_theory.measure_space (semiring num))) : is_add_cyclic (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_125056 (h0 : topological_space (has_bot (has_bot Type))) : path_connected_space (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_125057 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_125058 (h0 : ring (canonically_ordered_monoid (has_Inf Type))) : rank_condition (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_125059 (h0 : ordered_comm_monoid (ring (has_nndist linarith.comp))) : has_exists_mul_of_le (ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_125060 (h0 : group (linear_ordered_cancel_comm_monoid unsigned)) : is_cyclic (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_125061 (h0 : not (topological_space nnreal -> false)) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_125062 (h0 : group (id (semiring empty))) : group.fg (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_125063 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) pos) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_125064 (h0 : add_group (complete_distrib_lattice (has_add name))) : is_add_cyclic (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_125065 (h0 : topological_space (has_to_string (has_add name))) : totally_disconnected_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_125066 (h0 : group (ring (finset (has_to_string (ring (finset (ring Type))))))) : normalizer_condition (ring (finset (has_to_string (ring (finset (ring Type)))))) := sorry --non-trivial
lemma new_lemma_125067 (h0 : functor.add_const (ring (preorder unsigned)) unsigned) : @is_principal_ideal_ring.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125068 (h0 : ordered_add_comm_monoid (has_to_string (has_neg_part name))) : archimedean (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_125069 (h0 : finset (uniform_space num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125070 (h0 : filter (semi_normed_comm_ring linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125071 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (preorder num)) := sorry --non-trivial
lemma new_lemma_125072 (h0 : not (topological_space (has_div reducibility_hints) -> false)) : @t0_space.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_125073 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125074 (h0 : ring (semi_normed_comm_ring (distrib_lattice (has_top to_additive.value_type)))) : is_domain (semi_normed_comm_ring (distrib_lattice (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_125075 (h0 : has_mul (has_le (mul_one_class ereal))) (h2 : ring (con (has_le (mul_one_class ereal)))) : rank_condition (con (has_le (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_125076 (h1 : topological_space (add_monoid to_additive.value_type)) : totally_disconnected_space (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125077 (h0 : ring (complete_semilattice_Sup (has_norm congr_arg_kind))) : strong_rank_condition (complete_semilattice_Sup (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125078 (h0 : topological_space (has_inner empty empty)) : normal_space (has_inner empty empty) := sorry --non-trivial
lemma new_lemma_125079 (h0 : group (random_gen (has_inv ennreal))) : group.fg (random_gen (has_inv ennreal)) := sorry --non-trivial
lemma new_lemma_125080 (h0 : monoid (with_bot (has_norm to_additive.value_type))) : monoid.fg (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125081 (h0 : topological_space (is_R_or_C (semiring empty))) : loc_path_connected_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_125082 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_125083 (h0 : has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_125084 (h0 : list (has_add (finset environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125085 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_125086 (h0 : complete_lattice (has_Inf (has_Inf real))) : is_atomistic (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_125087 (h0 : uniform_space (semigroup (has_neg (has_pos_part linarith.comp)))) : separated_space (semigroup (has_neg (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_125088 (h0 : topological_space (finset (has_bot name))) : sequential_space (finset (has_bot name)) := sorry --non-trivial
lemma new_lemma_125089 (h0 : functor.add_const (add_group (has_neg linarith.comp)) name) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_125090 (h0 : fin has_zero.zero) : @path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_125091 (h0 : topological_space (has_norm (random_gen linarith.ineq))) : t0_space (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125092 (h0 : set (has_compl to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_125093 (h0 : topological_space (canonically_ordered_comm_semiring name)) : path_connected_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_125094 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (uniform_space.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (uniform_space.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125095 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_bot (has_Inf real)))))) : path_connected_space (has_pos_part (has_Inf (has_Inf (has_bot (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_125096 (h0 : uniform_space (has_inv (random_gen (random_gen linarith.ineq)))) : complete_space (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_125097 (h1 : filter (with_one (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_125098 (h0 : ordered_add_comm_monoid (has_star (option empty))) : archimedean (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_125099 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_125100 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125101 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_125102 (h0 : ring (linear_ordered_field reducibility_hints)) : is_domain (linear_ordered_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_125103 (h0 : finset (ring (option (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125104 (h0 : topological_space (partial_order congr_arg_kind)) : locally_compact_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125105 (h0 : functor.add_const (ring (ordered_cancel_add_comm_monoid empty)) num) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_cancel_add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_125106 (h0 : topological_space (normed_comm_ring (option (option empty)))) : t0_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_125107 (h0 : monoid (denumerable fun_info)) : monoid.fg (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_125108 (h0 : complete_lattice (has_compl (has_div enat))) : is_compactly_generated (has_compl (has_div enat)) := sorry --non-trivial
lemma new_lemma_125109 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_125110 (h0 : complete_lattice (dlist linarith.comp_source)) : is_compactly_generated (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125111 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_125112 (h0 : topological_space (has_neg pos)) : preirreducible_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_125113 (h1 : complete_lattice (with_one (has_top num))) : is_atomistic (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_125114 (h0 : functor.comp complete_lattice has_neg name) : @is_compactly_generated.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125115 (h0 : topological_space (has_bot (option (option empty)))) : totally_separated_space (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_125116 (h0 : ring (has_compl (mul_one_class string.iterator_imp))) : rank_condition (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_125117 (h0 : not (topological_space (linear_ordered_semiring empty) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125118 (h0 : functor.add_const (group (has_Inf pos)) name) : @is_simple_group.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_125119 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_125120 (h0 : not (uniform_space (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_125121 (h0 : topological_space (has_zero (has_neg_part name))) : irreducible_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_125122 (h0 : ring (complete_distrib_lattice (has_Inf Type))) : strong_rank_condition (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_125123 (h0 : topological_space (has_neg name)) : sequential_space (has_neg name) := sorry --non-trivial
lemma new_lemma_125124 (h0 : list (measurable_space (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125125 (h0 : functor.comp topological_space semigroup ennreal) : @regular_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_125126 (h0 : topological_space (has_nndist (mul_zero_class pos))) : preconnected_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_125127 (h0 : ring (uniform_space (mul_one_class string.iterator_imp))) : strong_rank_condition (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_125128 (h0 : uniform_space (with_bot (semiring (semiring congr_arg_kind)))) : complete_space (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125129 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125130 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : topological_space.separable_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_125131 (h0 : ordered_add_comm_monoid (has_nndist (has_add (has_add (has_add ennreal))))) : archimedean (has_nndist (has_add (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_125132 (h0 : add_group (comm_ring (has_lt char))) : is_add_cyclic (comm_ring (has_lt char)) := sorry --non-trivial
lemma new_lemma_125133 (h0 : topological_space (has_norm (has_nnnorm (random_gen (random_gen to_additive.value_type))))) : t0_space (has_norm (has_nnnorm (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_125134 (h0 : functor.comp topological_space has_neg_part name) : @t1_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125135 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : t1_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_125136 (h0 : topological_space (with_bot (semiring (semiring (semiring (semiring empty)))))) : preirreducible_space (with_bot (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_125137 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_125138 (h0 : functor.add_const (finset (boolean_algebra Type)) (has_Inf Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125139 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @regular_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_125140 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) unsigned) : @irreducible_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125141 (h0 : topological_space (has_norm (semiring linarith.comp))) : t0_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_125142 (h0 : ring (has_nnnorm (has_nnnorm reducibility_hints))) : rank_condition (has_nnnorm (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_125143 (h0 : topological_space (has_nnnorm (random_gen (has_le char)))) : t0_space (has_nnnorm (random_gen (has_le char))) := sorry --non-trivial
lemma new_lemma_125144 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_125145 (h0 : topological_space (add_comm_monoid (add_comm_monoid Type))) : preconnected_space (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_125146 (h0 : functor.add_const (topological_space (has_nndist unsigned)) linarith.comp) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125147 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125148 (h0 : topological_space (complete_distrib_lattice (finset ennreal))) : topological_space.separable_space (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_125149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125150 (h0 : functor.add_const (add_monoid (simple_graph Type)) name) : @add_monoid.fg.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (simple_graph.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_125151 (h0 : uniform_space (measurable_space (random_gen empty))) : complete_space (measurable_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_125152 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @normal_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125153 (h0 : list (id (has_inv linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125154 (h0 : topological_space (encodable (distrib_lattice (random_gen (has_nnnorm fun_info))))) : path_connected_space (encodable (distrib_lattice (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_125155 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125156 (h0 : set (has_subset string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_125157 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid pos)) (boolean_algebra linarith.comp)) : @archimedean.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_125158 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_125159 (h0 : topological_space (has_lt (mul_one_class enat))) : t0_space (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_125160 (h0 : has_lt bool) : no_max_order bool := sorry --non-trivial
lemma new_lemma_125161 (h0 : functor.add_const (filter (has_Inf pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125162 (h0 : filter (comm_monoid (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125163 (h0 : uniform_space (fintype char)) : complete_space (fintype char) := sorry --non-trivial
lemma new_lemma_125164 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_add (has_add real))))))) : irreducible_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_add (has_add real)))))) := sorry --non-trivial
lemma new_lemma_125165 (h0 : list (bin_tree (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125166 (h1 : topological_space (has_nnnorm (random_gen string_imp))) : path_connected_space (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_125167 (h0 : topological_space (sub_neg_monoid (has_Inf (sub_neg_monoid real)))) : sequential_space (sub_neg_monoid (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_125168 (h0 : ordered_comm_monoid (has_zero (has_well_founded linarith.comp))) : has_exists_mul_of_le (has_zero (has_well_founded linarith.comp)) := sorry --non-trivial
lemma new_lemma_125169 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_neg_part pos)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_125170 (h0 : add_group (normed_linear_ordered_group num)) : is_add_cyclic (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_125171 (h0 : functor.add_const (add_group (has_to_string name)) name) : @is_add_cyclic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_125172 (h0 : finset (has_neg (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125173 (h0 : topological_space (topological_space (mul_one_class reducibility_hints))) : t0_space (topological_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_125174 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_125175 (h0 : uniform_space (has_nndist (has_add ennreal))) : complete_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_125176 (h0 : ring (ordered_comm_monoid (has_neg linarith.comp))) : is_principal_ideal_ring (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_125177 (h0 : group (add_comm_monoid (has_nndist linarith.comp))) : is_simple_group (add_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_125178 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid pos))) : totally_separated_space (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_125179 (h0 : function.extfun Type (functor.comp semiring normed_comm_ring)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} normed_comm_ring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} normed_comm_ring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_125180 (h0 : topological_space (ordered_comm_ring (ring Type))) : totally_separated_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_125181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125182 (h0 : filter (add_cancel_monoid (has_to_string environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_125183 (h0 : functor.add_const (complete_lattice (has_nndist name)) linarith.comp) : @is_atomistic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125184 (h0 : complete_lattice (add_cancel_monoid ennreal)) : is_atomistic (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_125185 (h0 : complete_lattice (has_compl (random_gen fun_info))) : is_compactly_generated (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_125186 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_125187 (h0 : functor.add_const (add_group (preorder num)) num) : @is_add_cyclic.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_125188 (h0 : function.extfun Type (functor.comp topological_space finset)) : @totally_separated_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_125189 (h0 : uniform_space (add_cancel_monoid (has_add (normed_comm_ring (add_comm_monoid (comm_group Type)))))) : separated_space (add_cancel_monoid (has_add (normed_comm_ring (add_comm_monoid (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_125190 (h0 : function.extfun Type group) : @is_simple_group.{0} (option.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_125191 (h0 : topological_space (normed_group (random_gen (has_norm fun_info)))) : locally_compact_space (normed_group (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_125192 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class reducibility_hints)))) : t0_space (uniform_space (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_125193 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring unsigned)) := sorry --non-trivial
lemma new_lemma_125194 (h0 : not (ring (has_append string.iterator_imp) -> false)) : @rank_condition.{0} (has_append.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_125195 (h0 : list (semigroup (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125196 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @monoid.fg.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125197 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) (has_neg Type)) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_125198 (h0 : filter (add_right_cancel_monoid (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125199 (h0 : fin has_zero.zero) : @separated_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_125200 (h0 : ring (id (mul_one_class string.iterator_imp))) : rank_condition (id (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_125201 (h0 : functor.comp topological_space finset Type) : @t1_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_125202 (h0 : group (measurable_space linarith.comp_source)) : group.fg (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125203 (h0 : not (has_mem.mem (normed_group fun_info) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_125204 (h0 : topological_space (boolean_algebra (semigroup (has_add linarith.comp)))) : regular_space (boolean_algebra (semigroup (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_125205 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_125206 (h0 : topological_space (has_well_founded unsigned)) : t1_space (has_well_founded unsigned) := sorry --non-trivial
lemma new_lemma_125207 (h0 : ring (with_one fun_info)) : rank_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_125208 (h0 : group (omega_complete_partial_order unsigned)) : normalizer_condition (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_125209 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_125210 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_125211 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_125212 (h0 : complete_lattice (simple_graph (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (simple_graph (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_125213 (h0 : ring (uniform_space (mul_one_class string_imp))) : strong_rank_condition (uniform_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_125214 (h3 : add_group (distrib to_additive.value_type)) : is_add_cyclic (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125215 (h0 : cancel_comm_monoid_with_zero (distrib linarith.ineq)) : unique_factorization_monoid (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_125216 (h0 : finset (boolean_algebra (has_to_string pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125217 (h0 : functor.add_const (list (boolean_algebra Type)) (has_neg linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125218 (h0 : topological_space (id (has_norm (has_norm num)))) : t0_space (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_125219 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : path_connected_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125220 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_125221 (h0 : functor.add_const (topological_space (has_bot empty)) (semiring (semiring empty))) : @totally_separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125222 (h0 : monoid (has_emptyc (has_norm num))) : monoid.fg (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_125223 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125224 (h0 : uniform_space (with_bot (has_norm linarith.comp_source))) : separated_space (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125225 (h0 : complete_lattice (has_neg (comm_group unsigned))) : is_atomistic (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_125226 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_125227 (h0 : add_monoid (with_one (semiring (semiring (has_norm num))))) : add_monoid.fg (with_one (semiring (semiring (has_norm num)))) := sorry --non-trivial
lemma new_lemma_125228 (h0 : group (bin_tree (semiring (semiring congr_arg_kind)))) : is_cyclic (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125229 (h0 : functor.add_const (topological_space (has_bot unsigned)) unsigned) (h1 : functor.add_const (measurable_space (has_bot unsigned)) congr_arg_kind) : @opens_measurable_space.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} unsigned)) unsigned h0) (@functor.add_const.run.{0 0} (measurable_space.{0} (has_bot.{0} unsigned)) congr_arg_kind h1)  := sorry --non-trivial
lemma new_lemma_125230 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_125231 (h0 : complete_lattice (option (semiring (semiring (semiring num))))) : is_atomistic (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_125232 (h1 : topological_space (with_bot linarith.comp_source) -> Prop) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@classical.epsilon.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) (@nonempty_of_inhabited.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) (@inhabited_topological_space.{0} (with_bot.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_125233 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_125234 (h0 h1 : multiset (semi_normed_comm_ring string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_125235 (h0 : complete_lattice (boolean_algebra pos)) : is_atomistic (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_125236 (h0 : topological_space (metric_space (semiring empty))) : t1_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_125237 (h0 : group (has_pos_part (finset (has_neg (has_pos_part pos))))) : normalizer_condition (has_pos_part (finset (has_neg (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_125238 (h0 : topological_space (has_nndist (finset linarith.comp))) : irreducible_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_125239 (h0 : ring (nondiscrete_normed_field reducibility_hints)) : strong_rank_condition (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_125240 (h0 : topological_space (option (semiring unsigned))) : discrete_topology (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_125241 (h0 : topological_space (monoid ennreal)) : totally_separated_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_125242 (h0 : finset (boolean_algebra (has_Inf (finset (has_pos_part (has_Inf (has_add (boolean_algebra pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125243 (h0 : not (topological_space (plift empty) -> false)) : @totally_separated_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125244 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_Inf pos)) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_125245 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (finset pos))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_125246 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_125247 (h0 : cancel_comm_monoid_with_zero (has_add (has_Inf real))) : unique_factorization_monoid (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_125248 (h2 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : is_compactly_generated (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125249 (h0 : topological_space (has_nndist (comm_group unsigned))) : preconnected_space (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_125250 (h0 : function.extfun Type (functor.add_const (topological_space (linear_order empty)))) : @locally_compact_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_125251 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : set (linear_ordered_comm_group_with_zero string.iterator_imp)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_125252 (h0 : functor.add_const (topological_space (has_neg_part name)) pos) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_125253 (h0 : not (ring (option congr_arg_kind) -> false)) : @strong_rank_condition.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125254 (h0 : not (topological_space linarith.comp -> false)) : @irreducible_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_125255 (h0 : ordered_comm_ring (has_bot name) -> ordered_comm_ring (has_bot name) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_125256 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125257 (h0 : functor.add_const (function.extfun (Type 1) group) (has_Inf (ring pos))) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_Inf.{0} (ring.{0} pos)) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_125258 (h0 : uniform_space (finset (has_zero linarith.comp))) : complete_space (finset (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_125259 (h0 : ring (has_neg_part unsigned)) : is_domain (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_125260 (h0 : filter (ordered_comm_monoid (ring pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_125261 (h0 : functor.add_const (semiring (ordered_comm_monoid Type)) pos) : @is_noetherian_ring.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_125262 (h0 : functor.add_const (group pos) environment.implicit_infer_kind) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125263 (h0 : topological_space (semigroup (has_add pos))) : locally_compact_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_125264 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_125265 (h0 : list (comm_group (comm_group (comm_group pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125266 (h0 : uniform_space (mul_zero_class (has_add (finset (group_with_zero (has_to_string (has_add Type))))))) : complete_space (mul_zero_class (has_add (finset (group_with_zero (has_to_string (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_125267 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_125268 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_125269 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125270 (h0 : not (ring (add_cancel_comm_monoid reducibility_hints) -> false)) : @is_domain.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_125271 (h0 : topological_space (has_norm (has_norm (has_norm empty)))) : discrete_topology (has_norm (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_125272 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_125273 (h0 : topological_space (has_nndist congr_arg_kind)) : path_connected_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125274 (h0 : ring (has_div (has_nnnorm enat))) : is_domain (has_div (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_125275 (h0 : group (bin_tree (semiring (semiring (semiring congr_arg_kind))))) : group.fg (bin_tree (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_125276 (h0 : monoid (has_emptyc (has_norm linarith.comp_source))) : monoid.fg (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125277 (h0 : group (random_gen (has_top (has_top (has_nnnorm fun_info))))) : group.fg (random_gen (has_top (has_top (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_125278 (h0 : topological_space (has_Inf (ordered_ring linarith.comp))) : locally_compact_space (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_125279 (h0 : ordered_add_comm_monoid (semigroup (comm_group (comm_group (has_to_string Type))))) : archimedean (semigroup (comm_group (comm_group (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_125280 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_125281 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125282 (h0 : ring (has_div (mul_one_class fun_info))) : rank_condition (has_div (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_125283 (h0 : filter (cancel_monoid (option (option (option pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125284 (h0 : topological_space (has_nndist (has_to_string environment.implicit_infer_kind))) : topological_space.separable_space (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_125285 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_125286 (h0 : functor.add_const (ring (has_to_string Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_125288 (h0 : functor.add_const (topological_space (mul_zero_class Type)) pos) : @preirreducible_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_125289 (h0 : ordered_comm_monoid (has_pos_part (finset linarith.comp))) : has_exists_mul_of_le (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_125290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125291 (h0 : topological_space (mul_one_class (mul_one_class ereal))) : path_connected_space (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_125292 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) : t0_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_125293 (h0 : add_monoid (has_norm num)) (h1 : has_norm num) : is_of_fin_add_order h1 := sorry --non-trivial
lemma new_lemma_125294 (h1 : topological_space linarith.comp) : path_connected_space linarith.comp := sorry --non-trivial
lemma new_lemma_125295 (h0 : functor.add_const (functor.add_const (group pos) unsigned) (option pos)) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) unsigned) (option.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_125296 (h0 : ring (has_one (has_norm (semiring empty)))) : rank_condition (has_one (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_125297 (h0 : topological_space (has_norm fun_info)) : t0_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_125298 (h0 : complete_lattice (semiring linarith.ineq)) : is_compactly_generated (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_125299 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_125300 (h0 : topological_space (has_zero (cancel_monoid name))) : sequential_space (has_zero (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_125301 (h1 : multiset (non_unital_non_assoc_semiring ereal)) (h2 : not (multiset (non_unital_non_assoc_semiring ereal) -> false)) : multiset.disjoint h1 (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_125302 (h0 : monoid (generalized_boolean_algebra (has_Inf (finset (has_nndist name))))) : monoid.fg (generalized_boolean_algebra (has_Inf (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_125303 (h0 : topological_space (ordered_comm_ring (has_neg (has_add linarith.comp)))) : preirreducible_space (ordered_comm_ring (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_125304 (h0 : functor.add_const (ring (has_add pos)) (has_zero (has_zero name))) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) (has_zero.{0} (has_zero.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_125305 (h0 : semiring (canonically_ordered_monoid (has_Inf pos))) : is_noetherian_ring (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_125306 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_125307 (h0 : topological_space (has_union (has_top congr_arg_kind))) : path_connected_space (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125308 (h0 : topological_space (group_with_zero unsigned)) : irreducible_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_125309 (h0 : functor.add_const (list (has_to_string Type)) (ring linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125310 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @totally_disconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_125311 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) name) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_125312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125313 (h0 : ring (has_to_string congr_arg_kind)) : strong_rank_condition (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125314 (h1 : ring string.iterator) : is_domain string.iterator := sorry --non-trivial
lemma new_lemma_125315 (h0 : functor.add_const (monoid (mul_zero_class pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (mul_zero_class.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125316 (h0 : complete_lattice (random_gen unsigned)) : is_atomistic (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_125317 (h0 : functor.add_const (comm_ring (canonically_linear_ordered_monoid unsigned)) pos) : @local_ring.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (comm_ring.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_125318 (h0 : topological_space (has_one (has_norm linarith.comp))) : normal_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_125319 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @locally_compact_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125320 (h0 : topological_space (has_neg (has_nndist Type))) : locally_compact_space (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_125321 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_125322 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : preconnected_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_125323 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_125324 (h0 : uniform_space (has_norm (random_gen string_imp))) : complete_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_125325 (h1 : ring (has_ssubset fun_info)) : is_domain (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_125326 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125327 (h0 : finset (complete_distrib_lattice (has_to_string (finset environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125328 (h0 : prod (has_nndist pos) (has_nndist pos)) : set.diagonal (has_nndist pos) h0 := sorry --non-trivial
lemma new_lemma_125329 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_125330 (h0 : not (prod (has_star empty) (has_star empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_125331 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen unsigned))) : @is_add_cyclic.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125332 (h1 : not (monoid (measurable_space fun_info) -> false)) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_125333 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf Type)))) : normal_space (add_cancel_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_125334 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) (has_neg (has_add environment.implicit_infer_kind))) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) (has_neg.{0} (has_add.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125335 (h0 : functor.add_const (function.extfun (Type 1) add_group) pos) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_125336 (h0 : finset (has_to_string (has_neg (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125337 (h0 : not (ring (has_emptyc fun_info) -> false)) : @is_domain.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_125338 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_125339 (h0 : add_group (boolean_algebra (has_add real))) : is_add_cyclic (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_125340 (h0 : topological_space (pseudo_metric_space (boolean_algebra linarith.comp))) : regular_space (pseudo_metric_space (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_125341 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_125342 (h0 : add_group (has_compl (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (has_compl (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_125343 (h0 : group (has_nndist (has_to_string (comm_group (has_to_string (comm_group pos)))))) : is_simple_group (has_nndist (has_to_string (comm_group (has_to_string (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_125344 (h0 : function.extfun Type (functor.add_const (ring (free_add_monoid unsigned)))) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (free_add_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_125345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_125346 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_125347 (h0 : not (list (id empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_125348 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) ring.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_125349 (h0 : group linarith.comp) : is_simple_group linarith.comp := sorry --non-trivial
lemma new_lemma_125350 (h0 : uniform_space (with_one (has_norm fun_info))) : complete_space (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_125351 (h0 : not (group (semi_normed_ring fun_info) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_125352 (h0 : function.extfun Type group) : @group.fg.{0} (has_bot.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_125353 (h0 : topological_space (cancel_monoid (mul_zero_class (has_add (ring name))))) : preirreducible_space (cancel_monoid (mul_zero_class (has_add (ring name)))) := sorry --non-trivial
lemma new_lemma_125354 (h0 : group (has_neg (has_to_string (has_to_string num)))) : is_simple_group (has_neg (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_125355 (h0 : topological_space (denumerable (denumerable (random_gen (random_gen string_imp))))) : irreducible_space (denumerable (denumerable (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_125356 (h0 : ring (ordered_comm_semiring (random_gen linarith.comp_source))) : strong_rank_condition (ordered_comm_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125357 (h1 : measurable_space (normed_field linarith.ineq)) (h2 : filter (normed_field linarith.ineq)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_125358 (h0 : topological_space (topological_space linarith.ineq)) : totally_disconnected_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_125359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_125360 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_125361 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125362 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) pos) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_125363 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_125364 (h0 : group (has_nndist (finset environment.implicit_infer_kind))) : is_cyclic (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_125365 (h2 : topological_space (add_comm_semigroup linarith.ineq)) (h3 : set (set (add_comm_semigroup linarith.ineq))) : topological_space.is_topological_basis h3 := sorry --non-trivial
lemma new_lemma_125366 (h1 : topological_space (distrib (has_add to_additive.value_type))) : totally_disconnected_space (distrib (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125367 (h1 : ring (add_monoid to_additive.value_type)) : strong_rank_condition (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125368 (h0 : functor.add_const (monoid (boolean_algebra name)) name) : @monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_125369 (h0 : group (complete_semilattice_Sup linarith.comp_source)) : group.fg (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125370 (h0 : functor.comp group canonically_ordered_comm_semiring name) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125371 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_125372 (h0 : complete_lattice (partial_order (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125373 (h0 : functor.comp ordered_comm_monoid boolean_algebra.core pos) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_125374 (h0 : group (semi_normed_comm_ring to_additive.value_type)) : is_cyclic (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125375 (h3 : topological_space linarith.ineq) : t0_space linarith.ineq := sorry --non-trivial
lemma new_lemma_125376 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring pos)) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_125377 (h0 : topological_space (add_group congr_arg_kind)) : topological_space.separable_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125378 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_125379 (h0 : topological_space (cancel_monoid Type)) : normal_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_125380 (h0 : topological_space char) (h1 : has_sub char) : has_continuous_sub char := sorry --non-trivial
lemma new_lemma_125381 (h0 : complete_lattice (has_nndist (has_neg_part Type))) : is_compactly_generated (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_125382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_125383 (h0 : functor.add_const (group (sub_neg_monoid name)) linarith.comp) : @is_cyclic.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125384 (h0 : list (with_one (comm_ring (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125385 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : preconnected_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_125386 (h0 : topological_space (normed_comm_ring (has_neg (finset linarith.comp)))) : path_connected_space (normed_comm_ring (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_125387 (h0 : topological_space (has_bot (ordered_comm_monoid (ordered_comm_monoid (has_Inf real))))) : irreducible_space (has_bot (ordered_comm_monoid (ordered_comm_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_125388 (h0 : topological_space (normed_comm_ring (comm_group (comm_group name)))) : normal_space (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_125389 (h0 : function.extfun nat fin) : @rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_125390 (h0 : list (random_gen (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125391 (h0 : ring (distrib (random_gen char))) : is_domain (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_125392 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_125393 (h0 : functor.add_const (filter (has_to_string unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125394 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) (option empty)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_125395 (h0 : functor.add_const (group (has_neg linarith.comp)) (has_neg pos)) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_125396 (h0 : add_group (has_bot (has_bot (canonically_linear_ordered_monoid (has_add real))))) : is_add_cyclic (has_bot (has_bot (canonically_linear_ordered_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_125397 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg linarith.comp)) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_125398 (h0 : has_lt (semi_normed_ring std_gen)) : no_max_order (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_125399 (h0 : topological_space (complete_distrib_lattice Type)) : regular_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_125400 (h0 : ring (non_unital_non_assoc_ring char)) : rank_condition (non_unital_non_assoc_ring char) := sorry --non-trivial
lemma new_lemma_125401 (h0 : function.extfun Type uniform_space) (h1 : add_group (has_norm linarith.ineq)) : @uniform_add_group.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} linarith.ineq)) h1  := sorry --non-trivial
lemma new_lemma_125402 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : locally_compact_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_125403 (h0 : list (complete_semilattice_Sup (has_top string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125404 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125405 (h0 : functor.comp ring mul_zero_class name) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125406 (h0 : topological_space (add_comm_monoid (option pos))) : irreducible_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_125407 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_125408 (h0 : functor.add_const (group pos) (has_neg (has_zero Type))) : @is_cyclic.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) (has_neg.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_125409 (h0 : add_monoid (partial_order (semiring (semiring (semiring (semiring empty)))))) : add_monoid.fg (partial_order (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_125410 (h1 : uniform_space (semiring fun_info)) : complete_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_125411 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_125412 (h0 : ring (has_Sup unsigned)) : is_domain (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_125413 (h0 : uniform_space (add_cancel_monoid (has_add pos))) : complete_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_125414 (h0 : topological_space (pseudo_metric_space (option (option ennreal)))) : locally_compact_space (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_125415 (h0 : group (topological_space (comm_ring (has_pos_part fun_info)))) : group.fg (topological_space (comm_ring (has_pos_part fun_info))) := sorry --non-trivial
lemma new_lemma_125416 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125417 (h0 : topological_space (distrib_lattice linarith.ineq)) : t0_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_125418 (h0 : prod (has_inter (option empty)) (has_inter (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_125419 (h0 : ring (semigroup (has_neg name))) : is_domain (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_125420 (h1 : ring (normed_group (with_one string_imp))) : is_domain (normed_group (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_125421 (h0 : complete_lattice (has_add (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_125422 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @regular_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_125423 (h0 : cancel_comm_monoid_with_zero (has_nndist num)) : unique_factorization_monoid (has_nndist num) := sorry --non-trivial
lemma new_lemma_125424 (h0 : finset nnreal) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125425 (h0 : topological_space (has_nndist (has_to_string Type))) : totally_disconnected_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_125426 (h0 : finset (mul_zero_class ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125427 (h0 : ring (has_top (random_gen (has_inv (has_inv fun_info))))) : rank_condition (has_top (random_gen (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_125428 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_125429 (h0 : measurable_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen (random_gen char)))))) (h1 : measure_theory.measure (add_cancel_comm_monoid (random_gen (random_gen (random_gen (random_gen char)))))) (h2 : filter (add_cancel_comm_monoid (random_gen (random_gen (random_gen (random_gen char)))))) : measure_theory.measure.finite_at_filter h1 h2 := sorry --non-trivial
lemma new_lemma_125430 (h0 : complete_lattice (ordered_comm_semiring (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (ordered_comm_semiring (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_125431 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @sequential_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_125432 (h0 : topological_space (distrib char)) (h1 : not (preorder (distrib char) -> false)) : @order_topology.{0} (distrib.{0} char) h0 (@classical.by_contradiction'.{1} (preorder.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_125433 (h0 : ring (has_zero (finset (has_neg linarith.comp)))) : strong_rank_condition (has_zero (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_125434 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) linarith.comp) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125435 (h0 : ring (has_norm (has_norm linarith.comp))) : rank_condition (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_125436 (h0 : functor.add_const (group (comm_group linarith.comp)) (has_neg (normed_comm_ring Type))) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} linarith.comp)) (has_neg.{1} (normed_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_125437 (h0 : function.extfun Type (functor.add_const (group (ring linarith.comp)))) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (ring.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_125438 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) Type) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_125439 (h0 : ring (boolean_algebra (has_neg Type))) : is_principal_ideal_ring (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_125440 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125441 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125442 (h0 : prod (complete_semilattice_Sup unsigned) (complete_semilattice_Sup unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_125443 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_125444 (h0 : ordered_add_comm_monoid (boolean_algebra (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : archimedean (boolean_algebra (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_125445 (h3 : complete_lattice (distrib_lattice fun_info)) : is_compactly_generated (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_125446 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (has_neg_part Type)) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_125447 (h0 : list (ordered_comm_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125448 (h0 : ring (random_gen (comm_ring string_imp))) : rank_condition (random_gen (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_125449 (h0 : functor.comp topological_space has_add pos) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_125450 (h0 : topological_space (boolean_algebra.core name)) : normal_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_125451 (h0 : topological_space (ring name)) : loc_path_connected_space (ring name) := sorry --non-trivial
lemma new_lemma_125452 (h0 : functor.add_const (finset (has_add pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125453 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125454 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125455 (h0 : ring (topological_space (random_gen fun_info))) : strong_rank_condition (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_125456 (h0 : ordered_add_comm_monoid (simple_graph (has_Inf linarith.comp))) : archimedean (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_125457 (h0 : topological_space (finset name)) : irreducible_space (finset name) := sorry --non-trivial
lemma new_lemma_125458 (h0 : set (has_lt string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_125459 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_125460 (h0 : functor.comp ordered_comm_monoid ring Type) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} ordered_comm_monoid.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_125461 (h0 : not (filter (fintype fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_125462 (h0 : topological_space (cancel_monoid (option (comm_monoid unsigned)))) : normal_space (cancel_monoid (option (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_125463 (h0 : functor.add_const (filter (has_neg linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125464 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) name) : @rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_125465 (h0 : list (has_dist empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125466 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_125467 (h0 : functor.add_const (uniform_space (has_neg unsigned)) name) : @complete_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_125468 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_125469 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_125470 (h1 : filter (has_add (has_inv (has_ssubset char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_125471 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125472 (h2 : add_group (encodable linarith.comp_source)) : is_add_cyclic (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125473 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_125474 (h0 : functor.add_const (ordered_comm_monoid Type) (comm_group pos)) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_125475 (h0 : uniform_space (has_Inf (ring name))) : separated_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_125476 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @normalizer_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125477 (h0 : group (mul_zero_class (semiring unsigned))) : is_cyclic (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_125478 (h0 : topological_space (measurable_space (has_union (id linarith.comp)))) : path_connected_space (measurable_space (has_union (id linarith.comp))) := sorry --non-trivial
lemma new_lemma_125479 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_125480 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_125481 (h0 : ring (topological_space (has_ssubset linarith.ineq))) : rank_condition (topological_space (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125482 (h0 : ring (has_ssubset (has_nnnorm reducibility_hints))) : strong_rank_condition (has_ssubset (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_125483 (h1 : topological_space (normed_field (random_gen (uniform_space reducibility_hints)))) : t0_space (normed_field (random_gen (uniform_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_125484 (h0 : complete_lattice (has_lt (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_125485 (h0 : functor.add_const (group (boolean_algebra.core Type)) Type) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_125486 (h0 : ring (normed_group (has_top fun_info))) : strong_rank_condition (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_125487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125488 (h0 : functor.add_const (group (has_Sup empty)) (semiring empty)) : @normalizer_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_125489 (h0 : complete_lattice (cancel_monoid pos)) : complete_lattice.is_Sup_finite_compact (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_125490 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @topological_space.separable_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_125491 (h0 : ring (has_Sup (semiring congr_arg_kind))) : is_principal_ideal_ring (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125492 (h0 : ring (has_Inf (has_pos_part (has_add (ring linarith.comp))))) : rank_condition (has_Inf (has_pos_part (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_125493 (h0 : filter (has_one (has_norm (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125494 (h0 : not (ring (measurable_space congr_arg_kind) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125495 (h3 : add_group char) : is_add_cyclic char := sorry --non-trivial
lemma new_lemma_125496 (h0 : topological_space (has_Inf (has_neg (has_neg pos)))) : irreducible_space (has_Inf (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_125497 (h0 : functor.add_const (function.extfun (Type 1) list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_125498 (h0 : topological_space (semigroup (complete_distrib_lattice pos))) : totally_disconnected_space (semigroup (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_125499 (h0 : complete_lattice (linear_ordered_comm_ring congr_arg_kind)) : is_atomistic (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125500 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : sequential_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_125501 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_to_string)) : @has_exists_mul_of_le.{0} (has_to_string.{0} ennreal) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_125502 (h0 : topological_space (semi_normed_ring (mul_one_class linarith.comp_source))) : t0_space (semi_normed_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125503 (h0 : functor.add_const (complete_lattice znum) (option unsigned)) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_125504 (h2 : uniform_space (with_one num)) : complete_space (with_one num) := sorry --non-trivial
lemma new_lemma_125505 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) environment.implicit_infer_kind) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125506 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_125507 (h0 : complete_lattice (normed_group (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125508 (h0 : topological_space (has_nndist (has_neg (has_add Type)))) : locally_compact_space (has_nndist (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_125509 (h0 : ring (comm_ring (has_ssubset string_imp))) : is_domain (comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_125510 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_125511 (h0 : functor.add_const Prop (normed_group unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_125512 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (ring Type)) := sorry --non-trivial
lemma new_lemma_125513 (h0 : topological_space (has_neg_part (has_nndist (has_nndist ennreal)))) : locally_compact_space (has_neg_part (has_nndist (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_125514 (h0 : has_le (complete_semilattice_Sup (with_bot string_imp))) (h1 : bounded_order (complete_semilattice_Sup (with_bot string_imp))) : is_simple_order (complete_semilattice_Sup (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_125515 (h0 : list (plift unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125516 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125517 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_125518 (h2 : ring (simple_graph environment.projection_info)) : is_domain (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_125519 (h0 : functor.add_const (ring (cancel_monoid pos)) ennreal) : @is_domain.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_125520 (h0 : topological_space (has_zero (finset (has_to_string linarith.comp)))) : totally_disconnected_space (has_zero (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_125521 (h0 : ring (has_norm congr_arg_kind)) : is_domain (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125522 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) linarith.comp) : @t0_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125523 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125524 (h0 : add_monoid (has_dist (option ennreal))) : add_monoid.fg (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_125525 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_125526 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125527 (h0 : topological_space (has_norm (has_top fun_info))) : totally_separated_space (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_125528 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_125529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_125530 (h0 : topological_space (ordered_comm_monoid (ring (ring linarith.comp)))) : irreducible_space (ordered_comm_monoid (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_125531 (h0 : functor.add_const (function.extfun Type uniform_space) (mul_one_class Type)) : @complete_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (mul_one_class.{1} Type) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_125532 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_125533 (h0 : topological_space (denumerable (random_gen fun_info))) : totally_separated_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_125534 (h0 : topological_space (has_nndist (has_to_string (finset pos)))) : t1_space (has_nndist (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_125535 (h0 : function.extfun Type uniform_space) : @separated_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_125536 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_bot empty)) := sorry --non-trivial
lemma new_lemma_125537 (h0 : functor.add_const (ring (normed_linear_ordered_group num)) unsigned) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125538 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_125539 (h0 : uniform_space (non_unital_non_assoc_semiring string_imp)) : complete_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_125540 (h0 : group (has_neg (ring Type))) : is_simple_group (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_125541 (h0 : functor.add_const (list (mul_zero_class pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125542 (h0 : functor.add_const (topological_space (ring Type)) Type) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_125543 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid (sub_neg_monoid real)))) : locally_compact_space (ordered_comm_monoid (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_125544 (h1 : group (semiring (has_emptyc linarith.ineq))) : group.fg (semiring (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125545 (h1 : ring (denumerable linarith.ineq)) : strong_rank_condition (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_125546 (h0 : topological_space (has_pos_part (has_Inf (has_neg (has_Inf linarith.comp))))) : discrete_topology (has_pos_part (has_Inf (has_neg (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_125547 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @t1_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_125548 (h0 : group (linear_ordered_cancel_comm_monoid unsigned)) : group.fg (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_125549 (h0 : complete_lattice (complete_distrib_lattice (finset name))) : is_compactly_generated (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_125550 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (comm_group (has_neg_part pos))) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (comm_group.{0} (has_neg_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_125551 (h0 : topological_space (add_comm_monoid (boolean_algebra name))) : t0_space (add_comm_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_125552 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_125553 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) real) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_125554 (h0 : topological_space (has_add pos)) : t0_space (has_add pos) := sorry --non-trivial
lemma new_lemma_125555 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125556 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125557 (h0 : has_mul (comm_group (has_to_string Type))) (h1 : functor.add_const (comm_group (has_to_string Type)) linarith.comp) : is_regular (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_125558 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_125559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_125560 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_125561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ring name)) := sorry --non-trivial
lemma new_lemma_125562 (h0 : set (mul_one_class ereal -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_125563 (h0 : group (linear_ordered_semiring (has_norm (has_norm (has_norm linarith.comp))))) : is_cyclic (linear_ordered_semiring (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_125564 (h0 : topological_space (finset (has_pos_part real))) : irreducible_space (finset (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_125565 (h0 : ring (has_add (has_to_string (has_to_string (has_neg ennreal))))) : strong_rank_condition (has_add (has_to_string (has_to_string (has_neg ennreal)))) := sorry --non-trivial
lemma new_lemma_125566 (h0 : ring (has_star (semiring unsigned))) : is_domain (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_125567 (h0 : functor.add_const (group (ring name)) Type) : @normalizer_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_125568 (h0 : topological_space (has_add (has_bot linarith.comp))) : preirreducible_space (has_add (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_125569 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_125570 (h0 : topological_space (measurable_space (semiring empty))) : t0_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_125571 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_125572 (h0 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : path_connected_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_125573 (h0 : uniform_space int) : complete_space int := sorry --non-trivial
lemma new_lemma_125574 (h0 : list (complete_distrib_lattice empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125575 (h0 : list (boolean_algebra (has_pos_part (has_pos_part (has_pos_part pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125576 (h0 : group (linear_ordered_comm_monoid_with_zero empty)) : is_cyclic (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_125577 (h0 : topological_space (has_one (semiring (semiring congr_arg_kind)))) : t0_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125578 (h0 : ring (has_to_string (option ennreal))) : is_domain (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_125579 (h0 : topological_space (add_left_cancel_monoid fun_info)) (h1 : preorder (add_left_cancel_monoid fun_info)) : order_topology (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_125580 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add (canonically_linear_ordered_monoid real)))) : is_atomistic (normed_lattice_add_comm_group (has_add (canonically_linear_ordered_monoid real))) := sorry --non-trivial
lemma new_lemma_125581 (h0 : group (linear_ordered_cancel_comm_monoid (semiring (semiring congr_arg_kind)))) : group.fg (linear_ordered_cancel_comm_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125582 (h0 : functor.add_const (uniform_space (uniform_space unsigned)) ennreal) : @separated_space.{0} (uniform_space.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (uniform_space.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_125583 (h0 : filter (comm_group (has_add unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125584 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : locally_compact_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_125585 (h0 : topological_space (linear_ordered_comm_monoid_with_zero num)) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_125586 (h0 : finset (has_to_string (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_125588 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) name) : @is_compactly_generated.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_125589 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_125590 (h0 : topological_space (has_pos_part (has_Inf real))) : path_connected_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_125591 (h0 : topological_space (has_edist (option unsigned))) : totally_disconnected_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_125592 (h0 : ring (cancel_monoid string.iterator_imp)) : strong_rank_condition (cancel_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_125593 (h0 : topological_space (ring (option (option (option ennreal))))) : normal_space (ring (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_125594 (h0 : complete_lattice (ordered_comm_ring (has_Inf (has_add (sub_neg_monoid (has_Inf Type)))))) : is_atomistic (ordered_comm_ring (has_Inf (has_add (sub_neg_monoid (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_125595 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) num) : @t1_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_125596 (h0 : group (distrib_lattice (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (distrib_lattice (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_125597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_125598 (h0 : list (has_zero (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125599 (h0 : uniform_space (linear_ordered_field unsigned)) : separated_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_125600 (h2 : ring (mul_one_class ereal)) : is_domain (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_125601 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid Type))) : path_connected_space (canonically_ordered_comm_semiring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_125602 (h0 : topological_space (complete_linear_order (semiring (semiring num)))) : totally_disconnected_space (complete_linear_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_125603 (h0 : list (boolean_algebra.core environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125604 (h0 : fin has_zero.zero) : @separated_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_Inf.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_125605 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_125606 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) ennreal) : @t1_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_125607 (h0 : topological_space linarith.ineq) (h3 : preorder linarith.ineq) : order_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_125608 (h0 : set fun_info) : set.finite h0 := sorry --non-trivial
lemma new_lemma_125609 (h0 : ordered_add_comm_monoid (semigroup (semiring (semiring unsigned)))) : archimedean (semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_125610 (h0 : functor.add_const (finset (monoid empty)) (comm_monoid unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125611 (h0 : add_group (normed_group (has_inv fun_info))) : is_add_cyclic (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_125612 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_125613 (h0 : functor.add_const (add_monoid (comm_monoid empty)) empty) : @add_monoid.fg.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125614 (h0 : complete_lattice (comm_ring (random_gen string_imp))) : is_compactly_generated (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_125615 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option (option (option empty))))) : unique_factorization_monoid (add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_125616 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_125617 (h0 : ring (has_zero (comm_group name))) : strong_rank_condition (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_125618 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_125619 (h0 : topological_space (has_le (mul_one_class fun_info))) : path_connected_space (has_le (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_125620 (h0 : nat) (h1 h2 : fin (id (id h0))) : fin.lt h1 h2 := sorry --non-trivial
lemma new_lemma_125621 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_125622 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125623 (h0 : functor.add_const (function.extfun (Type 1) semiring) name) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_125624 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_simple_group.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_125625 (h0 : not (topological_space (has_inv string_imp) -> false)) : @path_connected_space.{0} (has_inv.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_125626 (h0 : topological_space (id (semiring (semiring unsigned)))) : totally_disconnected_space (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_125627 (h0 : topological_space (has_le enat)) : totally_disconnected_space (has_le enat) := sorry --non-trivial
lemma new_lemma_125628 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) (semiring (semiring congr_arg_kind))) : @totally_separated_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125629 (h1 : add_group (has_ssubset string.iterator_imp)) : is_add_cyclic (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_125630 (h0 : group (add_group (semiring (semiring (has_norm empty))))) : is_cyclic (add_group (semiring (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_125631 (h1 : not (topological_space (simple_graph linarith.comp_source) -> false)) : @path_connected_space.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_125632 (h0 : ring (has_neg (has_neg name))) : strong_rank_condition (has_neg (has_neg name)) := sorry --non-trivial
lemma new_lemma_125633 (h0 : complete_lattice (plift (semiring (semiring num)))) : is_atomistic (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_125634 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125635 (h0 : ring (has_top (has_top to_additive.value_type))) : is_domain (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125636 (h0 : not (group (measurable_space.dynkin_system unsigned) -> false)) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_125637 (h1 h2 : multiset ereal) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_125638 (h0 : complete_lattice (ring (has_neg Type))) : complete_lattice.is_Sup_finite_compact (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_125639 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_add pos)))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_125640 (h0 : uniform_space (linear_ordered_cancel_comm_monoid (option (option (option unsigned))))) : separated_space (linear_ordered_cancel_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_125641 (h0 : ordered_comm_monoid (has_bot (sub_neg_monoid Type))) : has_exists_mul_of_le (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_125642 (h0 : filter (id linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125643 (h0 : topological_space (ring linarith.comp)) : preconnected_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_125644 (h0 : topological_space (ring (ring name))) : locally_compact_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_125645 (h0 : topological_space (bin_tree num)) : t1_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_125646 (h0 : fun_info -> fun_info -> fun_info) (h1 : fun_info) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_125647 (h0 : topological_space (has_Inf (ring Type))) : totally_separated_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_125648 (h0 : topological_space (has_neg (has_add (has_to_string unsigned)))) : regular_space (has_neg (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_125649 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125650 (h0 : uniform_space (monoid (option (option (option (option unsigned)))))) : separated_space (monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_125651 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_125652 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero num)) congr_arg_kind) : @is_compactly_generated.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_125653 (h1 : topological_space (semi_normed_comm_ring to_additive.value_type)) : path_connected_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125654 (h0 : group (add_left_cancel_monoid (complete_semilattice_Sup (has_nnnorm char)))) : is_cyclic (add_left_cancel_monoid (complete_semilattice_Sup (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_125655 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_125656 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero ennreal))) : @unique_factorization_monoid.{0} ennreal (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_125657 (h0 : topological_space (boolean_algebra name)) : normal_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_125658 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_125659 (h0 : topological_space (random_gen (has_norm linarith.comp))) : totally_separated_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_125660 (h0 : topological_space (ordered_comm_ring (boolean_algebra (has_Inf (has_Inf pos))))) : totally_separated_space (ordered_comm_ring (boolean_algebra (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_125661 (h0 : functor.add_const (add_monoid (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_125662 (h2 : ring (normed_field char)) : strong_rank_condition (normed_field char) := sorry --non-trivial
lemma new_lemma_125663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_125664 (h0 : topological_space (finset (has_add unsigned))) : regular_space (finset (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_125665 (h0 : topological_space (has_dist (option (option (option unsigned))))) : t0_space (has_dist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_125666 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) environment.implicit_infer_kind) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125667 (h0 : topological_space (has_top (has_norm (has_norm empty)))) : t0_space (has_top (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_125668 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_125669 (h0 : functor.add_const (add_group (finset unsigned)) unsigned) : @is_add_cyclic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125670 (h0 : uniform_space (has_to_string congr_arg_kind)) : complete_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125671 (h0 : not (ring (with_one congr_arg_kind) -> false)) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125672 (h0 : uniform_space (normed_group (has_top congr_arg_kind))) : separated_space (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125673 (h0 : ring (normed_group linarith.comp_source)) : strong_rank_condition (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125674 (h0 : functor.add_const (ring (comm_group linarith.comp)) pos) : @rank_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_125675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_125676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_125677 (h4 : not (complete_lattice (uniform_space to_additive.value_type) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125678 (h0 : group (with_one (has_inv to_additive.value_type))) : normalizer_condition (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125679 (h0 : ring (has_nndist (option (option (option (option (option (option unsigned)))))))) : rank_condition (has_nndist (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_125680 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} char) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} char))  := sorry --non-trivial
lemma new_lemma_125681 (h0 : group (ring (has_to_string linarith.comp))) : is_cyclic (ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_125682 (h2 : ring (has_append to_additive.value_type)) : strong_rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125683 (h0 : monoid (semiring (add_right_cancel_monoid (ordered_ring congr_arg_kind)))) : monoid.fg (semiring (add_right_cancel_monoid (ordered_ring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125684 (h0 : functor.add_const (monoid pos) Type) : @monoid.fg.{0} pos (@functor.add_const.run.{0 1} (monoid.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_125685 (h0 : functor.add_const (ring (comm_group Type)) name) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_125686 (h0 : uniform_space (random_gen (has_compl char))) : complete_space (random_gen (has_compl char)) := sorry --non-trivial
lemma new_lemma_125687 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_125688 (h0 : topological_space (boolean_algebra.core (semigroup (add_comm_monoid pos)))) : discrete_topology (boolean_algebra.core (semigroup (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_125689 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_125690 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_125691 (h0 : uniform_space (ordered_comm_monoid (has_add (has_Inf Type)))) : separated_space (ordered_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_125692 (h1 : complete_lattice string.iterator_imp) : complete_lattice.is_Sup_finite_compact string.iterator_imp := sorry --non-trivial
lemma new_lemma_125693 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125694 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_125695 (h0 : filter (has_top (has_norm (measurable_space empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125696 (h0 : set (mul_one_class string.iterator_imp -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_125697 (h0 : topological_space (semigroup (has_add (cancel_monoid name)))) : regular_space (semigroup (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_125698 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125699 (h0 : measurable_space environment.projection_info) (h1 : measure_theory.measure environment.projection_info) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_125700 (h0 : complete_lattice (normed_group (has_top (has_top (has_top fun_info))))) : is_compactly_generated (normed_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_125701 (h0 : group (ordered_comm_ring (has_Inf Type))) : group.fg (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_125702 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup enat))) : t0_space (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_125703 (h0 : topological_space (is_R_or_C unsigned)) : locally_compact_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_125704 (h0 : list (has_add linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125705 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : locally_compact_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_125706 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_125707 (h0 : topological_space (id (with_bot string_imp))) : locally_compact_space (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_125708 (h0 : not (uniform_space (denumerable char) -> false)) : @complete_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_125709 (h0 : topological_space (has_top (has_top empty))) : t0_space (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_125710 (h0 : functor.add_const (group (measurable_space.dynkin_system empty)) empty) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125711 (h0 : complete_lattice (partial_order unsigned)) : complete_lattice.is_Sup_finite_compact (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_125712 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_125713 (h0 : cancel_comm_monoid_with_zero (has_to_string (option name))) : unique_factorization_monoid (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_125714 (h0 : ring (has_nndist (finset environment.implicit_infer_kind))) : strong_rank_condition (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_125715 (h0 : topological_space (has_Inf linarith.comp)) : t1_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_125716 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_125717 (h0 : set (linarith.ineq -> nat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_125718 (h2 : ring (with_one to_additive.value_type)) : is_domain (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125719 (h0 : group (canonically_linear_ordered_monoid congr_arg_kind)) : normalizer_condition (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125720 (h0 : uniform_space (ordered_comm_monoid (has_Inf linarith.comp))) : separated_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_125721 (h0 : uniform_space (partial_order empty)) : complete_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_125722 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp_source))) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125723 (h0 : ring (id (has_inv (has_inv linarith.comp_source)))) : is_domain (id (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_125724 (h0 : ring (has_lt std_gen)) : strong_rank_condition (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_125725 (h0 : not (group (semiring empty) -> false)) : @is_cyclic.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125726 (h0 : group (linear_ordered_semiring to_additive.value_type)) : is_cyclic (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_125727 (h0 : topological_space (id (has_norm (has_norm congr_arg_kind)))) : normal_space (id (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125728 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @totally_separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125729 (h0 : has_neg (normed_field linarith.ineq)) (h1 : measurable_space (normed_field linarith.ineq)) : has_measurable_neg (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_125730 (h0 : ordered_comm_monoid (group_with_zero (option pos))) : has_exists_mul_of_le (group_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_125731 (h0 : Prop) (h1 : not h0) (h2 : h0) : @t0_space.{0} linarith.ineq (@not.elim.{1} h0 (topological_space.{0} linarith.ineq) h1 h2)  := sorry --trivial
lemma new_lemma_125732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_125733 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_125734 (h0 : functor.add_const (complete_lattice (sub_neg_monoid real)) real) : @is_atomistic.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_125735 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string (has_add pos)))) : t1_space (canonically_ordered_comm_semiring (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_125736 (h0 : functor.comp complete_lattice mul_zero_class Type) : @complete_lattice.is_Sup_finite_compact.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_125737 (h0 : functor.comp ordered_comm_monoid finset linarith.comp) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} finset.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125738 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125739 (h1 : topological_space (metric_space num)) : normal_space (metric_space num) := sorry --non-trivial
lemma new_lemma_125740 (h0 : list (has_nndist (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125741 (h0 : group (ring (has_to_string name))) : is_simple_group (ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_125742 (h1 : complete_lattice (dlist linarith.ineq)) : complete_lattice.is_Sup_finite_compact (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_125743 (h0 : functor.add_const (uniform_space (add_group congr_arg_kind)) unsigned) : @separated_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125744 (h0 : complete_lattice (mul_one_class enat)) : complete_lattice.is_Sup_finite_compact (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_125745 (h0 : topological_space (has_top (has_top congr_arg_kind))) : path_connected_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125746 (h0 : not (monoid (linear_ordered_comm_ring congr_arg_kind) -> false)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125747 (h0 : complete_lattice (semigroup (boolean_algebra (has_neg (finset Type))))) : complete_lattice.is_Sup_finite_compact (semigroup (boolean_algebra (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_125748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_125749 (h0 : topological_space (linear_ordered_semiring linarith.ineq)) : totally_disconnected_space (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_125750 (h0 : functor.comp topological_space has_neg pos) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_125751 (h0 : ring (fintype (random_gen string_imp))) : rank_condition (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_125752 (h0 : functor.add_const (add_monoid (non_assoc_semiring empty)) num) : @add_monoid.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_125753 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (finset ennreal))) : unique_factorization_monoid (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_125754 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_125755 (h0 : ring (semi_normed_ring (comm_ring (random_gen (comm_ring (has_nnnorm fun_info)))))) : strong_rank_condition (semi_normed_ring (comm_ring (random_gen (comm_ring (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_125756 (h0 : ring (nondiscrete_normed_field (has_nnnorm linarith.ineq))) : is_domain (nondiscrete_normed_field (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125757 (h0 : prod (add_comm_semigroup linarith.ineq) (add_comm_semigroup linarith.ineq)) : set.diagonal (add_comm_semigroup linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_125758 (h0 : function.extfun nat fin) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_125759 (h0 : ordered_add_comm_monoid (has_zero (comm_group pos))) : archimedean (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_125760 (h0 : ring (normed_field (random_gen (random_gen char)))) : rank_condition (normed_field (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_125761 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf linarith.comp)))) : locally_compact_space (ordered_comm_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_125762 (h0 : ring (add_group (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (add_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_125763 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_125764 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_125765 (h0 : complete_lattice (linear_ordered_comm_ring (has_top unsigned))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_125766 (h0 : not (uniform_space (has_norm unsigned) -> false)) : @separated_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_125767 (h1 : ring (with_bot string_imp)) : is_domain (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_125768 (h0 : list (with_bot (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_125769 (h0 : finset (preorder (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125770 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @discrete_topology.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_125771 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_125772 (h0 : complete_lattice (boolean_algebra (measurable_space linarith.comp))) : is_compactly_generated (boolean_algebra (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_125773 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (has_neg pos)) : @archimedean.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (has_neg.{0} pos) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_125774 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_125775 (h0 : not (filter (normed_group unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_125776 (h0 h1 : multiset (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_125777 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_125778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_125779 (h0 : ring (has_neg (has_add unsigned))) : is_domain (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_125780 (h0 : topological_space (has_star (semiring congr_arg_kind))) : topological_space.separable_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125781 (h0 : topological_space (uniform_space (option ennreal))) : loc_path_connected_space (uniform_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_125782 (h0 : group (ordered_comm_ring Type)) : is_simple_group (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_125783 (h0 : not (filter (mul_zero_class (semiring (semiring (semiring (semiring (semiring num)))))) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_125784 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125785 (h0 : ring (add_cancel_comm_monoid congr_arg_kind)) : is_principal_ideal_ring (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125786 (h0 : topological_space (boolean_algebra.core ennreal)) : t1_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_125787 (h0 : semiring (normed_comm_ring (non_assoc_semiring name))) : is_noetherian_ring (normed_comm_ring (non_assoc_semiring name)) := sorry --non-trivial
lemma new_lemma_125788 (h0 : semiring (has_zero linarith.comp)) : is_noetherian_ring (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_125789 (h0 : not (ring (denumerable string_imp) -> false)) : @is_domain.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_125790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125791 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_125792 (h0 : topological_space (comm_semigroup (add_comm_monoid real))) : t1_space (comm_semigroup (add_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_125793 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_125794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_125795 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_125796 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_125797 (h0 : topological_space (cancel_monoid (semigroup (add_comm_monoid pos)))) : topological_space.separable_space (cancel_monoid (semigroup (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_125798 (h0 : ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : rank_condition (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_125799 (h0 : topological_space (has_Inf (has_add (has_add linarith.comp)))) : locally_compact_space (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_125800 (h0 : not (ring (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_125801 (h1 : function.extfun Type topological_space) : @normal_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125802 (h0 : complete_lattice (random_gen (fintype linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125803 (h0 : topological_space (with_bot (has_norm linarith.ineq))) : path_connected_space (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125804 (h0 : finset (has_add unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125805 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) add_monoid.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_125806 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : path_connected_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_125807 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_125808 (h0 : topological_space (has_norm (has_top linarith.comp_source))) : totally_disconnected_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125809 (h0 : complete_lattice (linear_ordered_comm_group (option unsigned))) : is_atomistic (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_125810 (h0 : functor.add_const (functor.comp semiring has_to_string pos) pos) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} has_to_string.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} semiring.{0} has_to_string.{0} pos) pos h0))  := sorry --non-trivial
lemma new_lemma_125811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125812 (h0 : function.extfun Type (functor.add_const (ring (add_comm_monoid name)))) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_comm_monoid.{0} name))) h0 pos))  := sorry --non-trivial
lemma new_lemma_125813 (h0 : functor.add_const (uniform_space (bin_tree empty)) num) : @complete_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_125814 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125815 (h0 : functor.comp topological_space has_neg_part name) : @preconnected_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125816 (h1 : ring (simple_graph string.iterator_imp)) : is_domain (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_125817 (h1 : measurable_space char) (h2 : has_sup char) : has_measurable_sup₂ char := sorry --non-trivial
lemma new_lemma_125818 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_125819 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_125820 (h0 : topological_space (cancel_monoid (has_to_string name))) : loc_path_connected_space (cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_125821 (h0 : set (has_le reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_125822 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125823 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : loc_path_connected_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_125824 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_125825 (h0 : functor.add_const (group (normed_comm_ring pos)) (boolean_algebra Type)) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_125826 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_125827 (h0 : complete_lattice (complete_semilattice_Sup (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (complete_semilattice_Sup (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_125828 (h0 : group (ordered_ring (add_left_cancel_semigroup unsigned))) : is_cyclic (ordered_ring (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_125829 (h0 : uniform_space (metric_space reducibility_hints)) : complete_space (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_125830 (h0 : functor.add_const (complete_lattice (normed_comm_ring ennreal)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_125831 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : topological_space.separable_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_125832 (h0 : topological_space (has_one (metric_space (linear_ordered_semiring (with_bot congr_arg_kind))))) : totally_separated_space (has_one (metric_space (linear_ordered_semiring (with_bot congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_125833 (h0 : monoid (option unsigned) -> monoid (option unsigned) -> Prop) : is_symm (monoid (option unsigned)) h0 := sorry --non-trivial
lemma new_lemma_125834 (h0 : functor.add_const (topological_space (order_dual empty)) num) : totally_disconnected_space (order_dual empty) := sorry --non-trivial
lemma new_lemma_125835 (h1 : ring (has_nnnorm linarith.ineq)) : is_domain (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_125836 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_125837 (h0 : add_monoid (has_nndist (option num))) : add_monoid.fg (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_125838 (h4 : ring (random_gen char)) : rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_125839 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_125840 (h0 : prod (normed_comm_ring empty) (normed_comm_ring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_125841 (h0 : topological_space (has_Inf (has_add Type))) : preirreducible_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_125842 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : t0_space (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125843 (h0 h1 : multiset (non_unital_non_assoc_semiring (non_unital_non_assoc_semiring string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_125844 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : path_connected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125845 (h0 : semiring (has_top congr_arg_kind)) : is_noetherian_ring (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125846 (h0 : functor.add_const (ring (has_neg Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_125847 (h0 : filter (linear_ordered_field num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125848 (h1 : uniform_space (encodable (random_gen string_imp))) : complete_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_125849 (h0 : filter (ring (has_Inf (boolean_algebra Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_125850 (h0 : add_group (has_norm (semiring (random_gen congr_arg_kind)))) : is_add_cyclic (has_norm (semiring (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125851 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.ineq))) : @is_add_cyclic.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_125852 (h0 : monoid (normed_group num)) : monoid.fg (normed_group num) := sorry --non-trivial
lemma new_lemma_125853 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) pos) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_125854 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core unsigned)) (boolean_algebra.core name)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} unsigned)) (boolean_algebra.core.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_125855 (h0 : group (add_cancel_comm_monoid (random_gen to_additive.value_type))) : is_cyclic (add_cancel_comm_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125856 (h0 : ring (ring unsigned)) : strong_rank_condition (ring unsigned) := sorry --non-trivial
lemma new_lemma_125857 (h1 : group (distrib linarith.comp_source)) : group.fg (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125858 (h0 : functor.add_const (finset (has_pos_part pos)) (has_add (has_add linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125859 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_125860 (h0 : topological_space (has_to_string (ring linarith.comp))) : locally_compact_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_125861 (h0 : uniform_space (comm_ring (random_gen (fintype (has_nnnorm linarith.ineq))))) : complete_space (comm_ring (random_gen (fintype (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_125862 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) pos) := sorry --non-trivial
lemma new_lemma_125863 (h0 : ring (has_zero (has_add (has_nndist pos)))) : rank_condition (has_zero (has_add (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_125864 (h0 : functor.add_const (topological_space (comm_group ennreal)) Type) : @topological_space.separable_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_125865 (h0 : functor.add_const (list (semigroup unsigned)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125866 (h0 : ring (left_cancel_semigroup (semiring empty))) : rank_condition (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_125867 (h0 : uniform_space (dlist (semi_normed_comm_ring linarith.comp_source))) : complete_space (dlist (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125868 (h0 : complete_lattice (has_bot (has_neg (has_neg (has_neg (has_neg pos)))))) : is_compactly_generated (has_bot (has_neg (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_125869 (h0 : functor.add_const (ring (ordered_comm_group unsigned)) empty) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_125870 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @normal_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_125871 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : discrete_topology (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_125872 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) (normed_comm_ring name)) : @sequential_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_125873 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_125874 (h0 : not (complete_lattice (normed_field string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_125875 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125876 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_125877 (h0 : topological_space (boolean_algebra (has_Inf (ordered_comm_monoid Type)))) : locally_compact_space (boolean_algebra (has_Inf (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_125878 (h0 : functor.add_const (topological_space (has_add real)) real) : @totally_separated_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_125879 (h0 : not (uniform_space (has_one congr_arg_kind) -> false)) : @complete_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125880 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_125881 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_125882 (h0 : topological_space (add_cancel_monoid (finset (boolean_algebra Type)))) : t0_space (add_cancel_monoid (finset (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_125883 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring name)) name) : @archimedean.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_125884 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125885 (h0 : group environment.implicit_infer_kind) : is_simple_group environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_125886 (h0 : topological_space (normed_group fun_info)) : path_connected_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_125887 (h0 : functor.comp topological_space has_to_string name) : @normal_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_125888 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125889 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_125890 (h0 : topological_space (ring (ring linarith.comp))) : sequential_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_125891 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_125892 (h0 : multiset (semi_normed_ring linarith.ineq)) (h1 : not (multiset (semi_normed_ring linarith.ineq) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_125893 (h1 : topological_space (add_comm_semigroup string_imp)) : totally_disconnected_space (add_comm_semigroup string_imp) := sorry --non-trivial
lemma new_lemma_125894 (h0 : ring (has_top (has_top empty))) : is_domain (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_125895 (h0 : topological_space (has_neg unsigned)) : locally_compact_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_125896 (h0 : ring (uniform_space (mul_one_class (mul_one_class (has_nnnorm enat))))) : strong_rank_condition (uniform_space (mul_one_class (mul_one_class (has_nnnorm enat)))) := sorry --non-trivial
lemma new_lemma_125897 (h0 : not (topological_space (with_bot num) -> false)) : @locally_compact_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_125898 (h0 : functor.add_const (add_monoid (has_nndist Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_125899 (h0 : functor.add_const (finset (has_to_string pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125900 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_125901 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring congr_arg_kind))) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_125902 (h0 : not (group Type -> false)) : @is_cyclic.{1} Type (@classical.by_contradiction'.{2} (group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_125903 (h0 : topological_space (comm_group (has_neg_part (option ennreal)))) : t1_space (comm_group (has_neg_part (option ennreal))) := sorry --non-trivial
lemma new_lemma_125904 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : locally_compact_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_125905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_125906 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero empty)) empty) : @unique_factorization_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125907 (h0 : group (semi_normed_comm_ring string.iterator_imp)) : is_cyclic (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_125908 (h0 : ring (add_left_cancel_monoid linarith.comp_source)) : rank_condition (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125909 (h0 : list (semigroup (has_zero linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125910 (h0 : uniform_space (normed_comm_ring (has_add pos))) : complete_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_125911 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_125912 (h2 : not (ring char -> false)) : @rank_condition.{0} char (@classical.by_contradiction'.{1} (ring.{0} char) h2)  := sorry --non-trivial
lemma new_lemma_125913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_125914 (h0 : topological_space (complete_distrib_lattice (finset (finset ennreal)))) : discrete_topology (complete_distrib_lattice (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_125915 (h0 : topological_space (linear_ordered_add_comm_group char)) : locally_compact_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_125916 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) name) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_125917 (h0 : ring (with_bot (semiring num))) : rank_condition (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_125918 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_125919 (h0 : ring (has_sub (semiring (semiring unsigned)))) : is_principal_ideal_ring (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_125920 (h0 : topological_space (id fun_info)) : t0_space (id fun_info) := sorry --non-trivial
lemma new_lemma_125921 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_125922 (h1 : complete_lattice (semiring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125923 (h0 : group (normed_linear_ordered_group (semiring empty))) : is_cyclic (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_125924 (h0 : not (ring (measure_theory.measure_space empty) -> false)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_125925 (h0 : topological_space (has_nndist (option (option num)))) : totally_disconnected_space (has_nndist (option (option num))) := sorry --non-trivial
lemma new_lemma_125926 (h0 : functor.add_const (topological_space (has_edist unsigned)) congr_arg_kind) : @t1_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_125927 (h0 : monoid (has_emptyc (has_top (has_top linarith.comp_source)))) : monoid.fg (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_125928 (h1 : not (topological_space (with_zero to_additive.value_type) -> false)) : @path_connected_space.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_125929 (h0 : ring (complete_linear_order empty)) : is_domain (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_125930 (h0 : topological_space (comm_semigroup linarith.comp)) : preconnected_space (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_125931 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_125932 (h0 : functor.add_const (filter (add_cancel_monoid Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125933 (h0 : group (normed_comm_ring (has_add (has_add environment.implicit_infer_kind)))) : is_simple_group (normed_comm_ring (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_125934 (h0 : add_group (add_cancel_monoid (simple_graph Type))) : is_add_cyclic (add_cancel_monoid (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_125935 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_125936 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid real)))) : irreducible_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_125937 (h0 : add_monoid (comm_group (has_add unsigned))) : add_monoid.fg (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_125938 (h0 : topological_space (non_assoc_semiring linarith.comp_source)) : locally_compact_space (non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_125939 (h0 : complete_lattice (omega_complete_partial_order congr_arg_kind)) : is_compactly_generated (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_125940 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_125941 (h0 : functor.add_const (add_group (semigroup pos)) (has_add (boolean_algebra name))) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (has_add.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_125942 (h0 : list (has_inter congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_125943 (h0 : ring (normed_group (with_one unsigned))) : rank_condition (normed_group (with_one unsigned)) := sorry --non-trivial
lemma new_lemma_125944 (h0 : monoid (complete_semilattice_Sup string_imp)) : monoid.fg (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_125945 (h0 : group (ordered_comm_monoid (has_add Type))) : normalizer_condition (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_125946 (h0 : monoid (boolean_algebra.core (ring environment.implicit_infer_kind))) : monoid.fg (boolean_algebra.core (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_125947 (h0 : topological_space (ring (has_neg pos))) : path_connected_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_125948 (h0 : functor.add_const (topological_space (has_neg ennreal)) unsigned) : @normal_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125949 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : regular_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_125950 (h0 : topological_space (metric_space (has_top unsigned))) : discrete_topology (metric_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_125951 (h0 : ring (has_add num)) : is_principal_ideal_ring (has_add num) := sorry --non-trivial
lemma new_lemma_125952 (h0 : topological_space (linear_order (semiring empty))) : totally_separated_space (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_125953 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_125954 (h0 : functor.add_const (topological_space (plift unsigned)) (option empty)) : @topological_space.separable_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_125955 (h2 : ring (has_sdiff reducibility_hints)) (h3 : ring (has_ssubset (ring_topology (has_sdiff reducibility_hints)))) : is_domain (has_ssubset (ring_topology (has_sdiff reducibility_hints))) := sorry --non-trivial
lemma new_lemma_125956 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_125957 (h0 : functor.add_const (uniform_space (has_neg pos)) (finset environment.implicit_infer_kind)) : @separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_125958 (h0 : set (simple_graph (has_compl char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_125959 (h0 : topological_space (has_inv fun_info)) : path_connected_space (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_125960 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @locally_compact_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_125961 (h1 : complete_lattice (measurable_space (has_norm (has_norm congr_arg_kind)))) : is_atomistic (measurable_space (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_125962 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_125963 (h0 : filter (partial_order (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_125964 (h0 : ring (boolean_algebra.core (has_add name))) : is_domain (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_125965 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @path_connected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125966 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_125967 (h0 : complete_lattice (has_add (has_add name))) : is_compactly_generated (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_125968 (h1 : ring (mul_one_class char)) : strong_rank_condition (mul_one_class char) := sorry --non-trivial
lemma new_lemma_125969 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_125970 (h0 : functor.add_const Prop (add_cancel_monoid pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_125971 (h1 : set (ereal -> environment.implicit_infer_kind)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_125972 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_125973 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_125974 (h0 : topological_space (has_add (ordered_ring (ordered_ring name)))) : t0_space (has_add (ordered_ring (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_125975 (h0 : ring (preorder (semiring (semiring (semiring (semiring (semiring num))))))) : strong_rank_condition (preorder (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_125976 (h0 : functor.add_const (group (comm_group ennreal)) unsigned) : @normalizer_condition.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125977 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_125978 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id empty)) := sorry --non-trivial
lemma new_lemma_125979 (h1 : ring (topological_space (random_gen linarith.ineq))) : rank_condition (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_125980 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @is_cyclic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_125981 (h0 : group (canonically_linear_ordered_monoid (has_Inf Type))) : is_simple_group (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_125982 (h0 : topological_space (denumerable (has_ssubset to_additive.value_type))) : t0_space (denumerable (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_125983 (h0 : ring (distrib (has_nnnorm reducibility_hints))) : rank_condition (distrib (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_125984 (h1 : set (linear_ordered_comm_ring (normed_field string_imp))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_125985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_125986 (h0 : group (has_zero (has_to_string (finset (has_add linarith.comp))))) : group.fg (has_zero (has_to_string (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_125987 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @t0_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_125988 (h0 : group (has_nndist (has_zero num))) : is_simple_group (has_nndist (has_zero num)) := sorry --non-trivial
lemma new_lemma_125989 (h0 : functor.add_const (filter (as_linear_order unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_125990 (h0 : functor.add_const (group (add_cancel_monoid pos)) ennreal) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_125991 (h0 : topological_space (comm_monoid (semiring empty))) : t1_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_125992 (h0 : functor.add_const (topological_space name) unsigned) : @locally_compact_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_125993 (h0 : topological_space (comm_ring (random_gen char))) : locally_compact_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_125994 (h0 : functor.add_const (monoid (has_bot pos)) real) : @monoid.fg.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_bot.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_125995 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_125996 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_125997 (h0 : topological_space (boolean_algebra (has_neg pos))) : preconnected_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_125998 (h0 : finset (simple_graph (has_Inf linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_125999 (h0 : complete_lattice (ring (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_126000 (h0 : functor.add_const (group (boolean_algebra.core pos)) Type) : @group.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_126001 (h0 : topological_space (semigroup (has_add Type))) : totally_separated_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_126002 (h0 : topological_space (left_cancel_monoid num)) : totally_separated_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_126003 (h0 : functor.add_const (complete_lattice (ring name)) Type) : @is_compactly_generated.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126004 (h0 : functor.add_const (filter (has_Inf linarith.comp)) (has_neg (has_neg Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126005 (h0 : topological_space (has_norm (has_top num))) : totally_disconnected_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_126006 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) linarith.comp) : @is_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126007 (h1 : uniform_space (has_append char) -> char) (h2 : coe_sort (set.range h1)) : @complete_space.{0} (has_append.{0} char) (@set.range_splitting.{0 0} (uniform_space.{0} (has_append.{0} char)) char h1 h2)  := sorry --non-trivial
lemma new_lemma_126008 (h2 : ring (add_monoid fun_info)) : strong_rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_126009 (h0 : finset (has_nndist (ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126010 (h0 : functor.add_const (functor.add_const (list (free_add_monoid empty)) num) congr_arg_kind) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_126011 (h0 : set (prod char char)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_126012 (h0 : semiring (semigroup (has_nndist name))) : is_noetherian_ring (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_126013 (h0 : topological_space (add_cancel_monoid ennreal)) : sequential_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_126014 (h0 : topological_space (comm_group (has_neg_part name))) : irreducible_space (comm_group (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_126015 (h0 : group (boolean_algebra (has_pos_part pos))) : is_simple_group (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_126016 (h0 : functor.add_const (add_monoid (boolean_algebra Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126017 (h0 : list (ring ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126018 (h0 : functor.add_const (list (simple_graph linarith.comp)) (has_Inf pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126019 (h0 : list (finset (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126020 (h0 : list (has_neg (semigroup pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126021 (h2 : topological_space (encodable fun_info)) : t0_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_126022 (h0 : cancel_comm_monoid_with_zero (has_add (has_neg (has_to_string name)))) : unique_factorization_monoid (has_add (has_neg (has_to_string name))) := sorry --non-trivial
lemma new_lemma_126023 (h0 : function.extfun Type (functor.add_const (add_monoid name))) : @add_monoid.fg.{0} name (@functor.add_const.run.{0 0} (add_monoid.{0} name) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} name)) h0 empty))  := sorry --non-trivial
lemma new_lemma_126024 (h0 : not (ring (non_assoc_semiring empty) -> false)) : @is_domain.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_126025 (h0 : topological_space (ring (metric_space (ring environment.implicit_infer_kind)))) : regular_space (ring (metric_space (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_126026 (h0 : topological_space (add_comm_monoid (option name))) : irreducible_space (add_comm_monoid (option name)) := sorry --non-trivial
lemma new_lemma_126027 (h0 : functor.add_const (add_monoid (semigroup name)) Type) : @add_monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126028 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) (h1 : preorder (semi_normed_comm_ring linarith.ineq)) : order_topology (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_126029 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @regular_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_126030 (h3 : topological_space (semi_normed_ring linarith.comp_source)) : t0_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126031 (h0 : filter (add_cancel_monoid (semiring (semiring (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126032 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @complete_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126033 (h0 : ordered_comm_monoid (add_comm_monoid (finset pos))) : has_exists_mul_of_le (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_126034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126035 (h0 : complete_lattice (semigroup (has_to_string (has_to_string (has_to_string unsigned))))) : is_compactly_generated (semigroup (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_126036 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid linarith.comp)) : archimedean (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_126037 (h0 : uniform_space (cancel_monoid (finset pos))) : separated_space (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_126038 (h0 : uniform_space (topological_space (denumerable (denumerable (denumerable char))))) : complete_space (topological_space (denumerable (denumerable (denumerable char)))) := sorry --non-trivial
lemma new_lemma_126039 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126040 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126041 (h0 : functor.add_const (finset (has_star empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126042 (h0 : ring (canonically_linear_ordered_monoid (has_Inf pos))) : is_domain (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_126043 (h0 : has_lt (has_compl (mul_one_class string.iterator_imp))) : no_max_order (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_126044 (h0 : prod (semigroup (option name)) (semigroup (option name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_126045 (h0 : add_group (add_left_cancel_semigroup unsigned)) : is_add_cyclic (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_126046 (h0 : fin has_zero.zero) : @irreducible_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_126047 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_126048 (h0 : functor.add_const (topological_space (has_zero ennreal)) name) : @t1_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_126049 (h1 : filter (add_monoid (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_126050 (h0 : topological_space (option (semiring empty))) : t0_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_126051 (h0 : uniform_space (with_one unsigned)) : complete_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_126052 (h0 : topological_space (has_star (semiring empty))) : path_connected_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_126053 (h0 : topological_space (has_add (has_Inf (ring (ring Type))))) : normal_space (has_add (has_Inf (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_126054 (h0 : topological_space (mul_zero_class (finset (has_nndist (finset pos))))) : t0_space (mul_zero_class (finset (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_126055 (h0 : functor.add_const (topological_space (ring Type)) name) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_126056 (h1 : topological_space (mul_one_class linarith.ineq)) : totally_disconnected_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_126057 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @is_atomistic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_126058 (h0 : functor.add_const (group (boolean_algebra pos)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126059 (h0 : functor.add_const (function.extfun Type group) (has_neg Type)) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg.{1} Type) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126060 (h0 : not (ring (denumerable linarith.ineq) -> false)) : @rank_condition.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_126061 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : t1_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_126062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_126063 (h0 : functor.comp group add_cancel_monoid pos) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_126064 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126065 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group (option empty))) : archimedean (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_126066 (h1 : ring (semi_normed_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (semi_normed_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_126067 (h0 : topological_space (ring (has_add (boolean_algebra name)))) : t0_space (ring (has_add (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_126068 (h0 : semiring ennreal) : is_noetherian_ring ennreal := sorry --non-trivial
lemma new_lemma_126069 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_126070 (h0 : functor.add_const (uniform_space (has_to_string name)) Type) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126071 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126072 (h0 : topological_space (complete_linear_order (has_top empty))) : t0_space (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_126073 (h0 : topological_space (semigroup (semiring empty))) : normal_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_126074 (h1 : ring (has_append (has_nnnorm (random_gen char)))) : is_domain (has_append (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_126075 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (measurable_space congr_arg_kind) h0) := sorry --non-trivial
lemma new_lemma_126076 (h0 : topological_space (has_inv linarith.ineq)) : path_connected_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_126077 (h0 : topological_space name) : preconnected_space name := sorry --non-trivial
lemma new_lemma_126078 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) Type) : @is_atomistic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_126079 (h0 : monoid (complete_semilattice_Sup (comm_ring (random_gen to_additive.value_type)))) : monoid.fg (complete_semilattice_Sup (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126081 (h0 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : strong_rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126082 (h0 : list (has_nnnorm linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126083 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) pos) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_126084 (h0 : add_group (measurable_space (with_bot (has_inv linarith.ineq)))) : is_add_cyclic (measurable_space (with_bot (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_126085 (h0 : function.extfun (set char) (fun (x : set char), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_126086 (h0 : not (topological_space congr_arg_kind -> false)) : @path_connected_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (topological_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_126087 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126088 (h0 : ring (has_to_string (has_add (has_add (has_inter Type))))) : rank_condition (has_to_string (has_add (has_add (has_inter Type)))) := sorry --non-trivial
lemma new_lemma_126089 (h0 : group (has_add (has_add pos))) : normalizer_condition (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_126090 (h0 : finset (complete_distrib_lattice (ring (ring (has_neg pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_126092 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) linarith.comp) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126093 (h0 : topological_space (add_cancel_monoid unsigned)) : t0_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_126094 (h0 : group (left_cancel_monoid empty)) : is_cyclic (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_126095 (h0 : not (complete_lattice (complete_linear_order congr_arg_kind) -> false)) : @is_atomistic.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126096 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126097 (h0 : functor.comp topological_space finset (cancel_monoid pos)) : @loc_path_connected_space.{0} (finset.{0} (cancel_monoid.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} (cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126098 (h0 : topological_space (has_neg_part name)) : path_connected_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_126099 (h0 : not (topological_space (normed_field to_additive.value_type) -> false)) : @t0_space.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_126100 (h0 : group (complete_distrib_lattice empty)) : is_cyclic (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_126101 (h0 : group (has_zero (normed_comm_ring (has_add linarith.comp)))) : is_cyclic (has_zero (normed_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_126102 (h0 : monoid (normed_group (has_top linarith.ineq))) : monoid.fg (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126103 (h0 : monoid (cancel_monoid (option ennreal))) : monoid.fg (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_126104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126105 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126106 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : discrete_topology (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_126107 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_126108 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126109 (h0 : monoid (has_zero (has_add linarith.comp))) : monoid.fg (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_126110 (h0 : group (has_top (has_norm (has_norm linarith.comp_source)))) : is_cyclic (has_top (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_126111 (h0 : with_one (semiring num) -> with_one (semiring num) -> with_one (semiring num)) : is_right_cancel (with_one (semiring num)) h0 := sorry --non-trivial
lemma new_lemma_126112 (h0 : complete_lattice (finset (has_neg pos))) : complete_lattice.is_Sup_finite_compact (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_126113 (h0 : functor.add_const (topological_space (has_add Type)) (ring (has_neg name))) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (ring.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_126114 (h0 : ring (comm_group (has_add (has_add environment.implicit_infer_kind)))) : is_principal_ideal_ring (comm_group (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_126115 (h0 : topological_space (free_add_monoid congr_arg_kind)) : t1_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126116 (h1 : Type) (h2 : h1) (h3 : h1 -> id Prop) : id_bind h2 h3 := sorry --non-trivial
lemma new_lemma_126117 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126118 (h0 : topological_space (simple_graph string.iterator_imp)) : totally_disconnected_space (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_126119 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_126120 (h0 : topological_space (add_right_cancel_monoid num)) : locally_compact_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_126121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126122 (h0 : ring (random_gen fun_info)) : strong_rank_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_126123 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126124 (h0 : topological_space (random_gen (has_top (has_top fun_info)))) : totally_disconnected_space (random_gen (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_126125 (h0 : topological_space (has_neg (comm_group unsigned))) : loc_path_connected_space (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_126126 (h0 : functor.add_const (uniform_space (has_neg name)) environment.implicit_infer_kind) : @separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126127 (h0 : topological_space (sub_neg_monoid (has_add pos))) : discrete_topology (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_126128 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (has_neg Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126129 (h0 : topological_space (has_nnnorm linarith.ineq)) (h1 : add_group (has_nnnorm linarith.ineq)) : topological_add_group (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_126130 (h0 : uniform_space (id num)) : separated_space (id num) := sorry --non-trivial
lemma new_lemma_126131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_126132 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_126133 (h1 : uniform_space (add_comm_semigroup (add_comm_semigroup enat))) : complete_space (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_126134 (h0 : functor.add_const (function.extfun (Type 1) list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_126135 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126136 (h0 : function.extfun Type (functor.add_const (list (measurable_space.dynkin_system unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_126137 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126138 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} znum (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) znum)  := sorry --non-trivial
lemma new_lemma_126139 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_126140 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : locally_compact_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_126141 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_126142 (h0 : complete_lattice (has_add (ring (ring linarith.comp)))) : is_compactly_generated (has_add (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_126143 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_126144 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_126145 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class string_imp)))) : is_domain (semi_normed_ring (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_126146 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126147 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) name) : @is_atomistic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_126148 (h0 : set (has_ssubset (has_inter reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_126149 (h2 : ring (random_gen linarith.comp_source)) : is_domain (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126150 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (left_cancel_semigroup.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (left_cancel_semigroup.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_126151 (h0 : ring (has_ssubset (has_lt linarith.ineq))) : rank_condition (has_ssubset (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126152 (h0 : functor.add_const (add_monoid (has_zero name)) name) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_126153 (h0 : filter (uniform_space (topological_space reducibility_hints))) : @complete_space.{0} (topological_space.{0} reducibility_hints) (@filter.Liminf.{0} (uniform_space.{0} (topological_space.{0} reducibility_hints)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (topological_space.{0} reducibility_hints)) (@uniform_space.complete_lattice.{0} (topological_space.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_126154 (h0 : has_one (has_one (semiring empty)) -> has_one (has_one (semiring empty)) -> Prop) : is_per (has_one (has_one (semiring empty))) h0 := sorry --non-trivial
lemma new_lemma_126155 (h0 : topological_space (has_zero (has_Inf linarith.comp))) : t0_space (has_zero (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_126156 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : discrete_topology (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_126157 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) name) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_126158 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) Type) : @is_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_126159 (h0 : ring (add_monoid (comm_ring linarith.ineq))) : is_domain (add_monoid (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126160 (h0 : group (add_comm_monoid (has_add linarith.comp))) : normalizer_condition (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_126161 (h0 : topological_space (cancel_monoid (option (option (option unsigned))))) : preirreducible_space (cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_126162 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info)))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_126163 (h1 : ring (mul_one_class linarith.comp_source)) : strong_rank_condition (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126164 (h0 : add_group (linear_ordered_semiring num)) : is_add_cyclic (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_126165 (h2 : topological_space (has_compl string_imp)) : path_connected_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_126166 (h0 : add_group (with_bot (random_gen (random_gen (random_gen string_imp))))) : is_add_cyclic (with_bot (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_126167 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) linarith.comp) : @is_atomistic.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_126168 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_126169 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_126170 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : t0_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126171 (h0 : topological_space (ordered_comm_monoid name)) : locally_compact_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_126172 (h0 : topological_space (normed_group (semiring (has_norm (has_norm (has_norm (has_norm linarith.comp))))))) : t0_space (normed_group (semiring (has_norm (has_norm (has_norm (has_norm linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_126173 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126174 (h0 : ring (canonically_ordered_monoid (has_Inf Type))) : strong_rank_condition (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_126175 (h0 : uniform_space (normed_group (has_norm (has_top (semiring (has_top num)))))) : complete_space (normed_group (has_norm (has_top (semiring (has_top num))))) := sorry --non-trivial
lemma new_lemma_126176 (h0 : ring (has_neg_part (has_neg_part (has_neg_part unsigned)))) : is_domain (has_neg_part (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_126177 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126178 (h0 : functor.add_const (ring (has_neg_part pos)) Type) : @rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_126179 (h0 : topological_space (has_nndist (has_neg (has_to_string linarith.comp)))) : irreducible_space (has_nndist (has_neg (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_126180 (h0 : not (monoid (option (semiring (semiring (semiring (semiring (semiring empty)))))) -> false)) : @monoid.fg.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@classical.by_contradiction'.{1} (monoid.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))) h0)  := sorry --non-trivial
lemma new_lemma_126181 (h0 : topological_space (has_norm empty)) : normal_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_126182 (h0 : has_lt (has_ssubset to_additive.value_type)) : no_max_order (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_126183 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (has_neg pos)) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126184 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_126185 (h0 : ring (canonically_linear_ordered_monoid (option name))) : rank_condition (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_126186 (h0 : functor.add_const (complete_lattice (finset ennreal)) (option pos)) : @is_atomistic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126187 (h0 : not (group (linear_ordered_comm_ring unsigned) -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126188 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126189 (h0 : empty) : @is_compactly_generated.{0} (dlist.{0} (has_nnnorm.{0} to_additive.value_type)) (@empty.elim.{1} (complete_lattice.{0} (dlist.{0} (has_nnnorm.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_126190 (h0 : monoid (complete_semilattice_Sup (random_gen (has_inv to_additive.value_type)))) : monoid.fg (complete_semilattice_Sup (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_126192 (h0 : filter (add_group fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126193 (h0 : finset (finset (has_neg (has_neg (has_neg Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126194 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126195 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (normed_lattice_add_comm_group.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_126196 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid unsigned)) : archimedean (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_126197 (h0 : topological_space (complete_semilattice_Sup (random_gen string_imp))) : t0_space (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_126198 (h0 : functor.add_const (filter (boolean_algebra unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126200 (h0 : ring (add_cancel_comm_monoid linarith.ineq)) : rank_condition (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_126201 (h0 : topological_space (has_bot (has_neg name))) : t1_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_126202 (h0 : topological_space (id (semiring (semiring (semiring unsigned))))) : totally_separated_space (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_126203 (h0 : topological_space (semigroup unsigned)) : topological_space.separable_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_126204 (h0 : ring (ring (option unsigned))) : is_principal_ideal_ring (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_126205 (h0 : topological_space (with_one (semiring linarith.comp))) : locally_compact_space (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_126206 (h0 : ring (partial_order (semiring (semiring num)))) : is_principal_ideal_ring (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_126207 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_126208 (h0 : not (topological_space (add_monoid fun_info) -> false)) : @path_connected_space.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_126209 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core pos))) : normal_space (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_126210 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) name) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_126211 (h0 : functor.add_const (ring (has_add linarith.comp)) (finset Type)) : @rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126212 (h0 : topological_space (topological_space (has_nnnorm (comm_ring reducibility_hints)))) : t0_space (topological_space (has_nnnorm (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_126213 (h0 : topological_space (has_zero (has_to_string (option unsigned)))) : topological_space.separable_space (has_zero (has_to_string (option unsigned))) := sorry --non-trivial
lemma new_lemma_126214 (h0 : functor.add_const (topological_space (has_Inf environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126215 (h0 : topological_space (boolean_algebra (ring Type))) : t0_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_126216 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126217 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126218 (h0 : topological_space (has_bot Type)) : locally_compact_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_126219 (h0 : add_monoid (ordered_comm_monoid (has_neg (has_neg pos)))) : add_monoid.fg (ordered_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_126220 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_126221 (h0 : finset (ring (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126222 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_126223 (h0 : functor.add_const (group (semigroup pos)) environment.implicit_infer_kind) : @group.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126224 (h2 : add_group (semi_normed_ring string_imp)) : is_add_cyclic (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_126225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_126226 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_126227 (h0 : functor.add_const (add_group (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126228 (h0 : uniform_space (with_bot (has_inv linarith.ineq))) : complete_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126229 (h0 : ring (ordered_comm_monoid Type)) : is_domain (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_126230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126231 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126232 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_126233 (h0 : not (uniform_space (with_one unsigned) -> false)) : @complete_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_126236 (h0 : ring (linear_ordered_comm_group (option unsigned))) : is_domain (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_126237 (h0 : group (comm_group (option (option name)))) : group.fg (comm_group (option (option name))) := sorry --non-trivial
lemma new_lemma_126238 (h0 : topological_space (measure_theory.measure_space empty)) (h1 : function.extfun Type preorder) : @order_closed_topology.{0} (measure_theory.measure_space.{0} empty) h0 (@function.extfun_app.{2 1} Type preorder.{0} h1 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_126239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_126240 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq))) : totally_disconnected_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126241 (h0 : uniform_space (semiring (random_gen linarith.comp_source))) : complete_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126242 (h0 : function.extfun Type ring) : @rank_condition.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126243 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_126244 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group unsigned)) (option unsigned)) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_126245 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (has_neg pos)) : @add_monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (has_neg.{0} pos) h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_126246 (h0 : monoid (has_to_string (has_add Type))) : monoid.fg (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_126247 (h0 : add_monoid (ordered_comm_monoid (complete_distrib_lattice name))) : add_monoid.fg (ordered_comm_monoid (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_126248 (h0 : monoid (pseudo_emetric_space unsigned)) : monoid.fg (pseudo_emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_126249 (h0 : complete_lattice (ordered_comm_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_126250 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126251 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126252 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126253 (h0 : topological_space (mul_zero_class (option ennreal))) : irreducible_space (mul_zero_class (option ennreal)) := sorry --non-trivial
lemma new_lemma_126254 (h0 : filter (has_nndist (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_126255 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126256 (h0 : topological_space (has_add (finset linarith.comp))) : regular_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_126257 (h0 : ring (semiring (boolean_algebra.core num))) : strong_rank_condition (semiring (boolean_algebra.core num)) := sorry --non-trivial
lemma new_lemma_126258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126259 (h0 : functor.add_const (monoid (boolean_algebra.core empty)) empty) : @monoid.fg.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_126260 (h0 : topological_space (complete_linear_order congr_arg_kind)) : locally_compact_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126261 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_126262 (h0 : functor.add_const (function.extfun Type uniform_space) (finset (finset linarith.comp))) : @complete_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_126263 (h0 : topological_space (with_one (random_gen (has_norm linarith.comp)))) : totally_disconnected_space (with_one (random_gen (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_126264 (h0 : topological_space (has_compl (random_gen char))) : path_connected_space (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_126265 (h0 : add_group (semigroup (has_add ennreal))) : is_add_cyclic (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_126266 (h0 : not (group (distrib_lattice linarith.comp_source) -> false)) : @is_cyclic.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_126267 (h0 : not (ring linarith.comp_source -> false)) : @rank_condition.{0} linarith.comp_source (@classical.by_contradiction'.{1} (ring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_126268 : is_trans ereal well_ordering_rel := sorry --non-trivial
lemma new_lemma_126269 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @irreducible_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126270 (h0 : not (monoid (complete_semilattice_Sup fun_info) -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_126271 (h1 : add_group (distrib_lattice linarith.comp_source)) : is_add_cyclic (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126272 (h0 : ring (has_norm (random_gen congr_arg_kind))) : is_domain (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126273 (h0 : topological_space (has_append fun_info)) : t0_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_126274 (h0 : functor.add_const (topological_space (has_bot pos)) linarith.comp) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126275 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126276 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_126277 (h0 : ring (denumerable (random_gen (random_gen char)))) : strong_rank_condition (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_126278 (h0 : group (complete_semilattice_Sup (has_norm empty))) : is_cyclic (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_126279 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_126280 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf (has_Inf real)))))) : locally_compact_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_126281 (h0 : topological_space (add_cancel_monoid empty)) : preirreducible_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_126282 (h0 : not (topological_space to_additive.value_type -> false)) : @path_connected_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_126283 (h0 : semiring (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_126284 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_126285 (h0 : group (normed_group (has_top linarith.comp_source))) : is_cyclic (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126286 (h0 : ring (has_add (sub_neg_monoid linarith.comp))) : strong_rank_condition (has_add (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_126287 (h0 : function.extfun Type group) : @is_cyclic.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_126289 (h1 : not (uniform_space (complete_semilattice_Sup num) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_126290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_126291 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126292 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) num) : @t1_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_126293 (h0 : complete_lattice (distrib (has_nnnorm (random_gen reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_126294 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_126295 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_add (option num))) := sorry --non-trivial
lemma new_lemma_126296 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring num)) : unique_factorization_monoid (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_126297 (h1 : topological_space (with_one to_additive.value_type)) : t0_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_126298 (h0 : topological_space (ring (has_neg_part Type))) : t1_space (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_126299 (h0 : complete_lattice (normed_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126300 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_126301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126303 (h1 : add_group (has_lt char)) : is_add_cyclic (has_lt char) := sorry --non-trivial
lemma new_lemma_126304 (h0 : monoid (has_norm (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (has_norm (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_126305 (h0 : topological_space (cancel_monoid (comm_group (boolean_algebra.core name)))) : irreducible_space (cancel_monoid (comm_group (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_126306 (h0 : ring (has_append (has_ssubset reducibility_hints))) : rank_condition (has_append (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_126307 (h0 : ring (topological_space (has_ssubset to_additive.value_type))) : rank_condition (topological_space (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_126308 (h0 : uniform_space (normed_field (random_gen (has_nnnorm char)))) : complete_space (normed_field (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_126309 (h0 : topological_space (has_lt fun_info)) (h1 : add_group (has_lt fun_info)) : topological_add_group (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_126310 (h0 : not (uniform_space (measure_theory.measure_space unsigned) -> false)) : @separated_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126311 (h0 : ring (ordered_ring unsigned)) : strong_rank_condition (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_126312 (h0 : functor.add_const (group (has_zero Type)) name) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_126313 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126314 (h0 : filter (cancel_monoid (option congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126315 : infinite (finset (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_126316 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126317 (h1 : not (topological_space (has_emptyc num) -> false)) : @t0_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_126318 (h3 : topological_space (has_div string_imp)) : t0_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_126319 (h0 : topological_space (ring (has_Inf Type))) : t1_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_126320 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @separated_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126321 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_126322 (h0 : has_lt (has_compl linarith.ineq)) : no_max_order (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_126323 (h0 : functor.add_const (ordered_comm_monoid (has_zero pos)) Type) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_126324 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126325 (h0 : functor.add_const (monoid (mul_zero_class ennreal)) (has_neg_part Type)) : @monoid.fg.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (mul_zero_class.{0} ennreal)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126326 (h0 : functor.add_const (add_group (has_to_string pos)) name) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_126327 (h0 : topological_space (has_neg_part unsigned)) : t1_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_126328 (h0 : functor.add_const (ring (finset linarith.comp)) Type) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_126329 (h0 : filter (mul_one_class char) -> Prop) (h1 : ring (derive_fintype.finset_in h0)) : rank_condition (derive_fintype.finset_in h0) := sorry --non-trivial
lemma new_lemma_126330 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126331 (h1 : topological_space (normed_field linarith.comp_source)) (h2 : add_group (normed_field linarith.comp_source)) : topological_add_group (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126332 (h0 : complete_lattice (add_comm_semigroup num)) : is_compactly_generated (add_comm_semigroup num) := sorry --non-trivial
lemma new_lemma_126333 (h0 : functor.add_const (semiring (left_cancel_monoid num)) num) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_126334 (h0 : topological_space (add_cancel_monoid (has_neg_part pos))) : locally_compact_space (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_126335 (h0 : semiring (linear_ordered_comm_group (option unsigned))) : is_noetherian_ring (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_126336 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (finset (finset (finset Type)))) : @is_compactly_generated.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (finset.{1} (finset.{1} (finset.{1} Type))) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_126337 (h0 : ring (free_add_monoid unsigned)) : is_principal_ideal_ring (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_126338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126339 (h0 : topological_space (metric_space empty)) : topological_space.separable_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_126340 (h0 : complete_lattice (has_nndist name)) : is_compactly_generated (has_nndist name) := sorry --non-trivial
lemma new_lemma_126341 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_126342 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126343 (h0 : complete_lattice (complete_linear_order unsigned)) : is_compactly_generated (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_126344 (h0 : ring (has_zero (option pos))) : is_principal_ideal_ring (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_126345 (h0 : functor.comp group has_add name) : @is_cyclic.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126346 (h0 : functor.add_const (topological_space (has_bot pos)) linarith.comp) : @discrete_topology.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126347 (h0 : ring (linear_ordered_field ennreal)) : rank_condition (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_126348 (h0 : functor.add_const Prop (comm_monoid congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_126349 (h0 : filter (complete_distrib_lattice (finset (finset name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_126350 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126351 (h0 : ring (normed_group (has_top linarith.comp_source))) : is_domain (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126352 (h0 : not (topological_space (partial_order empty) -> false)) (h1 : preorder (partial_order empty)) : @order_closed_topology.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0) h1  := sorry --non-trivial
lemma new_lemma_126353 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) name) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_126354 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_add_cyclic.{0} fun_info (@finset.pi.empty.{1 0} Type add_group.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_126355 (h0 : not (topological_space (add_left_cancel_monoid char) -> false)) : @path_connected_space.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_126356 (h0 : group (measurable_space.dynkin_system (semiring (has_top empty)))) : normalizer_condition (measurable_space.dynkin_system (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_126357 (h0 : topological_space (simple_graph Type)) : path_connected_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_126358 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) name) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_126359 (h0 : group (has_one (semiring (has_norm (semiring (semiring linarith.comp)))))) : normalizer_condition (has_one (semiring (has_norm (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_126360 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126361 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_126362 (h0 : topological_space (bin_tree num)) : locally_compact_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_126363 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_126364 (h0 : uniform_space (denumerable (has_nnnorm (has_nnnorm fun_info)))) : complete_space (denumerable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_126365 (h0 : not (topological_space (random_gen reducibility_hints) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_126366 (h0 : topological_space linarith.comp_source) : totally_separated_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_126367 (h0 : has_lift fun_info Prop) (h1 : fun_info) : @lift.{1 1} fun_info Prop h0 h1  := sorry --non-trivial
lemma new_lemma_126368 (h0 : measurable_space (has_append (has_nnnorm fun_info))) (h1 : has_sub (has_append (has_nnnorm fun_info))) : has_measurable_sub₂ (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_126369 (h0 : uniform_space (topological_space linarith.ineq)) : complete_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_126370 (h0 : topological_space (linear_ordered_field (option empty))) : normal_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_126371 (h0 : ring (finset (has_add linarith.comp))) : rank_condition (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_126372 (h0 : group (linear_ordered_semiring (has_norm linarith.comp))) : normalizer_condition (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_126373 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126374 (h0 : not (multiset Prop -> false)) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@classical.by_contradiction'.{1} (multiset.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_126375 (h0 : filter (simple_graph unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126376 (h0 : functor.add_const (topological_space (has_to_string Type)) unsigned) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_126377 (h0 : ring (id (semiring (has_norm num)))) : rank_condition (id (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_126378 (h0 : topological_space (has_le linarith.comp_source)) (h1 : preorder (has_le linarith.comp_source)) : order_topology (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126379 (h0 : semiring (add_cancel_monoid (finset name))) : is_noetherian_ring (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_126380 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126381 (h0 : functor.comp group has_nndist name) : @group.fg.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126383 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126384 (h0 : topological_space (has_neg_part (comm_group name))) : preirreducible_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_126385 (h0 : uniform_space (has_nnnorm (mul_one_class enat))) : complete_space (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_126386 (h0 : functor.add_const (functor.comp monoid boolean_algebra name) unsigned) : @monoid.fg.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} boolean_algebra.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} monoid.{0} boolean_algebra.{0} name) unsigned h0))  := sorry --non-trivial
lemma new_lemma_126387 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126388 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group empty)) empty) : @separated_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_126389 (h0 : linear_ordered_field (option congr_arg_kind) -> linear_ordered_field (option congr_arg_kind) -> Prop) : is_symm (linear_ordered_field (option congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_126390 (h0 : not (group (encodable linarith.ineq) -> false)) : @is_cyclic.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_126391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_126392 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126393 (h0 : ring (linear_ordered_semiring congr_arg_kind)) : rank_condition (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126394 (h0 : topological_space (has_dist (option (option ennreal)))) : locally_compact_space (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_126395 (h0 : ring (semiring linarith.comp_source)) : strong_rank_condition (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126396 (h0 : functor.add_const (finset Type) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126397 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_126398 (h0 : topological_space (distrib_lattice (has_ssubset linarith.ineq))) : irreducible_space (distrib_lattice (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126399 (h1 : has_le (add_comm_semigroup enat)) (h2 : add_comm_semigroup enat) : is_bot h2 := sorry --non-trivial
lemma new_lemma_126400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126401 (h0 : group (has_norm (has_norm linarith.comp_source))) : is_cyclic (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126402 (h0 : topological_space (has_add environment.implicit_infer_kind)) : sequential_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126403 (h0 : topological_space (boolean_algebra (has_add (has_add name)))) : locally_compact_space (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_126404 (h0 : topological_space (mul_one_class (add_comm_semigroup enat))) : totally_disconnected_space (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_126405 (h0 : functor.add_const (filter (has_to_string pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126406 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126407 (h0 : functor.add_const (group (comm_group Type)) name) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_126408 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group empty)) congr_arg_kind) : @archimedean.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_126409 (h0 : complete_lattice (has_neg_part (has_neg_part pos))) : complete_lattice.is_Sup_finite_compact (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_126410 (h0 : finset (as_linear_order unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126411 (h0 : functor.add_const (complete_lattice (semiring num)) (semiring (semiring unsigned))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} num)) (semiring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126412 (h0 : ring (has_ssubset (random_gen (has_top fun_info)))) : strong_rank_condition (has_ssubset (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_126413 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_126414 (h0 : complete_lattice (has_neg (add_group linarith.comp))) : is_atomistic (has_neg (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_126415 (h0 : ring (bin_tree (semiring num))) : is_domain (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_126416 (h0 : topological_space (has_add (semigroup (boolean_algebra (normed_comm_ring Type))))) : totally_disconnected_space (has_add (semigroup (boolean_algebra (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_126417 (h0 : topological_space (has_neg_part (has_add (has_add (has_add environment.implicit_infer_kind))))) : discrete_topology (has_neg_part (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_126418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_to_string name)) := sorry --non-trivial
lemma new_lemma_126419 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_126420 (h0 : functor.add_const (topological_space (linear_ordered_field name)) pos) : @regular_space.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_126421 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_126422 (h0 : monoid (has_neg (has_pos_part linarith.comp))) : monoid.fg (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_126423 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_126425 (h0 : topological_space (has_nndist (has_nndist (finset pos)))) : topological_space.separable_space (has_nndist (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_126426 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : irreducible_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_126427 (h0 : functor.add_const (topological_space (ring pos)) pos) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_126428 (h0 : ring (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : strong_rank_condition (has_div (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_126429 (h0 : add_group (partial_order (semiring (semiring (semiring num))))) : is_add_cyclic (partial_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_126430 (h1 : ring (distrib linarith.comp_source)) : strong_rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126431 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_126432 (h0 : topological_space (has_add (has_add (has_add (sub_neg_monoid name))))) : topological_space.separable_space (has_add (has_add (has_add (sub_neg_monoid name)))) := sorry --non-trivial
lemma new_lemma_126433 (h0 : ring (has_le ereal)) : is_domain (has_le ereal) := sorry --non-trivial
lemma new_lemma_126434 (h0 : monoid (finset (ring pos))) : monoid.fg (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_126435 (h0 : topological_space (add_cancel_comm_monoid (has_ssubset (mul_one_class reducibility_hints)))) : path_connected_space (add_cancel_comm_monoid (has_ssubset (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_126436 (h0 : complete_lattice (normed_group (has_top congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126437 (h0 : function.extfun Type (functor.add_const (topological_space nnreal))) : irreducible_space nnreal := sorry --non-trivial
lemma new_lemma_126438 (h4 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h4 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126440 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf linarith.comp)) : @normal_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_126441 (h0 : functor.add_const (group (has_nndist name)) (mul_zero_class pos)) : @group.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126442 (h0 : topological_space (complete_semilattice_Sup string_imp)) : t0_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_126443 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg pos)) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126444 (h1 : group string_imp) : group.fg string_imp := sorry --non-trivial
lemma new_lemma_126445 (h0 : functor.add_const (topological_space (has_add (semigroup environment.implicit_infer_kind))) (has_pos_part Type)) : @totally_disconnected_space.{0} (has_add.{0} (semigroup.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} (semigroup.{0} environment.implicit_infer_kind))) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126446 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_126447 (h0 : topological_space (has_to_string (has_to_string (has_to_string name)))) : t1_space (has_to_string (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_126448 (h1 : set (has_compl std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_126449 (h0 : monoid (add_cancel_monoid (ring (has_add (has_neg Type))))) : monoid.fg (add_cancel_monoid (ring (has_add (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_126450 (h0 : group (with_zero char)) : group.fg (with_zero char) := sorry --non-trivial
lemma new_lemma_126451 (h0 : complete_lattice (has_ssubset std_gen)) : is_compactly_generated (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_126452 (h0 : ring (cancel_monoid pos)) : is_principal_ideal_ring (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_126453 (h0 : topological_space (sub_neg_monoid pos)) : t1_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_126454 (h1 : filter linarith.ineq) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_126455 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_126456 (h0 : ring (denumerable string_imp)) : strong_rank_condition (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_126457 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (has_neg name)) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_126458 (h0 : topological_space (semigroup (boolean_algebra.core pos))) : t1_space (semigroup (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_126459 (h0 : functor.add_const (group (plift unsigned)) unsigned) : @is_cyclic.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_126460 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_126461 (h0 : topological_space (boolean_algebra.core (option empty))) : discrete_topology (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_126462 (h0 : functor.add_const (topological_space (has_zero ennreal)) pos) : @preconnected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_126463 (h0 : complete_lattice (normed_group congr_arg_kind)) : is_compactly_generated (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126464 (h0 : not (complete_lattice (with_bot (semiring linarith.comp)) -> false)) : @is_atomistic.{0} (with_bot.{0} (semiring.{0} linarith.comp)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} (semiring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_126465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : preconnected_space real := sorry --non-trivial
lemma new_lemma_126466 (h0 : topological_space (ordered_comm_ring (has_bot (has_add (has_add real))))) : normal_space (ordered_comm_ring (has_bot (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_126467 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_126468 (h0 : fin has_zero.zero) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_126469 (h0 : add_group (semi_normed_ring string_imp)) : is_add_cyclic (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_126470 (h0 : group (finset (finset (finset ennreal)))) : group.fg (finset (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_126471 (h0 : functor.add_const (function.extfun Type topological_space) (mul_one_class linarith.comp)) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (mul_one_class.{0} linarith.comp) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126472 (h0 : ring (ordered_comm_monoid (has_Inf (has_Inf (has_add Type))))) : strong_rank_condition (ordered_comm_monoid (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_126473 (h0 : function.extfun Type (functor.add_const (finset (normed_comm_ring empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 (option unsigned))) := sorry --non-trivial
lemma new_lemma_126474 (h0 : monoid (has_neg_part environment.implicit_infer_kind)) : monoid.fg (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126475 (h0 : functor.add_const (complete_lattice (option empty)) (semiring (semiring num))) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126476 (h0 : group (has_top empty)) : group.fg (has_top empty) := sorry --non-trivial
lemma new_lemma_126477 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_126478 (h0 : ring (has_neg (finset (finset (has_nndist pos))))) : rank_condition (has_neg (finset (finset (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_126479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_126480 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : totally_disconnected_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126481 (h0 : function.extfun Type metric_space) (h1 : set (measurable_space empty)) : @euclidean_geometry.cospherical.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type metric_space.{0} h0 (measurable_space.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_126482 (h1 : topological_space (comm_ring (has_nnnorm (normed_group to_additive.value_type)))) : locally_compact_space (comm_ring (has_nnnorm (normed_group to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126483 (h0 : ring (canonically_linear_ordered_monoid (has_neg (has_neg name)))) : rank_condition (canonically_linear_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_126484 (h0 : ordered_add_comm_monoid (ordered_comm_group (comm_monoid unsigned))) : archimedean (ordered_comm_group (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_126485 (h0 : topological_space (bin_tree (semiring num))) : preirreducible_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_126486 (h0 : topological_space (denumerable linarith.comp_source)) : totally_disconnected_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126487 (h0 : complete_lattice (pseudo_metric_space name)) : is_atomistic (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_126488 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126489 (h0 : group (normed_group num)) : group.fg (normed_group num) := sorry --non-trivial
lemma new_lemma_126490 (h0 : finset (finset congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126491 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126492 (h0 : functor.add_const (filter (has_neg_part Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126493 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_126494 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126495 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @complete_lattice.is_Sup_finite_compact.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_126496 (h0 : not (topological_space (has_sub unsigned) -> false)) : @discrete_topology.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126497 (h0 : ring (finset (option empty))) : is_domain (finset (option empty)) := sorry --non-trivial
lemma new_lemma_126498 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class char))) : totally_disconnected_space (add_cancel_comm_monoid (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_126499 (h0 : add_group (has_le string.iterator_imp)) : is_add_cyclic (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_126500 (h0 : functor.comp topological_space add_cancel_monoid pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_126501 (h0 : ring (ordered_comm_ring (sub_neg_monoid (has_add real)))) : is_domain (ordered_comm_ring (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_126502 (h0 : uniform_space (measurable_space (has_norm empty))) : complete_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_126503 (h0 : ring (topological_space (has_inv char))) : strong_rank_condition (topological_space (has_inv char)) := sorry --non-trivial
lemma new_lemma_126504 (h0 : topological_space (normed_comm_ring (complete_distrib_lattice Type))) : discrete_topology (normed_comm_ring (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_126505 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126506 (h0 : monoid (has_to_string (has_add (has_add Type)))) : monoid.fg (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_126507 (h1 : not (uniform_space string_imp -> false)) : @complete_space.{0} string_imp (@classical.by_contradiction'.{1} (uniform_space.{0} string_imp) h1)  := sorry --non-trivial
lemma new_lemma_126508 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) name) : @locally_compact_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_126509 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @is_atomistic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_126510 (h0 : functor.add_const (ring (has_neg Type)) pos) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_126511 (h0 : topological_space (has_inter ennreal)) : preirreducible_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_126512 (h0 : complete_lattice (has_neg (has_neg (has_neg environment.implicit_infer_kind)))) : is_compactly_generated (has_neg (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_126513 (h0 : list (finset (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_126514 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126515 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @topological_space.separable_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_126516 (h0 : add_group (mul_zero_class num)) : is_add_cyclic (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_126517 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (generalized_boolean_algebra pos)) : @preirreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (generalized_boolean_algebra.{0} pos) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_126518 (h0 : complete_lattice (ordered_comm_ring (has_add (sub_neg_monoid Type)))) : is_compactly_generated (ordered_comm_ring (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_126519 (h0 : functor.add_const (ring (boolean_algebra.core name)) name) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_126520 (h0 : group (has_inv (has_top (random_gen to_additive.value_type)))) : is_cyclic (has_inv (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126521 (h0 : ring (has_nndist environment.implicit_infer_kind)) : is_principal_ideal_ring (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126522 (h0 : functor.add_const (functor.add_const (list Type) linarith.comp) linarith.comp) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_126523 (h0 : uniform_space (with_one congr_arg_kind)) : complete_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126524 (h1 : complete_lattice (distrib linarith.ineq)) : complete_lattice.is_Sup_finite_compact (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_126525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126526 (h0 : topological_space (has_add Type)) : loc_path_connected_space (has_add Type) := sorry --non-trivial
lemma new_lemma_126527 (h0 : topological_space (ordered_comm_monoid name)) : regular_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_126528 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @t0_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_126529 (h0 : group (canonically_ordered_comm_semiring congr_arg_kind)) : normalizer_condition (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126530 (h0 : topological_space (normed_comm_ring (has_add pos))) : irreducible_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_126531 (h0 : finset (has_add (has_Inf real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126532 (h0 : functor.add_const Prop (canonically_linear_ordered_monoid name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_126533 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option empty))))) : normal_space (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_126534 (h0 : function.extfun nat fin) : @sequential_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126535 (h1 : set (add_comm_semigroup char -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_126536 (h0 : topological_space (topological_space (random_gen (random_gen (random_gen (random_gen char)))))) : path_connected_space (topological_space (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_126537 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_126538 (h0 : functor.comp topological_space has_zero unsigned) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_126539 (h0 : topological_space (has_zero (ring linarith.comp))) : t1_space (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_126540 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126541 (h0 : topological_space (has_add (has_add (has_nndist linarith.comp)))) : locally_compact_space (has_add (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_126542 (h1 : complete_lattice (non_unital_non_assoc_semiring std_gen)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_126543 (h0 : functor.comp topological_space has_neg name) : @loc_path_connected_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126544 (h3 : ring (has_nnnorm (mul_one_class string.iterator_imp))) : strong_rank_condition (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_126545 (h0 : topological_space (has_add (finset Type))) : regular_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_126546 (h0 : ring (has_to_string name)) : is_principal_ideal_ring (has_to_string name) := sorry --non-trivial
lemma new_lemma_126547 (h0 : has_lt (has_nnnorm std_gen)) : no_max_order (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_126548 (h0 : group (comm_group (has_neg (has_neg_part linarith.comp)))) : is_simple_group (comm_group (has_neg (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_126549 (h0 : function.extfun Type topological_space) : @t1_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126550 (h0 : function.extfun (complete_lattice (ring num)) (fun (x : complete_lattice (ring num)), Prop)) (h1 : Exists (fun (x : complete_lattice (ring num)), function.extfun_app h0 x)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} num) (@classical.some.{1} (complete_lattice.{0} (ring.{0} num)) (@function.extfun_app.{1 1} (complete_lattice.{0} (ring.{0} num)) (λ (x : complete_lattice.{0} (ring.{0} num)), Prop) h0) h1)  := sorry --non-trivial
lemma new_lemma_126551 (h0 : complete_lattice (pseudo_metric_space ennreal)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_126552 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_126554 (h0 : not (group (add_group congr_arg_kind) -> false)) : @group.fg.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126555 (h0 : add_group (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : is_add_cyclic (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_126556 (h0 : ring (uniform_space (distrib reducibility_hints))) : strong_rank_condition (uniform_space (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_126557 (h0 : ring (filter (semiring unsigned))) : is_principal_ideal_ring (filter (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_126558 (h0 : topological_space (has_pos_part (has_add (has_Inf (ring linarith.comp))))) : normal_space (has_pos_part (has_add (has_Inf (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_126559 (h0 : multiset Prop) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) h0  := sorry --non-trivial
lemma new_lemma_126560 (h0 : list (has_neg (boolean_algebra environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126562 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_126563 (h2 : has_lt (nondiscrete_normed_field environment.projection_info)) : no_max_order (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_126564 (h0 : uniform_space (id (semiring empty))) : separated_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_126565 (h0 : functor.add_const (uniform_space (option num)) congr_arg_kind) : @complete_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_126566 (h0 : set (simple_graph char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_126567 (h0 : monoid (random_gen (random_gen (has_top to_additive.value_type)))) : monoid.fg (random_gen (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126568 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} bool) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} bool))  := sorry --non-trivial
lemma new_lemma_126569 (h0 : topological_space (has_nndist (has_add Type))) : topological_space.separable_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_126570 (h0 : topological_space (has_top (has_norm empty))) : totally_separated_space (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_126571 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_126572 (h0 : ring (has_nndist (option (option unsigned)))) : is_principal_ideal_ring (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_126573 (h0 : group stieltjes_function) : group.fg stieltjes_function := sorry --non-trivial
lemma new_lemma_126574 (h0 : functor.comp ordered_add_comm_monoid has_neg name) : @archimedean.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126575 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : regular_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_126576 (h0 : add_group (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : is_add_cyclic (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_126577 (h0 : not (complete_lattice (measurable_space empty) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space empty) := sorry --non-trivial
lemma new_lemma_126578 (h0 : add_monoid (has_to_string (has_to_string pos))) : add_monoid.fg (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_126579 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126580 (h2 : not (topological_space (has_add to_additive.value_type) -> false)) : @t0_space.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_126581 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : discrete_topology (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126582 (h0 : functor.add_const (group (has_pos_part pos)) linarith.comp) : @is_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126583 (h0 : topological_space (boolean_algebra.core (finset linarith.comp))) : normal_space (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_126584 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126585 (h0 : ring (monoid_with_zero (monoid_with_zero congr_arg_kind))) : is_principal_ideal_ring (monoid_with_zero (monoid_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126586 (h0 : prod (linear_ordered_comm_group ennreal) (linear_ordered_comm_group ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_126587 (h0 : topological_space (random_gen (has_top (has_top (has_top (has_top num)))))) : preirreducible_space (random_gen (has_top (has_top (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_126588 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : sequential_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126589 (h0 : function.extfun nat fin) : @rank_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_126591 (h0 : not (topological_space (metric_space unsigned) -> false)) : @irreducible_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126592 (h0 : function.extfun Type topological_space) : @normal_space.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126593 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (finset (finset (ring linarith.comp)))) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (finset.{0} (finset.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_126594 (h0 : add_group (pseudo_metric_space string_imp)) : is_add_cyclic (pseudo_metric_space string_imp) := sorry --non-trivial
lemma new_lemma_126595 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126596 (h0 : not (list (semi_normed_comm_ring string_imp) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_126597 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126598 (h0 : ring (has_neg (finset pos))) : is_domain (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_126599 (h0 : functor.comp topological_space complete_distrib_lattice name) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126600 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_126601 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_pos_part pos)) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126602 (h0 : topological_space (left_cancel_monoid (semiring empty))) : totally_separated_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_126603 (h0 : finset bool) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126604 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126605 (h0 : topological_space (random_gen (has_inv to_additive.value_type))) : totally_separated_space (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_126606 (h0 : set (linear_ordered_comm_group_with_zero std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_126607 (h0 : topological_space (add_cancel_monoid (has_nndist Type))) : normal_space (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_126608 (h0 : functor.add_const (group (add_comm_monoid unsigned)) linarith.comp) : @is_cyclic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126609 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_126610 (h1 : topological_space (distrib_lattice char)) : totally_disconnected_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_126611 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : path_connected_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_126612 (h1 : ring (has_nnnorm linarith.comp_source)) : strong_rank_condition (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126614 (h0 : complete_lattice (omega_complete_partial_order congr_arg_kind)) : is_atomistic (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126615 (h0 : ring (canonically_ordered_comm_semiring unsigned)) : rank_condition (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_126616 (h0 : ring (has_emptyc (complete_semilattice_Sup num))) : rank_condition (has_emptyc (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_126617 (h0 : monoid (with_one (random_gen linarith.comp_source))) : monoid.fg (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126618 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group ennreal)) : unique_factorization_monoid (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_126619 (h0 : complete_lattice (normed_comm_ring (has_neg_part pos))) : is_compactly_generated (normed_comm_ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_126620 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_126621 (h0 : semiring (ordered_cancel_add_comm_monoid (sub_neg_monoid pos))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_126622 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) empty) : @locally_compact_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_126623 (h0 : functor.add_const (group (has_nndist Type)) linarith.comp) : @is_simple_group.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126624 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (finset Type)) : @irreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126625 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126626 (h0 : group (has_to_string (has_Inf (has_Inf (has_neg pos))))) : group.fg (has_to_string (has_Inf (has_Inf (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_126627 (h0 : topological_space (finset (has_pos_part pos))) : t0_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_126628 (h0 : semiring (has_top (semiring (semiring (semiring unsigned))))) : is_noetherian_ring (has_top (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_126629 (h0 : topological_space (has_to_string (finset (finset pos)))) : totally_disconnected_space (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_126630 (h0 : uniform_space (linear_ordered_field ennreal)) : separated_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_126631 (h0 : topological_space (boolean_algebra (has_pos_part (finset linarith.comp)))) : locally_compact_space (boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_126632 (h0 : monoid (has_neg_part (has_add (add_comm_monoid environment.implicit_infer_kind)))) : monoid.fg (has_neg_part (has_add (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_126633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126634 (h0 : has_mem.mem num has_emptyc.emptyc) : @is_cyclic.{0} num (@finset.pi.empty.{1 0} Type group.{0} num h0)  := sorry --non-trivial
lemma new_lemma_126635 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_126636 (h0 : topological_space (generalized_boolean_algebra (finset Type))) : totally_separated_space (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_126637 (h0 : complete_lattice (has_compl (random_gen char))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_126638 (h0 : topological_space (has_pos_part name)) : discrete_topology (has_pos_part name) := sorry --non-trivial
lemma new_lemma_126639 (h0 : functor.add_const (topological_space (option num)) empty) : @totally_separated_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_126640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_126641 (h0 : set (simple_graph fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_126642 (h0 : functor.add_const (topological_space (has_nndist pos)) ennreal) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_126643 (h0 : topological_space (option (option (option pos)))) : normal_space (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_126644 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid pos))) : path_connected_space (complete_distrib_lattice (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_126645 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : irreducible_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_126646 (h0 : group (generalized_boolean_algebra (has_neg pos))) : is_cyclic (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_126647 (h0 : Type) (h1 : euclidean_domain Type) (h2 : decidable_eq Type) (h3 : function.extfun Type list) : palindrome (function.extfun_app h3 (has_union (euclidean_domain.gcd_a linarith.comp h0))) := sorry --non-trivial
lemma new_lemma_126648 (h0 : filter (has_neg (has_nndist name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_126649 (h0 : uniform_space (random_gen (random_gen (random_gen (mul_one_class string_imp))))) : complete_space (random_gen (random_gen (random_gen (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_126650 (h2 : ring (distrib reducibility_hints)) : is_domain (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_126651 (h0 : group linarith.comp) : group.fg linarith.comp := sorry --non-trivial
lemma new_lemma_126652 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_126653 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_well_founded.{1} pos) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_well_founded.{1} pos))  := sorry --non-trivial
lemma new_lemma_126654 (h0 : filter (linear_ordered_field pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_126655 (h0 : ring (has_compl (has_ssubset (has_ssubset fun_info)))) : strong_rank_condition (has_compl (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_126656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_126657 (h0 : uniform_space (has_neg (option pos))) : separated_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_126658 (h0 : functor.comp group pseudo_metric_space ennreal) : @normalizer_condition.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_126659 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126660 (h0 : functor.add_const (functor.add_const (function.extfun Type uniform_space) linarith.comp) name) : @complete_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp) name h0)) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_126661 (h0 : function.extfun (finset Type) (has_mem.mem (lattice to_additive.value_type))) : @complete_lattice.is_Sup_finite_compact.{0} (lattice.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (lattice.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (lattice.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_126662 (h0 : complete_lattice (id (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_compactly_generated (id (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_126663 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset (ring pos))) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (finset.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_126664 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : normal_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_126665 (h0 : ring (as_linear_order unsigned)) : strong_rank_condition (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_126666 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126667 (h0 : monoid (plift (semiring empty))) : monoid.fg (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_126668 (h0 : complete_lattice (plift congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126669 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) Type) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_126670 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add (mul_zero_class pos))) : @separated_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{0} (mul_zero_class.{0} pos)) h0) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126671 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126672 (h0 : ring (has_add (has_neg (has_Inf Type)))) : rank_condition (has_add (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_126673 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126674 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring empty)))) : @complete_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126676 (h0 : ordered_comm_monoid (has_add (complete_semilattice_Sup (mul_one_class linarith.comp)))) : has_exists_mul_of_le (has_add (complete_semilattice_Sup (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_126677 (h0 : complete_lattice (has_top (random_gen (random_gen string_imp)))) : is_compactly_generated (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_126678 (h0 : uniform_space (finset num)) : separated_space (finset num) := sorry --non-trivial
lemma new_lemma_126679 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126680 (h0 : topological_space (has_union (semiring (has_norm unsigned)))) : totally_disconnected_space (has_union (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_126681 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_neg name)))) : locally_compact_space (canonically_ordered_monoid (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_126682 (h0 : uniform_space (mul_zero_class (finset (finset ennreal)))) : complete_space (mul_zero_class (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_126683 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_126684 (h0 : not (group (semiring num) -> false)) : @group.fg.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126685 (h0 : functor.add_const (group (finset linarith.comp)) (has_neg pos)) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126686 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126687 (h0 : function.extfun nat fin) : @regular_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.exponent_exists.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126689 (h0 : topological_space (add_right_cancel_monoid (plift (semiring (semiring (semiring num)))))) : path_connected_space (add_right_cancel_monoid (plift (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_126690 (h0 : topological_space (has_top (semiring (semiring unsigned)))) : discrete_topology (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_126691 (h0 : monoid (add_right_cancel_monoid (has_top num))) : monoid.fg (add_right_cancel_monoid (has_top num)) := sorry --non-trivial
lemma new_lemma_126692 (h0 : complete_lattice (canonically_ordered_monoid empty)) : is_compactly_generated (canonically_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_126693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126694 (h0 : topological_space (has_neg_part (finset pos))) : path_connected_space (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_126695 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_126696 (h0 : add_group (complete_semilattice_Sup linarith.ineq)) : is_add_cyclic (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_126697 (h0 : uniform_space (dlist fun_info)) : complete_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_126698 (h0 : filter (add_right_cancel_monoid (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126699 (h0 : monoid (with_bot (has_inv (has_inv linarith.comp_source)))) : monoid.fg (with_bot (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_126700 (h0 : monoid (has_sub (semiring (semiring empty)))) : monoid.fg (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_126701 (h0 : ring (has_zero (ring (ring (ring (ring environment.implicit_infer_kind)))))) : strong_rank_condition (has_zero (ring (ring (ring (ring environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_126702 (h0 : not (ring (uniform_space string_imp) -> false)) : @is_domain.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_126703 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126704 (h2 : ring (has_compl to_additive.value_type)) : rank_condition (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_126705 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126706 (h0 : complete_lattice (has_union linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_126707 (h0 : uniform_space (mul_zero_class (mul_zero_class pos))) : separated_space (mul_zero_class (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_126708 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_126709 (h0 : functor.add_const (topological_space (has_Sup empty)) congr_arg_kind) : @totally_separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_126710 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_126711 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_126712 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @sequential_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_126713 (h0 : topological_space (denumerable (has_nnnorm linarith.comp_source))) : path_connected_space (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126714 (h0 : monoid (complete_distrib_lattice (has_Inf pos))) : monoid.fg (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_126715 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_126716 (h0 : topological_space (has_compl (mul_one_class (has_lt enat)))) : totally_disconnected_space (has_compl (mul_one_class (has_lt enat))) := sorry --non-trivial
lemma new_lemma_126717 (h0 : uniform_space (finset (finset (has_pos_part linarith.comp)))) : complete_space (finset (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_126718 (h0 : topological_space (boolean_algebra (has_pos_part (has_add Type)))) : regular_space (boolean_algebra (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_126719 (h0 : function.extfun Type group) : @group.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126720 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @discrete_topology.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_126721 (h0 : topological_space (ordered_comm_ring (has_add (has_pos_part (has_Inf real))))) : loc_path_connected_space (ordered_comm_ring (has_add (has_pos_part (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_126722 (h0 : functor.comp topological_space ring name) : @path_connected_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126723 (h0 : topological_space (left_cancel_monoid (semiring empty))) : path_connected_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_126724 (h0 : topological_space (simple_graph empty)) : totally_disconnected_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_126725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126726 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_126727 (h0 : topological_space (normed_group (random_gen linarith.comp_source))) : totally_separated_space (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126728 (h0 : uniform_space (complete_distrib_lattice ennreal)) : complete_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_126729 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126730 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_126731 (h0 : not (complete_lattice (has_sub empty) -> false)) : @is_atomistic.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_126732 (h0 : topological_space (encodable string_imp)) (h1 : measurable_space (encodable string_imp)) : opens_measurable_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_126733 (h0 : ordered_add_comm_monoid (has_Inf (has_neg pos))) : archimedean (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_126734 (h0 : list (normed_lattice_add_comm_group linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126735 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_pos_part name))) : archimedean (ordered_comm_ring (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_126736 (h0 : topological_space (has_norm (has_ssubset to_additive.value_type))) : locally_compact_space (has_norm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_126737 (h0 : topological_space (linear_ordered_comm_group unsigned)) : totally_disconnected_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_126738 (h0 : functor.add_const (ring empty) (semiring empty)) : @is_principal_ideal_ring.{0} empty (@functor.add_const.run.{0 0} (ring.{0} empty) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126739 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_126740 (h0 : functor.add_const (topological_space (monoid_with_zero unsigned)) pos) : @totally_separated_space.{0} (monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_126741 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : irreducible_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126742 (h0 : topological_space (ordered_comm_monoid (has_add real))) : loc_path_connected_space (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_126743 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : totally_disconnected_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_126744 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @add_monoid.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_126745 (h0 : topological_space (with_bot (has_inv (has_inv (denumerable (has_inv linarith.ineq)))))) : path_connected_space (with_bot (has_inv (has_inv (denumerable (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_126746 (h0 : group (semi_normed_comm_ring char)) : group.fg (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_126747 (h0 : not (add_group (with_bot linarith.comp) -> false)) : @is_add_cyclic.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_126748 (h0 : topological_space (has_norm (has_top linarith.comp_source))) : totally_separated_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126749 (h0 : group (has_nnnorm (has_nnnorm linarith.ineq))) : group.fg (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126750 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : t0_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_126751 (h0 : cancel_monoid environment.implicit_infer_kind -> cancel_monoid environment.implicit_infer_kind -> Prop) : is_symm (cancel_monoid environment.implicit_infer_kind) h0 := sorry --non-trivial
lemma new_lemma_126752 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_126753 (h0 : topological_space (plift (semiring (semiring (semiring (semiring (semiring num))))))) : totally_separated_space (plift (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_126754 (h0 : topological_space (ring (boolean_algebra linarith.comp))) : path_connected_space (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_126755 (h0 : ring (has_pos_part (ring (has_Inf linarith.comp)))) : strong_rank_condition (has_pos_part (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_126756 (h0 : complete_lattice (has_nndist (add_comm_monoid pos))) : is_atomistic (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_126757 (h0 : functor.add_const (complete_lattice (mul_zero_class empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_126758 (h0 : group (add_cancel_monoid (has_add pos))) : is_simple_group (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_126759 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126760 (h0 : monoid (ordered_comm_group empty)) : monoid.fg (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_126761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_126762 (h3 : ring (has_append char)) : strong_rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_126763 (h0 : topological_space string.iterator_imp) : path_connected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_126764 (h0 : group (has_union (semiring (semiring (has_union empty))))) : normalizer_condition (has_union (semiring (semiring (has_union empty)))) := sorry --non-trivial
lemma new_lemma_126765 (h0 : complete_lattice (has_star (semiring (semiring (semiring (semiring empty)))))) : is_atomistic (has_star (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_126766 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) (comm_group Type)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126767 (h0 : ereal -> order_hom nat Prop) (h1 : ereal) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@www_fun.{1 1} ereal (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_126768 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @discrete_topology.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_126769 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string Type)) environment.implicit_infer_kind) : @archimedean.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126770 (h0 : add_group (simple_graph char)) : is_add_cyclic (simple_graph char) := sorry --non-trivial
lemma new_lemma_126771 (h0 : topological_space bool) : t0_space bool := sorry --non-trivial
lemma new_lemma_126772 (h0 : function.extfun Type group) : @group.fg.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126773 (h1 : set string_imp) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_126774 (h0 : not (ring (bin_tree congr_arg_kind) -> false)) : @strong_rank_condition.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126775 (h1 : set congr_arg_kind) : set.finite h1 := sorry --non-trivial
lemma new_lemma_126776 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} (has_add.{0} (has_add.{0} (add_comm_monoid.{0} (comm_group.{0} pos))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} (has_add.{0} (has_add.{0} (add_comm_monoid.{0} (comm_group.{0} pos))))))  := sorry --non-trivial
lemma new_lemma_126777 (h0 : topological_space (semiring (semiring (semiring unsigned)))) : path_connected_space (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_126778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126779 (h0 : topological_space (normed_comm_ring (finset (finset linarith.comp)))) : t1_space (normed_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_126780 (h0 : topological_space (has_neg_part (mul_zero_class unsigned))) : discrete_topology (has_neg_part (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_126781 (h0 : add_monoid (boolean_algebra.core unsigned)) : add_monoid.fg (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_126782 (h0 : group (add_comm_monoid (comm_monoid unsigned))) : is_cyclic (add_comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_126783 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126784 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @t0_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126785 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @group.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_126786 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) (has_add pos)) : @strong_rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126787 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126788 (h0 : finset (ordered_cancel_add_comm_monoid (option (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126789 (h0 : not (complete_lattice (distrib_lattice linarith.ineq) -> false)) : @is_compactly_generated.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_126790 (h0 : fin has_zero.zero) : list.head (matrix.vec_empty (id (id h0))) := sorry --non-trivial
lemma new_lemma_126791 (h0 : filter (has_neg_part (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126792 (h0 : topological_space (semigroup (has_neg (has_neg (ring (has_to_string environment.implicit_infer_kind)))))) : t0_space (semigroup (has_neg (has_neg (ring (has_to_string environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_126793 (h0 : group (ordered_comm_ring (finset (finset (finset Type))))) : normalizer_condition (ordered_comm_ring (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_126794 (h0 : functor.add_const (add_monoid (normed_comm_ring name)) pos) : @add_monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_126795 (h0 : functor.add_const (monoid (semigroup name)) Type) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126796 (h0 : functor.add_const (finset (has_to_string pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_126797 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero unsigned)) : archimedean (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_126798 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : normal_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_126799 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (option (option pos)))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_126800 (h0 : string_imp -> string_imp -> Prop) : is_strict_order string_imp h0 := sorry --non-trivial
lemma new_lemma_126801 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_126803 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_126804 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_126805 (h0 : ring (comm_group environment.implicit_infer_kind)) : strong_rank_condition (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126806 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_126807 (h0 : topological_space (semiring (has_norm (has_inv linarith.comp_source)))) : irreducible_space (semiring (has_norm (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_126808 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) name) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_126809 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : locally_compact_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_126810 (h0 : topological_space (has_Inf real)) : preconnected_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_126811 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_126812 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_126813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (distrib_lattice fun_info)) := sorry --non-trivial
lemma new_lemma_126814 (h0 : add_comm_monoid (boolean_algebra.core ennreal) -> add_comm_monoid (boolean_algebra.core ennreal) -> Prop) : is_symm (add_comm_monoid (boolean_algebra.core ennreal)) h0 := sorry --non-trivial
lemma new_lemma_126815 (h2 : set (enat -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_126816 (h0 : functor.add_const (ring (has_add linarith.comp)) linarith.comp) : @rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126817 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_126818 (h0 : not (topological_space (has_one unsigned) -> false)) : @totally_separated_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_126819 (h0 : group (monoid ennreal)) : is_cyclic (monoid ennreal) := sorry --non-trivial
lemma new_lemma_126820 (h0 : functor.add_const (group (ring linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126821 (h0 : topological_space (random_gen (has_nnnorm linarith.comp_source))) : t0_space (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_126822 (h0 : ring (omega_complete_partial_order congr_arg_kind)) : is_principal_ideal_ring (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126823 (h0 : finset (mul_zero_class congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_126824 (h0 : add_monoid (has_bot (has_Inf pos))) : add_monoid.fg (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_126825 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126826 (h0 : set (has_ssubset (mul_one_class environment.projection_info) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_126827 (h0 : linarith.comp_source -> linarith.ineq -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_126828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (uniform_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126829 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_126830 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) (h1 : function.extfun Type (fun (x : Type), Prop)) : @is_greatest.{1} Type (@function.extfun_app.{3 2} (Type 1) preorder.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 preorder.{1}) Type) (@function.extfun_app.{2 1} Type (λ (x : Type), Prop) h1) empty  := sorry --non-trivial
lemma new_lemma_126831 (h0 : topological_space (boolean_algebra.core ennreal)) : loc_path_connected_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_126832 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_126833 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126834 (h0 : add_group (dlist (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (dlist (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_126835 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : path_connected_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126836 (h0 : topological_space (has_star (semiring (semiring (ordered_cancel_comm_monoid unsigned))))) : locally_compact_space (has_star (semiring (semiring (ordered_cancel_comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_126837 (h0 : functor.comp topological_space has_to_string unsigned) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_126838 (h0 : add_group (semiring (semiring unsigned))) : is_add_cyclic (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_126839 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) (has_add name)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_126840 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126841 (h0 : semiring (comm_group (comm_group Type))) : is_noetherian_ring (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_126842 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_126843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_126844 (h0 : add_monoid (add_comm_monoid unsigned)) : add_monoid.fg (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_126845 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (linear_order empty)))) : @unique_factorization_monoid.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_126846 (h0 : functor.add_const (topological_space (has_neg pos)) (boolean_algebra Type)) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126847 (h0 : functor.comp topological_space has_neg name) : @totally_separated_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_126848 (h0 : uniform_space (add_group (linear_ordered_semiring (has_top num)))) : complete_space (add_group (linear_ordered_semiring (has_top num))) := sorry --non-trivial
lemma new_lemma_126849 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add name)) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{0} name) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_126850 (h0 : functor.add_const (add_monoid (cancel_monoid name)) Type) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126851 (h0 : topological_space (has_edist empty)) : t0_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_126852 (h4 : prod linarith.ineq linarith.ineq) : set.diagonal linarith.ineq h4 := sorry --non-trivial
lemma new_lemma_126853 (h0 : complete_lattice (normed_lattice_add_comm_group name)) : is_atomistic (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_126854 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126855 (h0 : list (semi_normed_comm_ring (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126856 (h0 : complete_lattice linarith.comp) : complete_lattice.is_Sup_finite_compact linarith.comp := sorry --non-trivial
lemma new_lemma_126857 (h0 : set (mul_one_class string.iterator_imp -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_126858 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @is_atomistic.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126859 (h0 : complete_lattice (linear_ordered_comm_group_with_zero string.iterator_imp)) : is_compactly_generated (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_126860 (h0 : topological_space (comm_group unsigned)) : normal_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_126861 (h0 : complete_lattice (complete_distrib_lattice empty)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_126862 (h0 : functor.add_const (function.extfun Type semiring) (ring (finset linarith.comp))) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (ring.{0} (finset.{0} linarith.comp)) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126863 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126864 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_126865 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126866 (h0 : ring (has_nndist (group_with_zero name))) : strong_rank_condition (has_nndist (group_with_zero name)) := sorry --non-trivial
lemma new_lemma_126867 (h0 : complete_lattice (monoid (option (option empty)))) : complete_lattice.is_Sup_finite_compact (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_126868 (h0 : list (measurable_space.dynkin_system congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_126869 (h0 : list (ordered_comm_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126870 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_126871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_126872 (h0 : topological_space (has_to_string (add_comm_monoid (comm_group Type)))) : normal_space (has_to_string (add_comm_monoid (comm_group Type))) := sorry --non-trivial
lemma new_lemma_126873 (h0 : uniform_space (sub_neg_monoid (has_Inf linarith.comp))) : complete_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_126874 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) (has_sdiff Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (has_sdiff.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_126875 (h0 : functor.add_const (uniform_space (add_semigroup empty)) empty) : @complete_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_126876 (h0 : semiring (has_nndist (finset ennreal))) : is_noetherian_ring (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_126877 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C empty)) (option unsigned)) : @archimedean.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_126878 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126879 (h0 : topological_space (ring (option empty))) : irreducible_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_126880 (h0 : ring (has_dist ennreal)) : rank_condition (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_126881 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126882 (h0 : list (add_comm_monoid (has_neg_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : topological_space.separable_space real := sorry --non-trivial
lemma new_lemma_126884 (h0 : function.extfun Type (prod znum)) : id_rel (function.extfun_app h0 znum) := sorry --non-trivial
lemma new_lemma_126885 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_126886 (h0 : topological_space (comm_group (ring Type))) : t1_space (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_126887 (h0 : filter (add_right_cancel_monoid (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126888 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_126889 (h0 : group (has_top linarith.comp_source)) : group.fg (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_126890 (h1 : not (complete_lattice (denumerable char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_126891 (h0 : function.extfun Type (functor.add_const (group (free_add_monoid empty)))) : @normalizer_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (free_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_126892 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : path_connected_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_126893 (h0 : not (ring (has_star num) -> false)) : @is_principal_ideal_ring.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126894 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_126895 (h0 : topological_space (has_nndist pos)) : preconnected_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_126896 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_126897 (h0 : measurable_space enat) (h1 : measure_theory.measure enat) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_126898 (h0 : add_monoid (ring num)) : add_monoid.fg (ring num) := sorry --non-trivial
lemma new_lemma_126899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126900 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (finset pos))) : unique_factorization_monoid (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_126901 (h0 : functor.add_const (topological_space (ring name)) pos) : @topological_space.separable_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_126902 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (ring (has_to_string Type))) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) (ring.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_126903 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_126904 (h0 : group (with_bot (has_ssubset to_additive.value_type))) : is_cyclic (with_bot (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_126905 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_126906 (h0 : functor.add_const (uniform_space (has_zero name)) pos) : @complete_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_126907 (h0 : functor.add_const (complete_lattice (finset name)) Type) : @is_atomistic.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_126908 (h1 : set (nondiscrete_normed_field ereal)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_126909 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_126910 (h0 : uniform_space (sub_neg_monoid (has_bot real))) : separated_space (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_126911 (h0 : monoid (left_cancel_semigroup (semiring unsigned))) : monoid.fg (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_126912 (h0 : ring (has_pos_part (has_neg pos))) : strong_rank_condition (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_126913 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_126914 (h0 : filter (linear_ordered_semiring (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_126915 (h0 : metric_space empty -> num -> num) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_126916 (h0 : list (has_to_string (has_add (has_add Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126917 (h0 : monoid (linear_ordered_comm_ring congr_arg_kind)) : monoid.fg (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126918 (h0 : list (has_ssubset (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126919 (h1 : complete_lattice (normed_group (has_top linarith.ineq))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126920 (h0 : uniform_space (finset empty)) : complete_space (finset empty) := sorry --non-trivial
lemma new_lemma_126921 (h1 : complete_lattice (has_emptyc linarith.comp)) : is_atomistic (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_126922 (h0 : not (add_group (has_norm char) -> false)) : @is_add_cyclic.{0} (has_norm.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_126923 (h0 : list (comm_ring (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126924 (h0 : list (has_top (has_norm (has_inv linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_126925 (h0 : functor.add_const (ring (metric_space num)) (semiring empty)) : @is_principal_ideal_ring.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (metric_space.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_126926 (h1 : has_mem.mem linarith.comp has_emptyc.emptyc) : @strong_rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_126927 (h0 : ring (semi_normed_ring (has_lt char))) : is_domain (semi_normed_ring (has_lt char)) := sorry --non-trivial
lemma new_lemma_126928 (h1 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h1 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126929 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @regular_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126930 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126931 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_domain.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126932 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126933 (h0 : set (random_gen linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_126934 (h0 : topological_space (comm_group (option ennreal))) : totally_disconnected_space (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_126935 (h0 : functor.add_const (ring ennreal) num) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num h0)  := sorry --non-trivial
lemma new_lemma_126936 (h0 : topological_space (add_semigroup unsigned)) : path_connected_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_126937 (h0 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_126938 (h2 : complete_lattice (complete_semilattice_Sup num)) : is_atomistic (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_126939 (h0 : group (normed_group (random_gen (random_gen to_additive.value_type)))) : group.fg (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_126940 (h0 : pseudo_metric_space (option pos) -> pseudo_metric_space (option pos) -> Prop) : is_symm (pseudo_metric_space (option pos)) h0 := sorry --non-trivial
lemma new_lemma_126941 (h0 : not (ring znum -> false)) : @rank_condition.{0} znum (@classical.by_contradiction'.{1} (ring.{0} znum) h0)  := sorry --non-trivial
lemma new_lemma_126942 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126943 (h0 : topological_space (metric_space (has_norm (has_norm (has_top congr_arg_kind))))) : t0_space (metric_space (has_norm (has_norm (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_126944 (h0 : topological_space (ring (has_pos_part environment.implicit_infer_kind))) : locally_compact_space (ring (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_126945 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126946 (h0 : topological_space (cancel_monoid congr_arg_kind)) : totally_separated_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126947 (h0 : filter (normed_lattice_add_comm_group (sub_neg_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_126948 (h0 : topological_space (ring environment.implicit_infer_kind)) : totally_separated_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_126949 (h0 : not (add_group (distrib_lattice to_additive.value_type) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_126950 (h0 : semiring ereal) (h1 : ereal) : even h1 := sorry --non-trivial
lemma new_lemma_126951 (h0 : complete_lattice (with_zero fun_info)) : is_compactly_generated (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_126952 (h0 : topological_space (add_cancel_monoid (normed_comm_ring (boolean_algebra.core Type)))) : preirreducible_space (add_cancel_monoid (normed_comm_ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_126953 (h0 : not (complete_lattice (has_norm empty) -> false)) : @is_atomistic.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_126954 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126955 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_add pos)) := sorry --non-trivial
lemma new_lemma_126956 (h0 : add_monoid (normed_comm_ring congr_arg_kind)) : add_monoid.fg (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_126958 (h0 : ring (has_append (has_nnnorm (random_gen char)))) : rank_condition (has_append (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_126959 (h0 : fin has_zero.zero) : @t0_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_126960 (h0 : topological_space (simple_graph congr_arg_kind)) : t1_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_126961 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_126962 (h1 : ring (fintype (has_nnnorm char))) : invariant_basis_number (fintype (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_126963 (h0 : functor.comp topological_space mul_zero_class Type) : @topological_space.separable_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_126964 (h0 : group (normed_group (random_gen linarith.ineq))) : normalizer_condition (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_126966 (h0 : functor.add_const (function.extfun Type ring) (ring linarith.comp)) : @is_domain.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} linarith.comp) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_126967 (h0 : not (topological_space (complete_linear_order num) -> false)) : @totally_separated_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_126968 (h0 : add_monoid (non_assoc_semiring (has_top (has_top (semiring (semiring empty)))))) : add_monoid.fg (non_assoc_semiring (has_top (has_top (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_126969 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_126970 (h0 : add_monoid (has_to_string (measurable_space.dynkin_system name))) : add_monoid.fg (has_to_string (measurable_space.dynkin_system name)) := sorry --non-trivial
lemma new_lemma_126971 (h0 : complete_lattice (distrib_lattice (ring linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_126972 (h0 : ordered_add_comm_monoid (non_assoc_semiring (option (option (option empty))))) : archimedean (non_assoc_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_126973 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_126974 (h0 : complete_lattice (generalized_boolean_algebra (has_add pos))) : is_compactly_generated (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_126975 (h0 : ring (has_compl string_imp)) : is_domain (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_126976 (h0 : topological_space (comm_semigroup (ordered_comm_monoid (has_Inf (has_add (has_pos_part pos)))))) : discrete_topology (comm_semigroup (ordered_comm_monoid (has_Inf (has_add (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_126977 (h0 : functor.add_const (ring (has_add Type)) pos) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_126978 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_126979 (h1 : complete_lattice (distrib char)) : is_compactly_generated (distrib char) := sorry --non-trivial
lemma new_lemma_126980 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (has_neg pos)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_126981 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist name)) name) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_126982 (h0 : add_monoid (normed_comm_ring (has_to_string pos))) : add_monoid.fg (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_126983 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @locally_compact_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_126984 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_126985 (h0 : group (with_bot (semiring empty))) : group.fg (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_126986 (h0 : function.extfun Type (functor.add_const (ring unsigned))) : @strong_rank_condition.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} unsigned)) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_126987 (h0 : add_monoid (ring (add_comm_monoid Type))) : add_monoid.fg (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_126988 (h0 : uniform_space (has_top (semiring (semiring empty)))) : separated_space (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_126989 (h1 h2 : multiset (linear_ordered_comm_group_with_zero environment.projection_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_126990 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring pos)) real) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_126991 (h0 : fin has_zero.zero) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_126992 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_126993 (h0 : topological_space (has_zero num)) : regular_space (has_zero num) := sorry --non-trivial
lemma new_lemma_126994 (h0 : functor.add_const (ordered_add_comm_monoid (has_dist ennreal)) unsigned) : @archimedean.{0} (has_dist.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_dist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_126995 (h0 : function.extfun Type (functor.comp group has_neg)) : @is_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_neg.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_126996 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option congr_arg_kind))) : archimedean (add_cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126997 (h0 : monoid (has_add (has_zero (ring (ring name))))) : monoid.fg (has_add (has_zero (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_126998 (h0 : topological_space (has_sub (semiring congr_arg_kind))) : t0_space (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_126999 (h0 : topological_space (has_compl (has_nnnorm linarith.comp_source))) : t0_space (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_127000 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot num)) := sorry --non-trivial
lemma new_lemma_127001 (h2 : not (complete_lattice (with_zero to_additive.value_type) -> false)) : @is_compactly_generated.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_127002 (h0 : add_group (mul_one_class (add_comm_semigroup (mul_one_class char)))) : is_add_cyclic (mul_one_class (add_comm_semigroup (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_127003 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127004 (h0 : add_monoid (bin_tree congr_arg_kind)) : add_monoid.fg (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_127005 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_127006 (h0 : topological_space (finset (finset (finset linarith.comp)))) : preirreducible_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_127007 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Sup.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Sup.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_127008 (h0 : group (with_one linarith.ineq)) : group.fg (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_127009 (h0 : topological_space (option (semiring (semiring num)))) : t1_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_127010 (h0 : group (semigroup (semigroup ennreal))) : normalizer_condition (semigroup (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_127011 (h1 : ring (topological_space (random_gen linarith.ineq))) : is_domain (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127012 (h1 : not (ring (has_nnnorm string_imp) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_127013 (h2 : uniform_space (distrib char)) : complete_space (distrib char) := sorry --non-trivial
lemma new_lemma_127014 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_127015 (h0 : semiring (add_comm_semigroup nat)) (h3 : add_comm_semigroup nat) : even h3 := sorry --non-trivial
lemma new_lemma_127016 (h0 : functor.comp topological_space finset Type) : @t0_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_127017 (h0 : topological_space (random_gen (has_norm unsigned))) : path_connected_space (random_gen (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_127018 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semilattice_inf.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127019 (h0 : topological_space (with_bot (has_norm num))) : t0_space (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_127020 (h0 : uniform_space (has_norm (has_inv (has_top (has_inv linarith.comp_source))))) : complete_space (has_norm (has_inv (has_top (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_127021 (h0 : group (generalized_boolean_algebra (ring (has_nndist (has_add pos))))) : is_simple_group (generalized_boolean_algebra (ring (has_nndist (has_add pos)))) := sorry --non-trivial
lemma new_lemma_127022 (h0 : filter (option (option (option (option congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127023 (h0 : monoid (preorder unsigned)) : monoid.fg (preorder unsigned) := sorry --non-trivial
lemma new_lemma_127024 (h0 : topological_space (with_bot (has_inv (random_gen (has_inv linarith.comp_source))))) : locally_compact_space (with_bot (has_inv (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_127025 (h0 : complete_lattice (has_compl to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127026 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) : path_connected_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_127027 (h0 : complete_lattice (has_bot (has_add (has_bot real)))) : complete_lattice.is_Sup_finite_compact (has_bot (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_127028 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_127029 (h0 : not (uniform_space (linear_ordered_semiring linarith.comp) -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_127030 (h0 : functor.add_const (semiring rat) num) : is_noetherian_ring rat := sorry --non-trivial
lemma new_lemma_127031 (h0 : group (with_one linarith.comp)) : is_cyclic (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_127032 (h0 : list (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127033 (h0 : functor.add_const (monoid (add_comm_monoid pos)) pos) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127034 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @locally_compact_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127035 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_127036 (h0 : filter (has_top (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127037 (h0 : functor.add_const (group (finset linarith.comp)) (ring (ring (ring Type)))) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) (ring.{1} (ring.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_127038 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_127039 (h0 : not (topological_space (div_inv_monoid to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_127040 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_127041 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option ennreal))) : is_atomistic (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_127042 (h0 : topological_space (generalized_boolean_algebra (ring (ring pos)))) : normal_space (generalized_boolean_algebra (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_127043 (h0 : semiring (add_left_cancel_semigroup (option (option unsigned)))) : is_noetherian_ring (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_127044 (h0 : monoid (linear_ordered_cancel_comm_monoid empty)) : monoid.fg (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_127045 (h0 : group (ordered_comm_monoid name)) : is_simple_group (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_127046 (h0 : monoid (option (semiring unsigned))) : monoid.fg (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127047 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_127048 (h0 : topological_space (has_neg (option (option ennreal)))) : preirreducible_space (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_127049 (h0 : filter (normed_comm_ring (has_add (add_comm_monoid name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_127050 (h0 : functor.add_const (topological_space (option num)) empty) : @t0_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_127051 (h0 : add_monoid (measure_theory.measure_space (has_top unsigned))) : add_monoid.fg (measure_theory.measure_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_127052 (h0 : complete_lattice (has_ssubset (metric_space (random_gen (random_gen string_imp))))) : is_compactly_generated (has_ssubset (metric_space (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_127053 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127054 (h0 : topological_space (semiring (semiring unsigned))) : topological_space.separable_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127055 (h0 : complete_lattice (measurable_space (has_norm (random_gen fun_info)))) : is_atomistic (measurable_space (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_127056 (h0 : topological_space (semi_normed_comm_ring (has_ssubset to_additive.value_type))) : t0_space (semi_normed_comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127057 (h0 : cancel_comm_monoid_with_zero (has_neg_part (finset Type))) : unique_factorization_monoid (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_127058 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127059 (h0 : functor.comp topological_space mul_zero_class pos) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_127060 (h0 : topological_space (has_ssubset (random_gen (random_gen linarith.ineq)))) : irreducible_space (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_127061 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_127062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_127063 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_127064 (h0 : topological_space (has_to_string (has_add Type))) : sequential_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_127065 (h0 : functor.add_const (uniform_space (option congr_arg_kind)) unsigned) : @complete_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127066 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_127067 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_127068 (h0 : group (measurable_space (has_norm congr_arg_kind))) : normalizer_condition (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127069 (h0 : group (normed_field (random_gen char))) : is_cyclic (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_127070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_127071 (h0 : set (add_comm_semigroup enat -> mul_one_class (add_comm_semigroup enat))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_127072 (h0 : add_monoid (mul_zero_class (has_to_string ennreal))) : add_monoid.fg (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_127073 (h0 : group (has_emptyc (has_top linarith.ineq))) : normalizer_condition (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127074 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_127075 (h0 : list (comm_group (has_to_string (has_to_string Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_127076 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @irreducible_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_127077 (h0 : complete_lattice (canonically_linear_ordered_monoid (option ennreal))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_127078 (h0 : add_group (has_Inf Type)) : is_add_cyclic (has_Inf Type) := sorry --non-trivial
lemma new_lemma_127079 (h0 : ring (normed_comm_ring (comm_group (comm_group (comm_group name))))) : strong_rank_condition (normed_comm_ring (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_127080 (h0 : topological_space (topological_space (random_gen char))) : path_connected_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_127081 (h0 : uniform_space (has_Inf (has_neg name))) : complete_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_127082 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_127083 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_127084 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127085 (h0 : order_hom nat (topological_space (monoid ennreal))) : @normal_space.{0} (monoid.{0} ennreal) (@monotonic_sequence_limit.{0} (topological_space.{0} (monoid.{0} ennreal)) (@topological_space.partial_order.{0} (monoid.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_127086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_127087 (h0 : topological_space (has_add environment.implicit_infer_kind)) : locally_compact_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_127088 (h0 : functor.add_const (filter (ring linarith.comp)) (comm_group (has_add name))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127089 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_127090 (h0 : group (boolean_algebra (semigroup Type))) : is_cyclic (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_127091 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_disconnected_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_127092 (h0 : complete_lattice (has_bot (has_Inf pos))) : is_atomistic (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_127093 (h0 : functor.add_const (group (boolean_algebra.core pos)) name) : @group.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_127094 (h0 : ring (free_add_monoid unsigned)) : rank_condition (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_127095 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg unsigned)) Type) : @archimedean.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_127096 (h0 : functor.comp group has_neg_part Type) : @normalizer_condition.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_127097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127098 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @is_simple_group.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 pos)) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_127099 (h0 : functor.add_const (topological_space (has_Inf pos)) (finset linarith.comp)) : @path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_127100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_127101 (h0 h1 : set real) (h2 : with_bot (fin has_zero.zero)) (h3 : ne h2 has_bot.bot) : set.re_prod_im h0 h1 (matrix.vec_empty (matrix.vec_empty (with_bot.unbot h2 h3))) := sorry --non-trivial
lemma new_lemma_127102 (h2 : add_group string.iterator_imp) : is_add_cyclic string.iterator_imp := sorry --non-trivial
lemma new_lemma_127103 (h0 : finset (ordered_comm_monoid (has_nndist pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127104 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127105 (h0 : uniform_space (linear_ordered_semiring (linear_ordered_semiring unsigned))) : separated_space (linear_ordered_semiring (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127106 (h0 : has_to_string (has_to_string Type) -> has_to_string (has_to_string Type) -> has_to_string (has_to_string Type)) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_127107 (h0 : topological_space (boolean_algebra (has_add name))) : preirreducible_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_127108 (h0 : ring (has_ssubset (has_ssubset fun_info))) : strong_rank_condition (has_ssubset (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_127109 (h0 : group (simple_graph (generalized_boolean_algebra environment.implicit_infer_kind))) : is_cyclic (simple_graph (generalized_boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127110 (h0 : fin has_zero.zero) : nat.prime (matrix.vec_empty h0) := sorry --non-trivial
lemma new_lemma_127111 (h0 : topological_space (comm_group (has_add name))) : t0_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_127112 (h0 : topological_space (boolean_algebra (finset name))) : loc_path_connected_space (boolean_algebra (finset name)) := sorry --non-trivial
lemma new_lemma_127113 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_127114 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : totally_disconnected_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_127115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_127116 (h0 : topological_space (boolean_algebra (comm_group unsigned))) : preconnected_space (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_127117 (h0 : complete_lattice (dlist (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_127118 (h0 : list (dlist (random_gen (has_ssubset (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127119 (h0 : topological_space (has_nndist linarith.comp)) : t0_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_127120 (h0 : ring (has_sub (semiring (semiring unsigned)))) : strong_rank_condition (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_127121 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127122 (h0 : filter (ring (metric_space (has_add (has_Inf (has_Inf linarith.comp)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_127125 (h0 : group (mul_one_class fun_info)) (h1 : subgroup (mul_one_class fun_info)) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_127126 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_127127 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_127128 (h0 : functor.add_const (group (semiring unsigned)) empty) : @group.fg.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_127129 (h0 : monoid (has_neg (has_nndist Type))) : monoid.fg (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_127130 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_127131 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127132 (h0 : cancel_comm_monoid_with_zero (has_neg (add_cancel_monoid Type))) : unique_factorization_monoid (has_neg (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_127133 (h0 : list (linear_ordered_add_comm_group (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127134 (h0 : set (semi_normed_ring (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_127135 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_127136 (h0 : filter (has_add (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127137 (h0 : complete_lattice (with_one (with_bot fun_info))) : complete_lattice.is_Sup_finite_compact (with_one (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_127138 (h0 : topological_space (left_cancel_monoid unsigned)) : normal_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_127139 (h0 : topological_space (cancel_monoid (has_nndist environment.implicit_infer_kind))) : t0_space (cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127141 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : totally_disconnected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127142 (h0 : ring (comm_ring (has_ssubset char))) : rank_condition (comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_127143 (h0 : finset (linear_order (option (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)))) congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127145 (h0 : topological_space (with_bot (semiring fun_info))) : totally_disconnected_space (with_bot (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_127146 (h0 : prod to_additive.value_type to_additive.value_type) : set.diagonal to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_127147 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_127148 (h0 : add_group (has_inv (has_inv (has_inv to_additive.value_type)))) : is_add_cyclic (has_inv (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_127149 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) (complete_distrib_lattice name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127150 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid linarith.comp)) (has_neg Type)) : @archimedean.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_127151 (h0 : function.extfun Type (functor.add_const (ring pos))) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127152 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_127153 (h0 : topological_space (simple_graph linarith.ineq)) : totally_disconnected_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_127154 (h0 : add_group (generalized_boolean_algebra (has_add (has_neg (has_neg name))))) : is_add_cyclic (generalized_boolean_algebra (has_add (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_127155 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_127156 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127157 (h0 : measurable_space (normed_field ereal)) (h1 : filter (normed_field ereal)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_127158 (h0 : topological_space (has_to_string (comm_group (has_add pos)))) : preconnected_space (has_to_string (comm_group (has_add pos))) := sorry --non-trivial
lemma new_lemma_127159 (h0 : topological_space (has_zero (has_neg_part unsigned))) : regular_space (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_127160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_127161 (h0 : topological_space (simple_graph (finset linarith.comp))) : t1_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_127162 (h0 : ring (semiring (semiring (semiring empty)))) : is_domain (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_127163 (h0 : fin has_zero.zero) : @separated_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127164 (h0 : ring (has_append (has_ssubset char))) : rank_condition (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_127165 (h0 : functor.add_const (ring (bin_tree empty)) unsigned) : @is_domain.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127166 (h0 : topological_space (monoid (option (option empty)))) : path_connected_space (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_127167 (h0 : functor.add_const (ordered_comm_monoid (has_add environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_127168 (h0 : function.extfun Type ring) : @is_domain.{0} num (@function.extfun_app.{2 1} Type ring.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_127169 (h0 : uniform_space (comm_semigroup name)) : separated_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_127170 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_nndist)) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_127171 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : loc_path_connected_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_127172 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf (sub_neg_monoid (has_Inf (sub_neg_monoid pos)))))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf (sub_neg_monoid (has_Inf (sub_neg_monoid pos))))) := sorry --non-trivial
lemma new_lemma_127173 (h0 : semiring (has_star (semiring (semiring empty)))) : is_noetherian_ring (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_127174 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_127175 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class environment.implicit_infer_kind)) (has_nndist Type)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_127176 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127177 (h0 : functor.comp topological_space finset Type) : @path_connected_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_127178 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_127179 (h2 : ring (semi_normed_ring fun_info)) : is_domain (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_127180 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127181 (h0 : topological_space (boolean_algebra.core Type)) : normal_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_127182 (h0 : topological_space (group_with_zero pos)) : totally_separated_space (group_with_zero pos) := sorry --non-trivial
lemma new_lemma_127183 (h0 : monoid (bin_tree (semiring empty))) : monoid.fg (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_127184 (h0 : group (has_add (cancel_monoid pos))) : is_simple_group (has_add (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_127185 (h0 : topological_space (monoid_with_zero (has_to_string pos))) : normal_space (monoid_with_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_127186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_127187 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_127188 (h0 : topological_space (has_to_string name)) : loc_path_connected_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_127189 (h0 : topological_space (linear_ordered_comm_group_with_zero (uniform_space string.iterator_imp))) : path_connected_space (linear_ordered_comm_group_with_zero (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_127190 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_127191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127192 (h0 : topological_space (has_Inf (boolean_algebra.core pos))) : totally_separated_space (has_Inf (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_127193 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (has_zero Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_127194 (h0 : list (mul_zero_class congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127195 (h0 : uniform_space (linear_ordered_semiring linarith.ineq)) : complete_space (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_127196 (h0 h1 : multiset (ordered_comm_monoid char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_127197 (h0 : topological_space (ordered_comm_ring (has_neg name))) : preconnected_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_127198 (h0 : group (add_group (random_gen empty))) : group.fg (add_group (random_gen empty)) := sorry --non-trivial
lemma new_lemma_127199 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @normal_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_127200 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_127201 (h0 : uniform_space (canonically_ordered_comm_semiring (option name))) : complete_space (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_127202 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) num) : @is_domain.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_127203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_127204 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127205 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_127206 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127207 (h0 : function.extfun Type (functor.add_const (functor.add_const (monoid (has_edist unsigned)) unsigned))) : @monoid.fg.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} unsigned)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} (has_edist.{0} unsigned)) unsigned) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (monoid.{0} (has_edist.{0} unsigned)) unsigned)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_127208 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_127209 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_127210 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : preconnected_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_127211 (h0 : not (ring (semi_normed_comm_ring reducibility_hints) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_127212 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127213 (h0 : topological_space (has_top (metric_space num))) : totally_disconnected_space (has_top (metric_space num)) := sorry --non-trivial
lemma new_lemma_127214 (h0 : complete_lattice (has_add (option unsigned))) : is_compactly_generated (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_127215 (h0 : topological_space (has_pos_part linarith.comp)) : discrete_topology (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_127216 (h0 : function.extfun Type group) : @group.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_127217 (h0 : ring (ordered_comm_group (option (option unsigned)))) : is_principal_ideal_ring (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_127218 (h0 : group (dlist (has_nnnorm (has_ssubset (has_nnnorm (has_ssubset fun_info)))))) : group.fg (dlist (has_nnnorm (has_ssubset (has_nnnorm (has_ssubset fun_info))))) := sorry --non-trivial
lemma new_lemma_127219 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_127220 (h0 : uniform_space (boolean_algebra (has_pos_part (has_Inf pos)))) : complete_space (boolean_algebra (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_127221 (h1 : add_group (non_unital_non_assoc_semiring to_additive.value_type)) : is_add_cyclic (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127222 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type))))) : totally_disconnected_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_127223 (h0 : add_monoid (metric_space (semiring unsigned))) : add_monoid.fg (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127224 (h0 : add_monoid (has_neg_part (add_comm_monoid environment.implicit_infer_kind))) : add_monoid.fg (has_neg_part (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127225 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_127226 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (ring pos))) : @irreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} (ring.{0} pos)) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127227 (h0 : not (monoid (has_sub num) -> false)) : @monoid.fg.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_127228 (h1 : group linarith.comp_source) : is_cyclic linarith.comp_source := sorry --non-trivial
lemma new_lemma_127229 (h0 : not (function.extfun (finset Type) (has_mem.mem (semiring fun_info)) -> false)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127230 (h0 : complete_lattice (semigroup (ring environment.implicit_infer_kind))) : is_compactly_generated (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127231 (h0 : complete_lattice (boolean_algebra (finset Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_127232 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_127233 (h0 : topological_space (add_comm_monoid (ring linarith.comp))) : t1_space (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_127234 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @preirreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_127235 (h0 : punit) (h1 : ring (has_nnnorm (has_repr (category_theory.hom_of_element ereal h0)))) : rank_condition (has_nnnorm (has_repr (category_theory.hom_of_element ereal h0))) := sorry --non-trivial
lemma new_lemma_127236 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127237 (h0 : topological_space (finset (finset (has_add pos)))) : discrete_topology (finset (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_127238 (h1 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_127239 (h0 : option (ring (has_le fun_info))) (h1 : coe_sort (option.is_some h0)) : @is_domain.{0} (has_le.{0} fun_info) (@option.get.{0} (ring.{0} (has_le.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_127240 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_127241 (h0 : ring (comm_group (has_add (add_cancel_monoid pos)))) : is_principal_ideal_ring (comm_group (has_add (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_127242 (h0 : ring (normed_field to_additive.value_type)) : rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127243 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : totally_disconnected_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127244 (h0 : topological_space (id (random_gen string_imp))) : totally_disconnected_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_127245 (h0 : functor.add_const (list (boolean_algebra name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127246 (h0 : filter (has_nnnorm char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127247 (h0 : functor.add_const (topological_space (finset name)) Type) : @sequential_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_127248 (h0 : group (has_nnnorm (random_gen (random_gen to_additive.value_type)))) : is_cyclic (has_nnnorm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_127249 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (with_bot num)) := sorry --non-trivial
lemma new_lemma_127250 (h0 : group (has_neg (has_pos_part pos))) : group.fg (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_127251 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (group.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_127252 (h0 : topological_space (has_zero (option (option pos)))) : preconnected_space (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_127253 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127254 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t1_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_127255 (h0 : add_group (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind))) : is_add_cyclic (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127256 (h0 : filter (has_top (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127257 (h0 : uniform_space (random_gen (random_gen (has_top (has_top linarith.comp_source))))) : complete_space (random_gen (random_gen (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_127258 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_127259 (h0 : not (function.extfun (finset Type) (has_mem.mem linarith.comp) -> false)) : @is_compactly_generated.{0} linarith.comp (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127260 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127261 (h1 h2 : multiset (has_div string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_127262 (h0 : not (uniform_space (normed_field string_imp) -> false)) : @complete_space.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_127263 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) unsigned) : @strong_rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127264 (h0 : functor.comp topological_space semigroup (finset environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (semigroup.{0} (finset.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_127265 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_127266 (h0 : finset (with_bot num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127267 (h1 : complete_lattice (has_append (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (has_append (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_127268 (h2 : not (add_group (topological_space char) -> false)) : @is_add_cyclic.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_127269 (h0 : topological_space (comm_ring (complete_semilattice_Sup (random_gen string_imp)))) : path_connected_space (comm_ring (complete_semilattice_Sup (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_127270 (h0 : group (left_cancel_semigroup num)) : is_cyclic (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_127271 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_127272 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_127273 (h0 : ring (topological_space string_imp)) : strong_rank_condition (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_127274 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) complete_lattice.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_127275 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (plift unsigned)) := sorry --non-trivial
lemma new_lemma_127276 (h0 : complete_lattice (has_ssubset (add_comm_semigroup fun_info))) : complete_lattice.is_Sup_finite_compact (has_ssubset (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_127277 (h0 : topological_space (has_star (option congr_arg_kind))) : topological_space.separable_space (has_star (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127278 (h0 : monoid (linear_ordered_semiring (random_gen (random_gen num)))) : monoid.fg (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_127279 (h0 : ring (ring (has_to_string pos))) : strong_rank_condition (ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_127280 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @discrete_topology.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_127281 (h4 : topological_space (has_ssubset char)) : path_connected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_127282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127283 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid (has_Inf linarith.comp))) : unique_factorization_monoid (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_127284 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127285 (h0 : finset (ring (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127287 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_127288 (h0 : cancel_comm_monoid_with_zero (add_group (has_top (semiring unsigned)))) : unique_factorization_monoid (add_group (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_127289 (h0 : topological_space (monoid_with_zero (option pos))) : loc_path_connected_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_127290 (h0 : topological_space (left_cancel_monoid (random_gen (random_gen char)))) : totally_disconnected_space (left_cancel_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_127291 (h0 : complete_lattice (with_bot congr_arg_kind)) : is_atomistic (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_127292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_127293 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127294 (h0 : group (boolean_algebra.core (complete_distrib_lattice Type))) : is_simple_group (boolean_algebra.core (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_127295 (h0 : add_group (uniform_space (comm_ring string_imp))) : is_add_cyclic (uniform_space (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_127296 (h0 : topological_space (comm_group name)) : normal_space (comm_group name) := sorry --non-trivial
lemma new_lemma_127297 (h0 : topological_space (finset (add_comm_monoid (add_comm_monoid unsigned)))) : totally_separated_space (finset (add_comm_monoid (add_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_127298 (h0 : ring (normed_comm_ring ennreal)) : is_principal_ideal_ring (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_127299 (h0 : set (with_bot linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_127300 (h0 : topological_space (finset linarith.comp)) : t0_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_127301 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) name) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_127302 (h0 : topological_space (semigroup (has_to_string environment.implicit_infer_kind))) : topological_space.separable_space (semigroup (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127303 (h0 : list (has_inv (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127304 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_Inf (ring pos)))) : archimedean (ordered_comm_ring (has_Inf (ring pos))) := sorry --non-trivial
lemma new_lemma_127305 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_127306 (h0 : topological_space (has_Sup empty)) : irreducible_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_127307 (h0 : finset (has_to_string (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127308 (h3 : uniform_space (topological_space (random_gen char))) : complete_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_127309 (h0 : topological_space (add_comm_semigroup ereal)) (h2 : preorder (add_comm_semigroup ereal)) : order_closed_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_127310 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127311 (h0 : semiring (generalized_boolean_algebra (has_add (has_add linarith.comp)))) : is_noetherian_ring (generalized_boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_127312 (h0 : functor.add_const (cancel_comm_monoid_with_zero (omega_complete_partial_order unsigned)) unsigned) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127314 (h0 : functor.comp topological_space complete_distrib_lattice pos) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos h0))))  := sorry --non-trivial
lemma new_lemma_127315 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_127316 (h0 : topological_space (has_compl (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : totally_disconnected_space (has_compl (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_127317 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_127318 (h0 : functor.add_const (filter (has_add Type)) (ring (ring (ring (finset Type))))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127319 (h0 : group (has_pos_part (finset Type))) : normalizer_condition (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_127320 (h0 : ordered_add_comm_monoid (boolean_algebra.core (option (option pos)))) : archimedean (boolean_algebra.core (option (option pos))) := sorry --non-trivial
lemma new_lemma_127321 (h0 : topological_space (plift (semiring (semiring (semiring (semiring (semiring empty))))))) : irreducible_space (plift (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_127322 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_127323 (h0 : group (has_Inf (has_pos_part (has_neg linarith.comp)))) : is_simple_group (has_Inf (has_pos_part (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_127324 (h0 : topological_space (has_inter (option (option (option unsigned))))) : normal_space (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_127325 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_127326 (h0 : has_lt (complete_linear_order (add_comm_semigroup fun_info))) : no_max_order (complete_linear_order (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_127327 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_127328 (h0 : complete_lattice (semi_normed_ring linarith.comp_source) -> string_imp) (h1 : coe_sort (set.range h0)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} linarith.comp_source) (@set.range_splitting.{0 0} (complete_lattice.{0} (semi_normed_ring.{0} linarith.comp_source)) string_imp h0 h1)  := sorry --non-trivial
lemma new_lemma_127329 (h0 : add_group (group_with_zero (option (option unsigned)))) : is_add_cyclic (group_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_127330 (h0 : topological_space (has_to_string (has_neg_part (has_add Type)))) : discrete_topology (has_to_string (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_127331 (h0 : functor.add_const (group (normed_comm_ring Type)) pos) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_127332 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) Type) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_127333 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127334 (h0 : function.extfun (finset Type) (has_mem.mem (uniform_space.core linarith.comp_source))) : @complete_space.{0} (uniform_space.core.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (uniform_space.core.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (uniform_space.core.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127335 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127336 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_127337 (h0 : add_group (with_one (random_gen string_imp))) : is_add_cyclic (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_127338 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_127339 (h0 : functor.add_const (list (boolean_algebra Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127340 (h0 : functor.add_const (filter (has_nndist name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127341 (h0 : functor.comp topological_space has_neg ennreal) : @totally_separated_space.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_127342 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_127343 (h0 : topological_space (group_with_zero num)) : preirreducible_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_127344 (h0 : add_group (linear_ordered_semiring (random_gen linarith.comp_source))) : is_add_cyclic (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_127345 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_127346 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : t1_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_127347 (h1 : not (ring (denumerable to_additive.value_type) -> false)) : @is_domain.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_127348 (h0 : topological_space (comm_ring (random_gen (has_ssubset linarith.ineq)))) : irreducible_space (comm_ring (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_127349 (h0 : finset (ring (has_neg (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127350 (h0 : ordered_add_comm_monoid (has_Inf (canonically_linear_ordered_monoid real))) : archimedean (has_Inf (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_127351 (h1 : topological_space environment.implicit_infer_kind) : path_connected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_127352 (h0 : functor.add_const (list (has_add Type)) (ordered_ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127353 (h0 : function.extfun Type (functor.add_const (uniform_space (has_bot empty)))) : @separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_127354 (h0 : set (char -> reducibility_hints)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_127355 (h0 : topological_space (has_compl (mul_one_class to_additive.value_type))) : totally_disconnected_space (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127356 (h0 : finset (has_nndist (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127357 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf real)))) : regular_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_127358 (h0 : group (encodable (has_top fun_info))) : is_cyclic (encodable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_127359 (h0 : function.extfun Type (functor.add_const (semiring (semigroup unsigned)))) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_127360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_127361 (h0 : monoid (has_zero (finset linarith.comp))) : monoid.fg (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_127362 (h0 : ring (add_comm_monoid environment.implicit_infer_kind)) : is_principal_ideal_ring (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_127363 (h0 : ring (boolean_algebra.core (has_add (has_add name)))) : is_principal_ideal_ring (boolean_algebra.core (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_127364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127365 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_127366 (h0 : functor.add_const (topological_space (has_bot name)) linarith.comp) : @preirreducible_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127367 (h0 : complete_lattice (has_neg (cancel_monoid (finset (finset Type))))) : is_atomistic (has_neg (cancel_monoid (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_127368 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127369 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_127370 (h0 : complete_lattice (has_neg (option (option empty)))) : is_compactly_generated (has_neg (option (option empty))) := sorry --non-trivial
lemma new_lemma_127371 (h0 : functor.add_const (add_monoid (canonically_ordered_monoid pos)) pos) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127372 (h0 : topological_space (complete_distrib_lattice (boolean_algebra unsigned))) : t0_space (complete_distrib_lattice (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_127373 (h1 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h1 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127374 (h0 : uniform_space (normed_field (has_nnnorm (has_nnnorm char)))) : complete_space (normed_field (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_127375 (h0 : set (has_div (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_127376 (h1 : topological_space fun_info) : path_connected_space fun_info := sorry --non-trivial
lemma new_lemma_127377 (h0 : group (measurable_space (has_inv to_additive.value_type))) : normalizer_condition (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127378 (h0 : functor.add_const (list (boolean_algebra name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127379 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127380 (h0 : functor.add_const (add_group (sub_neg_monoid linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127381 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring (has_neg Type))) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127382 (h1 : set (multiplicative (mul_one_class linarith.ineq))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_127383 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_127384 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf pos)) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} pos) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127385 (h0 : topological_space (add_left_cancel_semigroup empty)) : irreducible_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_127386 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @t1_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_127387 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_127388 (h0 : list (has_top (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127389 (h0 : not (filter (mul_zero_class unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_127390 (h0 : topological_space (with_bot (normed_group (has_inv string_imp)))) : t0_space (with_bot (normed_group (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_127391 (h0 : topological_space (finset pos)) : path_connected_space (finset pos) := sorry --non-trivial
lemma new_lemma_127392 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_127393 (h0 : add_monoid (filter (option (option unsigned)))) : add_monoid.fg (filter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_127394 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_127395 (h0 : topological_space (comm_group (comm_group (comm_group pos)))) : irreducible_space (comm_group (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_127396 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) (option congr_arg_kind)) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) (option.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_127397 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : locally_compact_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_127398 (h0 : uniform_space (normed_comm_ring (finset name))) : complete_space (normed_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_127399 (h0 : topological_space (metric_space (random_gen reducibility_hints))) : t0_space (metric_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_127400 (h0 : topological_space (pseudo_metric_space (option pos))) : discrete_topology (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_127401 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127402 (h0 : not (filter (div_inv_monoid linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_127403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_127404 (h0 : topological_space (add_cancel_monoid pos)) : preconnected_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_127405 (h0 : group (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : group.fg (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_127406 (h0 : add_group (semigroup (has_neg_part Type))) : is_add_cyclic (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_127407 (h0 : topological_space (metric_space (semiring linarith.comp))) : discrete_topology (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_127408 (h0 : functor.add_const (topological_space ennreal) num) : totally_disconnected_space ennreal := sorry --non-trivial
lemma new_lemma_127409 (h0 : topological_space (has_Inf (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid real))))) : t0_space (has_Inf (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid real)))) := sorry --non-trivial
lemma new_lemma_127410 (h1 : list (has_norm (random_gen int))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_127411 (h0 : add_group (add_cancel_monoid (boolean_algebra (comm_group pos)))) : is_add_cyclic (add_cancel_monoid (boolean_algebra (comm_group pos))) := sorry --non-trivial
lemma new_lemma_127412 (h1 : multiset Prop) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) h1  := sorry --non-trivial
lemma new_lemma_127413 (h0 : not (function.extfun Type (prod unsigned) -> false)) : id_rel (function.extfun_app (classical.by_contradiction' h0) unsigned) := sorry --non-trivial
lemma new_lemma_127414 (h0 : topological_space (linear_ordered_add_comm_group (has_top fun_info))) : path_connected_space (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_127415 (h0 : functor.add_const (finset (comm_group name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127417 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127418 (h0 : topological_space (distrib_lattice ennreal)) : preirreducible_space (distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_127419 (h0 : functor.add_const (function.extfun (Type 1) ring) unsigned) : @rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) unsigned h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_127420 (h0 : group (semiring (has_norm (has_norm congr_arg_kind)))) : normalizer_condition (semiring (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_127421 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_127422 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127423 (h0 : complete_lattice (complete_semilattice_Sup (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_127424 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127425 (h0 : filter (finset (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_127426 (h1 : complete_lattice (has_compl linarith.ineq)) : is_compactly_generated (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_127427 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_127428 (h0 : topological_space (add_comm_monoid (comm_group Type))) : regular_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_127429 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_127430 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @t0_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127431 (h0 : functor.add_const (topological_space (has_edist empty)) (option empty)) : @preirreducible_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_127432 (h0 : topological_space (has_to_string (boolean_algebra Type))) : preirreducible_space (has_to_string (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_127433 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) ennreal) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_127434 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add (ring linarith.comp))) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} (ring.{0} linarith.comp)) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_127435 (h0 : functor.add_const (group (boolean_algebra Type)) linarith.comp) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127436 (h0 : topological_space (normed_comm_ring (has_neg (has_neg pos)))) : irreducible_space (normed_comm_ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_127437 (h0 : ring (option (semiring unsigned))) : is_domain (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127438 (h0 : functor.add_const (monoid (add_group empty)) empty) : @monoid.fg.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_127439 (h0 : functor.add_const (complete_lattice (pseudo_metric_space unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_127440 (h0 : add_group (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_add_cyclic (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_127441 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_127442 (h0 : not (topological_space (uniform_space linarith.ineq) -> false)) : @t0_space.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_127443 (h0 : filter (has_zero (has_add (has_add Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127444 (h0 : set (reducibility_hints -> reducibility_hints)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_127445 (h0 : function.extfun (add_comm_monoid Type) (fun (x : add_comm_monoid Type), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_127446 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_zero Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_127447 (h0 : topological_space (semi_normed_ring char)) : t0_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_127448 (h0 : group (generalized_boolean_algebra (has_add pos))) : is_cyclic (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_127449 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_127450 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg Type)))))) : irreducible_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_127451 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : sequential_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_127452 (h0 : topological_space (plift (complete_distrib_lattice unsigned))) : t1_space (plift (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_127453 (h0 : ring (omega_complete_partial_order (option (option unsigned)))) : is_domain (omega_complete_partial_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_127454 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : preirreducible_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_127455 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127456 (h0 : functor.add_const (filter (boolean_algebra Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127457 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_127459 (h0 : functor.add_const (topological_space (comm_group unsigned)) Type) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_127460 (h0 : add_group (has_neg (option (option ennreal)))) : is_add_cyclic (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_127461 (h0 : complete_lattice (add_group (semiring (has_union unsigned)))) : complete_lattice.is_Sup_finite_compact (add_group (semiring (has_union unsigned))) := sorry --non-trivial
lemma new_lemma_127462 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_127463 (h0 : functor.add_const (complete_lattice (normed_comm_ring ennreal)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_127464 (h0 : complete_lattice (add_monoid enat)) : complete_lattice.is_Sup_finite_compact (add_monoid enat) := sorry --non-trivial
lemma new_lemma_127465 (h0 : group (has_one (has_norm (has_top congr_arg_kind)))) : group.fg (has_one (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_127466 (h0 : list (is_R_or_C (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127467 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127468 (h0 : ring real.angle) : strong_rank_condition real.angle := sorry --non-trivial
lemma new_lemma_127469 (h0 : complete_lattice (has_add linarith.ineq)) : is_compactly_generated (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_127470 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127471 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))))) : is_domain (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) := sorry --non-trivial
lemma new_lemma_127472 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_127473 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (ring linarith.comp)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_127474 (h0 : ring (left_cancel_monoid (option (option empty)))) : rank_condition (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_127475 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_127476 (h0 : filter (has_sub (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127477 (h0 : uniform_space (has_div (mul_one_class to_additive.value_type))) : complete_space (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127478 (h1 : list (distrib_lattice (random_gen (has_norm to_additive.value_type)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_127479 (h0 : uniform_space (has_zero unsigned)) : separated_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_127480 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_127481 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127482 (h0 : filter (has_pos_part (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_127483 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_127484 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_127485 (h0 : complete_lattice (has_zero (has_add linarith.comp))) : is_atomistic (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_127486 (h0 : functor.add_const (ring (ordered_ring empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_127487 (h0 : ring (semigroup (has_add (boolean_algebra Type)))) : strong_rank_condition (semigroup (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_127488 (h0 : functor.add_const (uniform_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127489 (h0 : filter (measure_theory.measure_space (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127490 (h0 : functor.add_const (functor.comp group canonically_ordered_comm_semiring name) unsigned) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name) unsigned h0))  := sorry --non-trivial
lemma new_lemma_127491 (h0 : has_lt (add_comm_semigroup (add_comm_semigroup enat))) : no_max_order (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_127492 (h0 : topological_space (has_Inf (has_add (has_to_string (has_pos_part pos))))) : regular_space (has_Inf (has_add (has_to_string (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_127493 (h0 : functor.add_const (functor.comp monoid comm_group unsigned) Type) : @monoid.fg.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} monoid.{0} comm_group.{0} unsigned (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} monoid.{0} comm_group.{0} unsigned) Type h0))  := sorry --non-trivial
lemma new_lemma_127494 (h0 : ring (has_star (has_norm num))) : rank_condition (has_star (has_norm num)) := sorry --non-trivial
lemma new_lemma_127495 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : t0_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_127496 (h0 : set (uniform_space string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_127497 (h0 : functor.add_const (add_group (cancel_monoid name)) pos) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_127498 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : topological_space.separable_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127499 (h0 : list (free_add_monoid (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_127500 (h0 : complete_lattice (with_bot (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_127501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_ring fun_info)) := sorry --non-trivial
lemma new_lemma_127502 (h0 : list (generalized_boolean_algebra Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127503 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_127504 (h0 : group (id (has_inv (random_gen (has_top to_additive.value_type))))) : normalizer_condition (id (has_inv (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_127505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127506 (h0 : functor.add_const (semiring (semigroup empty)) unsigned) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127507 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos))))) : archimedean (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_127508 (h0 : ring (normed_group (random_gen num))) : is_domain (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_127509 (h0 : group (finset (option empty))) : is_cyclic (finset (option empty)) := sorry --non-trivial
lemma new_lemma_127510 (h0 : filter (has_nndist (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (preorder unsigned)) := sorry --non-trivial
lemma new_lemma_127512 (h0 : add_monoid (ring Type)) : add_monoid.fg (ring Type) := sorry --non-trivial
lemma new_lemma_127513 (h0 : not (topological_space (semiring empty) -> false)) : @t0_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_127514 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127515 (h0 : complete_lattice (has_norm (ordered_comm_semiring num))) : is_compactly_generated (has_norm (ordered_comm_semiring num)) := sorry --non-trivial
lemma new_lemma_127516 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127517 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_127518 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_127519 (h0 : group (linear_ordered_add_comm_group (random_gen char))) : group.fg (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_127520 (h0 : function.extfun Type ring) : @rank_condition.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_127521 (h1 : complete_lattice (topological_space to_additive.value_type)) : is_compactly_generated (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127522 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core linarith.comp))) : irreducible_space (add_cancel_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_127523 (h0 : not (has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_127524 (h0 : complete_lattice (add_cancel_monoid Type)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_127525 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_atomistic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_127527 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_127528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_127529 (h0 : not (ring (semiring fun_info) -> false)) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_127530 (h0 : list (has_nndist linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127531 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_127532 (h0 : topological_space (comm_ring (random_gen (random_gen fun_info)))) : irreducible_space (comm_ring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_127533 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127534 (h0 : functor.add_const (uniform_space (semigroup name)) linarith.comp) : @separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127535 (h0 : topological_space (has_neg_part (cancel_monoid (has_add Type)))) : path_connected_space (has_neg_part (cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_127536 (h0 : cancel_comm_monoid_with_zero (has_add (option name))) : unique_factorization_monoid (has_add (option name)) := sorry --non-trivial
lemma new_lemma_127537 (h0 : functor.add_const (ring (add_cancel_monoid pos)) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_127538 (h0 : group (random_gen (comm_ring (comm_ring char)))) : is_cyclic (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_127539 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_127540 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_127541 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127542 (h0 : list (left_cancel_semigroup congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127543 (h0 : ring (random_gen (has_norm num))) : strong_rank_condition (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_127544 (h0 : functor.add_const (ring (left_cancel_semigroup empty)) empty) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_127545 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_127546 (h0 : complete_lattice (has_to_string (boolean_algebra Type))) : complete_lattice.is_Sup_finite_compact (has_to_string (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_127547 (h0 : prod (simple_graph num) (simple_graph num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_127548 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) (has_neg pos)) : @topological_space.separable_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_127549 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : discrete_topology (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_127550 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_127551 (h0 : function.extfun Type (functor.add_const (monoid ennreal))) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_127552 (h0 : topological_space (has_emptyc (random_gen (has_top linarith.comp_source)))) : irreducible_space (has_emptyc (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_127553 (h0 : finset (has_zero (has_Inf (has_Inf (normed_comm_ring (has_pos_part linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127554 (h0 : group (generalized_boolean_algebra (generalized_boolean_algebra pos))) : is_cyclic (generalized_boolean_algebra (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_127555 (h0 : topological_space (normed_comm_ring (finset (finset (finset (finset pos)))))) : discrete_topology (normed_comm_ring (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_127556 (h0 : functor.add_const (list (has_neg_part Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127557 (h0 : topological_space (nondiscrete_normed_field (mul_one_class environment.projection_info))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_127558 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset unsigned)) := sorry --non-trivial
lemma new_lemma_127559 (h0 : filter (has_Inf (has_Inf name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_127560 (h0 : functor.add_const (add_group (add_right_cancel_monoid empty)) unsigned) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_right_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} (emetric_space.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} (emetric_space.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_127562 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127563 (h0 : complete_lattice (with_bot (semiring num))) : is_compactly_generated (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_127564 (h0 : not (uniform_space (add_right_cancel_monoid empty) -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_127565 (h0 : ring (linear_ordered_semiring (semiring linarith.comp))) : rank_condition (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_127566 (h0 : topological_space (has_append to_additive.value_type)) : t0_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127567 (h0 : function.extfun (Type 1) (functor.comp topological_space comm_group)) : @normal_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_127568 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127569 (h0 : not (group (with_one string_imp) -> false)) : @is_cyclic.{0} (with_one.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_127570 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_127571 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127572 (h0 : topological_space (with_bot (has_norm (has_norm num)))) : t0_space (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_127573 (h0 : num -> empty -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_127574 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_127575 (h0 : ring (has_compl (mul_one_class reducibility_hints))) : strong_rank_condition (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_127576 (h0 : functor.add_const (filter (has_to_string pos)) (normed_linear_ordered_group Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127577 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_127578 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127579 (h0 : not (filter (encodable to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_127580 (h0 : functor.add_const (list (has_nndist linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127581 (h0 : topological_space (ordered_comm_group empty) -> Prop) (h1 : Exists (fun (x : topological_space (ordered_comm_group empty)), h0 x)) : @t1_space.{0} (ordered_comm_group.{0} empty) (@classical.some.{1} (topological_space.{0} (ordered_comm_group.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_127582 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_127583 (h0 : functor.add_const (ordered_add_comm_monoid (add_group num)) empty) : @archimedean.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_127584 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_127585 (h0 : topological_space (has_neg_part (add_comm_monoid name))) : preirreducible_space (has_neg_part (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_127586 (h0 : list char) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127587 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) (comm_group name)) : @t1_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_127588 (h0 : list (normed_group (has_top (has_top (has_top (has_top (has_top (has_top (has_top linarith.ineq))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127589 (h0 : ring (ordered_comm_ring (has_Inf real))) : rank_condition (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_127590 (h0 : functor.add_const (group (bin_tree num)) empty) : @group.fg.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_127591 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_127592 (h0 : monoid (add_comm_monoid (add_comm_monoid (has_add pos)))) : monoid.fg (add_comm_monoid (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_127593 (h0 : ring (has_emptyc to_additive.value_type)) : is_domain (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127594 (h0 : topological_space (simple_graph fun_info)) : path_connected_space (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_127595 (h0 : set ennreal) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_127596 (h0 : topological_space (semi_normed_ring (mul_one_class enat))) : t0_space (semi_normed_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_127597 (h0 : filter (has_nndist (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127598 (h0 : setoid (comm_ring linarith.comp_source)) (h1 h2 : comm_ring linarith.comp_source) : setoid.rel h0 h1 h2 := sorry --non-trivial
lemma new_lemma_127599 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)))) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_127600 (h0 : finset (monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127601 (h0 : uniform_space (with_bot (random_gen fun_info))) : complete_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_127602 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_127603 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) (boolean_algebra name)) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_127604 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) pos) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_127605 (h0 : complete_lattice (has_top (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_127606 (h0 : not (cancel_comm_monoid_with_zero (left_cancel_semigroup unsigned) -> false)) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_127607 (h0 : group (boolean_algebra.core (generalized_boolean_algebra Type))) : normalizer_condition (boolean_algebra.core (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_127608 (h0 : topological_space (ring pos)) : loc_path_connected_space (ring pos) := sorry --non-trivial
lemma new_lemma_127609 (h0 : preorder (linear_ordered_add_comm_group fun_info)) (h1 : topological_space (locally_finite_order (linear_ordered_add_comm_group fun_info))) : t0_space (locally_finite_order (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_127610 (h0 : functor.add_const (ring (left_cancel_monoid num)) num) : @is_domain.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_127611 (h0 : filter std_gen) (h1 : char -> Prop) (h2 : char -> set std_gen) : filter.has_basis h0 h1 h2 := sorry --non-trivial
lemma new_lemma_127612 (h0 : has_neg (has_nnnorm ereal)) (h1 : measurable_space (has_nnnorm ereal)) : has_measurable_neg (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_127613 (h0 : topological_space (add_left_cancel_monoid string_imp)) : path_connected_space (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_127614 (h1 : topological_space (measurable_space num)) : t0_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_127615 (h0 : ring (fintype linarith.ineq)) : is_domain (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_127616 (h0 : ring (has_Inf linarith.comp)) : is_domain (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_127617 (h0 : list (with_one (with_bot to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127618 (h0 : topological_space (has_nndist (has_to_string (finset name)))) : loc_path_connected_space (has_nndist (has_to_string (finset name))) := sorry --non-trivial
lemma new_lemma_127619 (h0 : topological_space (has_neg_part (has_neg_part pos))) : totally_disconnected_space (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_127620 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @is_cyclic.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127621 (h0 : complete_lattice (has_union (semiring unsigned))) : is_atomistic (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127622 (h0 : complete_lattice (has_norm (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_127623 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_127624 (h0 : functor.add_const (ring (canonically_ordered_add_monoid unsigned)) (option (option unsigned))) : @is_principal_ideal_ring.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_add_monoid.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_127625 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127626 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_127627 (h0 : group (semigroup (normed_comm_ring name))) : is_simple_group (semigroup (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_127628 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : t0_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_127629 (h0 : fin has_zero.zero) : @discrete_topology.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127630 (h0 : functor.add_const (ring (comm_group Type)) linarith.comp) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127631 (h0 : filter (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127632 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_127633 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) Type) : @irreducible_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_127634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_127635 (h0 : topological_space Type) : sequential_space Type := sorry --non-trivial
lemma new_lemma_127636 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_127637 (h0 : group (cancel_monoid (boolean_algebra.core (normed_comm_ring environment.implicit_infer_kind)))) : group.fg (cancel_monoid (boolean_algebra.core (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_127638 (h0 : topological_space znum) : locally_compact_space znum := sorry --non-trivial
lemma new_lemma_127639 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : t0_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_127640 (h0 : add_group (sub_neg_monoid (has_Inf linarith.comp))) : is_add_cyclic (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_127641 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) empty) : @t0_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_127642 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127643 (h0 : ring (has_append (metric_space string.iterator_imp))) : is_domain (has_append (metric_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_127644 (h0 : group (finset name)) : normalizer_condition (finset name) := sorry --non-trivial
lemma new_lemma_127645 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid unsigned))) : topological_space.separable_space (complete_distrib_lattice (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_127646 (h1 : topological_space (dlist (has_inv fun_info))) : totally_disconnected_space (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_127647 (h0 : topological_space (has_top (has_ssubset to_additive.value_type))) : locally_compact_space (has_top (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127648 (h0 : functor.add_const (complete_lattice (finset congr_arg_kind)) congr_arg_kind) : @is_atomistic.{0} (finset.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_127649 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127650 (h0 : functor.add_const (complete_lattice (comm_group pos)) (ring (ring Type))) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127651 (h0 : topological_space (complete_semilattice_Sup linarith.ineq)) : locally_compact_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_127652 (h0 : uniform_space (comm_ring linarith.ineq)) : separated_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_127653 (h0 : not (topological_space (distrib_lattice fun_info) -> false)) : @t0_space.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_127654 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_127655 (h0 : ring (has_top (has_top fun_info))) : rank_condition (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_127656 (h0 : semiring (boolean_algebra (has_Inf pos))) : is_noetherian_ring (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_127657 (h0 : add_group (id (with_bot string_imp))) : is_add_cyclic (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_127658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_127659 (h0 : complete_lattice (left_cancel_semigroup num)) : is_atomistic (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_127660 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : locally_compact_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127661 (h0 : topological_space (has_sub (semiring (semiring num)))) : discrete_topology (has_sub (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_127662 (h0 : topological_space (measure_theory.measure_space (has_top unsigned))) : locally_compact_space (measure_theory.measure_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_127663 (h0 : functor.add_const (complete_lattice (semigroup name)) (has_add (has_add Type))) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127664 (h5 : filter (linear_ordered_add_comm_group to_additive.value_type)) : filter.ne_bot h5 := sorry --non-trivial
lemma new_lemma_127665 (h0 : finset (has_add (has_neg (has_neg (has_neg (has_neg Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127666 (h0 : ring (linear_ordered_add_comm_group string_imp)) : strong_rank_condition (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_127667 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_127668 (h0 : functor.add_const Prop (semigroup (normed_comm_ring unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_127669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127670 (h0 : add_group (add_cancel_monoid Type)) : is_add_cyclic (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_127671 (h0 : semiring (add_cancel_comm_monoid (semiring empty))) : is_noetherian_ring (add_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_127672 (h0 : ring (ring unsigned)) : is_domain (ring unsigned) := sorry --non-trivial
lemma new_lemma_127673 (h0 : ring (plift unsigned)) : rank_condition (plift unsigned) := sorry --non-trivial
lemma new_lemma_127674 (h0 : group (measurable_space string_imp)) : normalizer_condition (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_127675 (h0 : functor.add_const (uniform_space (non_assoc_semiring congr_arg_kind)) (semiring num)) : @separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_127676 (h1 : not (topological_space (comm_ring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_127677 (h0 : ordered_comm_monoid (finset (finset (has_nndist Type)))) : has_exists_mul_of_le (finset (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_127678 (h0 : monoid (has_neg (finset ennreal))) : monoid.fg (has_neg (finset ennreal)) := sorry --non-trivial
lemma new_lemma_127679 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @preirreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_127680 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_127681 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf pos)) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} pos) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127682 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : irreducible_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_127683 (h0 : topological_space (simple_graph (finset pos))) : normal_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_127684 (h0 : functor.add_const (finset (comm_group unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127685 (h0 : functor.add_const (topological_space (finset name)) Type) : @regular_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_127686 (h0 : functor.add_const (ring (finset pos)) pos) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127687 (h0 : complete_lattice (has_add (has_ssubset (has_ssubset string_imp)))) : is_compactly_generated (has_add (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_127688 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : irreducible_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_127689 (h0 : add_group (dlist linarith.comp_source)) : is_add_cyclic (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_127690 (h0 : set (mul_one_class std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_127691 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127692 (h0 : functor.add_const (ring (has_zero Type)) (has_zero (has_zero (has_zero pos)))) : @strong_rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_127693 (h0 : functor.add_const (finset (comm_group pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127694 (h0 : functor.add_const (group (complete_distrib_lattice empty)) (option empty)) : @normalizer_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_127695 (h0 : functor.comp uniform_space has_nndist name) : @complete_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_127696 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_127697 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_127698 (h0 : functor.add_const (group (semigroup pos)) Type) : @group.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_127699 (h0 : topological_space (has_pos_part (has_add real))) : locally_compact_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_127700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_127701 (h0 : not (ring (has_ssubset fun_info) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_127702 (h0 : topological_space (measurable_space.dynkin_system (add_group linarith.comp))) : path_connected_space (measurable_space.dynkin_system (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_127703 (h0 : ring (finset (has_zero environment.implicit_infer_kind))) : is_principal_ideal_ring (finset (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_127704 (h0 : complete_lattice (mul_zero_class (finset ennreal))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_127705 (h0 : functor.add_const (group (add_cancel_monoid unsigned)) linarith.comp) : @is_simple_group.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127706 (h0 : add_group (measurable_space (has_norm num))) : is_add_cyclic (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_127707 (h0 : functor.add_const (semiring (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_127708 (h0 : ring (complete_distrib_lattice Type)) : rank_condition (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_127709 (h0 : add_monoid (mul_one_class string.iterator_imp)) (h1 : complete_lattice (add_units (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (add_units (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_127710 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_127711 (h1 : topological_space (semi_normed_comm_ring (uniform_space string_imp))) : path_connected_space (semi_normed_comm_ring (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_127712 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_127713 (h0 : functor.add_const (semiring (has_add Type)) pos) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_127714 (h0 : list (measurable_space (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127715 (h0 : function.extfun (finset Type) (has_mem.mem znum)) : @is_atomistic.{0} znum (@finset.pi.empty.{1 0} Type complete_lattice.{0} znum (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) znum) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_127716 (h0 : function.extfun Type group) : @group.fg.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127717 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127718 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_127719 (h0 : topological_space (has_zero (add_cancel_monoid name))) : normal_space (has_zero (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_127720 (h0 : list Type) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127721 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option ennreal))) : archimedean (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_127722 (h0 : not (topological_space (has_one unsigned) -> false)) : @normal_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_127723 (h3 : ring linarith.ineq) : rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_127724 (h0 : topological_space (has_zero (has_to_string unsigned))) : loc_path_connected_space (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_127725 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127726 (h0 : topological_space (has_add (has_to_string congr_arg_kind))) : normal_space (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127727 (h0 : topological_space (ring (has_neg_part pos))) : normal_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_127728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_127729 (h0 : topological_space (distrib enat)) : totally_disconnected_space (distrib enat) := sorry --non-trivial
lemma new_lemma_127730 (h0 : ring (plift (add_group congr_arg_kind))) : strong_rank_condition (plift (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127731 (h0 : ring (has_nnnorm (has_nnnorm to_additive.value_type))) : strong_rank_condition (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127732 (h0 : finset (as_linear_order num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127733 (h0 : functor.add_const (topological_space (ring name)) name) : @sequential_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_127734 (h0 : group (finset (has_add (ordered_comm_monoid pos)))) : group.fg (finset (has_add (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_127735 (h1 : group (distrib_lattice string_imp)) : normalizer_condition (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_127736 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127737 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_127738 (h0 : topological_space (random_gen (random_gen fun_info))) : irreducible_space (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_127739 (h0 : ring (with_bot (has_norm fun_info))) : is_domain (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_127740 (h0 : list (has_neg_part (comm_group linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127741 (h0 : topological_space (pseudo_metric_space pos)) : normal_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_127742 (h0 : uniform_space (bin_tree (semiring (semiring empty)))) : separated_space (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_127743 (h0 : topological_space (has_neg (has_well_founded pos))) : t1_space (has_neg (has_well_founded pos)) := sorry --non-trivial
lemma new_lemma_127744 (h0 : group (sub_neg_monoid Type)) : normalizer_condition (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_127745 (h0 : topological_space (measurable_space (random_gen (random_gen (has_top fun_info))))) : path_connected_space (measurable_space (random_gen (random_gen (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_127746 (h0 : topological_space (normed_comm_ring (ring Type))) : locally_compact_space (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_127747 (h0 : group (has_Inf linarith.comp)) : is_simple_group (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_127748 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_127749 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127750 (h0 : ring (distrib (denumerable char))) : is_domain (distrib (denumerable char)) := sorry --non-trivial
lemma new_lemma_127751 (h0 : ring (has_div (mul_one_class to_additive.value_type))) : is_domain (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127752 (h0 : uniform_space (mul_zero_class (option unsigned))) : separated_space (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_127753 (h0 : topological_space (mul_zero_class (finset (boolean_algebra.core pos)))) : loc_path_connected_space (mul_zero_class (finset (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_127754 (h0 : add_monoid (ring (has_add (ordered_comm_monoid pos)))) : add_monoid.fg (ring (has_add (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_127755 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) Type) : @path_connected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_127756 (h0 : topological_space (simple_graph linarith.comp)) : totally_separated_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_127757 (h0 : group (simple_graph empty)) : normalizer_condition (simple_graph empty) := sorry --non-trivial
lemma new_lemma_127758 (h0 : topological_space (complete_semilattice_Sup (has_inv fun_info))) : t0_space (complete_semilattice_Sup (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_127759 (h0 : complete_lattice (has_add real)) : is_compactly_generated (has_add real) := sorry --non-trivial
lemma new_lemma_127760 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127761 (h1 : topological_space (add_cancel_comm_monoid reducibility_hints)) : totally_disconnected_space (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_127762 (h0 : topological_space (linear_ordered_add_comm_group fun_info)) : path_connected_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_127763 (h0 : functor.comp topological_space linear_ordered_field name) : @t1_space.{0} (linear_ordered_field.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} name h0)  := sorry --non-trivial
lemma new_lemma_127764 (h0 : topological_space (ordered_comm_ring (has_add pos))) : discrete_topology (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_127765 (h0 : not (add_group (complete_semilattice_Sup to_additive.value_type) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_127766 (h0 : topological_space (has_nndist (option (has_Sup (option Type))))) : locally_compact_space (has_nndist (option (has_Sup (option Type)))) := sorry --non-trivial
lemma new_lemma_127767 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring name)) pos) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_127768 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : preirreducible_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_127769 (h0 : finset (semiring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_127771 (h0 : complete_lattice (topological_space (comm_ring to_additive.value_type))) : is_compactly_generated (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127772 (h0 : topological_space (normed_linear_ordered_group empty)) : totally_disconnected_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_127773 (h0 : topological_space int) (h1 : topological_space std_gen) (h2 : int -> std_gen) : set.finite (continuous_at h2) := sorry --non-trivial
lemma new_lemma_127774 (h0 : topological_space (is_R_or_C empty)) : normal_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_127775 (h0 : ring linarith.comp) : is_domain linarith.comp := sorry --non-trivial
lemma new_lemma_127776 (h0 : not (topological_space (distrib (has_nnnorm (has_nnnorm linarith.ineq))) -> false)) : @path_connected_space.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_127777 (h0 : complete_lattice (has_to_string (finset (finset ennreal)))) : is_atomistic (has_to_string (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_127778 (h0 : functor.add_const (topological_space (boolean_algebra name)) (boolean_algebra linarith.comp)) : @t1_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_127779 (h0 : functor.add_const (ordered_add_comm_monoid pos) pos) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_127780 (h0 : list (distrib_lattice num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_127781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_127782 (h0 : group (boolean_algebra (has_to_string name))) : is_cyclic (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_127783 (h0 : complete_lattice (has_emptyc linarith.comp)) : is_atomistic (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_127784 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_127785 (h2 : uniform_space (complete_semilattice_Sup num)) : complete_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_127786 (h0 : topological_space (measurable_space.dynkin_system unsigned)) (h1 : add_group (measurable_space.dynkin_system unsigned)) : topological_add_group (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_127787 (h0 : topological_space (semigroup (has_add Type))) : totally_disconnected_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_127788 (h0 : topological_space (semiring (semiring (semiring unsigned)))) : discrete_topology (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_127789 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_127790 (h2 : topological_space (has_add to_additive.value_type)) : t0_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_127791 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_127792 (h0 : topological_space (has_nndist (add_comm_monoid (normed_comm_ring ennreal)))) : locally_compact_space (has_nndist (add_comm_monoid (normed_comm_ring ennreal))) := sorry --non-trivial
lemma new_lemma_127793 (h0 : not (uniform_space (has_top linarith.comp_source) -> false)) : @complete_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_127794 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup fun_info))) : t0_space (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_127795 (h0 : functor.add_const (function.extfun (Type 1) list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_127796 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127797 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_127798 (h0 : cancel_comm_monoid_with_zero (has_zero (semigroup name))) : unique_factorization_monoid (has_zero (semigroup name)) := sorry --non-trivial
lemma new_lemma_127799 (h2 : topological_space (has_compl (has_ssubset char))) : path_connected_space (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_127800 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra pos)) pos) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127801 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (finset pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_127802 (h0 : topological_space (sub_neg_monoid (finset name))) : normal_space (sub_neg_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_127803 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring (semiring (semiring empty)))))) : unique_factorization_monoid (partial_order (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_127804 (h0 : functor.add_const (ring (left_cancel_semigroup empty)) empty) : @is_domain.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_127805 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_127806 (h0 : topological_space (semiring (linear_ordered_semiring unsigned))) : preirreducible_space (semiring (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127807 (h0 : group (boolean_algebra (has_pos_part Type))) : is_simple_group (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_127808 (h0 : complete_lattice (complete_distrib_lattice (has_bot (has_Inf (has_bot name))))) : is_compactly_generated (complete_distrib_lattice (has_bot (has_Inf (has_bot name)))) := sorry --non-trivial
lemma new_lemma_127809 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_127810 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_127811 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127812 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg name)))) : topological_space.separable_space (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_127813 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (distrib_lattice fun_info)) := sorry --non-trivial
lemma new_lemma_127814 (h0 : functor.add_const (add_group nnreal) (option empty)) : @is_add_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (add_group.{0} nnreal) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_127815 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) (has_neg name)) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_127816 (h0 : functor.add_const (topological_space (has_nndist Type)) (has_neg linarith.comp)) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_127817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_127818 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_127819 (h2 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_127820 (h0 : functor.add_const (topological_space (add_group empty)) (option empty)) : @irreducible_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_127821 (h0 : topological_space (mul_zero_class pos)) : discrete_topology (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_127822 (h0 : topological_space (finset (emetric_space (mul_one_class environment.implicit_infer_kind)))) : regular_space (finset (emetric_space (mul_one_class environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_127823 (h0 : uniform_space (finset name)) : separated_space (finset name) := sorry --non-trivial
lemma new_lemma_127824 (h0 : functor.add_const (function.extfun Type list) (has_to_string (ring environment.implicit_infer_kind))) : palindrome (function.extfun_app (functor.add_const.run h0) (comm_group pos)) := sorry --non-trivial
lemma new_lemma_127825 (h0 : functor.add_const (add_monoid (has_neg environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_127826 (h0 : topological_space (add_right_cancel_monoid (random_gen (random_gen linarith.ineq)))) : locally_compact_space (add_right_cancel_monoid (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_127827 (h0 : topological_space (has_nndist (has_to_string (comm_group unsigned)))) : sequential_space (has_nndist (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_127828 (h0 : topological_space (with_one (has_top linarith.comp))) : preirreducible_space (with_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_127829 (h0 : functor.comp ring cancel_monoid unsigned) : @is_domain.{0} (cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_127830 (h0 : finset (option congr_arg_kind) -> finset (option congr_arg_kind) -> Prop) : is_symm (finset (option congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_127831 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_127832 (h0 : complete_lattice (metric_space (has_norm congr_arg_kind))) : is_atomistic (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127833 (h0 : group (random_gen (has_norm empty))) : is_cyclic (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_127834 (h0 : function.extfun Type topological_space) : @t1_space.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_127835 (h0 : finset (ring (has_neg (has_neg (finset (ring Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127836 (h0 : topological_space (id (semiring unsigned))) : preirreducible_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_127837 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_127838 (h0 : not (complete_lattice (has_star unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_127839 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_127840 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @t0_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127841 (h0 : functor.comp topological_space boolean_algebra.core pos) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_127842 (h1 : list (dlist (with_bot string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_127843 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_127844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_127845 (h0 : functor.add_const (group (filter empty)) (option (option empty))) : @group.fg.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (filter.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_127846 (h1 : complete_lattice (has_add linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_127847 (h0 : complete_lattice (measurable_space (random_gen linarith.comp))) : is_compactly_generated (measurable_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_127848 (h0 : semiring (normed_comm_ring (finset (finset pos)))) : is_noetherian_ring (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_127849 (h0 : ring (has_dist (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : rank_condition (has_dist (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_127850 (h1 : topological_space to_additive.value_type) : t0_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_127851 (h0 : group (comm_group (has_to_string (cancel_monoid (has_nndist ennreal))))) : normalizer_condition (comm_group (has_to_string (cancel_monoid (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_127852 (h0 : cancel_comm_monoid_with_zero (boolean_algebra pos)) : unique_factorization_monoid (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_127853 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : totally_separated_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_127854 (h0 : add_group (has_neg Type)) : is_add_cyclic (has_neg Type) := sorry --non-trivial
lemma new_lemma_127855 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option empty))) : is_atomistic (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_127856 (h0 : uniform_space (has_star (semiring (semiring (semiring empty))))) : separated_space (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_127857 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_127858 (h0 : semiring (add_comm_monoid (add_comm_monoid (boolean_algebra Type)))) : is_noetherian_ring (add_comm_monoid (add_comm_monoid (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_127859 (h1 : add_group (has_nnnorm string_imp)) : is_add_cyclic (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_127860 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : preconnected_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_127861 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_127862 (h0 : not (topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_127863 (h0 : function.extfun Type (prod (linear_ordered_field pos))) : id_rel (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_127864 (h0 : not (add_group (topological_space linarith.comp_source) -> false)) : @is_add_cyclic.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_127865 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid unsigned)) empty) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_127866 (h0 : ordered_comm_monoid (ordered_cancel_add_comm_monoid (ring pos))) : has_exists_mul_of_le (ordered_cancel_add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_127867 (h0 : topological_space (random_gen linarith.comp)) : preirreducible_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_127868 (h0 : not (ring (linear_ordered_field char) -> false)) : @is_domain.{0} (linear_ordered_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_127869 (h0 : functor.comp add_group semigroup (mul_zero_class name)) : @is_add_cyclic.{0} (semigroup.{0} (mul_zero_class.{0} name)) (@functor.comp.run.{0 0 0} add_group.{0} semigroup.{0} (mul_zero_class.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_127870 (h0 : topological_space (option ennreal)) : topological_space.separable_space (option ennreal) := sorry --non-trivial
lemma new_lemma_127871 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_127872 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_127873 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) name) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_127874 (h0 : topological_space (boolean_algebra (add_comm_monoid Type))) : discrete_topology (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_127875 (h0 : functor.add_const (cancel_comm_monoid_with_zero (pseudo_metric_space name)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (pseudo_metric_space.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_127876 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (normed_comm_ring pos)) : @separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (normed_comm_ring.{0} pos) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_127877 (h0 : topological_space (mul_zero_class empty)) : loc_path_connected_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_127878 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_127879 (h0 : functor.add_const (complete_lattice (boolean_algebra.core linarith.comp)) Type) : @is_atomistic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_127880 (h0 : complete_lattice (has_inv (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127881 (h0 : topological_space (has_to_string (finset (finset (has_add (finset pos)))))) : topological_space.separable_space (has_to_string (finset (finset (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_127882 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127883 (h0 : ring (metric_space (semiring (semiring unsigned)))) : is_domain (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_127884 (h0 : not (topological_space (uniform_space (random_gen char)) -> false)) : @t0_space.{0} (uniform_space.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (random_gen.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_127885 (h0 : topological_space (has_nnnorm std_gen)) (h1 : add_group (has_nnnorm std_gen)) : topological_add_group (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_127886 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @t0_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_127887 (h0 : uniform_space (has_pos_part (has_add (has_add real)))) : complete_space (has_pos_part (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_127888 (h0 : complete_lattice (linear_ordered_semiring linarith.comp)) : is_compactly_generated (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_127889 (h0 : topological_space (normed_group (has_ssubset to_additive.value_type))) : locally_compact_space (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127890 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_nndist.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_127891 (h0 : group (has_to_string (has_neg name))) : is_simple_group (has_to_string (has_neg name)) := sorry --non-trivial
lemma new_lemma_127892 (h0 : functor.add_const (functor.add_const (has_add linarith.comp) pos) (boolean_algebra pos)) : list.nodup (list.ret (functor.add_const.run (functor.add_const.run h0))) := sorry --non-trivial
lemma new_lemma_127893 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_127894 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127895 (h0 : add_group (simple_graph (has_add (finset Type)))) : is_add_cyclic (simple_graph (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_127896 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : preirreducible_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127897 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_127898 (h0 : topological_space (has_nndist (has_add name))) : regular_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_127899 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @totally_disconnected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127900 (h0 : topological_space (linear_order empty)) : topological_space.separable_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_127901 (h0 : list (has_neg (has_neg environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_127902 (h0 : topological_space (distrib (semi_normed_ring string_imp))) : path_connected_space (distrib (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_127903 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_127904 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @locally_compact_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_127905 (h0 : functor.add_const (add_monoid (has_neg pos)) (finset (ring Type))) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg.{0} pos)) (finset.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_127906 (h0 : filter (measurable_space (has_top linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127907 (h0 : uniform_space (boolean_algebra.core empty)) : separated_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_127908 (h0 : add_monoid (comm_monoid unsigned)) : add_monoid.fg (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_127909 (h0 : topological_space (has_inner linarith.comp linarith.comp)) : totally_disconnected_space (has_inner linarith.comp linarith.comp) := sorry --non-trivial
lemma new_lemma_127910 (h0 : topological_space (add_cancel_monoid (has_add (has_add pos)))) : locally_compact_space (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_127911 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_127912 (h0 : functor.add_const (ring (simple_graph pos)) pos) : @is_principal_ideal_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_127913 (h0 : topological_space (has_lt linarith.comp_source)) (h1 : preorder (has_lt linarith.comp_source)) : order_topology (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_127914 (h0 : heq string_imp (topological_space char)) (h1 : complete_lattice string_imp) : is_compactly_generated (topological_space char) := sorry --non-trivial
lemma new_lemma_127915 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} ennreal (@function.extfun_app.{2 1} Type add_group.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_127916 (h0 : has_mem.mem num has_emptyc.emptyc) : @totally_separated_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_127917 (h0 : add_group (uniform_space (distrib reducibility_hints))) : is_add_cyclic (uniform_space (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_127918 (h0 : group (partial_order empty) -> Prop) (h1 : Exists (fun (x : group (partial_order empty)), h0 x)) : @group.fg.{0} (partial_order.{0} empty) (@classical.some.{1} (group.{0} (partial_order.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_127919 (h0 : filter (linear_ordered_comm_group (option (option (option (option unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_127920 (h0 : finset (add_comm_monoid (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_127921 (h0 : functor.add_const (topological_space (has_to_string pos)) (ring environment.implicit_infer_kind)) : @preconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_127922 (h0 : topological_space num) : regular_space num := sorry --non-trivial
lemma new_lemma_127923 (h0 : topological_space (has_Inf name)) : totally_separated_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_127924 (h0 : functor.add_const (topological_space (has_pos_part pos)) (ordered_comm_monoid (sub_neg_monoid pos))) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (ordered_comm_monoid.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_127925 (h0 : topological_space (ring (finset (has_add (has_add (finset pos)))))) : preirreducible_space (ring (finset (has_add (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_127926 (h0 : semiring (add_comm_semigroup (mul_one_class fun_info))) (h1 : ideal (add_comm_semigroup (mul_one_class fun_info))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_127927 (h0 : group (canonically_ordered_monoid Type)) : group.fg (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_127928 (h1 : group (normed_field (has_nnnorm (has_nnnorm (random_gen (metric_space char)))))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm (random_gen (metric_space char))))) := sorry --non-trivial
lemma new_lemma_127929 (h1 : measurable_space (has_nnnorm ereal)) (h2 : filter (has_nnnorm ereal)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_127930 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_127931 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_add (ring linarith.comp)))) : unique_factorization_monoid (ordered_comm_ring (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_127932 (h0 : topological_space (has_nndist (finset (finset (finset (finset linarith.comp)))))) : irreducible_space (has_nndist (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_127933 (h0 : not (ring (measure_theory.measure_space empty) -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_127934 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_127935 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_127936 (h1 : complete_lattice (semi_normed_comm_ring linarith.comp_source)) : is_compactly_generated (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_127937 (h0 : functor.comp topological_space has_neg_part unsigned) : @t1_space.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_127938 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_127939 (h0 : group (normed_group (semiring (semiring (semiring congr_arg_kind))))) : normalizer_condition (normed_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_127940 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) num) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_127941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_127942 (h1 : uniform_space (random_gen reducibility_hints)) : complete_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_127943 (h0 : semiring (has_dist (option (option (option empty))))) : is_noetherian_ring (has_dist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_127944 (h0 : ordered_comm_monoid (complete_distrib_lattice (option (has_add pos)))) : has_exists_mul_of_le (complete_distrib_lattice (option (has_add pos))) := sorry --non-trivial
lemma new_lemma_127945 (h0 : list (has_inter (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_127946 (h0 : ring (semiring (complete_distrib_lattice empty))) : rank_condition (semiring (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_127947 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (comm_semigroup (comm_semigroup real)))) : unique_factorization_monoid (complete_distrib_lattice (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_127948 (h0 : topological_space (preorder (option congr_arg_kind))) : totally_disconnected_space (preorder (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_127949 (h0 : group (comm_ring string_imp)) : group.fg (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_127950 (h0 : topological_space (random_gen (random_gen (random_gen (random_gen fun_info))))) : locally_compact_space (random_gen (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_127951 (h0 : ring (has_top (has_norm linarith.ineq))) : rank_condition (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127952 (h0 : uniform_space (random_gen (mul_one_class (mul_one_class reducibility_hints)))) : complete_space (random_gen (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_127953 (h0 : complete_lattice (has_top (random_gen string_imp))) : is_atomistic (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_127954 (h0 : add_group (has_top (has_norm to_additive.value_type))) : is_add_cyclic (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_127955 (h0 : topological_space (semi_normed_ring (mul_one_class linarith.ineq))) : path_connected_space (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127956 (h0 : fin has_zero.zero) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_127957 (h0 : uniform_space (is_R_or_C string.iterator_imp)) : complete_space (is_R_or_C string.iterator_imp) := sorry --non-trivial
lemma new_lemma_127958 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_127959 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_127960 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_127961 (h0 : ring (denumerable fun_info)) : strong_rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_127962 (h0 : group (add_cancel_monoid ennreal)) : group.fg (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_127963 (h0 : group (finset (has_pos_part linarith.comp))) : is_cyclic (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_127964 (h0 : cancel_comm_monoid_with_zero (boolean_algebra unsigned)) : unique_factorization_monoid (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_127965 (h0 : ordered_comm_monoid (add_comm_monoid (has_zero linarith.comp))) : has_exists_mul_of_le (add_comm_monoid (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_127966 (h0 : complete_lattice (boolean_algebra (has_add (has_Inf real)))) : is_compactly_generated (boolean_algebra (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_127967 (h0 : functor.add_const (monoid (cancel_monoid environment.implicit_infer_kind)) unsigned) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127968 (h0 : ring (has_append (has_ssubset (has_ssubset (has_ssubset (random_gen string_imp)))))) : rank_condition (has_append (has_ssubset (has_ssubset (has_ssubset (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_127969 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) (has_to_string linarith.comp)) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_127970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_127971 (h1 : add_group (simple_graph linarith.ineq)) : is_add_cyclic (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_127972 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_127973 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero empty)) : is_atomistic (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_127974 (h0 : add_monoid (measure_theory.measure_space empty)) : add_monoid.fg (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_127975 (h0 : ring (normed_comm_ring pos)) : is_principal_ideal_ring (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_127976 (h0 : not (group (topological_space linarith.ineq) -> false)) : @group.fg.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_127977 (h0 : cancel_comm_monoid_with_zero (finset (finset ennreal))) : unique_factorization_monoid (finset (finset ennreal)) := sorry --non-trivial
lemma new_lemma_127978 (h0 : functor.add_const (list (has_nndist environment.implicit_infer_kind)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_127979 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) (has_add (has_add pos))) : @rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_127980 (h0 : measurable_space char) (h1 : char -> char -> Prop) (h2 : char) : measurable_set (eqv_gen h1 h2) := sorry --non-trivial
lemma new_lemma_127981 (h0 : functor.add_const (ring (has_nndist ennreal)) pos) : @rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_127982 (h0 : topological_space (has_inv (has_nnnorm (random_gen linarith.ineq)))) : t0_space (has_inv (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_127983 (h0 : ring (with_zero (has_nnnorm linarith.ineq))) : strong_rank_condition (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_127984 (h0 : functor.add_const (group (complete_distrib_lattice environment.implicit_infer_kind)) unsigned) : @is_cyclic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_127986 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_nndist pos))) : unique_factorization_monoid (has_Inf (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_127987 (h0 h1 : multiset (has_nnnorm linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_127988 (h0 : topological_space (ring (has_Inf name))) : t1_space (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_127989 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_127990 (h1 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_127991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_127992 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_127993 (h0 : semiring (normed_comm_ring pos)) : is_noetherian_ring (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_127994 (h0 : group (boolean_algebra (has_neg (finset environment.implicit_infer_kind)))) : normalizer_condition (boolean_algebra (has_neg (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_127995 (h0 : functor.add_const (group (has_star unsigned)) unsigned) : @normalizer_condition.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_127996 (h1 : topological_space (distrib fun_info)) : path_connected_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_127997 (h0 : ring (has_add (has_to_string num))) : strong_rank_condition (has_add (has_to_string num)) := sorry --non-trivial
lemma new_lemma_127998 (h0 : functor.add_const (ring (semiring congr_arg_kind)) (semiring empty)) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_127999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} fun_info))  := sorry --non-trivial
