import imports
lemma new_lemma_80000 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) (h1 : function.extfun Type has_sup) : @has_measurable_sup.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type measurable_space.{0} (random_gen.{0} num) h0) (@function.extfun_app.{2 1} Type has_sup.{0} h1 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_80001 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring unsigned))) : t0_space (linear_ordered_comm_monoid_with_zero (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_80002 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_80003 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_80004 (h0 : functor.add_const (complete_lattice (semiring unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_80005 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_80006 (h0 : ring num) (h1 : filter (has_top (subring num))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_80007 (h0 : ring (distrib (has_nnnorm (comm_ring (comm_ring linarith.comp_source))))) : rank_condition (distrib (has_nnnorm (comm_ring (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_80008 (h0 : group (boolean_algebra.core ennreal)) : group.fg (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_80009 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group linarith.ineq))) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80010 (h3 : complete_lattice (uniform_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_80011 (h0 : monoid (measurable_space.dynkin_system (semiring unsigned))) : monoid.fg (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_80012 (h0 : group (has_compl char)) : is_cyclic (has_compl char) := sorry --non-trivial
lemma new_lemma_80013 (h0 : add_group (add_group (semiring congr_arg_kind))) : is_add_cyclic (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80014 (h0 : group (has_one (semiring empty))) : normalizer_condition (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_80015 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_80016 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_well_founded.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_well_founded.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80017 (h0 : topological_space (has_Inf (has_Inf (ring (has_Inf Type))))) : irreducible_space (has_Inf (has_Inf (ring (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_80018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_80019 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_80020 (h1 : ring (semi_normed_ring fun_info)) : is_domain (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_80021 (h0 : ring (fintype (normed_field (comm_ring (random_gen char))))) : strong_rank_condition (fintype (normed_field (comm_ring (random_gen char)))) := sorry --non-trivial
lemma new_lemma_80022 (h0 : group (random_gen (has_top unsigned))) : normalizer_condition (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_80023 (h0 : functor.add_const (group (pseudo_metric_space name)) unsigned) : @group.fg.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80024 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : topological_space.separable_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_80025 (h0 : fin has_zero.zero) : @rank_condition.{1} (right_cancel_semigroup.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (right_cancel_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_80026 (h0 : topological_space (measurable_space string_imp)) : path_connected_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_80027 (h0 : ring (canonically_linear_ordered_monoid pos)) : strong_rank_condition (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_80028 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80029 (h0 : group (has_star (semiring (semiring empty)))) : group.fg (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_80030 (h0 : functor.comp complete_lattice comm_group Type) : @is_atomistic.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_80031 (h0 : group (has_nndist Type)) : normalizer_condition (has_nndist Type) := sorry --non-trivial
lemma new_lemma_80032 (h0 : topological_space (option (has_add ennreal))) : regular_space (option (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_80033 (h2 : add_group (non_unital_non_assoc_semiring linarith.ineq)) : is_add_cyclic (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_80034 (h0 : finset (boolean_algebra (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80035 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_zero (has_zero pos))) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_80036 (h0 : group (has_neg pos)) : group.fg (has_neg pos) := sorry --non-trivial
lemma new_lemma_80037 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : sequential_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_80038 (h0 : functor.add_const (monoid (bin_tree empty)) unsigned) : @monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80039 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80040 (h0 : ring (cancel_monoid (finset (finset (finset (finset ennreal)))))) : is_principal_ideal_ring (cancel_monoid (finset (finset (finset (finset ennreal))))) := sorry --non-trivial
lemma new_lemma_80041 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring Type))) : sequential_space (canonically_ordered_comm_semiring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_80042 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80043 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @preirreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80044 (h0 : topological_space (distrib_lattice (random_gen linarith.ineq))) : t0_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80045 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_80046 (h2 : add_group (semi_normed_ring (random_gen char))) : is_add_cyclic (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_80047 (h0 : group (with_bot (comm_ring (random_gen (random_gen to_additive.value_type))))) : normalizer_condition (with_bot (comm_ring (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_80048 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @sequential_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_80049 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_80050 (h0 : list (has_top (has_top char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80051 (h0 : function.extfun Type (prod (with_one num))) : id_rel (function.extfun_app h0 (with_one num)) := sorry --non-trivial
lemma new_lemma_80052 (h0 : group (boolean_algebra (has_neg linarith.comp))) : normalizer_condition (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_80053 (h0 : topological_space (has_emptyc congr_arg_kind)) : irreducible_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80054 (h0 : fin has_zero.zero) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_80055 (h0 : topological_space (sub_neg_monoid (has_neg real))) : preirreducible_space (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_80056 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : t0_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80057 (h0 : complete_lattice (has_top (has_ssubset to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_80058 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_compl.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80059 (h0 : complete_lattice (canonically_ordered_comm_semiring (cancel_monoid ennreal))) : is_atomistic (canonically_ordered_comm_semiring (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_80060 (h0 h1 : not (multiset (semi_normed_ring linarith.ineq) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_80061 (h0 : group (random_gen unsigned)) : is_cyclic (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_80062 (h0 : filter Prop -> filter Prop -> Prop) (h1 : quot h0) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@quot.out.{1} (filter.{0} Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_80063 (h0 : functor.add_const (uniform_space (has_nndist Type)) environment.implicit_infer_kind) : @separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_80065 (h0 : group (measurable_space.dynkin_system (semiring (semiring num)))) : is_cyclic (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_80066 (h0 : function.extfun Type (functor.add_const (topological_space (free_add_monoid empty)))) : @normal_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (free_add_monoid.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_80067 (h0 : topological_space (has_zero (has_nndist (finset pos)))) : regular_space (has_zero (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_80068 (h0 : list (linear_ordered_add_comm_group char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80069 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @normal_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80070 (h0 : ordered_comm_monoid (has_Inf (has_pos_part (has_Inf (has_pos_part pos))))) : has_exists_mul_of_le (has_Inf (has_pos_part (has_Inf (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_80071 (h0 : functor.add_const (add_monoid (has_star empty)) (semiring empty)) : @add_monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_80072 (h0 : topological_space (add_comm_monoid (comm_group pos))) : regular_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_80073 (h0 : uniform_space (has_top linarith.comp)) : complete_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_80074 (h0 : function.extfun nat fin) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_80075 (h0 : not (topological_space (comm_ring fun_info) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80076 (h0 : list (random_gen (has_inv (has_inv to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80077 (h0 : topological_space (comm_semigroup (has_add pos))) : path_connected_space (comm_semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_80078 (h0 : topological_space (has_Sup congr_arg_kind)) : topological_space.separable_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80079 (h0 : ring (non_assoc_semiring num)) : is_principal_ideal_ring (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_80080 (h0 : topological_space (cancel_monoid (option (option (option ennreal))))) : totally_disconnected_space (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_80081 (h0 : group (add_group (has_norm (has_union linarith.comp)))) : is_cyclic (add_group (has_norm (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_80082 (h0 : ring (distrib (comm_ring (has_nnnorm reducibility_hints)))) : strong_rank_condition (distrib (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_80083 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_80084 (h0 : not (topological_space (has_sub num) -> false)) : @locally_compact_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_80085 (h0 : group (semigroup (normed_comm_ring pos))) : is_simple_group (semigroup (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_80086 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_80087 (h0 : semiring (monoid_with_zero ennreal)) : is_noetherian_ring (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_80088 (h0 : group (has_neg_part environment.implicit_infer_kind)) : is_cyclic (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_80089 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_80090 (h0 : not (add_monoid (complete_semilattice_Sup congr_arg_kind) -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80091 (h0 : group (boolean_algebra (boolean_algebra.core (has_add (has_add Type))))) : normalizer_condition (boolean_algebra (boolean_algebra.core (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_80092 (h0 : functor.add_const (topological_space (finset ennreal)) (option (option unsigned))) : @path_connected_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_80093 (h0 : ring (has_neg_part (finset Type))) : is_principal_ideal_ring (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_80094 (h0 : uniform_space (has_compl string.iterator_imp)) : complete_space (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_80095 (h1 : set (ordering -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_80096 (h0 : complete_lattice (partial_order num)) : complete_lattice.is_Sup_finite_compact (partial_order num) := sorry --non-trivial
lemma new_lemma_80097 (h0 : not (topological_space (encodable fun_info) -> false)) : @totally_disconnected_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80098 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80099 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80100 (h0 : functor.add_const (complete_lattice (partial_order num)) num) : @is_atomistic.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_80101 (h0 : ring (sub_neg_monoid (has_add Type))) : rank_condition (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_80102 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80103 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_add Type))) : has_exists_mul_of_le (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_80104 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_80105 (h0 : complete_lattice (has_neg string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_neg string.iterator_imp) := sorry --non-trivial
lemma new_lemma_80106 (h0 : filter (boolean_algebra.core (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80107 (h0 : ring (ring (has_Inf (has_Inf (has_pos_part linarith.comp))))) : is_domain (ring (has_Inf (has_Inf (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_80108 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80109 (h1 : complete_lattice (id (with_bot linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (id (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80110 (h0 : topological_space (normed_comm_ring (option pos))) : path_connected_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_80111 (h0 : topological_space (filter num)) : normal_space (filter num) := sorry --non-trivial
lemma new_lemma_80112 (h0 : functor.add_const (group (has_to_string linarith.comp)) Type) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_80113 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_80114 (h0 : topological_space (group_with_zero empty)) : t0_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_80115 (h0 : group (measurable_space (semiring linarith.comp))) : is_cyclic (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_80116 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_80117 (h0 : group (has_pos_part (ring (has_add pos)))) : normalizer_condition (has_pos_part (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_80118 (h0 : list (has_nndist (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_80119 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_80120 (h0 : not (ring environment.projection_info -> false)) : @rank_condition.{0} environment.projection_info (@classical.by_contradiction'.{1} (ring.{0} environment.projection_info) h0)  := sorry --non-trivial
lemma new_lemma_80121 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_80122 (h0 : group (has_neg (has_Inf (finset pos)))) : is_cyclic (has_neg (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_80123 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_80124 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_80125 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_80126 (h0 : functor.add_const (topological_space (ring pos)) pos) : @t1_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_80127 (h0 : topological_space (monoid empty)) : locally_compact_space (monoid empty) := sorry --non-trivial
lemma new_lemma_80128 (h0 : topological_space (add_cancel_monoid (option (option congr_arg_kind)))) : t0_space (add_cancel_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_80129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80130 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80131 (h0 : topological_space (preorder congr_arg_kind)) : loc_path_connected_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80132 (h1 : ring (id linarith.comp)) : is_domain (id linarith.comp) := sorry --non-trivial
lemma new_lemma_80133 (h0 : functor.add_const (uniform_space (has_neg pos)) linarith.comp) : @complete_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80134 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80135 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_80136 (h0 : list (complete_semilattice_Sup (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80137 (h0 : group (has_pos_part (finset (has_pos_part (has_pos_part Type))))) : normalizer_condition (has_pos_part (finset (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_80138 (h0 : topological_space (has_to_string (has_neg_part Type))) : loc_path_connected_space (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_80139 (h0 : ring (has_bot (option (option unsigned)))) : is_principal_ideal_ring (has_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80140 (h1 : topological_space (random_gen to_additive.value_type)) : locally_compact_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_80141 (h0 : ring (has_top (random_gen (random_gen linarith.ineq)))) : rank_condition (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_80142 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80143 (h0 : functor.add_const (finset (has_add pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80144 (h0 : filter (has_inv string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80145 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_80146 (h1 : filter (with_zero to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_80147 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80148 (h0 : topological_space (add_group (semiring empty))) : normal_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_80149 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_80150 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80151 (h2 : ring (has_append char)) : is_domain (has_append char) := sorry --non-trivial
lemma new_lemma_80152 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_80153 (h0 : group (generalized_boolean_algebra (comm_semigroup pos))) : group.fg (generalized_boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_80154 (h0 : functor.add_const (fin has_zero.zero) (sub_neg_monoid linarith.comp)) : @normalizer_condition.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (sub_neg_monoid.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_80155 (h0 : functor.add_const (topological_space name) num) : @normal_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_80156 (h1 : group (measurable_space unsigned)) : group.fg (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_80157 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80158 : nonempty occurrences := sorry --simp
lemma new_lemma_80159 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_80160 (h0 : group (metric_space (has_top unsigned))) : is_cyclic (metric_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_80161 (h0 : topological_space (simple_graph (has_pos_part pos))) : locally_compact_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_80162 (h0 : uniform_space (canonically_ordered_comm_semiring (option pos))) : separated_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_80163 : infinite (has_lt (has_compl string_imp)) := sorry --non-trivial
lemma new_lemma_80164 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf pos)))) : regular_space (boolean_algebra (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_80165 (h0 : topological_space (has_norm (comm_ring linarith.ineq))) : t0_space (has_norm (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80166 (h0 : fin has_zero.zero) : @is_simple_group.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_80167 (h0 : uniform_space (bin_tree empty)) : separated_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_80168 (h0 : finset (cancel_monoid (comm_group (comm_group (comm_group (comm_group (comm_group name))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80169 (h0 : semiring (complete_distrib_lattice (ordered_comm_monoid pos))) : is_noetherian_ring (complete_distrib_lattice (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_80170 (h1 : group (normed_group linarith.comp_source)) : group.fg (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_80171 (h0 : functor.add_const (complete_lattice (has_to_string ennreal)) (finset Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} ennreal)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_80172 (h0 : topological_space (option empty)) : path_connected_space (option empty) := sorry --non-trivial
lemma new_lemma_80173 (h0 : functor.add_const (topological_space (has_bot real)) Type) : @totally_disconnected_space.{0} (has_bot.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_80174 (h0 : ordered_add_comm_monoid (comm_monoid empty)) : archimedean (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_80175 (h0 : not (group (has_norm linarith.comp_source) -> false)) : @normalizer_condition.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_80176 (h0 : group (denumerable (random_gen (has_inv (random_gen (random_gen (has_inv fun_info))))))) : group.fg (denumerable (random_gen (has_inv (random_gen (random_gen (has_inv fun_info)))))) := sorry --non-trivial
lemma new_lemma_80177 (h0 : function.extfun nat fin) : @path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_80178 (h0 : group (has_add ennreal)) : group.fg (has_add ennreal) := sorry --non-trivial
lemma new_lemma_80179 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option unsigned)))) : locally_compact_space (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80180 (h0 : ordered_add_comm_monoid (add_group (semiring (semiring num)))) : archimedean (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_80181 (h0 : cancel_comm_monoid_with_zero (preorder (option unsigned))) : unique_factorization_monoid (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_80182 (h0 : not (group (dlist fun_info) -> false)) : @group.fg.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80183 (h0 : add_group (canonically_ordered_add_monoid empty)) : is_add_cyclic (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_80184 (h0 : topological_space (non_unital_non_assoc_semiring (left_cancel_monoid (mul_one_class string.iterator_imp)))) : t0_space (non_unital_non_assoc_semiring (left_cancel_monoid (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_80185 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_80186 (h0 : fin has_zero.zero) : @monoid.fg.{0} (finset.{0} (has_Inf.{0} linarith.comp)) (@matrix.vec_empty.{0} (monoid.{0} (finset.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_80187 (h1 : ring (normed_field (mul_one_class enat))) : is_domain (normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_80188 (h0 : topological_space (finset (finset (mul_zero_class pos)))) : regular_space (finset (finset (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_80189 (h0 : topological_space (normed_group unsigned)) : locally_compact_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_80190 (h2 : add_comm_semigroup (add_comm_semigroup fun_info) -> add_comm_semigroup (add_comm_semigroup fun_info)) (h3 : add_comm_semigroup (add_comm_semigroup fun_info)) : function.is_fixed_pt h2 h3 := sorry --non-trivial
lemma new_lemma_80191 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string pos)))) : t0_space (normed_comm_ring (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_80192 (h0 : functor.add_const (function.extfun Type uniform_space) (cancel_monoid linarith.comp)) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (cancel_monoid.{0} linarith.comp) h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80193 (h0 : topological_space (complete_distrib_lattice (has_Inf (complete_distrib_lattice linarith.comp)))) : preirreducible_space (complete_distrib_lattice (has_Inf (complete_distrib_lattice linarith.comp))) := sorry --non-trivial
lemma new_lemma_80194 (h0 : topological_space (normed_comm_ring (has_neg_part (boolean_algebra pos)))) : totally_separated_space (normed_comm_ring (has_neg_part (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_80195 (h0 : unsigned -> unsigned -> Prop) : is_refl unsigned h0 := sorry --non-trivial
lemma new_lemma_80196 (h1 : ring (add_monoid fun_info)) : strong_rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_80197 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_80198 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_80199 (h0 : complete_lattice (comm_semigroup (add_comm_monoid Type))) : is_compactly_generated (comm_semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_80200 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_80201 (h0 : ring (has_union (semiring (semiring (semiring (has_union (semiring linarith.comp))))))) : is_domain (has_union (semiring (semiring (semiring (has_union (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_80202 (h1 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (fintype (has_nnnorm char)))))) : t0_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (fintype (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_80203 (h0 : topological_space (has_sdiff string_imp)) : t0_space (has_sdiff string_imp) := sorry --non-trivial
lemma new_lemma_80204 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) Type) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_80205 (h1 : linear_ordered_add_comm_group (has_compl linarith.comp_source)) : set.univ h1 := sorry --trivial
lemma new_lemma_80206 (h0 : complete_lattice (has_inv (random_gen fun_info))) : is_compactly_generated (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_80207 (h0 : complete_lattice (pseudo_metric_space (comm_group unsigned))) : is_compactly_generated (pseudo_metric_space (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_80208 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_80209 (h0 : group (has_add (finset (mul_one_class Type)))) : is_simple_group (has_add (finset (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_80210 (h0 : complete_lattice (has_norm (has_norm linarith.comp_source))) : is_compactly_generated (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80211 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @totally_disconnected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80212 (h0 : group (semiring (has_norm (semiring congr_arg_kind)))) : is_cyclic (semiring (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_80213 (h0 : ordered_comm_monoid (boolean_algebra.core (comm_group Type))) : has_exists_mul_of_le (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_80214 (h0 : topological_space (fintype num)) : topological_space.separable_space (fintype num) := sorry --non-trivial
lemma new_lemma_80215 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_80216 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80217 (h0 : group (ring (has_Inf linarith.comp))) : group.fg (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_80218 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_80219 (h0 : add_group (has_compl (random_gen char))) : is_add_cyclic (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_80220 (h0 : topological_space (uniform_space empty)) : irreducible_space (uniform_space empty) := sorry --non-trivial
lemma new_lemma_80221 (h0 : uniform_space (ordered_comm_ring linarith.comp)) : complete_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_80222 (h0 : function.extfun fun_info (fun (x : fun_info), Prop)) : set.finite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_80223 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80224 (h0 : set (semi_normed_ring linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_80225 (h0 : group (linear_ordered_comm_group ennreal)) : normalizer_condition (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_80226 (h0 : uniform_space (add_right_cancel_monoid linarith.comp)) : complete_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_80227 (h1 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : path_connected_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_80228 (h0 : complete_lattice (semigroup (finset linarith.comp))) : is_compactly_generated (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80230 (h0 : topological_space (semigroup name)) : totally_disconnected_space (semigroup name) := sorry --non-trivial
lemma new_lemma_80231 (h0 : functor.comp topological_space has_zero ennreal) : @t0_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_80232 (h0 : ring (monoid empty)) : rank_condition (monoid empty) := sorry --non-trivial
lemma new_lemma_80233 (h0 : topological_space (id linarith.comp)) : totally_separated_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_80234 (h0 : topological_space (ring (cancel_monoid name))) : sequential_space (ring (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_80235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_80236 (h0 : complete_lattice (ordered_comm_group empty)) : is_atomistic (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_80237 (h0 : ring (id (semiring (has_top unsigned)))) : rank_condition (id (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_80238 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} (add_comm_monoid.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} (add_comm_monoid.{0} name)))  := sorry --non-trivial
lemma new_lemma_80239 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring unsigned)) (boolean_algebra pos)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80240 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @strong_rank_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type ring.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80241 (h0 : topological_space (normed_field (metric_space (metric_space to_additive.value_type)))) : totally_disconnected_space (normed_field (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_80242 (h0 : topological_space (plift (metric_space unsigned))) : t0_space (plift (metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_80243 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_80244 (h0 : has_le (has_lt fun_info)) (h1 : bounded_order (has_lt fun_info)) : is_simple_order (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_80245 (h0 : ring (preorder unsigned)) : rank_condition (preorder unsigned) := sorry --non-trivial
lemma new_lemma_80246 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core unsigned)) name) : @archimedean.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_80247 (h0 : topological_space (linear_ordered_field (comm_group unsigned))) : topological_space.separable_space (linear_ordered_field (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_80248 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80249 (h0 : group (comm_semigroup (has_Inf (has_Inf (generalized_boolean_algebra real))))) : is_simple_group (comm_semigroup (has_Inf (has_Inf (generalized_boolean_algebra real)))) := sorry --non-trivial
lemma new_lemma_80250 (h0 : add_group (normed_lattice_add_comm_group (has_add (has_Inf linarith.comp)))) : is_add_cyclic (normed_lattice_add_comm_group (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_80251 (h0 : group (normed_group (has_inv (dlist linarith.comp_source)))) : normalizer_condition (normed_group (has_inv (dlist linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_80252 (h0 : monoid (boolean_algebra.core (option empty))) : monoid.fg (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_80253 (h0 : finset (add_cancel_monoid (has_add ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80254 (h0 : topological_space (finset (comm_group unsigned))) : preconnected_space (finset (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_80255 (h0 : list (has_emptyc (has_top (random_gen (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80256 (h0 : topological_space (monoid unsigned)) : loc_path_connected_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_80257 (h0 : semiring (add_cancel_monoid (boolean_algebra Type))) : is_noetherian_ring (add_cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_80258 (h0 : topological_space (as_linear_order unsigned)) : totally_separated_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_80259 (h0 : filter (normed_lattice_add_comm_group Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80260 (h0 : set (set string_imp)) (h1 : set string_imp) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_80261 (h0 : functor.add_const (group (has_add linarith.comp)) Type) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_80262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_pos_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_80263 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) name) : @rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_80264 (h0 : ring (measurable_space unsigned)) : is_domain (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_80265 (h1 : add_group (nondiscrete_normed_field (normed_field string.iterator_imp))) : is_add_cyclic (nondiscrete_normed_field (normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_80266 (h0 : ring (has_norm (with_bot fun_info))) : is_domain (has_norm (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_80267 (h0 : prod (cancel_monoid Type) (cancel_monoid Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_80268 (h0 : add_group (boolean_algebra (finset linarith.comp))) : is_add_cyclic (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80269 (h0 : ring environment.implicit_infer_kind) : strong_rank_condition environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_80270 (h1 : has_lt (has_lt (normed_field string_imp))) : no_max_order (has_lt (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_80271 (h0 : functor.add_const (fin has_zero.zero) real) : @is_domain.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_80272 (h0 : topological_space (uniform_space (random_gen linarith.comp_source))) : path_connected_space (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80273 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_80274 (h0 : topological_space (has_bot (sub_neg_monoid (has_neg (has_neg real))))) : regular_space (has_bot (sub_neg_monoid (has_neg (has_neg real)))) := sorry --non-trivial
lemma new_lemma_80275 (h0 : topological_space (comm_group (has_neg_part Type))) : preconnected_space (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_80276 (h0 : ring (normed_lattice_add_comm_group real)) : rank_condition (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_80277 (h0 : functor.add_const (topological_space Type) Type) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_80278 (h2 : topological_space (random_gen reducibility_hints)) (h3 : preorder (random_gen reducibility_hints)) : order_topology (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_80279 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_80280 (h0 : prod (has_zero ennreal) (has_zero ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_80281 (h0 : functor.add_const (filter (add_comm_monoid name)) (add_cancel_monoid (add_cancel_monoid (boolean_algebra name)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80282 (h0 : ring (has_Sup (option (option unsigned)))) : is_domain (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80283 (h0 : not (ring (partial_order empty) -> false)) : @rank_condition.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80284 (h0 : topological_space (linear_ordered_comm_group (option (option unsigned)))) : t1_space (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80285 (h0 : not (topological_space (div_inv_monoid fun_info) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80286 (h0 : ring (normed_comm_ring (finset (finset ennreal)))) : strong_rank_condition (normed_comm_ring (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_80287 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_80288 (h0 : topological_space (has_Inf (ordered_ring name))) : loc_path_connected_space (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_80289 (h0 : group (complete_semilattice_Sup (comm_ring linarith.ineq))) : group.fg (complete_semilattice_Sup (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80290 (h0 : topological_space (boolean_algebra.core (has_to_string congr_arg_kind))) : preconnected_space (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80291 (h0 : not (ring (complete_linear_order unsigned) -> false)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_80292 (h0 : function.extfun Type (functor.comp ring option)) : @is_domain.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} option.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} option.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_80293 (h2 : add_group environment.projection_info) : is_add_cyclic environment.projection_info := sorry --non-trivial
lemma new_lemma_80294 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_80295 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80296 (h0 : functor.add_const (group (finset Type)) linarith.comp) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80297 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_80298 (h0 : monoid (add_cancel_monoid (has_add linarith.comp))) : monoid.fg (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_80299 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_80300 (h0 : ring (mul_zero_class (normed_comm_ring pos))) : is_principal_ideal_ring (mul_zero_class (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_80301 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_80302 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : preconnected_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_80304 (h0 : topological_space (has_neg (has_add environment.implicit_infer_kind))) : discrete_topology (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80305 (h0 : monoid (has_Sup unsigned)) : monoid.fg (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_80306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_80307 (h0 : filter (semigroup (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80308 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80309 (h0 : functor.add_const (prod (free_add_monoid unsigned) (free_add_monoid unsigned)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80310 (h0 : not (topological_space (uniform_space enat) -> false)) : @t0_space.{0} (uniform_space.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_80311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_80312 (h0 : complete_lattice (add_cancel_monoid (semiring empty))) : is_compactly_generated (add_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_80313 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @preconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_80314 (h0 : ring (boolean_algebra (has_to_string pos))) : is_principal_ideal_ring (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_80315 (h0 : group (normed_comm_ring (has_neg environment.implicit_infer_kind))) : group.fg (normed_comm_ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80316 (h0 : add_group (metric_space (semiring (semiring unsigned)))) : is_add_cyclic (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_80317 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_80318 (h1 : ring (encodable string_imp)) : strong_rank_condition (encodable string_imp) := sorry --non-trivial
lemma new_lemma_80319 (h0 : topological_space (has_pos_part (has_zero pos))) : t1_space (has_pos_part (has_zero pos)) := sorry --non-trivial
lemma new_lemma_80320 (h0 : functor.add_const (finset (semiring congr_arg_kind)) (semiring (semiring (semiring congr_arg_kind)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80321 (h2 : filter (has_inv string_imp)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_80322 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @normalizer_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80323 (h0 : topological_space (has_nndist (has_to_string linarith.comp))) : totally_disconnected_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_80324 (h0 : add_group (id empty)) : is_add_cyclic (id empty) := sorry --non-trivial
lemma new_lemma_80325 (h0 : functor.add_const (group (has_to_string ennreal)) name) : @is_cyclic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_80326 (h0 : functor.add_const (function.extfun Type group) (ring linarith.comp)) : @group.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} linarith.comp) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80327 (h0 : functor.add_const (topological_space (free_add_monoid num)) congr_arg_kind) : @path_connected_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_80328 (h0 : topological_space (canonically_linear_ordered_monoid num)) : preirreducible_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_80329 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80330 (h0 : functor.add_const (filter (comm_group unsigned)) (has_to_string name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80331 (h0 : topological_space (has_nndist (option ennreal))) : irreducible_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_80332 (h0 : add_group (add_monoid (random_gen linarith.comp_source))) : is_add_cyclic (add_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80333 (h0 : group (canonically_linear_ordered_monoid (option (option ennreal)))) : group.fg (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_80334 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80335 (h1 : add_group (measurable_space num)) : is_add_cyclic (measurable_space num) := sorry --non-trivial
lemma new_lemma_80336 (h0 : complete_lattice linarith.comp_source) : complete_lattice.is_Sup_finite_compact linarith.comp_source := sorry --non-trivial
lemma new_lemma_80337 (h0 : topological_space (omega_complete_partial_order empty)) : loc_path_connected_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_80338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_80339 (h0 : group (has_neg (add_cancel_monoid Type))) : normalizer_condition (has_neg (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_80340 (h0 : ring (semiring (has_top (has_top (has_top to_additive.value_type))))) : rank_condition (semiring (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_80341 (h0 : topological_space (measurable_space (has_norm (has_top (has_norm (random_gen fun_info)))))) : locally_compact_space (measurable_space (has_norm (has_top (has_norm (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_80342 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring empty)) : @t1_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_80343 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80344 (h0 : group (has_add (finset linarith.comp))) : group.fg (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80345 (h0 : set (uniform_space (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_80346 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_80347 (h0 : add_group (has_top (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_80348 (h0 : functor.add_const (group (has_to_string pos)) environment.implicit_infer_kind) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80349 (h0 : group (has_pos_part (ring pos))) : group.fg (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_80350 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_80351 (h0 : topological_space (add_comm_monoid (cancel_monoid (has_add unsigned)))) : normal_space (add_comm_monoid (cancel_monoid (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_80352 (h0 : functor.add_const (group (monoid unsigned)) empty) : @is_cyclic.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_80353 (h0 : topological_space (semiring (has_top linarith.comp))) : discrete_topology (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_80354 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid_with_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_80355 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80356 (h0 : finset (linear_ordered_comm_ring (semiring (semiring (semiring num))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80357 (h0 : topological_space (has_zero (measurable_space linarith.comp))) : topological_space.separable_space (has_zero (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_80358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80359 (h0 : group (pseudo_metric_space (option empty))) : normalizer_condition (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_80360 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_pos_part linarith.comp))) : unique_factorization_monoid (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_80361 (h0 : filter (has_norm (has_norm (random_gen (has_top (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80362 (h0 : topological_space (has_compl (add_left_cancel_monoid linarith.ineq))) : t0_space (has_compl (add_left_cancel_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80363 (h0 : topological_space (has_zero (add_cancel_monoid (has_to_string name)))) : discrete_topology (has_zero (add_cancel_monoid (has_to_string name))) := sorry --non-trivial
lemma new_lemma_80364 (h0 : functor.add_const (function.extfun Type ring) (has_add linarith.comp)) : @rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_add.{0} linarith.comp) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80365 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @normal_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_80366 (h0 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @totally_separated_space.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80367 (h0 : topological_space (has_zero (comm_group (comm_group unsigned)))) : totally_separated_space (has_zero (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_80368 (h0 : topological_space (ordered_comm_monoid unsigned)) : path_connected_space (ordered_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_80369 (h0 : topological_space (comm_ring reducibility_hints)) : t0_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_80370 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_80371 (h0 : filter (add_right_cancel_monoid (semiring (has_top unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80372 (h0 : group (boolean_algebra (ring pos))) : group.fg (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_80373 (h0 : filter (comm_group (has_add (boolean_algebra name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80374 (h0 : not (complete_lattice (non_unital_non_assoc_semiring (random_gen (random_gen (random_gen char)))) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_80375 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80376 (h0 : topological_space (has_top (has_norm (has_norm num)))) : totally_disconnected_space (has_top (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_80377 (h1 : ring (denumerable (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (denumerable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_80378 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (ordered_comm_ring pos)))) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos))) h0 Type))  := sorry --non-trivial
lemma new_lemma_80379 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (option unsigned)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_80380 (h0 : topological_space (has_inner (option (option empty)) congr_arg_kind)) : preirreducible_space (has_inner (option (option empty)) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80381 (h0 : group (boolean_algebra (comm_group Type))) : normalizer_condition (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_80382 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_80383 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80384 (h0 : not (group (complete_semilattice_Sup num) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_80385 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80386 (h0 : ring (semiring (has_top num))) : strong_rank_condition (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_80387 (h0 : functor.add_const (group (omega_complete_partial_order unsigned)) empty) : @group.fg.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_80388 (h0 : not (group (uniform_space linarith.comp_source) -> false)) : @is_cyclic.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_80389 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_80390 (h0 : topological_space (uniform_space linarith.ineq)) : totally_disconnected_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_80391 (h0 : group nnreal) : group.fg nnreal := sorry --non-trivial
lemma new_lemma_80392 (h0 : complete_lattice (complete_distrib_lattice (has_neg_part Type))) : is_compactly_generated (complete_distrib_lattice (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_80393 (h0 : topological_space (has_ssubset (mul_one_class enat))) : totally_disconnected_space (has_ssubset (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_80394 (h0 : group (canonically_linear_ordered_monoid (option name))) : normalizer_condition (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_80395 (h0 : functor.add_const (topological_space (cancel_monoid name)) (mul_zero_class Type)) : @normal_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) (mul_zero_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_80396 (h0 : list (ring (boolean_algebra (boolean_algebra Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_80397 (h0 : complete_lattice (complete_semilattice_Sup (has_top (has_top linarith.comp_source)))) : is_compactly_generated (complete_semilattice_Sup (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_80398 (h0 : ring (uniform_space (uniform_space string_imp))) : rank_condition (uniform_space (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_80399 (h0 : topological_space (comm_group (option pos))) : regular_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_80400 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring name)) (has_neg_part pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80401 (h0 : functor.add_const (topological_space (metric_space empty)) num) : @preirreducible_space.{0} (metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_80402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_80403 (h0 : group (has_neg (comm_group unsigned))) : group.fg (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_80404 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_80405 (h0 : complete_lattice (option (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80406 (h0 : semiring (mul_zero_class (semiring unsigned))) : is_noetherian_ring (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_80407 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80408 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_80409 (h0 : complete_lattice (complete_semilattice_Sup (has_top fun_info))) : is_compactly_generated (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_80410 (h1 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_80411 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : preirreducible_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80412 (h0 : has_lt (ordered_ring char)) : no_max_order (ordered_ring char) := sorry --non-trivial
lemma new_lemma_80413 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @group.fg.{0} linarith.comp (@finset.pi.empty.{1 0} Type group.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80414 (h0 : ring (set fun_info)) : rank_condition (set fun_info) := sorry --non-trivial
lemma new_lemma_80415 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80416 (h0 : functor.add_const (ring (is_R_or_C empty)) empty) : @is_principal_ideal_ring.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80417 (h0 : ring (denumerable to_additive.value_type)) : is_domain (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_80418 (h0 : topological_space (has_union fun_info)) : totally_disconnected_space (has_union fun_info) := sorry --non-trivial
lemma new_lemma_80419 (h0 : group (mul_zero_class (option name))) : normalizer_condition (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_80420 (h0 : ring (add_comm_monoid (option (option (option pos))))) : strong_rank_condition (add_comm_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_80421 (h0 : ring (ordered_comm_monoid name)) : is_domain (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_80422 (h0 : group (add_cancel_monoid (linear_ordered_field (add_comm_monoid congr_arg_kind)))) : normalizer_condition (add_cancel_monoid (linear_ordered_field (add_comm_monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_80423 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @discrete_topology.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80424 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (has_neg linarith.comp)) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80425 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup pos)) := sorry --non-trivial
lemma new_lemma_80426 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_80427 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_80428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_80429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80430 (h0 : complete_lattice (has_norm (random_gen congr_arg_kind))) : is_atomistic (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80431 (h0 : not (ring (add_left_cancel_monoid (denumerable (comm_ring linarith.comp_source))) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} (denumerable.{0} (comm_ring.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} (denumerable.{0} (comm_ring.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_80432 (h0 : ring (has_Inf (has_add name))) : strong_rank_condition (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_80433 (h0 : functor.add_const (group (has_zero name)) linarith.comp) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80434 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_80435 (h0 : topological_space (semiring (normed_group fun_info))) : totally_separated_space (semiring (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_80436 (h0 : complete_lattice (linear_ordered_semiring (semiring (has_norm empty)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_80437 (h0 : group (has_Inf (finset name))) : group.fg (has_Inf (finset name)) := sorry --non-trivial
lemma new_lemma_80438 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80439 (h0 : filter (random_gen (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80440 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_80441 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_80442 (h0 : topological_space (add_cancel_monoid (ring environment.implicit_infer_kind))) : normal_space (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80443 (h1 : uniform_space (normed_field (comm_ring (comm_ring (comm_ring (comm_ring string_imp)))))) : complete_space (normed_field (comm_ring (comm_ring (comm_ring (comm_ring string_imp))))) := sorry --non-trivial
lemma new_lemma_80444 (h0 : fin has_zero.zero) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_80445 (h0 : functor.add_const (functor.add_const (ring auto.case_option) environment.implicit_infer_kind) pos) : @rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} auto.case_option) environment.implicit_infer_kind) pos h0))  := sorry --non-trivial
lemma new_lemma_80446 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_80447 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80448 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80449 (h0 : ring (with_bot (random_gen string_imp))) : is_domain (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_80450 (h0 : function.extfun Type group) : @is_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_80451 (h0 : not (uniform_space (add_group empty) -> false)) : @complete_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80452 (h0 : topological_space (ring unsigned)) : normal_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_80453 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra Type)) pos) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_80454 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : discrete_topology (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_80455 (h0 : list (dlist (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80456 (h0 : monoid (add_comm_monoid Type)) : monoid.fg (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_80457 (h0 : ring (finset (has_neg environment.implicit_infer_kind))) : is_domain (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80458 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80460 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_80461 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg Type)) (has_pos_part pos)) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80462 (h0 : topological_space (add_cancel_monoid (comm_group (has_add unsigned)))) : regular_space (add_cancel_monoid (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_80463 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_80464 (h0 : list (complete_linear_order (partial_order (semiring (option empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80465 (h1 : list (id to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_80466 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : path_connected_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_80467 (h0 : topological_space (has_nnnorm (random_gen linarith.ineq))) : path_connected_space (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80468 (h0 : topological_space (simple_graph linarith.ineq)) (h1 : add_group (simple_graph linarith.ineq)) : topological_add_group (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_80469 (h1 : group (uniform_space (metric_space reducibility_hints))) : is_cyclic (uniform_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_80470 (h0 : uniform_space (id (random_gen (random_gen string_imp)))) : complete_space (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_80471 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_80472 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) name) : @normal_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80473 (h0 : ring (boolean_algebra.core (add_comm_monoid (add_comm_monoid name)))) : is_principal_ideal_ring (boolean_algebra.core (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_80474 (h0 : ring (ring (option (option unsigned)))) : is_domain (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_80475 (h0 : ring (simple_graph (has_add name))) : strong_rank_condition (simple_graph (has_add name)) := sorry --non-trivial
lemma new_lemma_80476 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_edist empty)) := sorry --non-trivial
lemma new_lemma_80477 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80478 (h0 : topological_space (has_nndist empty)) : t1_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_80479 (h0 : comm_semiring (fintype char)) (h1 : not (polynomial (fintype char) -> false)) : polynomial.is_primitive (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_80480 (h0 : group (ring (has_add linarith.comp))) : normalizer_condition (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_80481 (h0 : functor.add_const (list (add_cancel_monoid Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80482 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup enat))) : totally_disconnected_space (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_80483 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) (ring linarith.comp)) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80484 (h0 : finset (finset (has_Inf (has_Inf pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80485 (h0 : topological_space (has_neg (option unsigned))) : loc_path_connected_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_80486 (h0 : not (topological_space (metric_space unsigned) -> false)) : @normal_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_80487 (h0 h1 : list (mul_one_class std_gen)) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_80488 (h0 : topological_space (boolean_algebra (has_add name))) : path_connected_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_80489 (h0 : group (normed_comm_ring (normed_comm_ring name))) : is_simple_group (normed_comm_ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_80490 (h0 : ring (semigroup (has_add Type))) : is_domain (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_80491 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring Type)) (finset environment.implicit_infer_kind)) : @archimedean.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (normed_comm_ring.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_80492 (h0 : fin has_zero.zero) : @t1_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_80493 (h0 : functor.add_const (complete_lattice (comm_group Type)) (has_neg_part pos)) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80494 (h0 : finset (preorder (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80495 (h0 : group (has_pos_part (has_pos_part Type))) : is_cyclic (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_80496 (h0 : functor.add_const (group (has_to_string pos)) (finset pos)) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80497 (h0 : topological_space (has_ssubset (distrib string_imp))) : t0_space (has_ssubset (distrib string_imp)) := sorry --non-trivial
lemma new_lemma_80498 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) pos) : @is_atomistic.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_80499 (h0 : list (dlist (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80500 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group (semigroup (comm_group Type)))) : @normal_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} (semigroup.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_80501 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @totally_separated_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_80502 (h0 : ring (dlist linarith.ineq)) : rank_condition (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_80503 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80504 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_80505 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_80506 (h0 : topological_space (has_neg_part (has_add (add_comm_monoid (has_add pos))))) : locally_compact_space (has_neg_part (has_add (add_comm_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_80507 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_80508 (h0 : functor.add_const (group (simple_graph linarith.comp)) name) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80509 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : topological_space.separable_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_80510 (h0 : topological_space (has_bot (option unsigned))) : locally_compact_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_80511 (h0 : topological_space (ordered_comm_monoid (has_add (has_add linarith.comp)))) : preirreducible_space (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_80512 (h0 : topological_space (has_norm (random_gen char))) : locally_compact_space (has_norm (random_gen char)) := sorry --non-trivial
lemma new_lemma_80513 (h0 : topological_space (random_gen (comm_ring (random_gen char)))) : totally_disconnected_space (random_gen (comm_ring (random_gen char))) := sorry --non-trivial
lemma new_lemma_80514 (h0 : functor.add_const (list (has_add linarith.comp)) (finset pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80515 (h0 : complete_lattice (has_inter unsigned)) : is_compactly_generated (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_80516 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_80517 (h0 : uniform_space (dlist (has_inv linarith.ineq))) : complete_space (dlist (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80518 (h0 : functor.add_const (add_group (has_Inf real)) pos) : @is_add_cyclic.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_80519 (h0 : topological_space (has_top (has_norm (has_norm linarith.comp)))) : normal_space (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_80520 (h0 : measurable_space (add_comm_semigroup (add_comm_semigroup enat))) (h1 : set (add_comm_semigroup (add_comm_semigroup enat))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_80521 (h0 : group (pseudo_metric_space (option unsigned))) : normalizer_condition (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_80522 (h0 : ulower pnat) (h1 : thunk pnat) : pnat.coprime (@ulower.up.{0} pnat encodable.pnat h0) (@trace_call_stack.{0} pnat h1)  := sorry --non-trivial
lemma new_lemma_80523 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_80524 (h0 : function.extfun Type group) : @is_cyclic.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_80525 (h0 : complete_lattice (ordered_cancel_add_comm_monoid ennreal)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_80526 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @normalizer_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_80527 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_80528 (h1 : set (std_gen -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_80529 (h0 : topological_space (ordered_comm_monoid (has_bot pos))) : preconnected_space (ordered_comm_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_80530 (h0 : group (comm_monoid (option empty))) : normalizer_condition (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_80531 (h0 : measurable_space (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : filter (linear_ordered_comm_group_with_zero linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_80532 (h1 : set std_gen) : set.finite h1 := sorry --non-trivial
lemma new_lemma_80533 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : totally_disconnected_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80534 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80535 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (boolean_algebra.core name)))) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name))) h0 Type))  := sorry --non-trivial
lemma new_lemma_80536 (h0 : list (add_cancel_monoid (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80537 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80538 (h0 : functor.add_const (filter (has_neg_part name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80539 (h0 : topological_space (pseudo_metric_space (finset Type))) : totally_disconnected_space (pseudo_metric_space (finset Type)) := sorry --non-trivial
lemma new_lemma_80540 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_80541 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_80542 (h0 : ring (mul_one_class (mul_one_class fun_info))) : strong_rank_condition (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_80543 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_80544 (h0 : filter (ring Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80545 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80546 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_80547 (h0 : group (sub_neg_monoid (has_pos_part (has_add linarith.comp)))) : normalizer_condition (sub_neg_monoid (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_80548 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} fun_info (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_80549 (h2 : topological_space (with_one num)) : totally_disconnected_space (with_one num) := sorry --non-trivial
lemma new_lemma_80550 (h0 : not (cancel_comm_monoid_with_zero (with_one empty) -> false)) : @unique_factorization_monoid.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80551 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_add linarith.comp))))) : preconnected_space (canonically_ordered_monoid (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_80552 (h0 : functor.add_const (group pos) name) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_80553 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : discrete_topology (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_80554 (h0 : ring (has_append (has_nnnorm reducibility_hints))) : strong_rank_condition (has_append (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_80555 (h0 : ring (cancel_monoid (option unsigned))) : rank_condition (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_80556 (h0 : topological_space (linear_ordered_semiring (random_gen linarith.comp_source))) : t0_space (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80557 (h0 : has_mem.mem (with_one linarith.comp_source) has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@multiset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_80558 (h0 : not (ring (topological_space linarith.comp_source) -> false)) : @rank_condition.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_80559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_80560 (h0 : has_lt (mul_one_class string_imp) -> has_lt (mul_one_class string_imp)) : set.finite (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_80561 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : t0_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_80562 (h1 : has_append (has_nnnorm (has_lt (has_lt (has_lt to_additive.value_type)))) -> Prop) (h2 : has_append (has_nnnorm (has_lt (has_lt (has_lt to_additive.value_type))))) : set_of h1 h2 := sorry --non-trivial
lemma new_lemma_80563 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_80564 (h0 : ring (add_group (has_top fun_info))) : rank_condition (add_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_80565 (h0 : add_group (semi_normed_ring (random_gen char))) : is_add_cyclic (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_80566 (h0 : topological_space (normed_group (random_gen string_imp))) : totally_separated_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_80567 (h0 : topological_space (with_bot (with_bot (random_gen congr_arg_kind)))) : path_connected_space (with_bot (with_bot (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_80568 (h0 : functor.add_const (add_group (add_cancel_monoid linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80569 (h4 : set (string.iterator_imp -> linarith.ineq)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_80570 (h0 : finset (add_cancel_comm_monoid (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80571 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_80572 (h0 : uniform_space (has_zero (normed_comm_ring linarith.comp))) : complete_space (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_80573 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) num) : @totally_separated_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_80574 (h0 : complete_lattice (canonically_ordered_monoid real)) : is_compactly_generated (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_80575 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_80576 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @preconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_80577 (h0 : not (add_monoid (left_cancel_semigroup empty) -> false)) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80578 (h0 : functor.add_const (add_group (complete_distrib_lattice name)) linarith.comp) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80579 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80580 (h0 : topological_space (monoid pos)) : discrete_topology (monoid pos) := sorry --non-trivial
lemma new_lemma_80581 (h0 : add_group (simple_graph (mul_one_class (mul_one_class environment.projection_info)))) : is_add_cyclic (simple_graph (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_80582 (h0 : uniform_space (mul_zero_class (semiring congr_arg_kind))) : complete_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80583 (h0 : topological_space (ring (option (option (option (option unsigned)))))) : path_connected_space (ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_80584 (h0 : not (group (has_union congr_arg_kind) -> false)) : @is_cyclic.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80585 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_80586 (h0 : group (ordered_comm_ring (ring (ring (has_pos_part linarith.comp))))) : normalizer_condition (ordered_comm_ring (ring (ring (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_80587 (h0 : complete_lattice (with_one (has_nnnorm fun_info))) : is_compactly_generated (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_80588 (h0 : topological_space (comm_semigroup (has_pos_part pos))) : totally_separated_space (comm_semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_80589 (h1 : topological_space (nondiscrete_normed_field ereal)) (h2 : preorder (nondiscrete_normed_field ereal)) : order_closed_topology (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_80590 (h0 : ordered_comm_monoid (cancel_monoid (comm_group Type))) : has_exists_mul_of_le (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_80591 (h0 : functor.add_const (ring environment.implicit_infer_kind) (has_add (has_add pos))) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_80592 (h0 : topological_space (monoid empty)) : totally_separated_space (monoid empty) := sorry --non-trivial
lemma new_lemma_80593 (h0 : uniform_space (normed_linear_ordered_group unsigned)) : complete_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_80594 (h0 : measurable_space (non_unital_non_assoc_semiring fun_info)) (h1 : filter (non_unital_non_assoc_semiring fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_80595 (h0 : functor.add_const (group (cancel_monoid Type)) name) : @is_cyclic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_80596 (h0 : num -> empty -> empty) (h1 : empty -> empty -> Prop) : covariant num empty h0 h1 := sorry --non-trivial
lemma new_lemma_80597 (h0 : topological_space (option (option pos))) : loc_path_connected_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_80598 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_80599 (h1 : group (metric_space num)) : is_cyclic (metric_space num) := sorry --non-trivial
lemma new_lemma_80600 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : discrete_topology (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_80601 (h0 : topological_space (with_one (random_gen to_additive.value_type))) : totally_disconnected_space (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_80602 (h1 : uniform_space (semi_normed_ring string.iterator_imp)) : complete_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_80603 (h0 : has_lt (distrib string.iterator_imp)) : no_max_order (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_80604 (h0 : add_group (add_right_cancel_monoid (option empty))) : is_add_cyclic (add_right_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_80605 (h0 : complete_lattice (add_left_cancel_semigroup empty)) : is_compactly_generated (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_80606 (h0 : topological_space (has_pos_part (ring pos))) : loc_path_connected_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_80607 (h0 : topological_space (normed_comm_ring (normed_comm_ring name))) : path_connected_space (normed_comm_ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_80608 (h0 : functor.add_const (group auto.case_option) empty) : @group.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_80609 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @complete_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80610 (h0 : ring (uniform_space reducibility_hints)) : is_domain (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_80611 (h0 : ring (random_gen (has_ssubset (has_lt string_imp)))) : is_domain (random_gen (has_ssubset (has_lt string_imp))) := sorry --non-trivial
lemma new_lemma_80612 (h0 : uniform_space (has_neg (finset (has_neg linarith.comp)))) : complete_space (has_neg (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_80613 (h0 : topological_space (complete_distrib_lattice (option (option (option (option (option empty))))))) : preirreducible_space (complete_distrib_lattice (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_80614 (h0 : add_group (denumerable (has_nnnorm (has_lt (has_nnnorm fun_info))))) : is_add_cyclic (denumerable (has_nnnorm (has_lt (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_80615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80616 (h0 : functor.add_const (ring (group_with_zero num)) num) : @strong_rank_condition.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_80617 (h0 : not (topological_space (has_lt linarith.ineq) -> false)) : @t0_space.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_80618 (h0 : functor.add_const (monoid (boolean_algebra unsigned)) (has_add pos)) : @monoid.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} unsigned)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80619 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80620 (h0 : functor.add_const (uniform_space (free_add_monoid congr_arg_kind)) empty) : @complete_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_80621 (h0 : function.extfun nat fin) : @is_atomistic.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_80622 (h0 : uniform_space (canonically_ordered_monoid (has_add Type))) : separated_space (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_80623 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : sequential_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_80624 (h0 : group (left_cancel_monoid (option unsigned))) : normalizer_condition (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_80625 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80626 (h0 : topological_space (has_edist congr_arg_kind)) : totally_disconnected_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80627 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_add linarith.comp))) : has_exists_mul_of_le (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_80628 (h0 : semiring (with_one (has_top (has_union num)))) : is_noetherian_ring (with_one (has_top (has_union num))) := sorry --non-trivial
lemma new_lemma_80629 (h0 : prod (pseudo_metric_space empty) (pseudo_metric_space empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_80630 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_80631 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80633 (h0 : functor.add_const (group (has_Inf pos)) Type) : @group.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_80634 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (pseudo_metric_space num)) := sorry --non-trivial
lemma new_lemma_80635 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_80636 (h0 : topological_space (has_union (has_top empty))) : discrete_topology (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_80637 (h0 : uniform_space (id linarith.comp_source)) : complete_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_80638 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : t1_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_80639 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))  := sorry --non-trivial
lemma new_lemma_80640 (h0 : topological_space (generalized_boolean_algebra (has_add (has_pos_part linarith.comp)))) : preconnected_space (generalized_boolean_algebra (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_80641 (h0 : function.extfun Type (functor.add_const (topological_space ordering))) : @loc_path_connected_space.{0} ordering (@functor.add_const.run.{0 0} (topological_space.{0} ordering) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} ordering)) h0 pos))  := sorry --non-trivial
lemma new_lemma_80642 (h0 : complete_lattice (semigroup (has_to_string congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (semigroup (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80643 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @preconnected_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80644 (h0 : functor.comp group comm_group pos) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_80645 (h0 : uniform_space (has_dist ennreal)) : separated_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_80646 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80647 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra.core Type)))) : normal_space (cancel_monoid (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_80648 (h0 : functor.add_const (uniform_space (semigroup pos)) environment.implicit_infer_kind) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80649 (h0 : finset (has_star (semiring (semiring (semiring congr_arg_kind))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80650 (h0 : group (linear_ordered_field (add_cancel_monoid pos))) : is_cyclic (linear_ordered_field (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_80651 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_80652 (h0 : semiring (canonically_ordered_monoid real)) (h1 : canonically_ordered_monoid real) : odd h1 := sorry --non-trivial
lemma new_lemma_80653 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_80654 (h0 : functor.add_const (finset (has_star empty)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80655 (h0 : group (has_inv (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))))) : is_cyclic (has_inv (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_80656 (h0 : not (add_group (has_append reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_80657 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm char)))) : locally_compact_space (has_ssubset (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_80658 (h0 : ring (semigroup (has_to_string pos))) : strong_rank_condition (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_80659 (h0 : filter (finset congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80660 (h2 : preorder (add_comm_semigroup fun_info)) (h3 : set (add_comm_semigroup fun_info)) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_80661 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @regular_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_80662 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_80663 (h0 h1 : omega_complete_partial_order std_gen) (h2 : std_gen -> std_gen) : omega_complete_partial_order.continuous' h2 := sorry --non-trivial
lemma new_lemma_80664 (h0 : ordered_add_comm_monoid (has_edist empty)) : archimedean (has_edist empty) := sorry --non-trivial
lemma new_lemma_80665 (h0 : group (with_bot (has_inv to_additive.value_type))) : is_cyclic (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_80666 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_80667 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_80668 (h0 : topological_space (has_bot (ordered_comm_group (ordered_comm_group empty)))) : totally_separated_space (has_bot (ordered_comm_group (ordered_comm_group empty))) := sorry --non-trivial
lemma new_lemma_80669 (h0 : functor.add_const (ring (comm_group unsigned)) pos) : @rank_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_80670 (h0 : not (ring (id unsigned) -> false)) : @is_domain.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_80671 (h0 : ring (denumerable fun_info) -> string_imp) (h1 : function.extfun (set string_imp) coe_sort) : @is_domain.{0} (denumerable.{0} fun_info) (@set.range_splitting.{0 0} (ring.{0} (denumerable.{0} fun_info)) string_imp h0 (@function.extfun_app.{1 1} (set.{0} string_imp) (@coe_sort.{1 2} (set.{0} string_imp) Type (@set.has_coe_to_sort.{0} string_imp)) h1 (@set.range.{0 1} string_imp (ring.{0} (denumerable.{0} fun_info)) h0)))  := sorry --non-trivial
lemma new_lemma_80672 (h0 : topological_space (has_bot (has_add (ordered_comm_monoid (has_add (has_bot Type)))))) : totally_disconnected_space (has_bot (has_add (ordered_comm_monoid (has_add (has_bot Type))))) := sorry --non-trivial
lemma new_lemma_80673 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) name) : @add_monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_80674 (h0 : not (group (left_cancel_monoid num) -> false)) : @group.fg.{0} (left_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_80675 (h0 : ring (cancel_monoid (comm_group (add_comm_monoid name)))) : rank_condition (cancel_monoid (comm_group (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_80676 (h1 : topological_space (mul_one_class (mul_one_class std_gen))) : totally_disconnected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_80677 (h0 : function.extfun Type topological_space) : @regular_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_80678 (h0 : functor.add_const (add_group (has_neg name)) pos) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_80679 (h0 : functor.add_const (add_monoid (has_neg_part pos)) Type) : @add_monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_80680 (h0 : filter (has_union empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80681 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_pos_part linarith.comp)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80682 (h0 : functor.comp ring has_to_string Type) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_80683 (h0 : not (complete_lattice (measurable_space num) -> false)) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_80684 (h1 : complete_lattice (semi_normed_comm_ring string_imp)) : is_compactly_generated (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_80685 (h0 : monoid (normed_lattice_add_comm_group (has_neg real))) : monoid.fg (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_80686 (h0 : ring (non_unital_non_assoc_semiring fun_info)) : rank_condition (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_80687 (h0 : measurable_space (has_lt (has_ssubset enat))) (h1 : filter (has_lt (has_ssubset enat))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_80688 (h1 : not (topological_space (has_append linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_80689 (h0 : ring (has_div char)) : strong_rank_condition (has_div char) := sorry --non-trivial
lemma new_lemma_80690 (h0 : filter (has_zero (semigroup Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80691 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80692 (h0 : filter (encodable (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80693 (h0 : finset znum) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80694 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_80695 (h0 : fin has_zero.zero) : @t0_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_80696 (h0 : topological_space (boolean_algebra (semigroup (has_add environment.implicit_infer_kind)))) : t0_space (boolean_algebra (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_80697 (h0 : topological_space (has_to_string (option (option ennreal)))) : t1_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_80698 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80699 (h0 : group (with_bot (has_top string_imp))) : group.fg (with_bot (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_80700 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80701 (h0 : semiring (has_sub congr_arg_kind) -> semiring (has_sub congr_arg_kind) -> Prop) : is_equiv (semiring (has_sub congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_80702 (h0 : ring (has_append (random_gen char))) : strong_rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_80703 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) (h2 : Prop) : yyy_to (with_bot.unbot h0 h1) h2 := sorry --non-trivial
lemma new_lemma_80704 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_80705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80706 (h0 : functor.add_const (add_group (cancel_monoid name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_80707 (h0 : topological_space (simple_graph (ring Type))) : locally_compact_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_80708 (h0 : topological_space (semigroup (finset (has_neg linarith.comp)))) : topological_space.separable_space (semigroup (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_80709 (h0 : complete_lattice (has_nndist (finset ennreal))) : is_atomistic (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_80710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_80711 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf (has_Inf real)))))) : t0_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_80712 (h1 : not (ring (comm_ring char) -> false)) : @rank_condition.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_80713 (h0 : topological_space (has_top (has_top (has_top to_additive.value_type)))) : totally_disconnected_space (has_top (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_80714 (h0 : complete_lattice (metric_space (semiring (semiring (semiring congr_arg_kind))))) : is_atomistic (metric_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_80715 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80716 (h0 : topological_space (with_bot (comm_ring (comm_ring (random_gen to_additive.value_type))))) : totally_disconnected_space (with_bot (comm_ring (comm_ring (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_80717 (h0 : measurable_space (has_compl fun_info)) (h1 : filter (has_compl fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_80718 (h0 : topological_space (has_le (linear_ordered_comm_group_with_zero string.iterator_imp))) : path_connected_space (has_le (linear_ordered_comm_group_with_zero string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_80719 (h0 : functor.add_const (ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) (ring Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_80720 (h1 : complete_lattice (denumerable (with_bot to_additive.value_type))) : is_compactly_generated (denumerable (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_80721 (h1 : set (simple_graph string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_80722 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero pos)) name) : @archimedean.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_80723 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_80724 (h0 : topological_space (has_add (mul_one_class (finset linarith.comp)))) : topological_space.separable_space (has_add (mul_one_class (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_80725 (h0 : group (has_nndist name)) : normalizer_condition (has_nndist name) := sorry --non-trivial
lemma new_lemma_80726 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) pos) : @t1_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_80727 (h0 : complete_lattice (has_compl (has_compl (has_compl linarith.ineq)))) : is_compactly_generated (has_compl (has_compl (has_compl linarith.ineq))) := sorry --non-trivial
lemma new_lemma_80728 (h0 : topological_space (complete_semilattice_Sup (comm_ring linarith.ineq))) : irreducible_space (complete_semilattice_Sup (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80729 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_80730 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_80731 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80732 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_80734 (h0 : complete_lattice (semi_normed_ring (mul_one_class linarith.comp_source))) : is_compactly_generated (semi_normed_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80735 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @irreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_80736 (h0 : group (add_group (semiring unsigned))) : is_cyclic (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_80737 (h0 : list (measurable_space.dynkin_system (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_80738 (h0 : add_group (with_zero linarith.ineq)) : is_add_cyclic (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_80739 (h0 : topological_space (ring linarith.comp)) : irreducible_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_80740 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_80741 (h0 : ring (has_add (has_neg (has_neg pos)))) : is_domain (has_add (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_80742 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_80743 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @path_connected_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80744 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80745 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80746 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_80747 (h0 : group (finset congr_arg_kind)) : group.fg (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80748 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : locally_compact_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_80749 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_80750 (h0 : ordered_comm_monoid (has_zero (has_add (has_add (has_add unsigned))))) : has_exists_mul_of_le (has_zero (has_add (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_80751 (h0 : add_group (semigroup ennreal)) : is_add_cyclic (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_80752 (h1 : topological_space (has_emptyc (random_gen linarith.comp_source))) : path_connected_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80753 (h0 : group (normed_lattice_add_comm_group linarith.comp)) : is_simple_group (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_80754 (h0 : group (has_norm (has_inv linarith.comp_source))) : is_cyclic (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80755 (h0 : functor.add_const (ring (option congr_arg_kind)) empty) : @rank_condition.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_80756 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @t0_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_80757 (h0 : functor.add_const (group (add_cancel_monoid name)) name) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_80758 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @t0_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80759 (h2 : topological_space congr_arg_kind) : locally_compact_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_80760 (h0 : topological_space (comm_semigroup real)) : t0_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_80761 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_80762 (h0 : topological_space (with_one (random_gen linarith.comp_source))) : path_connected_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80763 (h0 : topological_space (has_add (has_add real))) : totally_separated_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_80764 (h0 : monoid (has_bot (has_Inf (has_Inf (has_add (has_add (has_pos_part pos))))))) : monoid.fg (has_bot (has_Inf (has_Inf (has_add (has_add (has_pos_part pos)))))) := sorry --non-trivial
lemma new_lemma_80765 (h0 : topological_space (add_comm_monoid (finset linarith.comp))) : normal_space (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80766 (h0 : complete_lattice (semiring (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80767 (h0 : monoid (plift (option (option (option unsigned))))) : monoid.fg (plift (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_80768 (h0 : uniform_space (semiring (semiring congr_arg_kind))) : separated_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80769 (h0 : ring (dlist (has_nnnorm linarith.comp_source))) : strong_rank_condition (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80770 (h0 : list (with_bot (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80771 (h0 : add_group (add_right_cancel_monoid num)) : is_add_cyclic (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_80772 (h0 : add_group (has_lt (mul_one_class char))) : is_add_cyclic (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_80773 (h0 : functor.add_const (topological_space (comm_semigroup pos)) pos) : @topological_space.separable_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_80774 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_80775 (h0 : filter (linear_ordered_comm_ring congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80776 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80777 (h0 : topological_space (has_pos_part name)) : locally_compact_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_80778 (h1 : set (has_append linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_80779 (h0 : functor.add_const (ring (cancel_monoid name)) (mul_zero_class name)) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) (mul_zero_class.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_80780 (h0 : group (add_comm_monoid (has_neg environment.implicit_infer_kind))) : normalizer_condition (add_comm_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80781 (h0 : topological_space (has_to_string (finset linarith.comp))) : preconnected_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_80782 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @complete_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80783 (h0 : topological_space (boolean_algebra.core (has_neg_part (has_to_string (has_add unsigned))))) : preirreducible_space (boolean_algebra.core (has_neg_part (has_to_string (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_80784 (h0 : monoid (add_cancel_monoid (has_zero Type))) : monoid.fg (add_cancel_monoid (has_zero Type)) := sorry --non-trivial
lemma new_lemma_80785 (h0 : topological_space (semigroup (mul_one_class environment.implicit_infer_kind))) : topological_space.separable_space (semigroup (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80786 (h0 : topological_space (has_append char)) : totally_disconnected_space (has_append char) := sorry --non-trivial
lemma new_lemma_80787 (h0 : functor.comp add_group cancel_monoid name) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_80788 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_80789 (h0 : functor.add_const (complete_lattice (ring unsigned)) linarith.comp) : @is_atomistic.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80790 (h0 : ring (mul_one_class (mul_one_class string.iterator_imp))) : is_domain (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_80791 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @normal_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_80792 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80793 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @irreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_80794 (h0 : functor.add_const (ordered_add_comm_monoid (has_inter empty)) unsigned) : @archimedean.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80795 (h0 : fin has_zero.zero) (h1 : ulower pnat) : pnat.coprime (id (matrix.vec_empty h0)) (ulower.up h1) := sorry --non-trivial
lemma new_lemma_80796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_80797 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80798 (h0 : prod (add_cancel_monoid congr_arg_kind) (add_cancel_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_80799 (h0 : group (comm_group (has_neg_part (has_neg_part (option (option pos)))))) : is_cyclic (comm_group (has_neg_part (has_neg_part (option (option pos))))) := sorry --non-trivial
lemma new_lemma_80800 (h0 : functor.add_const (list (generalized_boolean_algebra name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80801 (h0 : ring (has_nnnorm (mul_one_class string.iterator_imp))) : strong_rank_condition (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_80802 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_80803 (h0 : topological_space (ring (option (option (option ennreal))))) : totally_separated_space (ring (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_80804 (h0 : function.extfun Type group) : @normalizer_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type group.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_80805 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_80806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_80807 (h0 : ring (finset (has_neg Type))) : rank_condition (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_80808 (h0 : functor.add_const (ring (semigroup unsigned)) unsigned) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80809 (h0 : not (uniform_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80810 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : regular_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_80811 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup empty)) empty) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80812 (h0 : add_monoid (with_bot (semiring empty))) : add_monoid.fg (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_80813 (h0 : functor.add_const (finset (ring name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80814 (h0 : topological_space (normed_group (semiring (semiring (semiring empty))))) : preirreducible_space (normed_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_80815 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80816 (h0 : topological_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : t0_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_80817 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) unsigned) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80818 (h0 : not (topological_space nnreal -> false)) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_80819 (h1 : set (mul_zero_class (mul_one_class (mul_one_class enat)) -> add_comm_semigroup enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_80820 (h0 : ring (metric_space (has_nnnorm fun_info))) : rank_condition (metric_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_80821 (h1 : not (complete_lattice (measurable_space congr_arg_kind) -> false)) : is_compactly_generated (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80822 (h1 : uniform_space (random_gen linarith.comp_source)) : complete_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_80823 (h0 : add_group (distrib (has_compl enat))) : is_add_cyclic (distrib (has_compl enat)) := sorry --non-trivial
lemma new_lemma_80824 (h0 : topological_space (comm_ring (has_nnnorm linarith.comp_source))) : totally_disconnected_space (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80825 (h0 h1 : multiset (semi_normed_comm_ring to_additive.value_type)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_80826 (h0 : complete_lattice (semiring (has_top num))) : is_compactly_generated (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_80827 (h1 : set linarith.comp) : set.finite h1 := sorry --non-trivial
lemma new_lemma_80828 (h0 : topological_space (add_comm_monoid (boolean_algebra name))) : path_connected_space (add_comm_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_80829 (h0 : fin has_zero.zero) : @path_connected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_80830 (h0 : topological_space (has_Inf (finset pos))) : normal_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_80831 (h0 : group (measurable_space (semiring unsigned))) : is_cyclic (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_80832 (h0 : topological_space (canonically_ordered_monoid (has_pos_part pos))) : topological_space.separable_space (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_80833 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_80834 (h0 : semiring (linear_ordered_semiring empty)) : is_noetherian_ring (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_80835 (h0 : monoid (has_sub (has_norm (measurable_space.dynkin_system (add_group congr_arg_kind))))) : monoid.fg (has_sub (has_norm (measurable_space.dynkin_system (add_group congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_80836 (h0 : topological_space (has_top (random_gen num))) : totally_separated_space (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_80837 (h1 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80838 (h0 : topological_space (has_ssubset (has_norm (comm_ring fun_info)))) : path_connected_space (has_ssubset (has_norm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_80839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_80840 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80841 (h0 : add_monoid (boolean_algebra (finset pos))) : add_monoid.fg (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_80842 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h0)))) := sorry --non-trivial
lemma new_lemma_80843 (h0 : group (normed_field linarith.comp_source)) : is_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_80844 (h0 : group (add_cancel_monoid (has_neg_part pos))) : is_simple_group (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_80845 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_80846 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_80847 (h0 : topological_space (topological_space fun_info)) : locally_compact_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_80848 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_80849 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen char))))) : totally_disconnected_space (has_ssubset (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_80850 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : t1_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_80851 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80852 (h0 : finset (mul_one_class (semiring (semiring (semiring (semiring (semiring empty))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80853 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @totally_separated_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_80854 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_80855 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) num) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_80856 (h0 : function.extfun Type (functor.add_const (filter pos))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_80857 (h0 : ring (with_bot congr_arg_kind)) : is_principal_ideal_ring (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80858 (h0 : topological_space (has_compl fun_info)) : locally_compact_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_80859 (h0 : list (left_cancel_monoid (semiring (semiring unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80860 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group unsigned)) : archimedean (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_80861 (h0 : filter (has_pos_part real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_80862 (h0 : topological_space (with_one linarith.comp)) : path_connected_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_80863 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) name) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_80864 (h0 : has_mem.mem topological_space has_zero.zero) : @sequential_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_80865 (h0 : topological_space (complete_semilattice_Sup (has_ssubset (has_nnnorm to_additive.value_type)))) : t0_space (complete_semilattice_Sup (has_ssubset (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_80866 (h0 : list (measurable_space (has_top (with_bot string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80867 (h1 : ring (with_one linarith.ineq)) : is_domain (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_80868 (h0 : not (topological_space (semi_normed_comm_ring fun_info) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80869 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) num) : @normal_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_80870 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_80871 (h0 : group (id congr_arg_kind)) : normalizer_condition (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80872 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80873 (h0 : ordered_add_comm_monoid (comm_semigroup (has_bot (has_neg (has_bot pos))))) : archimedean (comm_semigroup (has_bot (has_neg (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_80874 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @irreducible_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80875 (h0 : topological_space (finset (boolean_algebra.core (has_add Type)))) : irreducible_space (finset (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_80876 (h0 : topological_space (comm_group (option (option (comm_group name))))) : preconnected_space (comm_group (option (option (comm_group name)))) := sorry --non-trivial
lemma new_lemma_80877 (h0 : topological_space (has_norm (has_norm fun_info))) : irreducible_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_80878 (h0 : topological_space (ring num)) : totally_disconnected_space (ring num) := sorry --non-trivial
lemma new_lemma_80879 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80880 (h0 : has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_80881 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) empty) : @is_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80882 (h0 : uniform_space (simple_graph (has_nnnorm char))) : complete_space (simple_graph (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_80883 (h0 : ring (distrib (comm_ring char))) : is_domain (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_80884 (h0 : ordered_add_comm_monoid (has_bot (option (option (option (option (option (option empty)))))))) : archimedean (has_bot (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_80885 (h0 : monoid (ordered_comm_monoid pos)) : monoid.fg (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_80886 (h0 : topological_space (has_to_string (has_to_string name))) : t0_space (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_80887 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80888 (h0 : not (group (has_sub empty) -> false)) : @group.fg.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80889 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80890 (h0 : functor.add_const (topological_space (has_star unsigned)) (semiring num)) : @t1_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_80891 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_80892 (h0 : functor.add_const (ring (ring linarith.comp)) (mul_one_class (has_pos_part pos))) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (mul_one_class.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_80893 (h0 : ring (has_to_string (ring (boolean_algebra.core pos)))) : is_domain (has_to_string (ring (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_80894 (h0 : group (complete_distrib_lattice (has_add linarith.comp))) : is_cyclic (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_80895 (h0 : pseudo_metric_space ennreal -> pseudo_metric_space ennreal -> Prop) : is_symm (pseudo_metric_space ennreal) h0 := sorry --non-trivial
lemma new_lemma_80896 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_80897 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) linarith.comp) : @is_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80898 (h0 : complete_lattice (has_nnnorm linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_80899 (h1 : ring (add_comm_semigroup (random_gen (pseudo_metric_space string.iterator_imp)))) : is_domain (add_comm_semigroup (random_gen (pseudo_metric_space string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_80900 (h0 : topological_space (has_nndist (ring ennreal))) : preconnected_space (has_nndist (ring ennreal)) := sorry --non-trivial
lemma new_lemma_80901 (h0 : monoid (bin_tree congr_arg_kind)) : monoid.fg (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_80902 (h0 : monoid (has_well_founded ennreal)) : monoid.fg (has_well_founded ennreal) := sorry --non-trivial
lemma new_lemma_80903 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) (h1 : preorder (semi_normed_comm_ring to_additive.value_type)) : order_closed_topology (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_80904 (h1 : topological_space (mul_one_class char)) (h2 : add_group (mul_one_class char)) : topological_add_group (mul_one_class char) := sorry --non-trivial
lemma new_lemma_80905 (h0 : ring (boolean_algebra.core (boolean_algebra.core (boolean_algebra name)))) : is_principal_ideal_ring (boolean_algebra.core (boolean_algebra.core (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_80906 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : totally_disconnected_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80907 (h0 : complete_lattice (preorder unsigned)) : is_atomistic (preorder unsigned) := sorry --non-trivial
lemma new_lemma_80908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_80909 (h1 : not (ring (measurable_space unsigned) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} unsigned)) h1)  := sorry --non-trivial
lemma new_lemma_80910 (h0 : not (group (has_emptyc linarith.comp_source) -> false)) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_80911 (h0 : topological_space (with_bot (has_norm fun_info))) : t0_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_80912 (h0 : functor.add_const (complete_lattice (emetric_space name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (emetric_space.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (emetric_space.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_80913 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @normal_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80914 (h0 : topological_space (complete_linear_order (option unsigned))) : topological_space.separable_space (complete_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_80915 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_80916 (h0 : ring (with_bot (random_gen num))) : strong_rank_condition (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_80917 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm char)))) : t0_space (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_80918 (h0 : set (has_le (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_80919 (h0 : not (ring (has_lt char) -> false)) : @is_domain.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_80920 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_80921 (h0 : group (finset num)) : normalizer_condition (finset num) := sorry --non-trivial
lemma new_lemma_80922 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80923 (h0 : complete_lattice (has_neg_part (comm_group (comm_group (comm_group Type))))) : is_atomistic (has_neg_part (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_80924 (h0 : topological_space (with_one linarith.comp)) : locally_compact_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_80925 (h0 : group (add_right_cancel_monoid empty)) : normalizer_condition (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_80926 (h0 : uniform_space (normed_comm_ring (add_comm_monoid Type))) : separated_space (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_80927 (h0 : not (topological_space (semiring linarith.comp) -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_80928 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_80929 (h0 : topological_space (has_nndist linarith.comp)) : regular_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_80930 (h0 : ring (comm_ring (mul_one_class char))) : strong_rank_condition (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_80931 (h0 : topological_space (boolean_algebra (has_Inf name))) : sequential_space (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_80932 (h0 : topological_space real) : t1_space real := sorry --non-trivial
lemma new_lemma_80933 (h0 : topological_space (denumerable (has_ssubset fun_info))) : totally_disconnected_space (denumerable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_80934 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80935 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_80936 (h1 : topological_space (has_emptyc (has_norm fun_info))) : totally_separated_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_80937 (h0 : complete_lattice (has_nndist (has_add name))) : is_atomistic (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_80938 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @t1_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_80939 (h0 : not (topological_space (linear_ordered_semiring fun_info) -> false)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_80940 (h0 : fin has_zero.zero) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_80941 (h0 : group (has_to_string (comm_group unsigned))) : group.fg (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_80942 (h0 : list (boolean_algebra (has_add (has_add linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80943 (h0 : complete_lattice (ordered_comm_ring (has_bot Type))) : is_atomistic (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_80944 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_80945 (h0 : functor.add_const (group (has_zero Type)) (has_neg linarith.comp)) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_80946 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_80947 (h0 : functor.add_const (function.extfun Type finset) (finset linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_80948 (h0 : topological_space (has_Inf (sub_neg_monoid (sub_neg_monoid real)))) : regular_space (has_Inf (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_80949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_80950 (h0 : group (comm_monoid (option (option (option empty))))) : normalizer_condition (comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_80951 (h1 : group congr_arg_kind) : normalizer_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_80952 (h0 : has_lt (has_ssubset (normed_field char))) : no_max_order (has_ssubset (normed_field char)) := sorry --non-trivial
lemma new_lemma_80953 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) linarith.comp) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80954 (h0 : functor.add_const (ring (bin_tree unsigned)) unsigned) : @rank_condition.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_80956 (h1 : not (ring (comm_ring linarith.comp_source) -> false)) : @is_domain.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_80957 (h0 : functor.add_const (uniform_space (cancel_monoid linarith.comp)) linarith.comp) : @separated_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_80958 (h0 : not (uniform_space (normed_field string.iterator_imp) -> false)) : @complete_space.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_80959 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_80960 (h0 : complete_lattice (has_append (comm_ring (denumerable to_additive.value_type)))) : is_compactly_generated (has_append (comm_ring (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_80961 (h0 : filter (ring (has_neg_part pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_80962 (h0 : not (complete_lattice (comm_group congr_arg_kind) -> false)) : @is_compactly_generated.{0} (comm_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_80963 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_80964 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80965 (h0 : functor.add_const (ordered_add_comm_monoid (ring name)) (has_nndist pos)) : @archimedean.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} name)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_80966 (h0 : ordered_comm_monoid (has_pos_part pos)) : has_exists_mul_of_le (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_80967 (h0 : topological_space (semi_normed_ring (mul_one_class reducibility_hints))) : t0_space (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_80968 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : irreducible_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_80969 (h0 : functor.add_const (ring (cancel_monoid unsigned)) unsigned) : @strong_rank_condition.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_80970 (h0 : add_monoid (ring (finset pos))) : add_monoid.fg (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_80971 (h1 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (topological_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_80972 (h0 : functor.add_const (add_group (finset environment.implicit_infer_kind)) ennreal) : @is_add_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_80973 (h0 : uniform_space (linear_ordered_comm_group ennreal)) : separated_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_80974 (h0 : functor.add_const (complete_lattice (has_edist empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80975 (h0 : list (semi_normed_comm_ring (has_nnnorm (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_80976 (h0 : uniform_space (has_nnnorm (linear_ordered_field (has_nnnorm linarith.ineq)))) : complete_space (has_nnnorm (linear_ordered_field (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_80977 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_80978 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_80979 (h0 : add_group (has_nnnorm pos)) : is_add_cyclic (has_nnnorm pos) := sorry --non-trivial
lemma new_lemma_80980 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_80981 (h0 : finset (ring linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_80982 (h0 : group (with_bot (comm_ring to_additive.value_type))) : is_cyclic (with_bot (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_80983 (h1 : ring (add_zero_class (has_inv linarith.comp_source))) : is_domain (add_zero_class (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_80984 (h0 : std_gen -> string_imp) (h1 : string_imp -> std_gen) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_80985 (h0 : not (topological_space (has_norm linarith.ineq) -> false)) : @locally_compact_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_80986 (h0 : not (list (measurable_space linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_80987 (h0 : ring (has_neg_part (finset ennreal))) : strong_rank_condition (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_80988 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_80989 (h0 : uniform_space complex) : separated_space complex := sorry --non-trivial
lemma new_lemma_80990 (h0 : fin has_zero.zero) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_80991 (h0 : functor.add_const Prop (ordered_comm_monoid linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_80992 (h0 : monoid (semigroup (semiring (option unsigned)))) : monoid.fg (semigroup (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_80993 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system unsigned)) : unique_factorization_monoid (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_80994 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_80995 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid empty)) empty) : @unique_factorization_monoid.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_80996 (h0 : topological_space (complete_distrib_lattice unsigned)) : totally_disconnected_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_80997 (h0 : topological_space (linear_ordered_comm_group (option empty))) : totally_disconnected_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_80998 (h0 : functor.add_const (list (has_zero pos)) (ring (finset linarith.comp))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_80999 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81000 (h0 : function.extfun Type measurable_space) (h1 : function.extfun (finset Type) (has_mem.mem to_additive.value_type)) : @has_measurable_sub₂.{0} to_additive.value_type (@function.extfun_app.{2 1} Type measurable_space.{0} h0 to_additive.value_type) (@finset.pi.empty.{1 0} Type has_sub.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_81001 (h0 : add_group (has_lt (mul_one_class string_imp))) : is_add_cyclic (has_lt (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_81002 (h0 : complete_lattice (denumerable (has_nnnorm linarith.comp_source))) : is_compactly_generated (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_81003 (h0 : topological_space (has_neg (has_to_string (has_to_string (has_to_string pos))))) : totally_disconnected_space (has_neg (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_81004 (h0 : topological_space (pseudo_metric_space (has_to_string (has_to_string ennreal)))) : t1_space (pseudo_metric_space (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_81005 (h0 : functor.add_const (measurable_space (mul_zero_class ennreal)) ennreal) (h1 : has_div (mul_zero_class ennreal)) : @has_measurable_div₂.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (measurable_space.{0} (mul_zero_class.{0} ennreal)) ennreal h0) h1  := sorry --non-trivial
lemma new_lemma_81006 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_81007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (preorder unsigned)) := sorry --non-trivial
lemma new_lemma_81008 (h0 : ordered_comm_monoid (has_neg (option pos))) : has_exists_mul_of_le (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_81009 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81010 (h0 : complete_lattice (ordered_ring (semiring empty))) : is_atomistic (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_81011 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81012 (h0 : topological_space (has_bot (has_neg (has_neg pos)))) : normal_space (has_bot (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_81013 (h0 : topological_space (monoid empty)) : normal_space (monoid empty) := sorry --non-trivial
lemma new_lemma_81014 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) Type) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_81015 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_81016 (h0 : not (group (random_gen unsigned) -> false)) : @group.fg.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81017 (h0 : topological_space (has_nndist (canonically_linear_ordered_monoid ennreal))) : t1_space (has_nndist (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_81018 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_81019 (h0 : prod (add_right_cancel_monoid (has_top (semiring num))) (add_right_cancel_monoid (has_top (semiring num)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_81020 (h0 : complete_lattice (has_norm (has_norm (has_norm (has_norm (has_norm fun_info)))))) : is_compactly_generated (has_norm (has_norm (has_norm (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_81021 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_81022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81023 (h0 : complete_lattice (has_lt (has_ssubset linarith.ineq))) : is_compactly_generated (has_lt (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81024 (h1 : topological_space (add_left_cancel_monoid (with_zero to_additive.value_type))) : path_connected_space (add_left_cancel_monoid (with_zero to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81025 (h0 : ring (with_one (has_ssubset to_additive.value_type))) : strong_rank_condition (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81026 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) (has_nndist pos)) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_81027 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81028 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} (random_gen.{0} char)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} (random_gen.{0} char)))  := sorry --non-trivial
lemma new_lemma_81029 (h1 : topological_space (has_top congr_arg_kind)) : locally_compact_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81030 (h0 : topological_space (with_bot (has_norm (has_norm linarith.comp)))) : normal_space (with_bot (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_81031 (h0 : measurable_space char) (h1 : measure_theory.measure char) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_81032 (h0 : topological_space (canonically_ordered_monoid (has_add (simple_graph linarith.comp)))) : totally_disconnected_space (canonically_ordered_monoid (has_add (simple_graph linarith.comp))) := sorry --non-trivial
lemma new_lemma_81033 (h0 : topological_space (linear_ordered_comm_group pos)) : t0_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_81034 (h0 : uniform_space (has_neg (has_to_string pos))) : separated_space (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_81035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_81036 (h0 : group (boolean_algebra.core empty)) : normalizer_condition (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_81037 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81038 (h1 : topological_space (has_emptyc congr_arg_kind)) : locally_compact_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81039 (h0 : complete_lattice (has_bot (has_Inf (has_pos_part (has_Inf (has_Inf Type)))))) : is_compactly_generated (has_bot (has_Inf (has_pos_part (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_81040 (h0 : list (has_to_string (ring (mul_one_class linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_81041 (h0 : group (normed_group to_additive.value_type)) : normalizer_condition (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81042 (h0 : topological_space (add_comm_monoid (has_add Type))) : totally_separated_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_81043 (h0 : functor.add_const (ordered_comm_monoid ennreal) pos) : @has_exists_mul_of_le.{0} ennreal (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} ennreal) pos h0)  := sorry --non-trivial
lemma new_lemma_81044 (h0 : topological_space (comm_ring (random_gen (has_ssubset (has_top linarith.comp_source))))) : t0_space (comm_ring (random_gen (has_ssubset (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_81045 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : totally_separated_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_81046 (h0 : add_monoid (mul_zero_class (has_nndist ennreal))) : add_monoid.fg (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_81047 (h0 : ring (ordered_comm_group num)) : rank_condition (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_81048 (h0 : topological_space (monoid_with_zero pos)) : sequential_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_81049 (h0 : group (left_cancel_monoid (semiring empty))) : normalizer_condition (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_81050 (h0 : filter (linear_ordered_comm_group (option (option (option ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81051 (h0 : uniform_space (has_Inf (finset pos))) : separated_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_81052 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_81053 (h0 : list (add_semigroup congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81054 (h0 : uniform_space (comm_monoid congr_arg_kind)) : complete_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81055 (h2 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : path_connected_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81056 (h0 : function.extfun Type group) : @is_simple_group.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_81057 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : normal_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_81058 (h0 : list (has_neg (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81059 (h0 : ring (has_add (ring Type))) : rank_condition (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_81060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_81061 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_81062 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81063 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_81064 (h0 : not (topological_space (complete_semilattice_Sup string_imp) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_81065 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option pos))) : separated_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_81066 (h0 : functor.add_const (finset (has_neg pos)) (has_add linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81067 (h0 : topological_space (semigroup (finset pos))) : topological_space.separable_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_81068 (h0 : add_group (normed_group (comm_ring fun_info))) : is_add_cyclic (normed_group (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_81069 (h0 : topological_space (finset (finset linarith.comp))) : regular_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_81070 (h0 : ring (finset (mul_one_class (has_neg environment.implicit_infer_kind)))) : is_domain (finset (mul_one_class (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_81071 (h0 : topological_space (boolean_algebra (has_to_string (has_add pos)))) : preconnected_space (boolean_algebra (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_81072 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_81073 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group (option empty))) : archimedean (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_81074 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset Type)) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81075 (h0 : ring (boolean_algebra (ring linarith.comp))) : is_domain (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81076 (h0 : has_lt (non_unital_non_assoc_semiring linarith.comp_source)) : no_max_order (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81077 (h0 : group (with_one (has_nnnorm (has_nnnorm (has_nnnorm (has_top to_additive.value_type)))))) : group.fg (with_one (has_nnnorm (has_nnnorm (has_nnnorm (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_81078 (h0 : topological_space (comm_semigroup name)) : sequential_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_81079 (h0 : complete_lattice (has_add (has_nnnorm linarith.ineq))) : is_compactly_generated (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81080 (h0 : with_bot (ulower Prop)) (h1 : ne h0 has_bot.bot) : @ulower.up.{0} Prop encodable.Prop (@with_bot.unbot.{0} (@ulower.{0} Prop encodable.Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_81081 (h0 : functor.add_const (group (ring pos)) unsigned) : @is_simple_group.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81082 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_81083 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)) empty) : @is_atomistic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_81084 (h0 : not (complete_lattice (measurable_space fun_info) -> false)) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_81085 (h0 : topological_space (fintype (has_nnnorm (random_gen (has_nnnorm fun_info))))) : totally_disconnected_space (fintype (has_nnnorm (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_81086 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81087 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_81088 (h0 : finset (plift empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81089 (h0 : topological_space (has_to_string empty)) : totally_separated_space (has_to_string empty) := sorry --non-trivial
lemma new_lemma_81090 (h0 : topological_space (comm_group (mul_zero_class Type))) : path_connected_space (comm_group (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_81091 (h0 : functor.add_const (group (has_Inf Type)) pos) : @normalizer_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_81092 (h0 : functor.comp topological_space boolean_algebra name) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_81093 (h0 : group (simple_graph (finset (has_neg linarith.comp)))) : is_cyclic (simple_graph (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_81094 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) (semiring num)) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_81095 (h0 : semiring (with_bot (semiring linarith.comp))) : is_noetherian_ring (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81096 (h0 : function.extfun Type ring) : @is_domain.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81097 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_81098 (h0 : ring (has_pos_part (has_neg (has_add pos)))) : is_principal_ideal_ring (has_pos_part (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_81099 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81100 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_81101 (h0 : topological_space (ordered_comm_monoid (has_add name))) : path_connected_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_81102 (h0 : group (canonically_ordered_comm_semiring pos)) : is_simple_group (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_81103 (h0 : finset (has_Inf (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81104 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_81105 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @preconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_81106 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) pos) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_81107 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : preconnected_space (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_81108 (h0 : not (ring (has_lt (mul_one_class string_imp)) -> false)) : @rank_condition.{0} (has_lt.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_81109 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) congr_arg_kind) : @preirreducible_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81110 (h0 : ring (denumerable (random_gen (random_gen (random_gen char))))) : rank_condition (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_81111 (h0 : functor.comp topological_space boolean_algebra.core name) : @normal_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_81112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81113 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) Type) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_81114 (h0 : ring (has_union char)) : is_domain (has_union char) := sorry --non-trivial
lemma new_lemma_81115 (h0 : not (monoid (random_gen linarith.comp) -> false)) : @monoid.fg.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_81116 (h0 : complete_lattice (has_Sup congr_arg_kind)) : is_compactly_generated (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81117 (h0 : char -> char -> Prop) (h1 : prod char char) : function.uncurry h0 h1 := sorry --non-trivial
lemma new_lemma_81118 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_81119 (h0 : ring (mul_one_class to_additive.value_type)) : strong_rank_condition (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81120 (h0 : topological_space (has_nndist (ring (has_neg (boolean_algebra (has_neg Type)))))) : t0_space (has_nndist (ring (has_neg (boolean_algebra (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_81121 (h0 : ring (has_to_string (has_neg Type))) : is_principal_ideal_ring (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_81122 (h0 : functor.add_const (ring (finset linarith.comp)) linarith.comp) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81123 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81124 (h0 : topological_space (has_add (option unsigned))) : totally_separated_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_81125 (h0 : topological_space (has_star (semiring (semiring num)))) : topological_space.separable_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_81126 (h0 : ring (has_add linarith.comp_source)) : is_domain (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81127 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @normal_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_81128 (h0 : ring (distrib (comm_ring char))) : rank_condition (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_81129 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_81130 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_81131 (h0 : ring (finset ennreal)) : rank_condition (finset ennreal) := sorry --non-trivial
lemma new_lemma_81132 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring congr_arg_kind)) : @t0_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_81133 (h0 : ring (with_one (has_norm num))) : is_domain (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_81134 (h0 : group (ring (ring (has_neg linarith.comp)))) : is_cyclic (ring (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_81135 (h0 : list (boolean_algebra.core (complete_distrib_lattice pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81136 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part Type)) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{1} Type) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_81137 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : totally_disconnected_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_81138 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @t0_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_81139 (h0 : ring (normed_group (has_top (has_top (has_norm linarith.ineq))))) : is_domain (normed_group (has_top (has_top (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_81140 (h0 : add_group (denumerable (has_inv linarith.ineq))) : is_add_cyclic (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81141 (h0 : function.extfun Type ordered_add_comm_monoid) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_81142 (h0 : cancel_comm_monoid_with_zero (semigroup pos)) : unique_factorization_monoid (semigroup pos) := sorry --non-trivial
lemma new_lemma_81143 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (boolean_algebra (has_add name))) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (boolean_algebra.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_81144 (h0 : ring (has_Inf pos)) : strong_rank_condition (has_Inf pos) := sorry --non-trivial
lemma new_lemma_81145 (h0 h3 : multiset ereal) : multiset.le h0 h3 := sorry --non-trivial
lemma new_lemma_81146 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) (normed_comm_ring name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81147 (h1 : complete_lattice (semi_normed_ring char)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_81148 (h0 : list (has_Inf (has_pos_part linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81149 (h0 : functor.add_const (topological_space nnreal) num) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_81150 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) linarith.comp) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81151 (h0 : functor.add_const (uniform_space (has_zero pos)) (finset environment.implicit_infer_kind)) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_81152 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_81153 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option ennreal)))) : is_atomistic (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_81154 (h0 : group (with_bot (random_gen linarith.ineq))) : group.fg (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81155 (h0 : semiring (has_zero name)) : is_noetherian_ring (has_zero name) := sorry --non-trivial
lemma new_lemma_81156 (h2 : add_group (add_right_cancel_monoid char)) : is_add_cyclic (add_right_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_81157 (h1 : topological_space string.iterator_imp) : t0_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_81158 (h0 : ring (has_one (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (has_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_81159 (h0 : not (topological_space (normed_field linarith.comp_source) -> false)) : @t0_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_81160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81161 (h0 : uniform_space (finset unsigned)) : separated_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_81162 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81163 (h0 : topological_space (has_emptyc (has_top (has_top (has_top (has_top fun_info)))))) : locally_compact_space (has_emptyc (has_top (has_top (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_81164 (h0 : complete_lattice (with_bot (random_gen linarith.comp_source))) : is_atomistic (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_81165 (h0 : topological_space (simple_graph (has_neg pos))) : topological_space.separable_space (simple_graph (has_neg pos)) := sorry --non-trivial
lemma new_lemma_81166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81167 (h0 : empty) (h1 : list pnat) (h2 : pnat) (h3 : list pnat) : pnat.coprime (list.ilast' (empty.elim h0) h1) (list.ilast' h2 h3) := sorry --non-trivial
lemma new_lemma_81168 (h1 : topological_space (normed_field (mul_one_class environment.projection_info))) : totally_disconnected_space (normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_81169 (h0 : complete_lattice (comm_ring (dlist (has_ssubset fun_info)))) : is_compactly_generated (comm_ring (dlist (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_81170 (h0 : group (option (option ennreal))) : group.fg (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_81171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_81172 (h0 : functor.add_const (topological_space nnreal) empty) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_81173 (h0 : not (functor.add_const Prop unsigned -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_81174 (h0 : functor.add_const (ring (semigroup pos)) (has_neg linarith.comp)) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_81175 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81176 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t1_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_81177 (h0 : topological_space (with_one linarith.comp_source)) : irreducible_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81178 (h1 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81179 (h0 : topological_space (has_zero (normed_comm_ring linarith.comp))) : normal_space (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81180 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81181 (h0 : topological_space (boolean_algebra.core (finset Type))) : totally_disconnected_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_81182 (h0 : ring (nondiscrete_normed_field reducibility_hints)) : rank_condition (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_81183 (h0 : list (mul_zero_class (semigroup Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81184 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_81185 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81186 (h0 : functor.add_const (measurable_space (has_to_string linarith.comp)) Type) (h1 : has_add (has_to_string linarith.comp)) : @has_measurable_add.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (measurable_space.{0} (has_to_string.{0} linarith.comp)) Type h0) h1  := sorry --non-trivial
lemma new_lemma_81187 (h0 : ring (mul_zero_class empty)) : is_domain (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_81188 (h0 : functor.add_const (monoid (has_Inf Type)) linarith.comp) : @monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81189 (h0 : topological_space (encodable (has_nnnorm (random_gen (has_nnnorm to_additive.value_type))))) : totally_disconnected_space (encodable (has_nnnorm (random_gen (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_81190 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_81191 (h2 : group (fintype to_additive.value_type)) : is_cyclic (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81192 (h0 : ring (has_nnnorm (random_gen (random_gen char)))) : strong_rank_condition (has_nnnorm (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_81193 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg (has_neg (has_neg Type)))) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_81194 (h2 : complete_lattice num) : is_atomistic num := sorry --non-trivial
lemma new_lemma_81195 (h0 : functor.add_const (add_group (has_zero name)) (has_add name)) : @is_add_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_81196 (h0 : complete_lattice (has_add (has_bot pos))) : is_compactly_generated (has_add (has_bot pos)) := sorry --non-trivial
lemma new_lemma_81197 (h0 : prod (has_top (semiring unsigned)) (has_top (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_81198 (h0 h1 : ereal -> ereal -> ereal) : left_distributive h0 h1 := sorry --non-trivial
lemma new_lemma_81199 (h0 : add_monoid (canonically_ordered_comm_semiring linarith.comp)) : add_monoid.fg (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_81200 (h0 : uniform_space (boolean_algebra (has_pos_part pos))) : complete_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_81201 (h0 : topological_space (with_bot (random_gen to_additive.value_type))) : totally_disconnected_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81202 (h0 : functor.add_const (group (ring linarith.comp)) linarith.comp) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81203 (h0 : complete_lattice (boolean_algebra (boolean_algebra.core (add_cancel_monoid Type)))) : is_atomistic (boolean_algebra (boolean_algebra.core (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_81204 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) linarith.comp) : @separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81205 (h0 : filter (fintype (add_monoid to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81206 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : preirreducible_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_81207 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : t1_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81208 (h0 : not (ring (complete_linear_order num) -> false)) : @strong_rank_condition.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_81209 (h0 : topological_space (semigroup (option (option ennreal)))) : t0_space (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_81210 (h0 : group (comm_ring (mul_one_class (mul_one_class to_additive.value_type)))) : is_cyclic (comm_ring (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_81211 (h0 : topological_space (finset (add_comm_monoid unsigned))) : preirreducible_space (finset (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_81212 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81213 (h0 : topological_space (with_one (random_gen (random_gen fun_info)))) : locally_compact_space (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_81214 (h0 : functor.comp topological_space has_to_string linarith.comp) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81215 (h0 h1 : set char) (h2 : char) : set.diff h0 h1 h2 := sorry --non-trivial
lemma new_lemma_81216 (h0 : function.extfun Type (functor.comp topological_space canonically_linear_ordered_monoid)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_81217 (h0 : function.extfun (finset Type) (has_mem.mem to_additive.value_type)) : @discrete_topology.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_81218 (h0 : has_div reducibility_hints -> has_div reducibility_hints -> real) (h1 : forall (x : has_div reducibility_hints), eq (h0 x x) has_zero.zero) (h2 : forall (x y : has_div reducibility_hints), eq (h0 x y) (h0 y x)) (h3 : forall (x y z : has_div reducibility_hints), has_le.le (h0 x z) (has_add.add (h0 x y) (h0 y z))) : @complete_space.{0} (has_div.{0} reducibility_hints) (@uniform_space_of_dist.{0} (has_div.{0} reducibility_hints) h0 h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_81219 (h0 : ring (random_gen (has_nnnorm (denumerable reducibility_hints)))) : strong_rank_condition (random_gen (has_nnnorm (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_81220 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_81221 (h0 : topological_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : irreducible_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_81222 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81223 (h0 : group (has_neg (has_add (has_to_string pos)))) : normalizer_condition (has_neg (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_81224 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81225 (h0 : group (sub_neg_monoid (has_add pos))) : is_simple_group (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_81226 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : preconnected_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_81227 (h0 : has_sub (has_one unsigned) -> has_sub (has_one unsigned) -> Prop) : is_equiv (has_sub (has_one unsigned)) h0 := sorry --non-trivial
lemma new_lemma_81228 (h0 : function.extfun Type (functor.add_const (ring pos))) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_81229 (h0 : list (linear_ordered_add_comm_group num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81230 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @irreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_81231 (h0 : topological_space (mul_zero_class (has_add Type))) : normal_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_81232 (h0 : topological_space (is_R_or_C congr_arg_kind)) : topological_space.separable_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81233 (h0 : complete_lattice (linear_ordered_semiring (random_gen num))) : is_compactly_generated (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_81234 (h0 : topological_space (nondiscrete_normed_field (mul_one_class (mul_one_class environment.projection_info)))) : t0_space (nondiscrete_normed_field (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_81235 (h0 : topological_space (has_ssubset (has_ssubset string.iterator_imp))) : totally_disconnected_space (has_ssubset (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_81236 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_81237 (h0 : function.extfun Type (functor.comp ring cancel_monoid)) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_81238 (h0 : complete_lattice (has_neg (has_add name))) : complete_lattice.is_Sup_finite_compact (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_81239 (h0 : topological_space (option unsigned) -> Prop) (h1 : Exists (fun (x : topological_space (option unsigned)), h0 x)) : @totally_separated_space.{0} (option.{0} unsigned) (@classical.some.{1} (topological_space.{0} (option.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_81240 (h0 : add_group (has_inv (denumerable (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (has_inv (denumerable (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_81241 (h0 : complete_lattice (has_nnnorm (has_nnnorm fun_info))) : is_compactly_generated (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_81242 (h0 : has_le enat) (h1 : enat) : is_bot h1 := sorry --non-trivial
lemma new_lemma_81243 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) empty) : @preirreducible_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_81244 (h0 : function.extfun (set string_imp) (fun (x : set string_imp), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_81245 (h0 : ordered_add_comm_monoid (measurable_space.dynkin_system num)) : archimedean (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_81246 (h0 : functor.add_const (semiring (finset pos)) Type) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_81247 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81248 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81249 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_81250 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core pos))) : normal_space (add_cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_81251 (h1 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81252 (h0 : uniform_space (canonically_ordered_add_monoid unsigned)) : separated_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_81253 (h0 : functor.add_const (monoid (complete_distrib_lattice real)) real) : @monoid.fg.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_81254 (h0 : group (measurable_space (semiring num))) : normalizer_condition (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_81255 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_81256 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add name))) : unique_factorization_monoid (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_81257 (h0 : not (complete_lattice (random_gen fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_81258 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (id unsigned)) := sorry --non-trivial
lemma new_lemma_81259 (h0 : topological_space (has_add Type)) : discrete_topology (has_add Type) := sorry --non-trivial
lemma new_lemma_81260 (h0 : ring (has_compl (has_nnnorm fun_info))) : strong_rank_condition (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_81261 (h1 : ring (has_le (distrib (uniform_space linarith.ineq)))) : rank_condition (has_le (distrib (uniform_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_81262 (h0 : fin has_zero.zero) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_81263 (h0 : functor.add_const Prop (generalized_boolean_algebra real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_81264 (h1 : ring (normed_field (comm_ring (comm_ring char)))) : rank_condition (normed_field (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_81265 (h0 : topological_space (has_pos_part (has_add (sub_neg_monoid (has_neg (has_bot real)))))) : regular_space (has_pos_part (has_add (sub_neg_monoid (has_neg (has_bot real))))) := sorry --non-trivial
lemma new_lemma_81266 (h1 : add_group (normed_field to_additive.value_type)) : is_add_cyclic (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81267 (h0 : complete_lattice (measurable_space (has_top fun_info))) : is_compactly_generated (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_81268 (h0 : functor.add_const (add_monoid (boolean_algebra linarith.comp)) (finset (has_neg pos))) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81269 (h0 : uniform_space (comm_group (has_neg_part pos))) : complete_space (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_81270 (h0 : semiring (ordered_comm_ring (finset name))) : is_noetherian_ring (ordered_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_81271 (h4 : topological_space (comm_ring (random_gen (random_gen (random_gen char))))) : totally_disconnected_space (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_81272 (h0 : complete_lattice (sub_neg_monoid linarith.comp)) : is_compactly_generated (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_81273 (h0 : topological_space (with_one (has_ssubset (has_nnnorm linarith.comp_source)))) : path_connected_space (with_one (has_ssubset (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_81274 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_81275 (h0 : uniform_space (normed_comm_ring (option (option (option ennreal))))) : separated_space (normed_comm_ring (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_81276 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_81277 (h0 : complete_lattice (semiring to_additive.value_type)) : is_atomistic (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81278 (h2 : topological_space (add_comm_semigroup std_gen)) : topological_space.first_countable_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_81279 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_81280 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81281 (h0 : semiring (generalized_boolean_algebra (has_add name))) : is_noetherian_ring (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_81282 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : t0_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_81283 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra Type)) (ring Type)) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81284 (h0 : ring (add_left_cancel_monoid (has_nnnorm fun_info))) : is_domain (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_81285 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_81286 (h0 : complete_lattice (metric_space unsigned)) : complete_lattice.is_Sup_finite_compact (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_81287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_81288 (h0 : functor.add_const (filter (add_semigroup unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81289 (h0 : ordered_comm_monoid (finset linarith.comp)) : has_exists_mul_of_le (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_81290 (h0 : not (topological_space (add_group unsigned) -> false)) : @normal_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81291 (h0 : functor.add_const (has_mul (has_add Type)) Type) (h1 : functor.add_const (has_add Type) linarith.comp) : @is_right_regular.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (has_mul.{1} (has_add.{1} Type)) Type h0) (@functor.add_const.run.{1 0} (has_add.{1} Type) linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_81292 (h0 : complete_lattice (mul_zero_class (denumerable char))) : is_compactly_generated (mul_zero_class (denumerable char)) := sorry --non-trivial
lemma new_lemma_81293 (h0 : complete_lattice (random_gen (has_inv string_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_81294 (h0 : has_to_string (option (option ennreal)) -> has_to_string (option (option ennreal)) -> Prop) : is_symm (has_to_string (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_81295 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81296 (h0 : topological_space (add_comm_monoid (option (option (option pos))))) : t1_space (add_comm_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_81297 (h0 : group (boolean_algebra (has_add (has_to_string name)))) : group.fg (boolean_algebra (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_81298 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group Type)) (has_add (has_add unsigned))) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (comm_group.{1} Type)) (has_add.{0} (has_add.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81299 (h0 : ring (linear_ordered_semiring (semiring num))) : rank_condition (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_81300 (h0 : group (semiring num)) : normalizer_condition (semiring num) := sorry --non-trivial
lemma new_lemma_81301 (h0 : add_group (random_gen (random_gen string_imp))) : is_add_cyclic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_81302 (h1 : not (monoid (has_norm linarith.comp) -> false)) : @monoid.fg.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_81303 (h0 : list (canonically_ordered_comm_semiring (option (option (option unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_81304 (h0 : ring (semigroup (finset Type))) : is_principal_ideal_ring (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_81305 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81306 (h0 : has_mem.mem (measurable_space unsigned) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_81307 (h0 : topological_space (semigroup (cancel_monoid name))) : t0_space (semigroup (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_81308 (h0 : topological_space (simple_graph (ring linarith.comp))) : locally_compact_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81309 (h0 : filter string_imp) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81310 (h0 : topological_space (has_union (semiring (semiring (semiring unsigned))))) : path_connected_space (has_union (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_81311 (h0 : not (add_monoid (has_norm num) -> false)) : @add_monoid.fg.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_81312 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_81313 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_add real))) : archimedean (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_81314 (h0 : complete_lattice (has_to_string unsigned)) : is_compactly_generated (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_81315 (h0 : semiring (has_add (has_add name))) : is_noetherian_ring (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_81316 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @locally_compact_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81317 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81318 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) (ring pos)) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_add.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_81319 (h0 : ordered_comm_monoid (mul_zero_class (has_add ennreal))) : has_exists_mul_of_le (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_81320 (h0 : functor.add_const (complete_lattice (has_pos_part pos)) pos) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_81321 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81322 (h0 : topological_space (has_norm (comm_ring (comm_ring linarith.ineq)))) : irreducible_space (has_norm (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_81323 (h0 : topological_space (mul_zero_class (has_add pos))) : locally_compact_space (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_81324 (h0 : monoid (has_to_string (mul_one_class (has_neg Type)))) : monoid.fg (has_to_string (mul_one_class (has_neg Type))) := sorry --non-trivial
lemma new_lemma_81325 (h0 : functor.add_const (prod (add_right_cancel_monoid num) (add_right_cancel_monoid num)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81326 (h0 : ring (semigroup (has_to_string unsigned))) : rank_condition (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_81327 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81328 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @totally_separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_81329 (h0 : topological_space (mul_zero_class (option name))) : preirreducible_space (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_81330 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @complete_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_81331 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_81332 (h0 : ring (linear_ordered_comm_ring unsigned)) : rank_condition (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_81333 (h0 : semiring (has_add (finset environment.implicit_infer_kind))) : is_noetherian_ring (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81334 (h0 : topological_space (add_cancel_comm_monoid (random_gen reducibility_hints))) : t0_space (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_81335 (h2 : set (mul_one_class ereal)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_81336 (h0 : finset (linear_ordered_comm_monoid_with_zero unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81337 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.comp_source))) : t0_space (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_81338 (h0 : monoid (canonically_linear_ordered_monoid (has_neg pos))) : monoid.fg (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_81339 (h0 : topological_space (has_bot (has_bot name))) : regular_space (has_bot (has_bot name)) := sorry --non-trivial
lemma new_lemma_81340 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_81341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81342 (h0 : functor.add_const (functor.add_const (uniform_space Type) Type) pos) : @separated_space.{1} Type (@functor.add_const.run.{1 1} (uniform_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (uniform_space.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_81343 (h1 : ring (has_nnnorm (random_gen (random_gen (comm_ring char))))) : rank_condition (has_nnnorm (random_gen (random_gen (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_81344 (h0 : functor.add_const (ring (has_add linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81345 (h0 : functor.comp complete_lattice comm_group name) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_81346 (h1 : topological_space (has_emptyc linarith.comp)) : totally_disconnected_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_81347 (h0 : functor.add_const (list (has_nndist linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81348 (h0 : normed_lattice_add_comm_group fun_info -> normed_lattice_add_comm_group fun_info) (h1 : normed_lattice_add_comm_group fun_info) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_81349 (h0 : uniform_space (normed_comm_ring (has_nndist Type))) : separated_space (normed_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_81350 (h0 : not (ring (simple_graph linarith.ineq) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_81351 (h0 : ordered_comm_monoid (ordered_cancel_add_comm_monoid pos)) : has_exists_mul_of_le (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_81352 (h0 : has_le (random_gen string_imp)) (h1 : bounded_order (random_gen string_imp)) : is_simple_order (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_81353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_81354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_81355 (h0 : function.extfun (Type 1) (functor.comp add_group mul_zero_class)) : @is_add_cyclic.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} mul_zero_class.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} add_group.{1} mul_zero_class.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_81356 (h0 : topological_space (has_zero (has_to_string pos))) : totally_separated_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_81357 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81358 (h0 : monoid (has_top linarith.ineq)) : monoid.fg (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_81359 (h0 : group (mul_zero_class (finset Type))) : group.fg (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_81360 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra name)) unsigned) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81361 (h1 : complete_lattice (has_div (has_lt string_imp))) : is_compactly_generated (has_div (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_81362 (h0 : functor.add_const (ring (add_comm_monoid name)) (has_neg linarith.comp)) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_81363 (h0 : complete_lattice (mul_zero_class congr_arg_kind)) : is_atomistic (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81364 (h0 : not (uniform_space (semiring (has_top linarith.comp_source)) -> false)) : @complete_space.{0} (semiring.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_81365 (h0 : measurable_space to_additive.value_type) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @has_measurable_mul₂.{0} to_additive.value_type h0 (@function.extfun_app.{2 1} Type has_mul.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_mul.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_81366 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_81367 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81368 (h0 : topological_space (has_one unsigned)) : t0_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_81369 (h0 : measurable_space (semigroup environment.implicit_infer_kind)) (h1 : has_div (semigroup environment.implicit_infer_kind)) : has_measurable_div₂ (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_81370 (h0 : functor.comp list has_to_string (option pos)) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_81371 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : loc_path_connected_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_81372 (h0 : group (boolean_algebra.core name)) : normalizer_condition (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_81373 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_81374 (h0 : topological_space (semigroup (has_neg_part name))) : path_connected_space (semigroup (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_81375 (h0 : topological_space (ordered_ring (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)))) : irreducible_space (ordered_ring (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_81376 (h0 : filter (has_neg_part (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81377 (h0 : functor.add_const (function.extfun Type ring) (ring Type)) : @is_domain.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (ring.{1} Type) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81378 (h0 : topological_space (complete_distrib_lattice num)) : regular_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_81379 (h0 : group (random_gen (random_gen (random_gen fun_info)))) : normalizer_condition (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_81380 (h0 : not (uniform_space (complete_linear_order unsigned) -> false)) : @separated_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81381 (h0 : functor.add_const (complete_lattice (ring pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81382 (h0 : functor.add_const (group (has_nndist Type)) Type) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81383 (h0 : uniform_space (boolean_algebra.core (has_pos_part (ring linarith.comp)))) : separated_space (boolean_algebra.core (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_81384 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81385 (h0 : ring (canonically_ordered_add_monoid (option unsigned))) : strong_rank_condition (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_81386 (h0 : functor.add_const (list (has_Inf Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81387 (h0 : topological_space (semigroup (has_add (finset name)))) : preirreducible_space (semigroup (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_81388 (h0 : topological_space (has_one congr_arg_kind)) : normal_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81389 (h0 : topological_space (has_union (semiring num))) : path_connected_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_81390 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_81391 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (finset Type)) : @totally_separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81392 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_81393 (h1 : measurable_space (nondiscrete_normed_field reducibility_hints)) (h2 : filter (nondiscrete_normed_field reducibility_hints)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_81394 (h0 : topological_space (boolean_algebra (comm_group name))) : irreducible_space (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_81395 (h0 : add_group (complete_distrib_lattice (finset linarith.comp))) : is_add_cyclic (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_81396 (h1 : uniform_space (has_ssubset fun_info)) : complete_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_81397 (h0 : complete_lattice (mul_one_class to_additive.value_type)) : is_compactly_generated (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81398 (h0 : add_monoid (ring (ring linarith.comp))) : add_monoid.fg (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81399 (h0 : group (has_inter (option (option ennreal)))) : is_cyclic (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_81400 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_81401 (h0 : not (ring (order_dual congr_arg_kind) -> false)) : @is_domain.{0} (order_dual.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (order_dual.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_81402 (h0 : complete_lattice (semi_normed_ring (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_81403 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81404 (h0 : group (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : is_cyclic (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_81405 (h0 : functor.add_const (topological_space (comm_group ennreal)) pos) : @irreducible_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_81406 (h0 : list (has_to_string ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81407 (h0 : semiring (has_neg (option pos))) : is_noetherian_ring (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_81408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81409 (h0 : topological_space (normed_group congr_arg_kind)) : path_connected_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81410 (h0 : functor.add_const (ring (free_add_monoid unsigned)) congr_arg_kind) : @is_domain.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81411 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81412 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) Type) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81414 (h0 : complete_lattice (has_add (has_add (has_pos_part (has_add Type))))) : is_atomistic (has_add (has_add (has_pos_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_81415 (h0 : function.extfun Type has_le) : @no_bot_order.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type has_le.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81416 (h0 : complete_lattice (metric_space empty)) : is_atomistic (metric_space empty) := sorry --non-trivial
lemma new_lemma_81417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_81418 (h0 : ring (normed_comm_ring (option ennreal))) : rank_condition (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_81419 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81420 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option (has_well_founded name)))) : archimedean (add_cancel_monoid (option (has_well_founded name))) := sorry --non-trivial
lemma new_lemma_81421 (h0 : not (uniform_space (random_gen fun_info) -> false)) : @complete_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_81422 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add (has_add Type))))) : totally_separated_space (canonically_ordered_comm_semiring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_81423 (h0 : ring (normed_lattice_add_comm_group real)) : is_principal_ideal_ring (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_81424 (h0 : not (complete_lattice (has_sub congr_arg_kind) -> false)) : @is_compactly_generated.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_81425 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_81426 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81427 (h0 : functor.add_const (finset (plift num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81428 (h0 : topological_space ordering) : sequential_space ordering := sorry --non-trivial
lemma new_lemma_81429 (h0 : topological_space (ring (has_add pos))) : preconnected_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_81430 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_81431 (h0 : topological_space (as_linear_order environment.projection_info)) : totally_disconnected_space (as_linear_order environment.projection_info) := sorry --non-trivial
lemma new_lemma_81432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81433 (h0 : topological_space (has_compl fun_info)) : totally_disconnected_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_81434 (h0 : add_group (has_lt (random_gen (mul_one_class reducibility_hints)))) : is_add_cyclic (has_lt (random_gen (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_81435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81436 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @group.fg.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_81437 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_81438 (h0 : functor.add_const (add_group (option ennreal)) unsigned) : @is_add_cyclic.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81439 (h0 : functor.add_const (fin has_zero.zero) name) : @is_principal_ideal_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0)) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_81440 (h0 : functor.add_const (topological_space (has_zero ennreal)) name) : @loc_path_connected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_81441 (h0 : topological_space (boolean_algebra (has_add (has_add pos)))) : t0_space (boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_81442 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_81443 (h0 : functor.add_const (complete_lattice (normed_lattice_add_comm_group real)) (has_Inf (has_Inf real))) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) (has_Inf.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_81444 (h0 : add_group (has_inter num)) : is_add_cyclic (has_inter num) := sorry --non-trivial
lemma new_lemma_81445 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (finset (finset (has_add pos))))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (finset (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_81446 (h0 : function.extfun Type group) : @group.fg.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81447 (h0 : group (ring environment.implicit_infer_kind)) : is_simple_group (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_81448 (h0 : topological_space (has_dist num)) : discrete_topology (has_dist num) := sorry --non-trivial
lemma new_lemma_81449 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_81450 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_81451 (h0 : option (topological_space (complete_distrib_lattice (monoid (monoid congr_arg_kind))))) (h1 : topological_space (complete_distrib_lattice (monoid (monoid congr_arg_kind)))) : topological_space.separable_space (complete_distrib_lattice (monoid (monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_81452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81453 (h0 : topological_space (has_lt (as_linear_order linarith.comp_source))) : path_connected_space (has_lt (as_linear_order linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_81454 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81455 (h0 : functor.add_const (topological_space (add_comm_monoid empty)) congr_arg_kind) : @normal_space.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81456 (h0 : group (sub_neg_monoid (has_Inf linarith.comp))) : is_simple_group (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_81457 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_81458 (h0 : ereal -> linarith.ineq) : nonempty (function.bijective h0) := sorry --non-trivial
lemma new_lemma_81459 (h0 : topological_space (mul_zero_class congr_arg_kind)) : totally_separated_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81460 (h0 : monoid (has_nndist (finset pos))) : monoid.fg (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_81461 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81462 (h0 : topological_space (semiring (random_gen num))) : discrete_topology (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_81463 (h0 : ring (denumerable (has_inv (random_gen string_imp)))) : is_domain (denumerable (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_81464 (h0 : not (ring (add_cancel_comm_monoid linarith.ineq) -> false)) : @rank_condition.{0} (add_cancel_comm_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_81465 (h0 : add_monoid (normed_linear_ordered_group unsigned)) : add_monoid.fg (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_81466 (h0 : set (std_gen -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_81467 (h1 : add_group (measurable_space (with_bot string_imp))) : is_add_cyclic (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_81468 (h0 : add_group (complete_distrib_lattice (finset Type))) : is_add_cyclic (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_81469 (h0 : uniform_space (boolean_algebra.core (option ennreal))) : complete_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_81470 (h0 : topological_space (has_bot (option unsigned))) : totally_separated_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_81471 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81472 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_81473 (h0 : not (add_group (add_left_cancel_monoid linarith.comp_source) -> false)) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_81474 (h0 : semiring (has_nnnorm environment.projection_info)) (h1 : ideal (has_nnnorm environment.projection_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_81475 (h0 : not (group (has_one empty) -> false)) : @group.fg.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_81476 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81477 (h0 : functor.add_const (group (has_add name)) name) : @group.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_81478 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_81479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_81480 (h0 : uniform_space (has_norm (has_top num))) : separated_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_81481 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81482 (h0 : not (topological_space enat -> false)) : @path_connected_space.{0} enat (@classical.by_contradiction'.{1} (topological_space.{0} enat) h0)  := sorry --non-trivial
lemma new_lemma_81483 (h0 : functor.add_const (complete_lattice (has_pos_part linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81484 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_81485 (h0 : functor.add_const (group (add_comm_monoid Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81486 (h0 : ordered_add_comm_monoid znum) : archimedean znum := sorry --non-trivial
lemma new_lemma_81487 (h0 : add_monoid (add_comm_monoid (finset environment.implicit_infer_kind))) : add_monoid.fg (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81488 (h0 : topological_space (has_pos_part (sub_neg_monoid real))) : t1_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_81489 (h0 : topological_space (ring (ring (has_add (has_neg name))))) : normal_space (ring (ring (has_add (has_neg name)))) := sorry --non-trivial
lemma new_lemma_81490 (h0 : ring (complete_linear_order congr_arg_kind)) : rank_condition (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81491 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) num) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_81492 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_space real := sorry --non-trivial
lemma new_lemma_81493 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add pos)) (has_add name)) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_81494 (h0 : ring (ordered_cancel_add_comm_monoid pos)) : rank_condition (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_81495 (h0 : semiring (add_group empty)) : is_noetherian_ring (add_group empty) := sorry --non-trivial
lemma new_lemma_81496 (h0 : functor.add_const (complete_lattice (linear_ordered_field unsigned)) unsigned) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_field.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81497 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : matrix.vec_empty (function.extfun_app (function.extfun_app h0 fin) has_zero.zero) := sorry --non-trivial
lemma new_lemma_81498 (h0 : ring (linear_ordered_comm_ring congr_arg_kind)) : strong_rank_condition (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81499 (h0 : complete_lattice (linear_ordered_field (ring unsigned))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (ring unsigned)) := sorry --non-trivial
lemma new_lemma_81500 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (has_pos_part Type)) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81501 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) name) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_81502 (h0 : fin has_zero.zero) (h1 : pnat) : pnat.coprime (id (matrix.vec_empty h0)) h1 := sorry --non-trivial
lemma new_lemma_81503 (h0 : add_group (canonically_ordered_monoid (has_pos_part pos))) : is_add_cyclic (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_81504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81505 (h0 : topological_space (has_edist (semiring empty))) : totally_disconnected_space (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_81506 (h0 : topological_space (has_div std_gen)) : t0_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_81507 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_81508 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) (option (option (option name)))) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) (option.{0} (option.{0} (option.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_81509 (h0 : semiring (ordered_comm_monoid (ring linarith.comp))) : is_noetherian_ring (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_81510 (h0 : add_group (has_union (semiring (semiring num)))) : is_add_cyclic (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_81511 (h0 h1 : multiset (mul_one_class (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_81512 (h0 : topological_space (encodable (comm_ring to_additive.value_type))) : irreducible_space (encodable (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81513 (h0 : functor.add_const (topological_space znum) empty) : @preirreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_81514 (h0 : ring (comm_semigroup (comm_group unsigned))) : is_principal_ideal_ring (comm_semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_81515 (h0 : topological_space (boolean_algebra.core (comm_group unsigned))) : regular_space (boolean_algebra.core (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_81516 (h0 : functor.add_const (group Type) (finset pos)) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_81517 (h0 : functor.add_const (ring (has_nndist unsigned)) empty) : @is_domain.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_81518 (h0 : add_group (encodable string_imp)) : is_add_cyclic (encodable string_imp) := sorry --non-trivial
lemma new_lemma_81519 (h0 : topological_space (complete_lattice congr_arg_kind)) : t0_space (complete_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81520 (h0 : function.extfun Type (functor.comp complete_lattice has_to_string)) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) pos (@functor.comp.run.{0 0 0} complete_lattice.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_to_string.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_81521 (h0 : finset (add_cancel_monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81522 (h0 : add_group (normed_lattice_add_comm_group (has_bot (normed_lattice_add_comm_group real)))) : is_add_cyclic (normed_lattice_add_comm_group (has_bot (normed_lattice_add_comm_group real))) := sorry --non-trivial
lemma new_lemma_81523 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81524 (h0 : ring (semiring linarith.comp_source)) : is_domain (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81525 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_81526 (h0 : functor.add_const (topological_space (has_dist empty)) ennreal) : @totally_disconnected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_81527 (h0 : finset (simple_graph (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81528 (h0 : ring (has_inter ennreal)) : is_principal_ideal_ring (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_81529 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_81530 (h0 : uniform_space (ring (finset pos))) : complete_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_81531 (h0 : group (generalized_boolean_algebra (has_add linarith.comp))) : group.fg (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_81532 (h1 : topological_space (has_lt std_gen)) : t0_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_81533 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81534 (h0 : functor.add_const (ring (has_neg_part Type)) environment.implicit_infer_kind) : @is_domain.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81535 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm empty)))) : discrete_topology (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_81536 (h2 : topological_space (random_gen to_additive.value_type)) : irreducible_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81537 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81538 (h0 : not (ring (denumerable fun_info) -> false)) : @strong_rank_condition.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_81539 (h0 : uniform_space (has_compl (has_ssubset (has_ssubset linarith.ineq)))) : complete_space (has_compl (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_81540 (h0 : functor.add_const (group (has_add pos)) unsigned) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81541 (h0 : not (group (normed_field (is_R_or_C linarith.ineq)) -> false)) : @is_cyclic.{0} (normed_field.{0} (is_R_or_C.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} (is_R_or_C.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_81542 (h0 : finset (has_neg (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81543 (h0 : topological_space (normed_linear_ordered_group (semiring (option (semiring empty))))) : t0_space (normed_linear_ordered_group (semiring (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_81544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (preorder.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ring.{0} (preorder.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_81545 (h0 : ordered_add_comm_monoid (ring congr_arg_kind)) : archimedean (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81546 (h0 : topological_space (has_top (semiring (has_norm unsigned)))) : totally_separated_space (has_top (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_81547 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} znum (@function.extfun_app.{2 1} Type add_monoid.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_81548 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_81549 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_81550 (h0 : functor.add_const (semiring (normed_linear_ordered_group congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81551 (h0 : topological_space (ring (has_nndist (has_add name)))) : t1_space (ring (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_81552 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81553 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_81554 (h0 : functor.add_const (filter (boolean_algebra.core unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81555 (h0 : has_neg (semi_normed_comm_ring environment.projection_info)) (h1 : measurable_space (semi_normed_comm_ring environment.projection_info)) : has_measurable_neg (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_81556 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_81557 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_add pos)))) : has_exists_mul_of_le (ordered_comm_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_81558 (h0 : prod (has_nndist (option (option pos))) (has_nndist (option (option pos)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_81559 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_81560 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_81561 (h0 : topological_space (has_bot (sub_neg_monoid real))) : topological_space.separable_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_81562 (h0 : functor.add_const (uniform_space (normed_lattice_add_comm_group real)) (has_Inf Type)) : @complete_space.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_lattice_add_comm_group.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81563 (h0 : topological_space (nondiscrete_normed_field ereal)) (h1 : add_group (nondiscrete_normed_field ereal)) : topological_add_group (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_81564 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_81565 (h0 : functor.add_const (topological_space Type) Type) : @sequential_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_81566 (h0 : group (add_cancel_monoid (has_add name))) : is_cyclic (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_81567 (h0 : topological_space (ring (finset (has_neg Type)))) : irreducible_space (ring (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_81568 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice empty)) ennreal) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_81569 (h0 : has_lt (semi_normed_comm_ring to_additive.value_type)) : no_max_order (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81570 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : locally_compact_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_81571 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_81572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_81573 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (complete_distrib_lattice congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81574 (h0 : uniform_space (ring (ring pos))) : separated_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_81575 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_81576 (h0 : complete_lattice (finset (comm_group (comm_group pos)))) : complete_lattice.is_Sup_finite_compact (finset (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_81577 (h0 : topological_space (add_comm_monoid num)) : t0_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_81578 (h0 : function.extfun Type (prod (normed_linear_ordered_group unsigned))) : id_rel (function.extfun_app h0 (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_81579 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81580 (h1 : topological_space (has_nnnorm (random_gen (has_ssubset string_imp)))) : locally_compact_space (has_nnnorm (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_81581 (h0 : cancel_comm_monoid_with_zero (mul_zero_class Type)) : unique_factorization_monoid (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_81582 (h0 : topological_space (boolean_algebra (semigroup unsigned))) : totally_disconnected_space (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_81583 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_81584 (h0 : filter (has_neg unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81585 (h0 : filter (has_neg (has_to_string (has_to_string pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81586 (h0 : topological_space (has_Inf Type)) : regular_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_81587 (h0 : complete_lattice (has_nndist (normed_comm_ring (mul_zero_class pos)))) : is_atomistic (has_nndist (normed_comm_ring (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_81588 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add (has_add name))))) : preconnected_space (canonically_ordered_comm_semiring (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_81589 (h0 : uniform_space (has_add (sub_neg_monoid (has_bot real)))) : separated_space (has_add (sub_neg_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_81590 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_add.{1} (has_add.{1} (boolean_algebra.core.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type)))))) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} (has_add.{1} (boolean_algebra.core.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type)))))))  := sorry --non-trivial
lemma new_lemma_81591 (h0 : not (has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_81592 (h0 : ring (normed_lattice_add_comm_group (has_neg name))) : is_domain (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_81593 (h0 : semiring (left_cancel_monoid unsigned)) : is_noetherian_ring (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_81594 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81595 (h1 : topological_space (has_nnnorm to_additive.value_type)) : path_connected_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81596 (h0 : topological_space (add_comm_monoid pos)) : regular_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_81597 (h1 : complete_lattice (complete_semilattice_Sup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81598 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81599 (h0 : add_group (add_monoid (random_gen char))) : is_add_cyclic (add_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_81600 (h0 : not (ring (normed_group to_additive.value_type) -> false)) : @is_domain.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_81601 (h0 : ring (normed_group (has_top (has_norm fun_info)))) : strong_rank_condition (normed_group (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_81602 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81603 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81604 (h0 : function.extfun (finset ((Type -> Type) -> Type 1) -> Prop) (function.extfun (finset ((Type -> Type) -> Type 1)))) : @complete_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1) → Prop) (function.extfun.{3 0} (finset.{2} ((Type → Type) → Type 1))) h0 (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type))) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) uniform_space.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_81605 (h0 : ring (has_nndist (has_add name))) : is_domain (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_81606 (h2 : topological_space (complete_semilattice_Sup linarith.comp)) : path_connected_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_81607 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_81608 (h0 : add_group (left_cancel_monoid empty)) : is_add_cyclic (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_81609 (h0 : topological_space (has_add (sub_neg_monoid name))) : regular_space (has_add (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_81610 (h0 : functor.add_const (monoid (ring linarith.comp)) Type) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81611 (h0 : list (has_dist (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_81612 (h0 : uniform_space (ring (finset (ring linarith.comp)))) : complete_space (ring (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_81613 (h0 : ordered_comm_monoid (add_cancel_monoid (option name))) : has_exists_mul_of_le (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_81614 (h0 : complete_lattice (add_cancel_comm_monoid char)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_81615 (h0 : ordered_comm_monoid (measurable_space.dynkin_system (has_add Type))) : has_exists_mul_of_le (measurable_space.dynkin_system (has_add Type)) := sorry --non-trivial
lemma new_lemma_81616 (h0 : add_monoid (has_zero pos)) : add_monoid.fg (has_zero pos) := sorry --non-trivial
lemma new_lemma_81617 (h0 : topological_space (has_add (has_pos_part pos))) : totally_separated_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_81618 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81619 (h0 : functor.comp add_group add_cancel_monoid environment.implicit_infer_kind) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_group.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81620 (h1 : ring (mul_one_class (add_comm_semigroup ereal))) : strong_rank_condition (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_81621 (h0 : topological_space (with_one (semiring (semiring empty)))) : discrete_topology (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_81622 (h0 : topological_space (has_append (has_ssubset (has_ssubset (has_ssubset char))))) : totally_disconnected_space (has_append (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_81623 (h0 : topological_space (has_Inf (ordered_comm_monoid real))) : regular_space (has_Inf (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_81624 (h0 : functor.add_const (complete_lattice (has_nndist empty)) (option (option unsigned))) : @is_atomistic.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81625 (h1 : ring (add_comm_semigroup linarith.ineq)) : rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_81626 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_81627 (h0 : group (semigroup (canonically_linear_ordered_monoid ennreal))) : group.fg (semigroup (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_81628 (h0 : topological_space (add_group num)) : t1_space (add_group num) := sorry --non-trivial
lemma new_lemma_81629 (h0 : topological_space (plift (semiring (semiring empty)))) : path_connected_space (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_81630 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_81631 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81632 (h0 : ordered_comm_monoid (complete_distrib_lattice name)) : has_exists_mul_of_le (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_81633 (h0 : functor.add_const (topological_space (has_Inf environment.implicit_infer_kind)) Type) : @regular_space.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_81634 (h0 : functor.add_const (topological_space (ring Type)) name) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_81635 (h0 : group (has_top unsigned)) : is_cyclic (has_top unsigned) := sorry --non-trivial
lemma new_lemma_81636 (h0 : uniform_space (has_le linarith.comp_source)) : complete_space (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_81638 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_81639 (h0 : set (add_comm_semigroup (normed_field std_gen))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_81640 (h0 : filter (has_Inf (has_add (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81641 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_81642 (h0 : ring (has_one (has_top num))) : rank_condition (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_81643 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) name) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_81644 (h0 : filter (ring (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81645 (h0 : cancel_comm_monoid_with_zero (comm_semigroup Type)) : unique_factorization_monoid (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_81646 (h0 : group (normed_comm_ring (option (option (option unsigned))))) : is_cyclic (normed_comm_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_81647 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) pos) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_81648 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (has_Inf pos)) : @archimedean.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (has_Inf.{0} pos) h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_81649 (h0 : ordered_comm_monoid (has_neg linarith.comp)) : has_exists_mul_of_le (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_81650 (h2 : not (topological_space (denumerable linarith.ineq) -> false)) : @path_connected_space.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.ineq)) h2)  := sorry --non-trivial
lemma new_lemma_81651 (h0 : ring (linear_ordered_semiring linarith.ineq)) : strong_rank_condition (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_81652 (h0 : filter (add_cancel_monoid (has_neg name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81653 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_81654 (h0 : has_top (has_star congr_arg_kind) -> has_top (has_star congr_arg_kind) -> Prop) : is_equiv (has_top (has_star congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_81655 (h0 : topological_space (free_add_monoid (semiring empty))) : irreducible_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_81656 (h0 : functor.add_const (group (has_add pos)) real) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_81657 (h1 : complete_lattice (has_norm to_additive.value_type)) : is_compactly_generated (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81658 (h0 : topological_space (id (has_norm unsigned))) : normal_space (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_81659 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_81660 (h0 : semiring (has_bot (div_inv_monoid unsigned))) : is_noetherian_ring (has_bot (div_inv_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_81661 (h0 : topological_space (monoid_with_zero (option pos))) : preconnected_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_81662 (h0 : topological_space (monoid pos)) : t1_space (monoid pos) := sorry --non-trivial
lemma new_lemma_81663 (h0 : function.extfun Type group) : @is_cyclic.{0} znum (@function.extfun_app.{2 1} Type group.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_81664 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option (option (option ennreal))))) : unique_factorization_monoid (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_81665 (h0 : functor.add_const (uniform_space (ordered_comm_ring Type)) pos) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_81666 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (has_add (has_add pos))) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81667 (h0 : topological_space (has_nnnorm (random_gen to_additive.value_type))) : locally_compact_space (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81668 (h0 : complete_lattice (option congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81669 (h0 : ring (comm_group (comm_group (has_to_string unsigned)))) : strong_rank_condition (comm_group (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_81670 (h0 : filter (simple_graph linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81671 (h0 : semiring (boolean_algebra.core num)) : is_noetherian_ring (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_81672 (h0 : ring (has_pos_part (ring name))) : is_domain (has_pos_part (ring name)) := sorry --non-trivial
lemma new_lemma_81673 (h0 : functor.add_const (topological_space (simple_graph pos)) (simple_graph Type)) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) (simple_graph.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81674 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @normal_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_81675 (h0 : function.extfun Type group) : @normalizer_condition.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81676 (h0 : ring (has_div (mul_one_class enat))) : is_domain (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_81677 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_81678 (h0 : functor.add_const (function.extfun Type complete_lattice) (option (option Type))) : @is_compactly_generated.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{1} (option.{1} Type)) h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_81679 (h0 : ring (has_neg (finset name))) : invariant_basis_number (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_81680 (h1 : ring (topological_space (has_ssubset char))) : rank_condition (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_81681 (h0 : uniform_space (has_neg linarith.comp)) : separated_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_81682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_81683 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_nndist.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81684 (h0 : prod (ring (option empty)) (ring (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_81685 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81686 (h0 : uniform_space (normed_comm_ring (has_neg linarith.comp))) : complete_space (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_81687 (h0 : functor.add_const (list (comm_group pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81688 (h1 : not (ring (has_ssubset string_imp) -> false)) : @is_domain.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_81689 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_81691 (h0 : topological_space (has_Inf (has_Inf Type))) : topological_space.separable_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_81692 (h0 : uniform_space (bin_tree (semiring congr_arg_kind))) : separated_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81693 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81694 (h0 : topological_space (mul_zero_class (has_add (has_add ennreal)))) : t0_space (mul_zero_class (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_81695 (h0 : functor.add_const (filter (has_to_string linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81696 (h0 : topological_space (linear_ordered_comm_ring empty)) : discrete_topology (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_81697 (h0 : uniform_space (ring (has_Inf (has_pos_part linarith.comp)))) : complete_space (ring (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_81698 (h0 : functor.add_const (topological_space (mul_zero_class pos)) ennreal) : @normal_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_81699 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81700 (h0 : ordered_add_comm_monoid (linear_order (option unsigned))) : archimedean (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_81701 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_81702 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @totally_disconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81703 (h0 : topological_space (semigroup (ring pos))) : t0_space (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_81704 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81705 (h0 : not (uniform_space (has_emptyc fun_info) -> false)) : @complete_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_81706 (h0 : group (has_inter (option num))) : group.fg (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_81707 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81708 (h2 : topological_space (mul_one_class std_gen)) : path_connected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_81709 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @t1_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81710 (h1 : complete_lattice (add_comm_semigroup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81711 (h0 : group (with_one (has_nnnorm (random_gen to_additive.value_type)))) : group.fg (with_one (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_81712 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core linarith.comp))) : path_connected_space (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_81713 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_81714 (h2 : set (uniform_space to_additive.value_type)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_81715 (h0 : topological_space (comm_ring char)) : locally_compact_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_81716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81717 (h0 : add_group (semigroup (add_comm_monoid (normed_comm_ring Type)))) : is_add_cyclic (semigroup (add_comm_monoid (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_81718 (h0 : not (list (left_cancel_semigroup unsigned) -> false)) : palindrome (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_81719 (h0 : not (uniform_space (topological_space (denumerable (denumerable (denumerable reducibility_hints)))) -> false)) : @complete_space.{0} (topological_space.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} reducibility_hints)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} reducibility_hints))))) h0)  := sorry --non-trivial
lemma new_lemma_81720 (h0 : functor.add_const (complete_lattice (normed_comm_ring environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_81721 (h0 : group (topological_space (has_top to_additive.value_type))) : group.fg (topological_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81722 (h0 : uniform_space (add_cancel_monoid pos)) : complete_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_81723 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} fun_info (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_81724 (h0 : group (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : is_cyclic (normed_linear_ordered_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_81725 (h0 : topological_space (has_norm (has_top (has_top congr_arg_kind)))) : locally_compact_space (has_norm (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_81726 (h0 : functor.add_const (monoid (linear_ordered_field unsigned)) empty) : @monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_field.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_81727 (h0 : functor.add_const (filter (add_comm_monoid Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81728 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @sequential_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_81729 (h0 : has_mem.mem (linear_ordered_semiring linarith.ineq) has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_81730 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_81731 (h0 : ring (semigroup congr_arg_kind)) : strong_rank_condition (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81732 (h0 : complete_lattice (linear_ordered_semiring (semiring congr_arg_kind))) : is_compactly_generated (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81733 (h1 : add_group (comm_ring (has_ssubset (comm_ring (random_gen fun_info))))) : is_add_cyclic (comm_ring (has_ssubset (comm_ring (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_81734 (h0 : functor.add_const (monoid (has_zero linarith.comp)) (has_to_string (has_neg pos))) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} linarith.comp)) (has_to_string.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81735 (h0 : functor.add_const (add_monoid (simple_graph linarith.comp)) pos) : @add_monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_81736 (h0 : not (complete_lattice (add_left_cancel_monoid fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_81737 (h0 : uniform_space (has_pos_part (ordered_comm_monoid (has_pos_part (sub_neg_monoid real))))) : complete_space (has_pos_part (ordered_comm_monoid (has_pos_part (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_81738 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_right_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81739 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @t1_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81740 (h0 : group (div_inv_monoid (has_nnnorm fun_info))) : is_cyclic (div_inv_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_81741 (h0 : cancel_comm_monoid_with_zero (semigroup (has_zero (option pos)))) : unique_factorization_monoid (semigroup (has_zero (option pos))) := sorry --non-trivial
lemma new_lemma_81742 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class char)))) : is_domain (has_nnnorm (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_81743 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_81744 (h0 : cancel_comm_monoid_with_zero (comm_group (has_neg_part pos))) : unique_factorization_monoid (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_81745 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81746 (h0 : ring (simple_graph (ring (has_add (has_add pos))))) : is_principal_ideal_ring (simple_graph (ring (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_81747 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81748 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81749 (h0 : topological_space (ordered_comm_ring (has_pos_part (has_pos_part linarith.comp)))) : sequential_space (ordered_comm_ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_81750 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @irreducible_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81751 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_81752 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_81753 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_81754 (h0 : functor.add_const (topological_space (ordered_comm_monoid unsigned)) empty) : @t0_space.{0} (ordered_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_81755 (h0 : uniform_space (non_assoc_semiring (option unsigned))) : complete_space (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_81756 (h0 : filter (has_neg_part (has_add (has_add ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_81757 (h0 : topological_space (semi_normed_ring std_gen)) : path_connected_space (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_81758 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_81759 (h0 : add_group (add_comm_semigroup linarith.ineq)) : is_add_cyclic (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_81760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_81761 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_81762 (h0 : ring (with_bot (has_norm num))) : strong_rank_condition (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_81763 (h1 : uniform_space (mul_one_class string.iterator_imp)) : complete_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_81764 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_to_string.{0} (ring.{0} pos)) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_to_string.{0} (ring.{0} pos)))  := sorry --non-trivial
lemma new_lemma_81765 (h0 : topological_space (has_one congr_arg_kind)) : locally_compact_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81766 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81767 (h0 : list (has_zero (has_add (option (option (ring pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81768 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) pos) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_81769 (h0 : add_group (bin_tree (option (option empty)))) : is_add_cyclic (bin_tree (option (option empty))) := sorry --non-trivial
lemma new_lemma_81770 (h0 : group (option pos)) : group.fg (option pos) := sorry --non-trivial
lemma new_lemma_81771 (h0 : functor.add_const (topological_space (semigroup name)) name) : @sequential_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_81772 (h0 : topological_space std_gen) (h1 : topological_space linarith.ineq) (h2 : ring (homeomorph std_gen linarith.ineq)) : is_domain (homeomorph std_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_81773 (h0 : not (list (dlist linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_81774 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @normal_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_81775 (h0 : complete_lattice (simple_graph linarith.comp)) : is_compactly_generated (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_81776 (h0 : functor.add_const (group (has_pos_part linarith.comp)) name) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_81777 (h0 : not (semiring (has_norm empty) -> false)) : @is_noetherian_ring.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_81778 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81779 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81780 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) pos) : @is_atomistic.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_81781 (h0 : topological_space (with_bot empty)) : path_connected_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_81782 (h0 : functor.add_const (list (has_add linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81783 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81784 (h0 : functor.add_const (function.extfun Type topological_space) (has_add linarith.comp)) : @sequential_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} linarith.comp) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_81785 (h0 : ennreal -> ennreal -> ennreal) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_81786 (h0 : semiring (simple_graph (has_add (boolean_algebra.core linarith.comp)))) : is_noetherian_ring (simple_graph (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_81787 (h0 : ring (with_bot (has_norm to_additive.value_type))) : rank_condition (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81788 (h0 : finset (has_zero (add_cancel_monoid Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81789 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_81790 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (add_comm_monoid ennreal))) : archimedean (canonically_ordered_comm_semiring (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_81791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_81792 (h1 : function.extfun Type topological_space) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_81793 (h0 : functor.add_const (prod (left_cancel_monoid empty) (left_cancel_monoid empty)) (option empty)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81794 (h0 : not (finset (linear_ordered_comm_ring empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_81795 (h1 : group (normed_field (denumerable linarith.comp_source))) : is_cyclic (normed_field (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_81796 (h0 : complete_lattice (normed_group (random_gen (has_inv linarith.comp_source)))) : is_atomistic (normed_group (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_81797 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_81798 (h0 : group (has_nnnorm (random_gen to_additive.value_type))) : group.fg (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_81799 (h0 : topological_space (cancel_monoid (finset environment.implicit_infer_kind))) : discrete_topology (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81800 (h0 : list (add_comm_monoid (option (option (option unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81801 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_81802 (h0 : topological_space (normed_field (random_gen (random_gen (random_gen (random_gen char)))))) : totally_disconnected_space (normed_field (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_81803 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81804 (h0 : topological_space (semigroup (boolean_algebra name))) : totally_separated_space (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_81805 (h0 : not (ring (measurable_space.dynkin_system unsigned) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81806 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (right_cancel_semigroup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (right_cancel_semigroup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_81807 (h0 : group (with_bot congr_arg_kind)) : is_cyclic (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81808 (h0 : topological_space (monoid (option (option (option ennreal))))) : locally_compact_space (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_81809 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @strong_rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_81810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_81811 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_81812 (h1 : uniform_space (has_top linarith.comp_source)) : complete_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_81813 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) ennreal) : @normal_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_81814 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @discrete_topology.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_81815 (h0 : finset (has_to_string empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81816 (h0 : fin has_zero.zero) : @complete_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_81817 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81818 (h0 : ring (mul_zero_class (complete_distrib_lattice (semigroup pos)))) : is_principal_ideal_ring (mul_zero_class (complete_distrib_lattice (semigroup pos))) := sorry --non-trivial
lemma new_lemma_81819 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81820 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_81821 (h0 : functor.add_const (topological_space (simple_graph pos)) (finset pos)) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_81822 (h0 : uniform_space (has_zero (comm_group (has_neg_part Type)))) : separated_space (has_zero (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_81823 (h0 : functor.add_const (ring (has_Inf Type)) pos) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_81824 (h0 : ring (non_assoc_semiring (option (option (option (option empty)))))) : is_domain (non_assoc_semiring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_81825 (h0 : topological_space (has_Inf (ring (ring Type)))) : totally_separated_space (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_81826 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : t1_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_81827 (h0 : complete_lattice (normed_group (has_top (semiring (semiring fun_info))))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top (semiring (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_81828 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_81829 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_atomistic.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_81830 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81831 (h0 : topological_space (has_lt linarith.ineq)) : t0_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_81832 (h0 : not (topological_space (random_gen string_imp) -> false)) : @path_connected_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_81833 (h0 : ring (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind))) : strong_rank_condition (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_81834 (h0 : functor.add_const (monoid (finset name)) name) : @monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_81835 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (ring Type)) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81836 (h0 : functor.add_const (group (has_to_string pos)) (has_to_string Type)) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_81837 (h0 : group (has_bot unsigned)) : normalizer_condition (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_81838 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} pos (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) pos)  := sorry --non-trivial
lemma new_lemma_81840 (h0 : add_monoid (plift (plift (has_top empty)))) : add_monoid.fg (plift (plift (has_top empty))) := sorry --non-trivial
lemma new_lemma_81841 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (omega_complete_partial_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_81842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81843 (h0 : complete_lattice (comm_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_81844 (h0 : group (has_bot (has_Inf Type))) : is_simple_group (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_81845 (h0 : complete_lattice (comm_monoid congr_arg_kind)) : is_compactly_generated (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81847 (h0 : not (complete_lattice (has_lt linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_81848 (h0 : topological_space (has_zero (boolean_algebra.core pos))) : t1_space (has_zero (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_81849 (h0 : ring (linear_ordered_semiring (semiring (semiring unsigned)))) : strong_rank_condition (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_81850 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_81851 (h0 : functor.add_const (function.extfun Type topological_space) (has_add pos)) : @totally_disconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_81852 (h0 : functor.comp filter boolean_algebra name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_81853 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81854 (h0 : complete_lattice (has_add (sub_neg_monoid (has_add pos)))) : is_atomistic (has_add (sub_neg_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_81855 (h0 : add_group (has_compl (mul_one_class (mul_one_class linarith.comp_source)))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_81856 (h0 : ordered_add_comm_monoid (has_Inf (has_pos_part (has_add Type)))) : archimedean (has_Inf (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_81857 (h0 : functor.add_const (group (has_star congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81858 (h0 : function.extfun (has_norm fun_info) (fun (x : has_norm fun_info), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_81859 (h0 : monoid (random_gen (has_top complex))) : monoid.fg (random_gen (has_top complex)) := sorry --non-trivial
lemma new_lemma_81860 (h1 : ring (nondiscrete_normed_field char)) : is_domain (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_81861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81862 (h0 : ordered_comm_ring (ordered_comm_monoid Type) -> ordered_comm_ring (ordered_comm_monoid Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_81863 (h0 : ring (has_star (semiring empty))) : is_domain (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_81864 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @irreducible_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81865 (h0 : functor.add_const (semiring (has_neg name)) Type) : @is_noetherian_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_81866 (h0 : topological_space (metric_space (id (id empty)))) : path_connected_space (metric_space (id (id empty))) := sorry --non-trivial
lemma new_lemma_81867 (h0 : filter (semigroup (semigroup pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81869 (h0 : uniform_space (boolean_algebra (has_Inf linarith.comp))) : separated_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_81870 (h0 : semiring (has_zero (ring (finset Type)))) : is_noetherian_ring (has_zero (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_81871 (h0 : not (complete_lattice (has_lt reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_81872 (h0 : complete_lattice (has_neg_part (has_to_string (ring (option pos))))) : complete_lattice.is_Sup_finite_compact (has_neg_part (has_to_string (ring (option pos)))) := sorry --non-trivial
lemma new_lemma_81873 (h0 : functor.add_const (ring (add_cancel_monoid Type)) Type) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81874 (h0 : functor.add_const (function.extfun (Type 1) monoid) pos) : @monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_81875 (h0 : ordered_add_comm_monoid (has_nndist congr_arg_kind)) : archimedean (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_81876 (h0 : complete_lattice (with_bot string_imp)) : complete_lattice.is_Sup_finite_compact (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_81877 (h0 : group (has_ssubset linarith.ineq)) : group.fg (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_81878 (h0 : function.extfun (Type 1) (functor.comp topological_space mul_zero_class)) : @t0_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} mul_zero_class.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_81879 (h0 : ring (as_linear_order (comm_monoid unsigned))) : is_domain (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_81880 (h0 : finset (simple_graph name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_81881 (h0 : not (topological_space (normed_group empty) -> false)) : @t1_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_81882 (h0 : list (add_cancel_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_81883 (h0 : topological_space (partial_order (semiring congr_arg_kind))) : totally_separated_space (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81884 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_81885 (h0 : topological_space (normed_comm_ring (finset name))) : loc_path_connected_space (normed_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_81886 (h1 : complete_lattice (linear_ordered_add_comm_group char)) : is_compactly_generated (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_81887 (h0 : complete_lattice (semi_normed_comm_ring char)) : is_compactly_generated (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_81888 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81889 (h0 : uniform_space (id (random_gen (random_gen linarith.ineq)))) : complete_space (id (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_81890 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @discrete_topology.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_81891 (h0 : not (topological_space (has_star unsigned) -> false)) : @preirreducible_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81892 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_81893 (h0 : group (comm_ring (has_ssubset (has_sdiff (has_ssubset to_additive.value_type))))) : is_cyclic (comm_ring (has_ssubset (has_sdiff (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_81894 (h0 : topological_space (semiring (random_gen fun_info))) : totally_separated_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_81895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81896 (h0 : ring (has_add unsigned)) : is_principal_ideal_ring (has_add unsigned) := sorry --non-trivial
lemma new_lemma_81897 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_81898 (h0 : topological_space (ring (has_neg Type))) : normal_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_81899 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_81900 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add Type))) : unique_factorization_monoid (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_81901 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) Type) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81902 (h0 : topological_space (boolean_algebra (has_Inf (finset (has_pos_part (has_Inf (finset Type))))))) : discrete_topology (boolean_algebra (has_Inf (finset (has_pos_part (has_Inf (finset Type)))))) := sorry --non-trivial
lemma new_lemma_81903 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_81904 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_81905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_81906 (h0 : topological_space (has_inner empty (option unsigned))) : normal_space (has_inner empty (option unsigned)) := sorry --non-trivial
lemma new_lemma_81907 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @is_cyclic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_81908 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_81909 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81910 (h0 : group (left_cancel_semigroup (semiring (semiring unsigned)))) : normalizer_condition (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_81911 (h0 : topological_space (has_pos_part (has_Inf real))) : preirreducible_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_81912 (h0 : monoid (id (has_inv (has_inv fun_info)))) : monoid.fg (id (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_81913 (h0 : ring (measurable_space.dynkin_system (option (option unsigned)))) : strong_rank_condition (measurable_space.dynkin_system (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_81914 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_81915 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) empty) : locally_compact_space nnreal := sorry --non-trivial
lemma new_lemma_81916 (h0 : ring (denumerable (random_gen linarith.ineq))) : is_domain (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81917 (h0 : topological_space (has_neg (ring (finset (has_neg Type))))) : irreducible_space (has_neg (ring (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_81918 (h0 : topological_space (has_zero (ring (ring environment.implicit_infer_kind)))) : loc_path_connected_space (has_zero (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_81919 (h0 : functor.add_const (complete_lattice (option unsigned)) unsigned) : @is_atomistic.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_81920 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_81921 (h0 : topological_space (has_neg_part (add_cancel_monoid name))) : totally_disconnected_space (has_neg_part (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_81922 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_81923 (h0 : uniform_space (complete_linear_order (semiring (semiring (semiring (semiring congr_arg_kind)))))) : separated_space (complete_linear_order (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_81924 (h0 : topological_space (has_add (option (option (option unsigned))))) : topological_space.separable_space (has_add (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_81925 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_81926 (h0 : topological_space (has_Inf (has_add (has_add (has_add pos))))) : t0_space (has_Inf (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_81927 (h0 : not (topological_space num -> false)) : @totally_separated_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_81928 (h0 : group (simple_graph (has_Inf Type))) : group.fg (simple_graph (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_81929 (h0 : group (has_star (semiring (semiring (semiring congr_arg_kind))))) : group.fg (has_star (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_81930 (h0 : not (ring (has_emptyc congr_arg_kind) -> false)) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_81931 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_81932 (h0 : topological_space (has_lt (mul_one_class linarith.ineq))) (h1 : not (preorder (has_lt (mul_one_class linarith.ineq)) -> false)) : @order_closed_topology.{0} (has_lt.{0} (mul_one_class.{0} linarith.ineq)) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_lt.{0} (mul_one_class.{0} linarith.ineq))) h1)  := sorry --non-trivial
lemma new_lemma_81933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81934 (h0 : topological_space (boolean_algebra.core (has_to_string ennreal))) : discrete_topology (boolean_algebra.core (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_81935 (h0 : ring (has_emptyc (has_inv (has_inv (has_inv (has_top fun_info)))))) : is_domain (has_emptyc (has_inv (has_inv (has_inv (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_81936 (h0 : topological_space (uniform_space to_additive.value_type)) : totally_disconnected_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_81937 (h0 : ordered_comm_monoid (ring (has_neg (has_Inf (has_Inf Type))))) : has_exists_mul_of_le (ring (has_neg (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_81938 (h0 : ring (sub_neg_monoid (ordered_comm_monoid (has_bot Type)))) : rank_condition (sub_neg_monoid (ordered_comm_monoid (has_bot Type))) := sorry --non-trivial
lemma new_lemma_81939 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) Type) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_81940 (h0 : complete_lattice (measurable_space (has_top congr_arg_kind))) : is_atomistic (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81941 (h0 : topological_space (has_neg_part (option name))) : loc_path_connected_space (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_81942 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_81943 (h0 : Prop) (h1 : fin has_zero.zero) : category_theory.hom_of_element h0 (matrix.vec_empty (id (id h1))) := sorry --non-trivial
lemma new_lemma_81944 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_81945 (h1 : not (topological_space (has_neg linarith.comp_source) -> false)) : @t0_space.{0} (has_neg.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_neg.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_81946 (h0 : group (topological_space (random_gen reducibility_hints))) : is_cyclic (topological_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_81947 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_81948 (h0 h1 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_measurable_div₂.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) measurable_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 measurable_space.{1}) (finset.{1} Type)) (@function.extfun_app.{3 2} (Type 1) has_div.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h1 has_div.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_81949 (h0 : ring (denumerable (random_gen (has_ssubset fun_info)))) : strong_rank_condition (denumerable (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_81950 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) linarith.comp) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81951 (h0 : topological_space (ordered_comm_ring (has_add Type))) : irreducible_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_81952 (h0 : set (semi_normed_comm_ring to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_81953 (h0 : group (with_one (has_nnnorm char))) : group.fg (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_81954 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_81955 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : preirreducible_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_81956 (h0 : functor.add_const (add_monoid (left_cancel_semigroup num)) num) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_81957 (h0 : group (finset (has_add ennreal))) : group.fg (finset (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_81958 (h0 : complete_lattice (topological_space (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81959 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) linarith.comp) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_81960 (h0 : uniform_space (with_one (topological_space fun_info))) : complete_space (with_one (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_81961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_81962 (h0 : add_group (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq)))) : is_add_cyclic (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_81963 (h0 : cancel_comm_monoid_with_zero (option (semiring congr_arg_kind))) : unique_factorization_monoid (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_81964 (h0 : functor.comp ring has_neg Type) : @is_domain.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_81965 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_81966 (h0 : functor.add_const (topological_space (option num)) congr_arg_kind) : @t1_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_81967 (h0 : set (non_unital_non_assoc_semiring string.iterator_imp -> to_additive.value_type)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_81968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_81969 (h0 : topological_space (normed_group (random_gen (random_gen congr_arg_kind)))) : t0_space (normed_group (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_81970 (h0 : ordered_add_comm_monoid (has_to_string (has_Inf Type))) : archimedean (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_81971 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_81972 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) Type) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_81973 (h0 : topological_space (with_bot (semiring empty))) : t1_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_81974 (h0 : ring (comm_ring (has_nnnorm string_imp))) : strong_rank_condition (comm_ring (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_81975 (h0 : not (group (non_assoc_semiring unsigned) -> false)) : @group.fg.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_81976 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_81977 (h0 : not (ring (distrib_lattice (has_ssubset linarith.comp_source)) -> false)) : @is_domain.{0} (distrib_lattice.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_81978 (h0 : topological_space (finset (finset (finset environment.implicit_infer_kind)))) : path_connected_space (finset (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_81979 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @preirreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_81980 (h0 : filter (id (semiring (has_norm empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_81981 (h1 : has_mem.mem Type has_emptyc.emptyc) : @is_add_cyclic.{1} Type (@finset.pi.empty.{2 1} (Type 1) add_group.{1} Type h1)  := sorry --non-trivial
lemma new_lemma_81982 (h0 : functor.add_const (finset (has_Inf environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81983 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_81984 (h1 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_81985 (h0 : complete_lattice (has_emptyc (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_81986 (h0 : functor.add_const (ring (has_to_string pos)) (has_Inf (has_neg (add_cancel_monoid (has_neg (has_neg Type)))))) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} pos)) (has_Inf.{1} (has_neg.{1} (add_cancel_monoid.{1} (has_neg.{1} (has_neg.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_81987 (h0 : topological_space (ordered_comm_monoid (has_add (ring linarith.comp)))) : discrete_topology (ordered_comm_monoid (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_81988 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_81989 (h0 : topological_space (has_add real)) : loc_path_connected_space (has_add real) := sorry --non-trivial
lemma new_lemma_81990 (h1 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h1) monoid.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_81991 (h0 : topological_space (finset (has_neg_part (boolean_algebra.core (has_add (has_add pos)))))) : normal_space (finset (has_neg_part (boolean_algebra.core (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_81992 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (semigroup Type))) : unique_factorization_monoid (boolean_algebra.core (semigroup Type)) := sorry --non-trivial
lemma new_lemma_81993 (h0 : function.extfun Type (functor.add_const (topological_space (has_star unsigned)))) : @totally_separated_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_81994 (h0 : group (normed_lattice_add_comm_group unsigned)) : is_cyclic (normed_lattice_add_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_81995 (h0 : functor.add_const (complete_lattice (has_to_string pos)) name) : @is_atomistic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_81996 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_81997 (h0 : topological_space (with_one (id linarith.comp))) : preirreducible_space (with_one (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_81998 (h0 : semiring (add_right_cancel_monoid (semiring (semiring unsigned)))) : is_noetherian_ring (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_81999 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_82000 (h0 : functor.add_const (ring (group_with_zero num)) congr_arg_kind) : @strong_rank_condition.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (group_with_zero.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_82001 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @t0_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_82002 (h0 : complete_lattice (distrib_lattice (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82003 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_82004 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group Type)))) : sequential_space (add_cancel_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_82005 (h0 : ring (has_star (has_norm (has_norm (has_norm empty))))) : strong_rank_condition (has_star (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_82006 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82007 (h0 : add_group (has_neg_part (option (option pos)))) : is_add_cyclic (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_82008 (h0 : nat) : nat.prime (id (id h0)) := sorry --non-trivial
lemma new_lemma_82009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_82010 (h0 : pseudo_emetric_space (ordered_cancel_comm_monoid empty)) (h1 : pseudo_emetric_space empty) (h2 : filter (isometric (ordered_cancel_comm_monoid empty) empty)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_82011 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_82012 (h0 : topological_space (semiring (has_top linarith.ineq))) : totally_disconnected_space (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82013 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (left_cancel_semigroup unsigned))) : unique_factorization_monoid (left_cancel_semigroup (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_82014 (h1 : group (comm_ring char)) : group.fg (comm_ring char) := sorry --non-trivial
lemma new_lemma_82015 (h0 : not (topological_space (option num) -> false)) : @t1_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_82016 (h0 : uniform_space (complete_semilattice_Sup fun_info)) : complete_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_82017 (h0 : topological_space (has_pos_part (ordered_ring Type))) : loc_path_connected_space (has_pos_part (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_82018 (h0 : ring (normed_field (mul_one_class (mul_one_class string_imp)))) : rank_condition (normed_field (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_82019 (h0 : function.extfun nat fin) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_82020 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @preconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_82021 (h1 : has_neg (has_ssubset (add_comm_semigroup (add_comm_semigroup enat)))) (h2 : measurable_space (has_ssubset (add_comm_semigroup (add_comm_semigroup enat)))) : has_measurable_neg (has_ssubset (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_82022 (h0 : functor.add_const (fin has_zero.zero) Type) : @rank_condition.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_82023 (h0 : not (ring (has_inv to_additive.value_type) -> false)) : @rank_condition.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_82024 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82025 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (comm_monoid (option unsigned)))) : unique_factorization_monoid (pseudo_metric_space (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_82026 (h0 : ring (has_one (semiring (has_norm linarith.comp)))) : rank_condition (has_one (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_82027 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_82028 (h0 : functor.add_const (finset (semigroup name)) (option unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82029 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_82030 (h0 : finset (has_Sup (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82031 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @normal_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_82032 (h0 : functor.add_const (list (free_add_monoid empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82033 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_82034 (h0 : group (non_unital_semiring string_imp)) : normalizer_condition (non_unital_semiring string_imp) := sorry --non-trivial
lemma new_lemma_82035 (h0 : topological_space (has_compl std_gen)) : t0_space (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_82036 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_82037 (h0 : group (has_ssubset (has_nnnorm string_imp))) : group.fg (has_ssubset (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_82038 (h0 : add_group (has_zero environment.implicit_infer_kind)) : is_add_cyclic (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_82039 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_82040 (h0 : topological_space (comm_group (has_neg (has_to_string name)))) : regular_space (comm_group (has_neg (has_to_string name))) := sorry --non-trivial
lemma new_lemma_82041 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @irreducible_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_82042 (h0 : uniform_space (has_append (ordered_cancel_comm_monoid (random_gen string_imp)))) : complete_space (has_append (ordered_cancel_comm_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_82043 (h0 : group (denumerable (random_gen char))) : group.fg (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_82044 (h0 : complete_lattice (monoid pos)) : is_compactly_generated (monoid pos) := sorry --non-trivial
lemma new_lemma_82045 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : irreducible_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82046 (h0 : group (uniform_space (normed_field (comm_ring linarith.comp_source)))) : is_cyclic (uniform_space (normed_field (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_82047 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82048 (h0 : topological_space (boolean_algebra (ring pos))) : discrete_topology (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_82049 (h0 : topological_space (sub_neg_monoid real)) : preirreducible_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_82050 (h0 : topological_space (sub_neg_monoid name)) : irreducible_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_82051 (h0 : not (topological_space (uniform_space (has_nnnorm linarith.comp_source)) -> false)) : @t0_space.{0} (uniform_space.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_82052 (h0 : group (with_bot linarith.comp_source)) : group.fg (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82053 (h0 : functor.add_const (uniform_space (comm_group name)) linarith.comp) : @separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82054 (h0 : topological_space (has_pos_part (has_pos_part linarith.comp))) : path_connected_space (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82055 (h0 : monoid (has_top (random_gen (random_gen to_additive.value_type)))) : monoid.fg (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82056 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring (ordered_ring unsigned)))) : unique_factorization_monoid (left_cancel_monoid (semiring (ordered_ring unsigned))) := sorry --non-trivial
lemma new_lemma_82057 (h0 : complete_lattice (complete_semilattice_Sup (has_top num))) : is_compactly_generated (complete_semilattice_Sup (has_top num)) := sorry --non-trivial
lemma new_lemma_82058 (h0 : add_group (normed_group (has_norm linarith.comp))) : is_add_cyclic (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_82059 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82060 (h0 : topological_space (boolean_algebra.core (finset (finset linarith.comp)))) : locally_compact_space (boolean_algebra.core (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_82061 (h0 : complete_lattice (with_one empty)) : complete_lattice.is_Sup_finite_compact (with_one empty) := sorry --non-trivial
lemma new_lemma_82062 (h0 : filter (ring (has_zero name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82063 (h0 : fin has_zero.zero) : @group.fg.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82064 (h0 : uniform_space (encodable char)) : complete_space (encodable char) := sorry --non-trivial
lemma new_lemma_82065 (h0 : functor.add_const (finset (ordered_comm_monoid pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82066 (h0 : functor.comp group has_to_string name) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_82067 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_82068 (h0 : semiring (has_nndist (has_neg_part (normed_comm_ring pos)))) : is_noetherian_ring (has_nndist (has_neg_part (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_82069 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_82070 (h0 : complete_lattice (measure_theory.measure_space (non_assoc_semiring unsigned))) : is_compactly_generated (measure_theory.measure_space (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_82071 (h0 : ring (has_nnnorm (normed_field char))) : is_domain (has_nnnorm (normed_field char)) := sorry --non-trivial
lemma new_lemma_82072 (h1 : list (linear_ordered_add_comm_group (has_norm (has_top string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_82073 (h0 : complete_lattice environment.implicit_infer_kind) : is_atomistic environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_82074 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_82075 (h0 : functor.add_const (group (has_zero name)) pos) : @is_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_82076 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_82077 (h0 : fin has_zero.zero) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_82078 : id false := sorry --nsimp
lemma new_lemma_82079 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : totally_separated_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_82080 (h1 : group (uniform_space string_imp)) : is_cyclic (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_82081 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_82082 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82083 (h0 : not (has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_82084 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : normal_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82085 (h0 : functor.add_const (ring (boolean_algebra Type)) name) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_82086 (h0 : complete_lattice (has_pos_part (has_bot (has_pos_part (normed_lattice_add_comm_group Type))))) : is_compactly_generated (has_pos_part (has_bot (has_pos_part (normed_lattice_add_comm_group Type)))) := sorry --non-trivial
lemma new_lemma_82087 (h0 : functor.add_const (topological_space (has_bot pos)) linarith.comp) : @locally_compact_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82088 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_82089 (h0 : cancel_comm_monoid_with_zero (has_bot (option empty))) : unique_factorization_monoid (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_82090 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : irreducible_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82091 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_82092 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82093 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) ennreal) : @rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_82094 (h0 : topological_space (has_one (has_norm (has_norm empty)))) : totally_disconnected_space (has_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_82095 (h0 : add_monoid (has_nndist name)) : add_monoid.fg (has_nndist name) := sorry --non-trivial
lemma new_lemma_82096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_82097 (h0 : ring (has_to_string num)) : is_principal_ideal_ring (has_to_string num) := sorry --non-trivial
lemma new_lemma_82098 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82099 (h0 : set (add_comm_semigroup char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82100 (h0 : ring (ring (has_add (has_add linarith.comp)))) : is_domain (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_82101 (h0 : ring (comm_group (has_neg linarith.comp))) : is_domain (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_82102 (h0 : uniform_space (add_comm_monoid (has_neg linarith.comp))) : separated_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_82103 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid (option empty))) := sorry --non-trivial
lemma new_lemma_82104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_82105 (h0 : not (topological_space (semiring linarith.ineq) -> false)) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_82106 (h3 : topological_space (has_lt linarith.ineq)) : t0_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_82107 (h0 : prod (boolean_algebra.core (option ennreal)) (boolean_algebra.core (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_82108 (h0 : functor.comp ring finset name) : @rank_condition.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_82109 (h1 : complete_lattice (mul_one_class linarith.comp_source)) : is_compactly_generated (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82110 (h0 : has_coe (add_comm_semigroup string.iterator_imp) Prop) (h1 : add_comm_semigroup string.iterator_imp) : @coe_b.{1 1} (add_comm_semigroup.{0} string.iterator_imp) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_82111 (h0 : functor.add_const (ring (has_neg linarith.comp)) Type) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_82112 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @normal_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_82113 (h0 : random_gen linarith.ineq -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_82114 (h0 : group (omega_complete_partial_order unsigned)) : group.fg (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_82115 (h0 : add_monoid (add_group (has_top linarith.comp))) : add_monoid.fg (add_group (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_82116 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_82117 (h0 : functor.add_const (complete_lattice (ordered_ring empty)) empty) : @is_compactly_generated.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_82118 (h0 : topological_space (add_comm_monoid (has_neg name))) : discrete_topology (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_82119 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82120 (h0 : list (linear_ordered_field (cancel_monoid pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82121 (h0 : random_gen string_imp -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_82122 (h2 : has_lt (mul_one_class std_gen)) : no_max_order (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_82123 (h0 : complete_lattice (boolean_algebra (ring (ring name)))) : is_atomistic (boolean_algebra (ring (ring name))) := sorry --non-trivial
lemma new_lemma_82124 (h0 : uniform_space (non_assoc_semiring unsigned)) : complete_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_82125 (h0 : topological_space (normed_comm_ring ennreal)) : locally_compact_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_82126 (h1 : topological_space (mul_one_class (mul_one_class (mul_one_class enat)))) : totally_disconnected_space (mul_one_class (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_82127 (h0 : uniform_space (linear_ordered_comm_group congr_arg_kind)) : separated_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82128 (h0 : functor.add_const (semiring (as_linear_order unsigned)) unsigned) : @is_noetherian_ring.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82129 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_82130 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_82131 (h0 : add_group (has_compl fun_info)) : is_add_cyclic (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_82132 (h0 : uniform_space (semigroup (has_pos_part linarith.comp))) : separated_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82133 (h0 : function.extfun empty (fun (x : empty), Prop)) (h1 : filter empty) : filter.frequently (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_82134 (h0 : topological_space (has_neg (has_to_string (ring Type)))) : locally_compact_space (has_neg (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_82135 (h0 : functor.add_const (ring (finset ennreal)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82136 (h0 : ring (has_lt (random_gen (random_gen char)))) : is_domain (has_lt (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_82137 (h0 : topological_space (has_one (semiring (semiring empty)))) : locally_compact_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_82138 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_82139 (h1 : topological_space (has_emptyc (has_top to_additive.value_type))) : irreducible_space (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82140 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_82141 (h0 : functor.add_const (finset (has_to_string unsigned)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82142 (h0 : not (group (distrib to_additive.value_type) -> false)) : @is_cyclic.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_82143 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @totally_separated_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82144 (h0 : list (has_norm (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} (has_norm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_82146 (h0 : topological_space (with_bot linarith.ineq)) : totally_separated_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_82147 (h0 : add_monoid (has_to_string (has_to_string Type))) : add_monoid.fg (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_82148 (h0 : uniform_space (semigroup (has_Inf Type))) : complete_space (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_82149 (h2 : uniform_space (topological_space char)) : complete_space (topological_space char) := sorry --non-trivial
lemma new_lemma_82150 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_82151 (h0 : add_monoid (semiring empty)) (h1 : has_one (semiring empty)) : char_zero (semiring empty) := sorry --non-trivial
lemma new_lemma_82152 (h0 : not (ring unsigned -> false)) : @strong_rank_condition.{0} unsigned (@classical.by_contradiction'.{1} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_82153 (h0 : functor.add_const (topological_space (comm_group name)) name) : @discrete_topology.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_82154 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_82155 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : loc_path_connected_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_82156 (h0 : ring (has_add (add_left_cancel_monoid pos))) : rank_condition (has_add (add_left_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_82157 (h0 : topological_space (encodable (random_gen char))) : locally_compact_space (encodable (random_gen char)) := sorry --non-trivial
lemma new_lemma_82158 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_82159 (h0 : topological_space (has_pos_part (has_add (has_Inf (has_Inf (has_Inf Type)))))) : t0_space (has_pos_part (has_add (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_82160 (h1 : set (add_comm_semigroup std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_82161 (h0 : uniform_space (metric_space (semiring (semiring (semiring (semiring empty)))))) : separated_space (metric_space (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_82162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82163 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82164 (h0 : uniform_space (boolean_algebra (finset pos))) : complete_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_82165 (h0 : function.extfun Type ring) : @is_domain.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82166 (h0 : functor.add_const (function.extfun (Type 1) finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_82167 (h0 : group (random_gen string_imp)) : is_cyclic (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_82168 (h0 : not (topological_space (with_one to_additive.value_type) -> false)) : @discrete_topology.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_82169 (h2 : ring (add_monoid linarith.comp_source)) : rank_condition (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82170 (h0 : group fun_info) (h1 : subgroup fun_info) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_82171 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) pos) : @separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_82172 (h0 : functor.add_const (add_monoid (ring linarith.comp)) Type) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_82173 (h0 : complete_lattice (has_norm (has_norm (has_norm linarith.comp_source)))) : is_atomistic (has_norm (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_82174 (h0 : complete_lattice (has_Sup unsigned)) : is_atomistic (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_82175 (h0 : list (has_inter empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82176 (h0 : topological_space (partial_order (semiring (semiring congr_arg_kind)))) : discrete_topology (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82177 (h1 : not (has_mem.mem monoid has_emptyc.emptyc -> false)) : @monoid.fg.{0} string_imp (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h1)) string_imp)  := sorry --non-trivial
lemma new_lemma_82178 (h0 : monoid (has_one (has_norm (has_top (has_top unsigned))))) : monoid.fg (has_one (has_norm (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_82179 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (semigroup name)) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_82180 (h0 : group (semigroup (option empty))) : group.fg (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_82181 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_82182 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_zero (has_zero (has_zero pos)))) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_82183 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82184 (h0 : filter (finset (finset (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82185 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_82186 (h0 : complete_lattice (has_star (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82187 (h0 : filter (has_inter (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82188 (h0 : not (has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_82189 (h0 : topological_space (comm_group (cancel_monoid pos))) : sequential_space (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_82190 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82191 (h0 : topological_space (has_dist (option num))) : t1_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_82192 (h0 : functor.add_const (add_monoid (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82193 (h0 : group (ordered_cancel_add_comm_monoid (option unsigned))) : group.fg (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_82194 (h0 : complete_lattice (semi_normed_ring (has_lt char))) : is_compactly_generated (semi_normed_ring (has_lt char)) := sorry --non-trivial
lemma new_lemma_82195 (h0 : functor.add_const (topological_space (ring Type)) (has_neg (has_neg pos))) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_82196 (h0 : semiring (linear_ordered_semiring (has_union linarith.comp))) : is_noetherian_ring (linear_ordered_semiring (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_82197 (h0 : topological_space (semigroup (mul_one_class (mul_one_class Type)))) : normal_space (semigroup (mul_one_class (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_82198 (h0 : group (has_neg_part unsigned)) : group.fg (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_82199 (h0 : add_monoid (has_emptyc (random_gen fun_info))) : add_monoid.fg (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_82200 (h0 : functor.add_const (fin has_zero.zero) Type) : @preirreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_82201 (h0 : list (has_nndist (has_add (has_add name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82202 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82203 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_82204 (h0 : complete_lattice (with_one (comm_ring linarith.ineq))) : is_compactly_generated (with_one (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82205 (h0 : topological_space (has_top (has_inner empty unsigned))) : normal_space (has_top (has_inner empty unsigned)) := sorry --non-trivial
lemma new_lemma_82206 (h0 : not (semiring (has_sub linarith.comp) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_82207 (h0 : complete_lattice (with_one (has_top (semiring congr_arg_kind)))) : is_atomistic (with_one (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82208 (h1 : complete_lattice (has_nnnorm num)) : is_compactly_generated (has_nnnorm num) := sorry --non-trivial
lemma new_lemma_82209 (h0 : topological_space (semigroup (ring (ring Type)))) : t1_space (semigroup (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_82210 (h0 : not (add_group (semi_normed_ring string_imp) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_82211 (h0 : not (topological_space (linear_ordered_semiring num) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_82212 (h0 : fin has_zero.zero) : @normal_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_82213 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82214 (h0 : topological_space (has_Sup (option (option unsigned)))) : loc_path_connected_space (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_82215 (h0 : semiring (ring (ordered_ring (has_pos_part Type)))) : is_noetherian_ring (ring (ordered_ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_82216 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid real)) (has_bot pos)) : @archimedean.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} real)) (has_bot.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_82217 (h0 : set (mul_one_class ereal -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82218 (h0 : functor.add_const (add_group (cancel_monoid pos)) pos) : @is_add_cyclic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82219 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @preirreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82220 (h0 : functor.comp add_group semigroup environment.implicit_infer_kind) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_group.{0} semigroup.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82221 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_82222 (h0 : not (complete_lattice (semiring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82223 (h0 : topological_space (has_edist (semiring (semiring empty)))) : totally_separated_space (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_82224 (h0 : semiring (complete_linear_order num)) : is_noetherian_ring (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_82225 (h0 : complete_lattice (fintype (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_82226 (h0 : functor.add_const (prod (ordered_ring empty) (ordered_ring empty)) num) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82227 (h0 : functor.add_const (ring (preorder congr_arg_kind)) (semiring (semiring (semiring num)))) : @strong_rank_condition.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_82228 (h0 : functor.add_const (functor.add_const (function.extfun Type complete_lattice) Type) (has_neg pos)) : @is_compactly_generated.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type) (has_neg.{0} pos) h0)) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82229 (h0 : filter (has_to_string (finset (finset (has_nndist (finset (finset pos))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82230 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_82231 (h0 : topological_space (mul_zero_class (has_neg_part Type))) : t1_space (mul_zero_class (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_82232 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_82233 (h1 : topological_space (comm_ring (comm_ring (denumerable to_additive.value_type)))) : t0_space (comm_ring (comm_ring (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82234 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) unsigned) : @regular_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82235 (h0 : topological_space (comm_group unsigned)) : preirreducible_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_82236 (h0 : semiring (has_pos_part (has_Inf (has_Inf Type)))) : is_noetherian_ring (has_pos_part (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_82237 (h0 : topological_space (add_comm_monoid (ring environment.implicit_infer_kind))) : t1_space (add_comm_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82238 (h0 : topological_space (has_zero (option (option unsigned)))) : totally_separated_space (has_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_82239 (h0 : monoid (has_zero num)) : monoid.fg (has_zero num) := sorry --non-trivial
lemma new_lemma_82240 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_82241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_82242 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82243 (h0 : functor.add_const Prop (boolean_algebra (has_add name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_82244 (h0 : group (mul_zero_class (semiring empty))) : is_cyclic (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_82245 (h0 : ordered_add_comm_monoid (finset (option pos))) : archimedean (finset (option pos)) := sorry --non-trivial
lemma new_lemma_82246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82247 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82248 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) (has_add pos)) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_82249 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : totally_separated_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82250 (h0 : topological_space (has_add (has_neg linarith.comp))) : normal_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_82251 (h3 : topological_space enat) : t0_space enat := sorry --non-trivial
lemma new_lemma_82252 (h0 h1 : multiset (semi_normed_ring string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_82253 (h0 : not (topological_space (measurable_space unsigned) -> false)) : @path_connected_space.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_82254 (h0 : topological_space (normed_lattice_add_comm_group Type)) : totally_separated_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_82255 (h0 : functor.add_const (finset (finset pos)) (finset environment.implicit_infer_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82256 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_82257 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82258 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.comp_source) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82259 (h0 : complete_lattice (has_edist (semiring empty))) : is_compactly_generated (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_82260 (h0 : topological_space (random_gen (random_gen (random_gen string_imp)))) : totally_separated_space (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_82261 (h0 : topological_space (complete_semilattice_Sup string_imp)) : path_connected_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_82262 (h0 : functor.comp (prod (option name)) option name) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_82263 (h0 : add_group (has_bot (has_Inf pos))) : is_add_cyclic (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_82264 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82265 (h0 : not (topological_space (add_cancel_comm_monoid linarith.comp_source) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82266 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_82267 (h0 : functor.add_const (complete_lattice (semigroup Type)) (finset linarith.comp)) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_82268 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) Type) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_82269 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_82270 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : t1_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82271 (h0 : monoid (complete_linear_order empty)) : monoid.fg (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_82272 (h0 h1 : multiset (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_82273 (h0 : topological_space (generalized_boolean_algebra (has_add (has_neg (has_add name))))) : preconnected_space (generalized_boolean_algebra (has_add (has_neg (has_add name)))) := sorry --non-trivial
lemma new_lemma_82274 (h0 : group (boolean_algebra.core (semigroup name))) : group.fg (boolean_algebra.core (semigroup name)) := sorry --non-trivial
lemma new_lemma_82275 (h0 : fin has_zero.zero) : @irreducible_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_82276 (h0 : functor.add_const (function.extfun (Type 1) list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_82277 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82278 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) pos) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_82279 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @locally_compact_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_82280 (h0 : topological_space (normed_comm_ring pos)) : path_connected_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_82281 (h2 : topological_space (distrib to_additive.value_type)) : path_connected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82282 (h0 : function.extfun Type ring) : @is_domain.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_82283 (h0 : topological_space (normed_comm_ring (has_nndist ennreal))) : loc_path_connected_space (normed_comm_ring (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_82284 (h0 : filter (has_nnnorm linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82286 (h0 : topological_space (has_append (has_ssubset linarith.comp_source))) : path_connected_space (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82287 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_82288 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_82289 (h0 : add_monoid (non_assoc_semiring empty)) : add_monoid.fg (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_82290 (h0 : list (has_inv (has_inv (has_norm (random_gen string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82291 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_82292 (h0 : add_monoid (semiring (has_emptyc fun_info))) : add_monoid.fg (semiring (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_82293 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_82294 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82295 (h0 : topological_space (distrib_lattice (has_nnnorm fun_info))) : t0_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_82296 (h1 : ring (normed_field fun_info)) : is_domain (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_82297 (h0 : topological_space (finset (ring (has_to_string pos)))) : t1_space (finset (ring (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_82298 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_82299 (h0 : ring (has_neg (has_Inf (has_pos_part (has_neg (has_add Type)))))) : is_domain (has_neg (has_Inf (has_pos_part (has_neg (has_add Type))))) := sorry --non-trivial
lemma new_lemma_82300 (h0 : topological_space (normed_group (has_top linarith.ineq))) : irreducible_space (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82301 (h0 : topological_space (ring ennreal)) : path_connected_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_82302 (h0 : ring (ordered_ring (semiring (semiring (semiring congr_arg_kind))))) : strong_rank_condition (ordered_ring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_82303 (h0 : topological_space (has_emptyc (emetric_space fun_info))) : totally_separated_space (has_emptyc (emetric_space fun_info)) := sorry --non-trivial
lemma new_lemma_82304 (h0 : ring (has_zero (has_to_string (ring pos)))) : is_domain (has_zero (has_to_string (ring pos))) := sorry --non-trivial
lemma new_lemma_82305 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : totally_separated_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82306 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_82307 (h0 : function.extfun Type (functor.add_const (topological_space (add_group num)))) : @topological_space.separable_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_group.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_82308 (h0 : filter (with_one (semiring (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82309 (h0 : ring (measurable_space.dynkin_system (semiring (semiring num)))) : is_domain (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_82310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_82311 (h0 : topological_space (has_add (has_nndist linarith.comp))) : locally_compact_space (has_add (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_82312 (h0 : list (has_to_string (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82313 (h0 : topological_space (plift (semiring (semiring congr_arg_kind)))) : preirreducible_space (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82314 (h0 : ulower pnat) (h1 : ulower (ulower pnat)) : pnat.coprime (ulower.up h0) (ulower.up (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_82315 (h0 : topological_space (has_zero (comm_group (has_add (has_add (has_to_string unsigned)))))) : loc_path_connected_space (has_zero (comm_group (has_add (has_add (has_to_string unsigned))))) := sorry --non-trivial
lemma new_lemma_82316 (h0 : topological_space (topological_space fun_info)) : preconnected_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_82317 (h1 : set (normed_field std_gen -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_82318 (h0 : functor.add_const (functor.add_const Prop (ring name)) (has_add (ring (ring pos)))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82319 (h0 : group (ring (has_pos_part linarith.comp))) : group.fg (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82320 (h2 : ring (has_add char)) : rank_condition (has_add char) := sorry --non-trivial
lemma new_lemma_82321 (h0 : add_comm_semigroup ereal -> Prop) (h1 : unit) : set.finite (matrix.row h0 h1) := sorry --non-trivial
lemma new_lemma_82322 (h0 : functor.add_const (topological_space (semigroup pos)) (has_Inf linarith.comp)) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_82323 (h0 : topological_space (cancel_monoid (comm_group (add_comm_monoid environment.implicit_infer_kind)))) : irreducible_space (cancel_monoid (comm_group (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_82324 (h0 : topological_space (has_add (has_bot linarith.comp))) : path_connected_space (has_add (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_82325 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82326 (h0 : topological_space (has_lt string_imp)) : t0_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_82327 (h0 : group (with_bot fun_info)) : is_cyclic (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_82328 (h0 : group (comm_ring (normed_group reducibility_hints))) : is_cyclic (comm_ring (normed_group reducibility_hints)) := sorry --non-trivial
lemma new_lemma_82329 (h0 : functor.add_const (ring (finset linarith.comp)) Type) : @strong_rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_82330 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} (has_nnnorm.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_82331 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) (semiring unsigned)) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_82332 (h0 : complete_lattice (uniform_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82333 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82334 (h0 : linear_ordered_field (has_add ennreal) -> linear_ordered_field (has_add ennreal) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_82335 (h0 : set (has_lt (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class char)))))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_82336 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_82337 (h0 : fin has_zero.zero) : @is_simple_group.{0} real (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) real)  := sorry --non-trivial
lemma new_lemma_82338 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_82339 (h0 : complete_lattice (ordered_comm_ring name)) : is_compactly_generated (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_82340 (h0 : uniform_space (has_top (random_gen (random_gen fun_info)))) : complete_space (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_82341 (h0 : list (has_star (semiring (semiring (semiring congr_arg_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82342 (h0 : functor.add_const (topological_space (ring Type)) pos) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_82343 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) pos) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82344 (h1 h2 : multiset (distrib enat)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_82345 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_82346 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_82347 (h0 : linear_ordered_field (finset ennreal) -> linear_ordered_field (finset ennreal) -> Prop) : is_symm (linear_ordered_field (finset ennreal)) h0 := sorry --non-trivial
lemma new_lemma_82348 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_82349 (h0 : not (group (has_append char) -> false)) : @is_cyclic.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_82350 (h0 : has_lt (has_ssubset enat)) : no_max_order (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_82351 (h0 : functor.add_const (topological_space (preorder num)) empty) : @locally_compact_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_82352 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_82353 (h0 : complete_lattice (has_norm empty)) : complete_lattice.is_Sup_finite_compact (has_norm empty) := sorry --non-trivial
lemma new_lemma_82354 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @t0_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_82355 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_82356 (h0 : not (topological_space (has_inv fun_info) -> false)) : @path_connected_space.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_82357 (h0 : not (group (complete_semilattice_Sup fun_info) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_82358 (h0 : not (add_group (complete_linear_order num) -> false)) : @is_add_cyclic.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_82359 (h0 : complete_lattice (distrib_lattice (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82360 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_82361 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_82362 (h1 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : path_connected_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_82363 (h0 : topological_space (has_emptyc linarith.comp)) : locally_compact_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_82364 (h0 : topological_space environment.implicit_infer_kind) : loc_path_connected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_82365 (h0 : monoid (comm_group (has_neg_part Type))) : monoid.fg (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_82366 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid pos) pos) pos) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_82367 (h0 : topological_space (has_Inf (boolean_algebra linarith.comp))) : totally_separated_space (has_Inf (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_82368 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) name) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_82369 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_semigroup empty)) (option (option unsigned))) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_82370 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} name (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_82371 (h0 : uniform_space (has_zero (option (option pos)))) : complete_space (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_82372 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_82373 (h0 : topological_space (simple_graph congr_arg_kind)) : locally_compact_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82374 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_82375 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_82376 (h0 : topological_space (normed_comm_ring (has_to_string name))) : irreducible_space (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_82377 (h0 : topological_space (preorder (semiring unsigned))) : irreducible_space (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_82378 (h0 : has_mem.mem Type has_emptyc.emptyc) : @rank_condition.{1} Type (@finset.pi.empty.{2 1} (Type 1) ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_82379 (h1 : ring (with_zero fun_info)) : strong_rank_condition (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_82380 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_82381 (h0 : uniform_space (has_append (random_gen (random_gen char)))) : complete_space (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_82382 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82383 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_82384 (h2 : filter (fintype to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_82385 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82386 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_82387 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_82388 (h0 : ring (simple_graph (has_add (has_to_string (has_add pos))))) : rank_condition (simple_graph (has_add (has_to_string (has_add pos)))) := sorry --non-trivial
lemma new_lemma_82389 (h0 : not (ring (linear_ordered_semiring fun_info) -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_82390 (h1 : not (filter (random_gen string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_82391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_82392 (h0 : functor.add_const (function.extfun Type ring) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_Sup.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind h0) (has_Sup.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_82393 (h0 : complete_lattice (has_norm num)) : complete_lattice.is_Sup_finite_compact (has_norm num) := sorry --non-trivial
lemma new_lemma_82394 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid unsigned)) num) : @archimedean.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_82395 (h0 : ring (has_add (sub_neg_monoid (has_Inf real)))) : strong_rank_condition (has_add (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_82396 (h0 : topological_space (has_pos_part pos)) : loc_path_connected_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_82397 (h0 : topological_space (has_neg (finset (finset (finset (finset (finset linarith.comp))))))) : path_connected_space (has_neg (finset (finset (finset (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_82398 (h0 : group (has_zero name)) : normalizer_condition (has_zero name) := sorry --non-trivial
lemma new_lemma_82399 (h0 : not (filter (measurable_space empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_82400 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : path_connected_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_82401 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_82402 (h0 : finset (finset (add_cancel_monoid (has_neg (finset (finset environment.implicit_infer_kind)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82403 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_82404 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_82405 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (finset pos)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (finset.{0} pos) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_82406 (h0 : functor.add_const (list (canonically_ordered_comm_semiring Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82407 (h0 : group (has_zero (has_add (has_add Type)))) : is_simple_group (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_82408 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82409 (h0 : set (fun_info -> add_comm_semigroup environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82410 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_82411 (h0 : group (add_right_cancel_monoid unsigned)) : group.fg (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_82412 (h0 : function.extfun Type linear_ordered_field) : list.nodup (list.ret (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_82413 (h0 : functor.add_const (group (option unsigned)) unsigned) : @normalizer_condition.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82414 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (normed_lattice_add_comm_group.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_82415 (h0 : topological_space (simple_graph (has_add linarith.comp))) : totally_separated_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_82416 (h0 : topological_space (has_one num)) : t0_space (has_one num) := sorry --non-trivial
lemma new_lemma_82417 (h0 : group (has_to_string (has_pos_part Type))) : normalizer_condition (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_82418 (h0 : functor.add_const (finset (normed_linear_ordered_group num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82419 (h1 : topological_space (simple_graph (has_compl (has_compl reducibility_hints)))) : t0_space (simple_graph (has_compl (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_82420 (h0 : group (comm_group (has_neg_part Type))) : group.fg (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_82421 (h0 : functor.add_const (topological_space (linear_ordered_field unsigned)) pos) : @path_connected_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_82422 (h0 : uniform_space (simple_graph (has_neg Type))) : separated_space (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_82423 (h0 : topological_space (has_norm (has_nnnorm linarith.comp_source))) : t0_space (has_norm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82424 (h1 : ring environment.projection_info) : rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_82425 (h0 : topological_space (has_top (random_gen to_additive.value_type))) : t0_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82426 (h0 : topological_space (comm_monoid congr_arg_kind)) : discrete_topology (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82427 (h0 : topological_space (add_cancel_monoid (has_neg (finset pos)))) : sequential_space (add_cancel_monoid (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_82428 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : regular_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_82429 (h0 : topological_space (has_compl (mul_one_class to_additive.value_type))) : t0_space (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82430 (h0 : topological_space (has_bot unsigned)) : totally_separated_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_82431 (h0 : ring (ordered_comm_ring pos)) : is_principal_ideal_ring (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_82432 (h1 : random_gen (linear_ordered_add_comm_group char) -> random_gen (linear_ordered_add_comm_group char) -> Prop) : is_trans (random_gen (linear_ordered_add_comm_group char)) h1 := sorry --non-trivial
lemma new_lemma_82433 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82434 (h0 : complete_lattice (add_cancel_monoid (has_neg Type))) : is_compactly_generated (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_82435 (h0 : group (pseudo_metric_space pos)) : group.fg (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_82436 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @separated_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_82437 (h0 : ring (group_with_zero (option ennreal))) : strong_rank_condition (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_82438 (h0 : filter (distrib_lattice (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82439 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82440 (h0 : group (option (option (option unsigned)))) : group.fg (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_82441 (h0 : ring (dlist (has_ssubset linarith.ineq))) : is_domain (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82442 (h0 : monoid (has_neg pos)) : monoid.fg (has_neg pos) := sorry --non-trivial
lemma new_lemma_82443 (h0 : topological_space (non_assoc_semiring (semiring empty))) : totally_disconnected_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_82444 (h0 : topological_space (has_zero (finset linarith.comp))) : preirreducible_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_82445 (h0 : functor.add_const (functor.add_const (uniform_space stieltjes_function) empty) (option empty)) : @separated_space.{0} stieltjes_function (@functor.add_const.run.{0 0} (uniform_space.{0} stieltjes_function) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} stieltjes_function) empty) (option.{0} empty) h0))  := sorry --non-trivial
lemma new_lemma_82446 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid Type)) real) : @regular_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) real h0)  := sorry --non-trivial
lemma new_lemma_82447 (h0 : cancel_comm_monoid_with_zero (has_to_string (option ennreal))) : unique_factorization_monoid (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_82448 (h0 : topological_space (add_group (semiring (semiring num)))) : discrete_topology (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_82449 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_82450 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_82452 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_82453 (h0 : topological_space (canonically_ordered_add_monoid (comm_monoid congr_arg_kind))) : path_connected_space (canonically_ordered_add_monoid (comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_82454 (h0 : not (add_group (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_82455 (h0 : functor.add_const (functor.add_const (topological_space name) congr_arg_kind) congr_arg_kind) : @locally_compact_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_82456 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_82457 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_82458 (h0 : not (add_group (has_union empty) -> false)) : @is_add_cyclic.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_82459 (h2 : complete_lattice (normed_field to_additive.value_type)) : is_compactly_generated (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82460 (h0 : fin has_zero.zero) : @is_simple_group.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_82461 (h0 : function.extfun Type (functor.add_const (group (omega_complete_partial_order empty)))) : @group.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (omega_complete_partial_order.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_82462 (h0 : complete_lattice (complete_linear_order unsigned)) : is_atomistic (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_82463 (h0 : topological_space (has_nndist (comm_group (comm_group unsigned)))) : irreducible_space (has_nndist (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_82464 (h0 : topological_space (distrib_lattice (random_gen (has_norm linarith.ineq)))) : irreducible_space (distrib_lattice (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_82465 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_82466 (h0 : topological_space (ordered_comm_ring pos)) : preirreducible_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_82467 (h0 : functor.add_const (list (normed_comm_ring name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82468 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_82469 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82470 (h0 : functor.add_const (functor.add_const (semiring (has_add name)) pos) pos) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} name)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (semiring.{0} (has_add.{0} name)) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_82471 (h0 : measurable_space (has_compl linarith.ineq)) (h1 : filter (has_compl linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_82472 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_82473 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_82474 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_82475 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82476 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf (boolean_algebra linarith.comp))))) : irreducible_space (boolean_algebra (has_pos_part (has_Inf (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_82477 (h0 : Type) (h1 : add_group (parse_result h0)) : is_add_cyclic (parse_result h0) := sorry --non-trivial
lemma new_lemma_82478 (h0 : topological_space (ordered_comm_ring (has_add real))) : locally_compact_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_82479 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_82480 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_82481 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82482 (h0 : ring (has_neg_part (option (has_neg_part ennreal)))) : rank_condition (has_neg_part (option (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_82483 (h0 : ring (complete_semilattice_Sup (has_top (random_gen fun_info)))) : is_domain (complete_semilattice_Sup (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_82484 (h0 : ordered_comm_monoid (has_bot linarith.comp)) : has_exists_mul_of_le (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_82485 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82486 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_82487 (h0 : group (boolean_algebra.core (has_Inf pos))) : group.fg (boolean_algebra.core (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_82488 (h0 : uniform_space (ordered_ring empty)) : complete_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_82489 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : totally_disconnected_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_82490 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82491 (h0 : functor.add_const (uniform_space (finset pos)) Type) : @separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_82492 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_82493 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (comm_group Type)) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_82494 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_82495 (h0 : topological_space (measurable_space (has_norm (has_norm (random_gen linarith.comp))))) : totally_disconnected_space (measurable_space (has_norm (has_norm (random_gen linarith.comp)))) := sorry --non-trivial
lemma new_lemma_82496 (h0 : ring (comm_group (has_to_string pos))) : is_principal_ideal_ring (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_82497 (h0 : semiring (comm_group unsigned)) : is_noetherian_ring (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_82498 (h0 : semiring (option (linear_ordered_comm_ring num))) : is_noetherian_ring (option (linear_ordered_comm_ring num)) := sorry --non-trivial
lemma new_lemma_82499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82500 (h1 : ring (id (random_gen num))) : is_domain (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_82501 (h0 : functor.add_const (ring (add_cancel_monoid pos)) (has_neg Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_82502 (h0 : topological_space (comm_group (semigroup num))) : normal_space (comm_group (semigroup num)) := sorry --non-trivial
lemma new_lemma_82503 (h0 : add_monoid (canonically_ordered_add_monoid congr_arg_kind)) : add_monoid.fg (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82504 (h2 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h2)  := sorry --non-trivial
lemma new_lemma_82505 (h0 : add_group (has_Inf (has_Inf name))) : is_add_cyclic (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_82506 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm fun_info))) : is_domain (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_82507 (h0 : fin has_zero.zero) : @is_simple_group.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82508 (h0 : semiring (mv_power_series empty (semiring empty))) : is_noetherian_ring (mv_power_series empty (semiring empty)) := sorry --non-trivial
lemma new_lemma_82509 (h0 : function.extfun (finset Type) (has_mem.mem (has_one unsigned))) : @group.fg.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type group.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_82510 (h0 : functor.add_const (semiring (linear_ordered_field congr_arg_kind)) num) : @is_noetherian_ring.{0} (linear_ordered_field.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_field.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_82511 (h0 : not (cancel_comm_monoid_with_zero (normed_group congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_82512 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_82513 (h0 : functor.add_const (monoid (cancel_monoid unsigned)) (add_comm_monoid environment.implicit_infer_kind)) : @monoid.fg.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} unsigned)) (add_comm_monoid.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_82514 (h0 : topological_space (topological_space (denumerable char))) : path_connected_space (topological_space (denumerable char)) := sorry --non-trivial
lemma new_lemma_82515 (h0 h1 : multiset (add_comm_semigroup (add_comm_semigroup fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_82516 (h0 : add_monoid (has_nndist (ring linarith.comp))) : add_monoid.fg (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_82517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} (has_neg.{0} linarith.comp)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_82518 (h0 : topological_space (linear_ordered_field (has_nndist name))) : discrete_topology (linear_ordered_field (has_nndist name)) := sorry --non-trivial
lemma new_lemma_82519 (h0 : not (complete_lattice (complete_linear_order empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_82520 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_ring real))) : totally_disconnected_space (generalized_boolean_algebra (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_82521 (h0 : topological_space (comm_ring (distrib_lattice linarith.ineq))) : t0_space (comm_ring (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82522 (h0 : ring (with_bot (random_gen (has_top linarith.ineq)))) : is_domain (with_bot (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_82523 (h0 : list (linear_ordered_cancel_comm_monoid (linear_ordered_comm_monoid_with_zero unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82524 (h0 : not (filter Prop -> false)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@classical.by_contradiction'.{1} (filter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_82525 (h1 : topological_space reducibility_hints) (h2 : preorder reducibility_hints) : order_topology reducibility_hints := sorry --non-trivial
lemma new_lemma_82526 (h0 : group (ordered_comm_ring (finset Type))) : is_cyclic (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_82527 (h0 : topological_space (has_neg_part (semigroup unsigned))) : irreducible_space (has_neg_part (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_82528 (h0 : list (option (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82529 (h0 : ring (add_comm_monoid (option ennreal))) : strong_rank_condition (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_82530 (h0 : topological_space (random_gen linarith.comp)) : totally_disconnected_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_82531 (h0 : topological_space (finset (semigroup (boolean_algebra name)))) : preirreducible_space (finset (semigroup (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_82532 (h0 : functor.add_const (finset environment.implicit_infer_kind) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82533 (h0 : monoid (has_nndist (has_to_string linarith.comp))) : monoid.fg (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_82534 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core (finset Type)))) : discrete_topology (boolean_algebra.core (boolean_algebra.core (finset Type))) := sorry --non-trivial
lemma new_lemma_82535 (h0 : ring (ring (has_add (has_neg pos)))) : strong_rank_condition (ring (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_82536 (h0 : functor.add_const (ordered_add_comm_monoid Type) (boolean_algebra (has_neg (has_neg pos)))) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) (boolean_algebra.{0} (has_neg.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_82537 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) (ring (ring (ring linarith.comp)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82538 (h0 : functor.add_const (group (add_cancel_monoid Type)) linarith.comp) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82539 (h0 : not (uniform_space (div_inv_monoid linarith.ineq) -> false)) : @complete_space.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_82540 (h0 : add_monoid (group_with_zero ennreal)) : add_monoid.fg (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_82541 (h0 : topological_space (complete_distrib_lattice (cancel_monoid environment.implicit_infer_kind))) : loc_path_connected_space (complete_distrib_lattice (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82542 (h0 : complete_lattice (linear_ordered_semiring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82543 (h0 : ordered_add_comm_monoid (add_cancel_monoid ennreal)) : archimedean (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_82544 (h0 : semiring (simple_graph (has_dist (has_dist (has_dist (comm_monoid (has_dist num))))))) : is_noetherian_ring (simple_graph (has_dist (has_dist (has_dist (comm_monoid (has_dist num)))))) := sorry --non-trivial
lemma new_lemma_82545 (h0 : functor.add_const (topological_space (free_add_monoid empty)) congr_arg_kind) : @totally_separated_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_82546 (h0 : topological_space (cancel_monoid (semigroup (comm_group (semigroup (has_add (add_cancel_monoid name))))))) : t0_space (cancel_monoid (semigroup (comm_group (semigroup (has_add (add_cancel_monoid name)))))) := sorry --non-trivial
lemma new_lemma_82547 (h0 : functor.comp semiring has_nndist name) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_82548 (h0 : topological_space (canonically_ordered_add_monoid (option empty))) : locally_compact_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_82549 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_82550 (h0 : topological_space (metric_space (metric_space num))) : normal_space (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_82551 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_82552 (h0 : not (complete_lattice auto.case_option -> false)) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@classical.by_contradiction'.{1} (complete_lattice.{0} auto.case_option) h0)  := sorry --non-trivial
lemma new_lemma_82553 (h0 : group (add_cancel_monoid (comm_group (comm_group (comm_group (comm_group Type)))))) : normalizer_condition (add_cancel_monoid (comm_group (comm_group (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_82554 (h0 : topological_space (add_right_cancel_monoid num)) : preirreducible_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_82555 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_82556 (h0 : filter (with_bot congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82557 (h0 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class fun_info)) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82558 (h0 : ring (has_append (comm_ring (has_nnnorm fun_info)))) : strong_rank_condition (has_append (comm_ring (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_82559 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82560 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_82561 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82562 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset (finset (finset linarith.comp)))) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} (finset.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_82563 (h0 : group (has_to_string (has_neg name))) : normalizer_condition (has_to_string (has_neg name)) := sorry --non-trivial
lemma new_lemma_82564 (h0 : functor.add_const (uniform_space (has_add Type)) Type) : @complete_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_82565 (h0 : list (has_top (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82566 (h0 : list (simple_graph (complete_distrib_lattice empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82567 (h0 : topological_space real.angle) : discrete_topology real.angle := sorry --non-trivial
lemma new_lemma_82568 (h0 : topological_space (has_edist (option empty))) : locally_compact_space (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_82569 (h0 : not (complete_lattice (measurable_space.dynkin_system unsigned) -> false)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_82570 (h0 : complete_lattice (add_monoid (random_gen (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (add_monoid (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82571 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : discrete_topology (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_82572 (h0 : functor.add_const (complete_lattice Type) name) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_82573 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_82574 (h0 : ring (has_div (has_ssubset (has_ssubset (has_ssubset reducibility_hints))))) : strong_rank_condition (has_div (has_ssubset (has_ssubset (has_ssubset reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_82575 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : loc_path_connected_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_82576 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_82577 (h0 : group (finset (add_cancel_monoid (has_neg pos)))) : is_cyclic (finset (add_cancel_monoid (has_neg pos))) := sorry --non-trivial
lemma new_lemma_82578 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_82579 (h0 : functor.add_const (semiring (has_nndist pos)) Type) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_82580 (h0 : ordered_comm_monoid (has_Inf (has_zero (has_neg name)))) : has_exists_mul_of_le (has_Inf (has_zero (has_neg name))) := sorry --non-trivial
lemma new_lemma_82581 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_82582 (h0 : not (ring (with_one num) -> false)) : @is_domain.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_82583 (h0 : functor.comp topological_space add_comm_monoid unsigned) : @normal_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_82584 (h0 : ring (semiring (has_norm linarith.comp))) : strong_rank_condition (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_82585 (h0 : ring (bin_tree num)) : is_principal_ideal_ring (bin_tree num) := sorry --non-trivial
lemma new_lemma_82586 (h0 : topological_space (boolean_algebra pos)) : sequential_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_82587 (h0 : group (has_add linarith.comp)) : group.fg (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_82588 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @totally_disconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_82589 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) pos) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_82590 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_82591 (h1 : not (uniform_space reducibility_hints -> false)) : @complete_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (uniform_space.{0} reducibility_hints) h1)  := sorry --non-trivial
lemma new_lemma_82592 (h1 : group (normed_group linarith.comp_source)) : is_cyclic (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82593 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.comp_source) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82594 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) (ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82595 (h0 : functor.add_const (ring (ordered_ring unsigned)) unsigned) : @strong_rank_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82596 (h0 : group (complete_semilattice_Sup (with_bot string_imp))) : normalizer_condition (complete_semilattice_Sup (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_82597 (h0 : functor.add_const (filter (has_neg Type)) (has_Inf Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82598 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82599 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_82600 (h0 : ring (linear_ordered_add_comm_group linarith.ineq)) : strong_rank_condition (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_82601 (h0 : group (has_ssubset (with_bot (random_gen (with_bot (random_gen (with_bot string_imp))))))) : is_cyclic (has_ssubset (with_bot (random_gen (with_bot (random_gen (with_bot string_imp)))))) := sorry --non-trivial
lemma new_lemma_82602 (h0 : not (topological_space (has_sub empty) -> false)) : @discrete_topology.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_82603 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : loc_path_connected_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82604 (h0 : uniform_space (add_cancel_comm_monoid (has_lt reducibility_hints))) : complete_space (add_cancel_comm_monoid (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_82605 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : locally_compact_space (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82606 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82607 (h0 : ring (finset (has_Inf (has_to_string environment.implicit_infer_kind)))) : strong_rank_condition (finset (has_Inf (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_82608 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra unsigned))) : totally_separated_space (canonically_ordered_comm_semiring (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_82609 (h0 : function.extfun Type (functor.add_const (ring (plift congr_arg_kind)))) : @is_principal_ideal_ring.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} congr_arg_kind)) num (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} (plift.{1} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_82610 (h0 : topological_space (has_emptyc (has_emptyc (random_gen linarith.comp_source)))) : path_connected_space (has_emptyc (has_emptyc (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_82611 (h1 : topological_space (has_nnnorm char)) : t0_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_82612 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) pos) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82613 (h0 : has_coe (add_comm_semigroup char) Prop) (h2 : add_comm_semigroup char) : @coe_b.{1 1} (add_comm_semigroup.{0} char) Prop h0 h2  := sorry --non-trivial
lemma new_lemma_82614 (h0 : topological_space (has_lt enat)) : path_connected_space (has_lt enat) := sorry --non-trivial
lemma new_lemma_82615 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82616 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : topological_space.separable_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_82617 (h0 : topological_space (has_pos_part (has_neg Type))) : t1_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_82618 (h1 : has_lt (mul_one_class enat)) : no_max_order (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_82619 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_82620 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @t0_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82621 (h0 : group (add_cancel_comm_monoid (linear_ordered_comm_ring char))) : is_cyclic (add_cancel_comm_monoid (linear_ordered_comm_ring char)) := sorry --non-trivial
lemma new_lemma_82622 (h0 : comm_monoid (linear_ordered_semiring (random_gen string_imp))) (h1 : submonoid (linear_ordered_semiring (random_gen string_imp))) (h2 : filter (localization h1)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_82623 (h0 : topological_space (has_norm (has_ssubset linarith.comp_source))) : t0_space (has_norm (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82624 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_82625 (h4 : topological_space (semi_normed_comm_ring linarith.ineq)) : t0_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_82626 (h0 : uniform_space (normed_comm_ring (comm_group Type))) : separated_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_82627 (h1 : topological_space (has_nnnorm reducibility_hints)) : path_connected_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_82628 (h0 : uniform_space (ordered_comm_ring (boolean_algebra.core linarith.comp))) : complete_space (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_82629 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_82630 (h0 : list (ring (has_pos_part (has_Inf Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82631 (h0 : group (measurable_space (random_gen string_imp))) : normalizer_condition (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_82632 (h0 : ring (non_assoc_semiring congr_arg_kind)) : is_principal_ideal_ring (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82633 (h1 : ring to_additive.value_type) : rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_82634 (h0 : ring (add_cancel_comm_monoid (metric_space char))) : rank_condition (add_cancel_comm_monoid (metric_space char)) := sorry --non-trivial
lemma new_lemma_82635 (h0 : functor.add_const (group (has_zero linarith.comp)) name) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_82636 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf Type)))) : locally_compact_space (sub_neg_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_82637 (h0 : topological_space (has_ssubset string_imp)) : t0_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_82638 (h0 : group (topological_space char)) : group.fg (topological_space char) := sorry --non-trivial
lemma new_lemma_82639 (h0 : measurable_space (has_ssubset linarith.ineq)) (h1 : measure_theory.measure (has_ssubset linarith.ineq)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_82640 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_82641 (h0 : not (add_group (uniform_space linarith.comp_source) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82642 (h0 : monoid (left_cancel_semigroup (semiring (add_group empty)))) : monoid.fg (left_cancel_semigroup (semiring (add_group empty))) := sorry --non-trivial
lemma new_lemma_82643 (h1 : filter (has_norm (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_82644 (h0 : functor.add_const (group (semigroup unsigned)) linarith.comp) : @group.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82645 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82646 (h0 : finset (has_Inf (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82647 (h0 : Prop) (h1 : with_bot punit) (h2 : ne h1 has_bot.bot) : category_theory.hom_of_element h0 (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_82648 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset pos)) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_82649 (h1 : ring (non_unital_non_assoc_semiring reducibility_hints)) : is_domain (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_82650 (h0 : topological_space (has_top (add_group empty))) : normal_space (has_top (add_group empty)) := sorry --non-trivial
lemma new_lemma_82651 (h0 : topological_space (semigroup (has_add linarith.comp))) : irreducible_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_82652 (h0 : uniform_space (is_R_or_C (option unsigned))) : complete_space (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_82653 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82654 (h0 : group (has_top (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82655 (h0 : ring (normed_group (has_top fun_info))) : rank_condition (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_82656 (h0 : functor.add_const (ring (has_to_string Type)) pos) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_82657 (h0 : topological_space (has_dist char)) : totally_disconnected_space (has_dist char) := sorry --non-trivial
lemma new_lemma_82658 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid linarith.comp))) : path_connected_space (normed_lattice_add_comm_group (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_82659 (h0 : topological_space (semigroup (add_cancel_monoid (boolean_algebra Type)))) : loc_path_connected_space (semigroup (add_cancel_monoid (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_82660 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82661 (h0 : functor.add_const Prop (linear_ordered_semiring empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_82662 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_82663 (h0 : not (has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_82664 (h0 : ring (denumerable (has_nnnorm char))) : is_domain (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_82665 (h1 : topological_space (normed_group (random_gen string_imp))) : t0_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_82666 (h0 : not (topological_space (has_Inf linarith.comp) -> false)) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_82667 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_82668 (h0 : topological_space (has_nndist (has_add unsigned))) : irreducible_space (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_82669 (h0 : functor.add_const (monoid (ring Type)) name) : @monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_82670 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_82672 (h0 : group (linear_ordered_comm_monoid_with_zero (semiring num))) : is_cyclic (linear_ordered_comm_monoid_with_zero (semiring num)) := sorry --non-trivial
lemma new_lemma_82673 (h0 : functor.add_const (topological_space auto.case_option) empty) : @irreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_82674 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @normalizer_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type group.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_82675 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_add linarith.comp)) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_82676 (h0 : ring (normed_field (mul_one_class (normed_field to_additive.value_type)))) : rank_condition (normed_field (mul_one_class (normed_field to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82677 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_neg pos)) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_82678 (h0 : not (measurable_space (has_div reducibility_hints) -> false)) (h1 : filter (has_div reducibility_hints)) : @filter.is_measurably_generated.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (measurable_space.{0} (has_div.{0} reducibility_hints)) h0) h1  := sorry --non-trivial
lemma new_lemma_82679 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82680 (h0 : add_group (canonically_ordered_monoid (has_Inf (has_add pos)))) : is_add_cyclic (canonically_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_82681 (h0 : group (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : group.fg (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82682 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_82683 (h0 : topological_space (left_cancel_monoid unsigned)) : totally_separated_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_82684 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_inter unsigned)) empty) : @unique_factorization_monoid.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_inter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_82685 (h1 : ring (comm_ring linarith.comp_source)) : strong_rank_condition (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82686 (h0 : not (topological_space (has_one num) -> false)) : @totally_disconnected_space.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_82687 (h0 : topological_space (has_nndist (has_neg environment.implicit_infer_kind))) : normal_space (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82688 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82689 (h0 : function.extfun Type group) : @group.fg.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82690 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_to_string pos)) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_82691 (h0 : uniform_space (has_norm (random_gen num))) : complete_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_82692 (h0 : ring (distrib (mul_one_class reducibility_hints))) : rank_condition (distrib (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_82693 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_ring Type))) : preconnected_space (normed_lattice_add_comm_group (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_82694 (h0 : list (semigroup (ring (ring (ring (ring pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82695 (h0 : finset (ordered_comm_group unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_82697 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) (complete_distrib_lattice name)) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (complete_distrib_lattice.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_82698 (h1 : topological_space (has_add (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char)))))) : path_connected_space (has_add (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_82699 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : preirreducible_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82700 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_82701 (h0 : complete_lattice (has_norm (random_gen fun_info))) : is_atomistic (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_82702 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82703 (h0 : finset (plift (mul_zero_class unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82704 (h0 : functor.add_const (topological_space (has_add name)) Type) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_82705 (h0 : group (semigroup (has_nndist (has_nndist (has_add Type))))) : is_cyclic (semigroup (has_nndist (has_nndist (has_add Type)))) := sorry --non-trivial
lemma new_lemma_82706 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_82707 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_82708 (h0 : group (add_cancel_monoid (has_add (ring (has_add linarith.comp))))) : is_simple_group (add_cancel_monoid (has_add (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_82709 (h0 : function.extfun nat fin) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82710 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_82711 (h0 : topological_space (dlist (random_gen (has_nnnorm (has_nnnorm linarith.ineq))))) : totally_disconnected_space (dlist (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_82712 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_82713 (h0 : functor.add_const (topological_space (linear_ordered_field name)) name) : @discrete_topology.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_82714 (h0 : set (has_nnnorm (has_nnnorm enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_82715 (h0 : topological_space (has_zero (finset pos))) : preirreducible_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_82716 (h4 : topological_space char) (h5 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_82717 (h0 : topological_space (semigroup (mul_zero_class unsigned))) : totally_separated_space (semigroup (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_82718 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (has_Inf (sub_neg_monoid Type)))))) : loc_path_connected_space (boolean_algebra (has_Inf (has_Inf (has_Inf (sub_neg_monoid Type))))) := sorry --non-trivial
lemma new_lemma_82719 (h0 : semiring (boolean_algebra.core (finset (has_add pos)))) : is_noetherian_ring (boolean_algebra.core (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_82720 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_82721 (h1 : ring (has_nnnorm string_imp)) : is_domain (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_82722 (h0 : topological_space (comm_group (option pos))) : discrete_topology (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_82723 (h0 : functor.add_const (uniform_space (monoid unsigned)) num) : @separated_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_82724 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : t0_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82725 (h0 : ring (has_union num)) : is_domain (has_union num) := sorry --non-trivial
lemma new_lemma_82726 (h0 : topological_space (boolean_algebra (has_pos_part (has_neg linarith.comp)))) : normal_space (boolean_algebra (has_pos_part (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_82727 (h1 : ring (has_add linarith.ineq)) : rank_condition (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_82728 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) linarith.comp) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82729 (h0 : complete_lattice (has_div (has_ssubset fun_info))) : is_compactly_generated (has_div (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_82730 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_82731 (h1 : add_group (has_div to_additive.value_type)) : is_add_cyclic (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82732 (h0 : ring (random_gen (has_nnnorm char))) : strong_rank_condition (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_82733 (h0 : ring (has_add (random_gen linarith.ineq))) : rank_condition (has_add (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82734 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_82735 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82736 (h0 : topological_space (non_assoc_semiring (semiring (semiring empty)))) : path_connected_space (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_82737 (h0 : topological_space (comm_ring (has_inv linarith.ineq))) : path_connected_space (comm_ring (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82738 (h0 : functor.add_const (complete_lattice (has_add name)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82739 (h0 : list (add_comm_monoid (has_neg_part pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82740 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82741 (h1 : ring (denumerable fun_info)) : strong_rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_82742 (h0 : functor.add_const (complete_lattice (has_dist num)) (option (option empty))) : @is_atomistic.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} num)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_82743 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82744 (h0 : topological_space (partial_order (option empty))) : totally_separated_space (partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_82745 (h0 : topological_space (has_top (has_inv to_additive.value_type))) : path_connected_space (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82746 (h0 : distrib enat -> distrib enat) : set.finite (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_82747 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_82748 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_82749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82750 (h2 : complete_lattice (has_div to_additive.value_type)) : is_compactly_generated (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82751 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} linarith.ineq (@function.extfun_app.{2 1} Type add_group.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_82752 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_82753 (h0 : functor.add_const (topological_space (cancel_monoid empty)) unsigned) : @totally_separated_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82754 (h1 : topological_space (measurable_space linarith.comp_source)) : locally_compact_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82755 (h0 : topological_space (semigroup (normed_comm_ring environment.implicit_infer_kind))) : t0_space (semigroup (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82756 (h0 : topological_space (normed_comm_ring (boolean_algebra (has_neg Type)))) : topological_space.separable_space (normed_comm_ring (boolean_algebra (has_neg Type))) := sorry --non-trivial
lemma new_lemma_82757 (h0 : topological_space (ring (has_Inf pos))) : t0_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_82758 (h0 : topological_space (simple_graph congr_arg_kind)) : totally_disconnected_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82759 (h0 : uniform_space (has_to_string num)) : separated_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_82760 (h0 : ring (complete_distrib_lattice (has_bot real))) : rank_condition (complete_distrib_lattice (has_bot real)) := sorry --non-trivial
lemma new_lemma_82761 (h0 : topological_space (with_one (linear_ordered_add_comm_group linarith.comp_source))) : t0_space (with_one (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82762 (h0 : monoid (has_add (has_neg_part linarith.comp))) : monoid.fg (has_add (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_82764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_82765 (h0 : cancel_comm_monoid_with_zero (has_one empty)) : unique_factorization_monoid (has_one empty) := sorry --non-trivial
lemma new_lemma_82766 (h0 : complete_lattice (semi_normed_comm_ring (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_82767 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82768 (h0 : topological_space (random_gen (has_ssubset linarith.comp_source))) : t0_space (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82769 (h0 : add_group (has_well_founded congr_arg_kind)) : is_add_cyclic (has_well_founded congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82770 (h0 : function.extfun nat fin) : @complete_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_82771 (h0 : topological_space (has_norm (has_top linarith.ineq))) : irreducible_space (has_norm (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82772 (h0 : add_group (canonically_ordered_comm_semiring (has_add pos))) : is_add_cyclic (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_82773 (h0 : ring (finset (has_to_string (has_to_string pos)))) : is_principal_ideal_ring (finset (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_82774 (h0 : topological_space (ring (ring linarith.comp))) : preirreducible_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_82775 (h1 : set (has_lt linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_82776 (h0 : filter (has_zero (has_neg pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82777 (h0 : functor.add_const (add_group (complete_distrib_lattice linarith.comp)) (has_nndist (has_Inf (has_Inf pos)))) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_nndist.{0} (has_Inf.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_82778 (h0 : group (topological_space (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (topological_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_82779 (h0 : functor.add_const (finset (finset unsigned)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82780 (h3 : ring (semi_normed_comm_ring (has_ssubset char))) : rank_condition (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_82781 (h0 : cancel_comm_monoid_with_zero (plift (comm_monoid unsigned))) : unique_factorization_monoid (plift (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_82782 (h0 : decidable_eq complex) (h1 : add_comm_group string_imp) (h2 : complex -> add_subgroup string_imp) : direct_sum.add_subgroup_is_internal h2 := sorry --non-trivial
lemma new_lemma_82783 (h0 : add_monoid (complete_semilattice_Sup (semiring unsigned))) : add_monoid.fg (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_82784 (h0 : ring (distrib (comm_ring linarith.comp_source))) : is_domain (distrib (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82785 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_82786 (h0 : ring (nondiscrete_normed_field char)) : is_domain (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_82787 (h0 : finset (simple_graph (has_pos_part (ring name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_82788 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @sequential_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_82789 (h0 : ring (left_cancel_monoid num)) : rank_condition (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_82790 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp))))))) : archimedean (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_82791 (h0 : topological_space Type) : normal_space Type := sorry --non-trivial
lemma new_lemma_82792 (h0 : semiring (filter linarith.comp)) (h1 : topological_space (polynomial (filter linarith.comp))) : irreducible_space (polynomial (filter linarith.comp)) := sorry --non-trivial
lemma new_lemma_82793 (h0 : set (canonically_linear_ordered_monoid string.iterator_imp -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_82794 (h0 : functor.add_const (group (has_add name)) name) : @is_simple_group.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_82795 (h0 : ring (complete_semilattice_Sup num)) : is_domain (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_82796 (h0 : ring (has_one congr_arg_kind)) : strong_rank_condition (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82797 (h0 : not (topological_space (comm_ring linarith.comp_source) -> false)) : @path_connected_space.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82798 (h0 : group (random_gen (denumerable fun_info))) : is_cyclic (random_gen (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_82799 (h0 : topological_space (uniform_space (random_gen (comm_ring string_imp)))) : path_connected_space (uniform_space (random_gen (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_82800 (h0 h1 : multiset (linear_ordered_comm_group_with_zero linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_82801 (h0 : ring (has_sub enat)) : strong_rank_condition (has_sub enat) := sorry --non-trivial
lemma new_lemma_82802 (h0 : topological_space (has_nndist (canonically_ordered_comm_semiring (has_neg (has_neg Type))))) : locally_compact_space (has_nndist (canonically_ordered_comm_semiring (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_82803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_82804 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_82805 (h0 : functor.add_const (group (linear_ordered_field pos)) unsigned) : @is_cyclic.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_82806 (h0 : monoid (has_union (has_top (has_top (semiring (semiring linarith.comp)))))) : monoid.fg (has_union (has_top (has_top (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_82807 (h0 : functor.add_const (complete_lattice (finset Type)) pos) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_82808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_82809 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : totally_separated_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82810 (h1 : uniform_space (add_monoid (fintype char))) : complete_space (add_monoid (fintype char)) := sorry --non-trivial
lemma new_lemma_82811 (h0 : ring (has_top (random_gen (has_top congr_arg_kind)))) : rank_condition (has_top (random_gen (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_82812 (h0 : semiring (has_bot real)) : is_noetherian_ring (has_bot real) := sorry --non-trivial
lemma new_lemma_82813 (h0 : not (topological_space num -> false)) : @t0_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_82814 (h0 : monoid (has_top (with_bot to_additive.value_type))) : monoid.fg (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82815 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_82816 (h0 : group (semiring (metric_space linarith.comp))) : group.fg (semiring (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_82817 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82818 (h0 : functor.add_const (ring (has_add name)) Type) : @is_domain.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_82819 (h2 : topological_space ereal) (h3 : preorder ereal) : order_topology ereal := sorry --non-trivial
lemma new_lemma_82820 (h0 : topological_space (has_one (semiring num))) : normal_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_82821 (h0 : topological_space (metric_space (random_gen (has_norm linarith.comp)))) : locally_compact_space (metric_space (random_gen (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_82822 (h0 : uniform_space (with_one num)) : separated_space (with_one num) := sorry --non-trivial
lemma new_lemma_82823 (h1 : topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_82824 (h0 : ring (mul_one_class (uniform_space reducibility_hints))) : strong_rank_condition (mul_one_class (uniform_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_82825 (h0 : ring (normed_comm_ring (has_to_string ennreal))) : rank_condition (normed_comm_ring (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_82826 (h0 : function.extfun Type group) : @group.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_82827 (h0 : functor.add_const (monoid (semigroup linarith.comp)) (has_add environment.implicit_infer_kind)) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} linarith.comp)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_82828 (h0 : uniform_space (finset (option (option empty)))) : separated_space (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_82829 (h0 : group (add_group (semiring (has_norm (semiring (semiring (semiring fun_info))))))) : is_cyclic (add_group (semiring (has_norm (semiring (semiring (semiring fun_info)))))) := sorry --non-trivial
lemma new_lemma_82830 (h0 : ring (has_bot (has_Inf (has_neg name)))) : rank_condition (has_bot (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_82831 (h0 : prod ennreal ennreal) : set.diagonal ennreal h0 := sorry --non-trivial
lemma new_lemma_82832 (h0 : functor.add_const (list (add_comm_monoid pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82833 (h0 : pnat) (h1 : ulower (ulower (fin has_zero.zero))) : pnat.coprime h0 (matrix.vec_empty (ulower.up (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_82834 (h1 : topological_space (mul_one_class fun_info)) : path_connected_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_82835 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_82836 (h0 : topological_space (add_cancel_monoid (has_neg_part Type))) : totally_disconnected_space (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_82837 (h1 : group (random_gen linarith.ineq)) : is_cyclic (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_82838 (h0 : complete_lattice (add_comm_monoid (option pos))) : is_compactly_generated (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_82839 (h0 : topological_space (with_one (has_norm (has_top empty)))) : discrete_topology (with_one (has_norm (has_top empty))) := sorry --non-trivial
lemma new_lemma_82840 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82841 (h0 : functor.add_const (complete_lattice (comm_group Type)) (has_add (boolean_algebra pos))) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) (has_add.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_82842 (h0 : list (topological_space (normed_linear_ordered_group to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82843 (h0 : topological_space (has_neg_part Type)) : loc_path_connected_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_82844 (h0 : list (add_cancel_monoid (has_add (has_add linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82845 (h0 : ring (semigroup (has_add name))) : rank_condition (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_82846 (h0 : not (topological_space (non_unital_non_assoc_semiring char) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_82847 (h0 : add_monoid (finset (option unsigned))) : add_monoid.fg (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_82848 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_82849 (h0 : functor.add_const (topological_space (has_neg_part pos)) Type) : @t0_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_82850 (h0 : functor.add_const (ring (has_Inf pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82851 (h0 : functor.add_const (ring (has_to_string Type)) pos) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_82852 (h0 : list (canonically_ordered_comm_semiring pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82853 (h0 : functor.add_const (complete_lattice (ordered_ring num)) empty) : @is_atomistic.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_82854 (h0 : topological_space (has_Inf (has_pos_part pos))) : totally_disconnected_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_82855 (h1 : has_coe (nondiscrete_normed_field (add_comm_semigroup ereal)) Prop) (h2 : nondiscrete_normed_field (add_comm_semigroup ereal)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} ereal)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_82856 (h0 : uniform_space (finset num)) : complete_space (finset num) := sorry --non-trivial
lemma new_lemma_82857 (h1 : set (normed_field linarith.ineq)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_82858 (h0 : topological_space (ring linarith.comp)) : locally_compact_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_82859 (h0 : uniform_space (finset congr_arg_kind)) : complete_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82860 (h0 : group (has_norm (has_norm num))) : group.fg (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_82861 (h2 : uniform_space (has_emptyc string_imp)) : complete_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_82862 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @loc_path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_82863 (h0 : not (prod (has_star congr_arg_kind) (has_star congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_82864 (h0 : topological_space (monoid_with_zero unsigned)) : irreducible_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_82865 (h0 : topological_space (has_edist (option (semiring empty)))) : totally_disconnected_space (has_edist (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_82866 (h0 : topological_space (ring (has_Inf pos))) : totally_separated_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_82867 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_82868 (h2 : complete_lattice (normed_field (add_comm_semigroup std_gen))) : complete_lattice.is_Sup_finite_compact (normed_field (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_82869 (h0 : complete_lattice (option empty)) : is_compactly_generated (option empty) := sorry --non-trivial
lemma new_lemma_82870 (h0 : add_group ereal) : is_simple_add_group ereal := sorry --non-trivial
lemma new_lemma_82871 (h2 : ring (fintype (has_nnnorm fun_info))) : rank_condition (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_82872 (h0 : monoid (distrib_lattice (option (option ennreal)))) : monoid.fg (distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_82873 (h0 : function.extfun Type (functor.add_const (ring (left_cancel_semigroup empty)))) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82874 (h1 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h1) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82875 (h0 : ring (has_emptyc (has_norm to_additive.value_type))) : is_domain (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82876 (h1 : complete_lattice (distrib to_additive.value_type)) : is_compactly_generated (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82877 (h0 : topological_space (distrib (mul_one_class (mul_one_class fun_info)))) : totally_disconnected_space (distrib (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_82878 (h0 : not (group (measurable_space linarith.comp_source) -> false)) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82879 (h0 : add_group (mul_zero_class (has_add Type))) : is_add_cyclic (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_82880 (h0 : ordered_semiring (normed_comm_ring (finset linarith.comp))) (h1 : semiring (add_cancel_monoid (floor_semiring (normed_comm_ring (finset linarith.comp))))) : is_noetherian_ring (add_cancel_monoid (floor_semiring (normed_comm_ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_82881 (h0 : group (measurable_space (has_top (semiring num)))) : normalizer_condition (measurable_space (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_82882 (h0 : not (ring (has_inv linarith.comp_source) -> false)) : @is_domain.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_82883 (h0 : add_group (normed_ring to_additive.value_type)) : is_add_cyclic (normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_82884 (h1 : not (complete_lattice (distrib_lattice fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_82885 (h0 : fin has_zero.zero) : @group.fg.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_82886 (h0 : topological_space (has_emptyc (has_top (has_norm linarith.comp)))) : discrete_topology (has_emptyc (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_82887 (h0 : ring (with_one (random_gen (random_gen char)))) : strong_rank_condition (with_one (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_82888 (h0 : topological_space (semigroup (finset ennreal))) : normal_space (semigroup (finset ennreal)) := sorry --non-trivial
lemma new_lemma_82889 (h0 : topological_space (has_zero (has_add Type))) : normal_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_82890 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : preconnected_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_82891 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82892 (h0 : complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) : is_compactly_generated (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_82893 (h0 : functor.add_const (list (cancel_monoid name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82894 (h0 : add_monoid (has_norm (metric_space (metric_space linarith.comp)))) : add_monoid.fg (has_norm (metric_space (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_82895 (h0 : topological_space (finset linarith.comp)) : t1_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_82896 (h0 : functor.add_const (ring (partial_order num)) empty) : @is_domain.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_82897 (h0 : topological_space (has_pos_part (has_Inf (has_Inf Type)))) : loc_path_connected_space (has_pos_part (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_82898 (h0 : filter (has_top (random_gen (has_ssubset fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_82899 (h0 : topological_space (has_emptyc linarith.comp_source)) : path_connected_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_82900 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semi_normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_82901 (h0 : ordered_comm_monoid (semigroup (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82902 (h0 : topological_space (has_top (id (metric_space linarith.comp)))) : normal_space (has_top (id (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_82903 (h0 : functor.add_const (list (semigroup Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82904 (h0 : ring (fintype (random_gen (random_gen (random_gen char))))) : strong_rank_condition (fintype (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_82905 (h0 : functor.add_const (ring (semigroup ennreal)) Type) : @rank_condition.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_82906 (h0 : monoid (comm_group (has_neg_part name))) : monoid.fg (comm_group (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_82907 (h0 : functor.add_const (prod (left_cancel_monoid empty) (left_cancel_monoid empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82908 (h0 : complete_lattice (has_union (has_norm unsigned))) : complete_lattice.is_Sup_finite_compact (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_82909 (h0 : complete_lattice (finset unsigned)) : complete_lattice.is_Sup_finite_compact (finset unsigned) := sorry --non-trivial
lemma new_lemma_82910 (h0 : topological_space (pseudo_metric_space (has_add (finset ennreal)))) : topological_space.separable_space (pseudo_metric_space (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_82911 (h0 : not (comm_ring (metric_space char) -> false)) (h1 : list (comm_ring (metric_space char))) : list.duplicate (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_82912 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82913 (h0 : topological_space (boolean_algebra.core (has_add (has_add name)))) : normal_space (boolean_algebra.core (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_82914 (h0 : topological_space (with_bot (has_top unsigned))) : discrete_topology (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_82915 (h0 : complete_lattice (with_bot linarith.ineq)) : is_compactly_generated (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_82916 (h0 : ring (has_nnnorm (random_gen string_imp))) : strong_rank_condition (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_82917 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) pos) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_82918 (h0 : functor.add_const (ring (add_cancel_monoid pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82919 (h0 : monoid (has_nndist (finset (finset Type)))) : monoid.fg (has_nndist (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_82920 (h0 : topological_space (boolean_algebra (has_add Type))) : totally_disconnected_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_82921 (h0 : topological_space (has_neg_part (comm_group environment.implicit_infer_kind))) : totally_disconnected_space (has_neg_part (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_82922 (h0 : has_add pos -> has_add pos -> Prop) : is_symm (has_add pos) h0 := sorry --non-trivial
lemma new_lemma_82923 (h0 : topological_space (ring (option pos))) : totally_disconnected_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_82924 (h0 : uniform_space (complete_distrib_lattice pos)) : separated_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_82925 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @preirreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_82926 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : path_connected_space (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_82927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_82928 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_neg Type)) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_82929 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_82930 (h0 : ordered_comm_monoid (generalized_boolean_algebra (boolean_algebra.core pos))) : has_exists_mul_of_le (generalized_boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_82931 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) empty) : @totally_separated_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_82932 (h0 : list (finset (add_comm_monoid name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82933 (h0 : ring (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) : strong_rank_condition (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_82934 (h0 : functor.add_const (uniform_space (has_nndist Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82935 (h0 : functor.add_const (list (has_to_string linarith.comp)) (ring (ring (normed_comm_ring linarith.comp)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_82936 (h0 : functor.add_const (complete_lattice (add_cancel_monoid empty)) empty) : @is_compactly_generated.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_82937 (h0 : uniform_space (has_sub (semiring (semiring unsigned)))) : complete_space (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_82938 (h0 : topological_space (has_nnnorm (has_ssubset (random_gen (random_gen to_additive.value_type))))) : t0_space (has_nnnorm (has_ssubset (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_82939 (h0 : functor.add_const (ring (finset (has_to_string name))) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (finset.{0} (has_to_string.{0} name)) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} (has_to_string.{0} name))) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_82940 (h0 : topological_space (has_top (random_gen (random_gen string_imp)))) : totally_separated_space (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_82941 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @normal_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_82942 (h0 : ring (normed_comm_ring (comm_group pos))) : is_domain (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_82943 (h0 : complete_lattice (linear_ordered_comm_group ennreal)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_82944 (h0 : ring (with_bot (random_gen linarith.comp_source))) : strong_rank_condition (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_82945 (h0 : list (semigroup (has_neg (has_neg linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_82946 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid real)) (has_add real)) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} real)) (has_add.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_82947 (h0 : functor.add_const (ring (has_neg pos)) Type) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_82948 (h0 : topological_space (simple_graph (ordered_comm_monoid real))) : discrete_topology (simple_graph (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_82949 (h0 : uniform_space (boolean_algebra (comm_semigroup real))) : complete_space (boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_82950 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_82951 (h0 : semiring (comm_group (finset linarith.comp))) : is_noetherian_ring (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_82952 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_82953 (h0 : functor.add_const (uniform_space (boolean_algebra.core unsigned)) pos) : @complete_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_82954 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_82955 (h0 : monoid (has_neg (ring (has_neg pos)))) : monoid.fg (has_neg (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_82956 (h0 : ordered_comm_monoid (finset (has_to_string pos))) : has_exists_mul_of_le (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_82957 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_82958 (h0 : topological_space (option (option (option ennreal)))) : irreducible_space (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_82959 (h0 : not (topological_space (add_monoid string_imp) -> false)) : @path_connected_space.{0} (add_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_82960 (h1 : set (enat -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_82961 (h0 : topological_space (has_top (random_gen (has_norm (random_gen fun_info))))) : path_connected_space (has_top (random_gen (has_norm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_82962 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : locally_compact_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_82963 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_82964 (h0 : functor.comp topological_space cancel_monoid Type) : @locally_compact_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_82965 (h0 : topological_space (has_nndist ennreal)) : preconnected_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_82966 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82967 (h1 : not (ring (has_lt linarith.comp_source) -> false)) : @is_domain.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_82968 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82969 (h0 : ring (has_zero (finset pos))) : is_domain (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_82970 (h0 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h1 : measure_theory.measure (nondiscrete_normed_field linarith.ineq)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_82971 (h0 : functor.add_const (group (has_to_string name)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82972 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) Type) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_82973 (h0 : functor.add_const (group (has_neg pos)) pos) : @group.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_82974 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_82975 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) (has_add (has_add pos))) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_82976 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_82977 (h0 : group (linear_ordered_semiring fun_info)) : normalizer_condition (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_82978 (h0 : functor.add_const (uniform_space (has_zero Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_82979 (h0 : functor.add_const (ring (add_cancel_comm_monoid num)) empty) : @is_domain.{0} (add_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_82980 (h0 : complete_lattice (has_nnnorm (has_nnnorm (has_nnnorm (comm_ring linarith.ineq))))) : is_compactly_generated (has_nnnorm (has_nnnorm (has_nnnorm (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_82981 (h0 : filter (has_zero (finset (finset (finset (has_to_string pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_82982 (h0 : monoid (non_assoc_semiring (option (option (option unsigned))))) : monoid.fg (non_assoc_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_82983 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_82984 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_82985 (h0 : ring (random_gen (random_gen linarith.comp))) : is_domain (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_82986 (h0 : ring (normed_comm_ring Type)) : is_principal_ideal_ring (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_82987 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_82988 (h0 : Prop) : nonempty (non_contradictory h0) := sorry --non-trivial
lemma new_lemma_82989 (h0 : ring (dlist (has_ssubset to_additive.value_type))) : strong_rank_condition (dlist (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_82990 (h0 : group (add_comm_monoid (boolean_algebra (has_neg linarith.comp)))) : is_cyclic (add_comm_monoid (boolean_algebra (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_82991 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_82992 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} (has_norm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_82993 (h0 : topological_space (mul_zero_class (has_neg_part name))) : totally_separated_space (mul_zero_class (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_82994 (h0 : functor.add_const (uniform_space (linear_ordered_comm_ring empty)) num) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_82995 (h0 : uniform_space (boolean_algebra.core (group_with_zero num))) : separated_space (boolean_algebra.core (group_with_zero num)) := sorry --non-trivial
lemma new_lemma_82996 (h0 : complete_lattice (comm_ring (random_gen (random_gen char)))) : is_compactly_generated (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_82997 (h0 : function.extfun Type ring) : @rank_condition.{0} pos (@function.extfun_app.{2 1} Type ring.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_82998 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_Inf linarith.comp))) : has_exists_mul_of_le (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_82999 (h0 : function.extfun nat fin) : @path_connected_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83000 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : t0_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83001 (h0 : topological_space (ring (has_add Type))) : path_connected_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_83002 (h0 : ring (linear_ordered_comm_group (monoid_with_zero (monoid (monoid (monoid ennreal)))))) : is_domain (linear_ordered_comm_group (monoid_with_zero (monoid (monoid (monoid ennreal))))) := sorry --non-trivial
lemma new_lemma_83003 (h0 : list (add_comm_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83004 (h0 : ring (has_add linarith.comp)) : is_domain (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_83005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83006 (h0 : complete_lattice (measurable_space (random_gen linarith.comp_source))) : is_compactly_generated (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83007 (h0 : group (ordered_comm_monoid (has_neg (has_neg (has_neg (has_add (has_neg name))))))) : group.fg (ordered_comm_monoid (has_neg (has_neg (has_neg (has_add (has_neg name)))))) := sorry --non-trivial
lemma new_lemma_83008 (h0 : functor.add_const (ordered_add_comm_monoid (preorder empty)) unsigned) : @archimedean.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83009 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : normal_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_83010 (h0 : topological_space (id (random_gen (random_gen linarith.ineq)))) : totally_separated_space (id (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83011 (h0 : complete_lattice (has_append (metric_space to_additive.value_type))) : is_compactly_generated (has_append (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83012 (h0 : functor.add_const (topological_space (comm_group ennreal)) ennreal) : @normal_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_83013 (h0 : filter Prop) : @id.{1} Prop (@Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) h0)  := sorry --non-trivial
lemma new_lemma_83014 (h0 : complete_lattice (mul_zero_class (finset ennreal))) : is_compactly_generated (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_83015 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_83016 (h2 : topological_space linarith.comp_source) : t0_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_83017 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_83018 (h0 : functor.add_const (ordered_comm_monoid (has_neg linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83019 (h0 : not (ring (complete_semilattice_Sup linarith.comp_source) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_83020 (h0 : ring (has_emptyc (random_gen to_additive.value_type))) : is_domain (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83021 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_83022 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83023 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83024 (h0 : uniform_space (linear_ordered_semiring (semiring (semiring empty)))) : complete_space (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83025 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_83026 (h0 : functor.add_const (group (has_bot unsigned)) num) : @is_cyclic.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_83027 (h0 : ring (pseudo_emetric_space (has_inv linarith.comp_source))) : is_domain (pseudo_emetric_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83028 (h0 : monoid (normed_group (semiring empty))) : monoid.fg (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_83029 (h0 : ring (has_to_string pos)) : is_principal_ideal_ring (has_to_string pos) := sorry --non-trivial
lemma new_lemma_83030 (h0 : group (with_one (semiring (random_gen (semiring (has_top linarith.comp)))))) : normalizer_condition (with_one (semiring (random_gen (semiring (has_top linarith.comp))))) := sorry --non-trivial
lemma new_lemma_83031 (h0 : function.extfun nat fin) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83032 (h0 : functor.add_const (add_monoid (free_add_monoid num)) num) : add_monoid.fg (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_83033 (h0 : topological_space (ring (ring pos))) : totally_disconnected_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_83034 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_83035 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83036 (h0 : functor.add_const (topological_space (ring pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_83038 (h0 : monoid (monoid_with_zero ennreal)) : monoid.fg (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_83039 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_83040 (h0 : topological_space (add_cancel_monoid (has_pos_part (has_add (has_add pos))))) : irreducible_space (add_cancel_monoid (has_pos_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_83041 (h0 : uniform_space (ordered_cancel_add_comm_monoid unsigned)) : separated_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_83042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83043 (h0 : semiring (has_pos_part pos)) : is_noetherian_ring (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_83044 (h1 : ring (normed_field char)) : rank_condition (normed_field char) := sorry --non-trivial
lemma new_lemma_83045 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_83046 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83047 (h1 : topological_space (has_top linarith.comp_source)) : path_connected_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_83048 (h0 : complete_lattice (pseudo_metric_space congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83049 (h0 : topological_space (simple_graph (ring (ring pos)))) : t0_space (simple_graph (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_83050 (h0 : functor.add_const (add_monoid (has_nndist Type)) pos) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_83051 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : discrete_topology (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_83052 (h0 : topological_space (has_one num)) : preirreducible_space (has_one num) := sorry --non-trivial
lemma new_lemma_83053 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83054 (h0 : add_group (distrib (has_ssubset char))) : is_add_cyclic (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_83055 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_83056 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_83057 (h0 : filter name) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_83058 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) congr_arg_kind) : @path_connected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83059 (h0 : functor.comp topological_space boolean_algebra.core unsigned) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_83060 (h0 : topological_space (semi_normed_comm_ring (random_gen (has_top fun_info)))) : totally_disconnected_space (semi_normed_comm_ring (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_83061 (h4 : ring (simple_graph string_imp)) : strong_rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_83062 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83063 (h0 : ennreal -> ennreal -> Prop) : is_symm ennreal h0 := sorry --non-trivial
lemma new_lemma_83064 (h0 : functor.add_const (list (has_pos_part linarith.comp)) (has_add linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83065 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring name)) Type) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_83066 (h0 : functor.add_const (group (boolean_algebra unsigned)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83067 (h1 : add_group (has_lt string_imp)) : is_add_cyclic (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_83068 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83069 (h0 : has_neg (normed_field string_imp)) (h1 : measurable_space (normed_field string_imp)) : has_measurable_neg (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_83070 (h0 : ring (comm_group (finset ennreal))) : rank_condition (comm_group (finset ennreal)) := sorry --non-trivial
lemma new_lemma_83071 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_83072 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83073 (h0 : add_group (mul_zero_class Type)) : is_add_cyclic (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_83074 (h0 : ring (normed_group (has_top (has_top linarith.ineq)))) : rank_condition (normed_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83075 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) Type) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_83076 (h0 : topological_space (has_top (semiring congr_arg_kind))) : locally_compact_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_83077 (h0 : group (has_neg (has_add (normed_comm_ring pos)))) : normalizer_condition (has_neg (has_add (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_83078 (h3 : group (metric_space to_additive.value_type)) : is_cyclic (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83079 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_83081 (h0 : topological_space (ring (finset Type))) : loc_path_connected_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_83082 (h0 : group (measurable_space (has_top (random_gen fun_info)))) : normalizer_condition (measurable_space (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_83083 (h0 : ring (ordered_comm_monoid (has_neg Type))) : is_domain (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_83084 (h0 : topological_space (normed_group (random_gen (has_top (power_series fun_info))))) : t0_space (normed_group (random_gen (has_top (power_series fun_info)))) := sorry --non-trivial
lemma new_lemma_83085 (h0 : list (has_zero (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83086 (h0 : topological_space (has_pos_part (ring linarith.comp))) : irreducible_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_83087 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_83088 (h0 : topological_space (ordered_comm_monoid name)) : preirreducible_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_83089 (h0 : filter (ordered_comm_semiring (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83090 (h0 : topological_space (mul_zero_class (finset (finset environment.implicit_infer_kind)))) : discrete_topology (mul_zero_class (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_83091 (h2 : list linarith.comp_source) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_83092 (h0 : Prop -> environment.projection_info) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_83093 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_pos_part linarith.comp))) : unique_factorization_monoid (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_83094 (h0 : finset (complete_linear_order congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83095 (h2 : not (topological_space (distrib_lattice fun_info) -> false)) : @t0_space.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_83096 (h0 : group (linear_ordered_semiring num)) : normalizer_condition (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_83097 (h0 : function.extfun ((nat -> Type) -> Type) (function.extfun (nat -> Type))) : @path_connected_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) (@function.extfun_app.{2 2} ((nat → Type) → Type) (function.extfun.{2 1} (nat → Type)) h0 (function.extfun.{1 1} nat)) fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83098 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_83099 (h0 : functor.add_const (finset (semigroup pos)) (has_zero Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83100 (h0 : topological_space Type) : irreducible_space Type := sorry --non-trivial
lemma new_lemma_83101 (h0 : topological_space (add_cancel_monoid (ring name))) : topological_space.separable_space (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_83102 (h0 : filter (mul_zero_class (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83103 (h0 : ring (ordered_comm_ring (has_Inf Type))) : is_principal_ideal_ring (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_83104 (h0 : list (pseudo_metric_space (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83105 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83106 (h2 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h2) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83107 (h0 : group (has_sub (has_top (has_top (semiring empty))))) : is_cyclic (has_sub (has_top (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_83108 (h0 : topological_space string.iterator) : totally_disconnected_space string.iterator := sorry --non-trivial
lemma new_lemma_83109 (h0 : list (has_add (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83110 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist num)) := sorry --non-trivial
lemma new_lemma_83111 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83112 (h0 : add_group (encodable char)) : is_add_cyclic (encodable char) := sorry --non-trivial
lemma new_lemma_83113 (h0 : complete_lattice (semiring (has_top (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_83114 (h0 : functor.add_const (ring (semigroup name)) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83115 (h0 : ring (random_gen (has_top (has_top (has_top (has_top (has_top to_additive.value_type))))))) : rank_condition (random_gen (has_top (has_top (has_top (has_top (has_top to_additive.value_type)))))) := sorry --non-trivial
lemma new_lemma_83116 (h0 : functor.add_const (group (add_cancel_monoid pos)) (has_neg Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_83117 (h0 : add_group (has_to_string (finset (finset name)))) : is_add_cyclic (has_to_string (finset (finset name))) := sorry --non-trivial
lemma new_lemma_83118 (h0 : group (measurable_space (id linarith.comp))) : is_cyclic (measurable_space (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_83119 (h0 : function.extfun Type (functor.add_const (semiring (add_right_cancel_monoid empty)))) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_right_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (add_right_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_83120 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83121 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @sequential_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83122 (h0 : topological_space (boolean_algebra (comm_group environment.implicit_infer_kind))) : t1_space (boolean_algebra (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83123 (h0 : ring (with_one (has_norm fun_info))) : rank_condition (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_83124 (h0 : list (ordered_ring (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_83126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_83127 (h0 : topological_space (has_compl (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : path_connected_space (has_compl (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_83128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_83129 (h0 : not (complete_lattice (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_83130 (h0 : topological_space (canonically_ordered_add_monoid (option unsigned))) : irreducible_space (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_83131 (h0 : ring (metric_space linarith.comp)) : strong_rank_condition (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_83132 (h0 : topological_space (boolean_algebra (finset (ring linarith.comp)))) : path_connected_space (boolean_algebra (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_83133 (h0 : topological_space (sub_neg_monoid (has_pos_part (has_Inf real)))) : t1_space (sub_neg_monoid (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_83134 (h0 : topological_space (ordered_comm_monoid (has_neg (has_Inf pos)))) : t1_space (ordered_comm_monoid (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_83135 (h0 : functor.add_const (monoid (normed_comm_ring name)) Type) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_83136 (h0 : ring (normed_group unsigned)) : strong_rank_condition (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_83137 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_83138 (h0 : topological_space (has_bot (ordered_comm_monoid (has_add real)))) : path_connected_space (has_bot (ordered_comm_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_83139 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_83140 (h0 : group (option ennreal)) : is_simple_group (option ennreal) := sorry --non-trivial
lemma new_lemma_83141 (h0 : ring (cancel_monoid (normed_comm_ring real.angle))) : is_principal_ideal_ring (cancel_monoid (normed_comm_ring real.angle)) := sorry --non-trivial
lemma new_lemma_83142 (h0 : ring (has_union (semiring num))) : is_principal_ideal_ring (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_83143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83144 (h0 : functor.add_const (list (has_neg Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83145 (h0 : topological_space (metric_space (semiring (semiring empty)))) : preirreducible_space (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83146 (h0 : ring (ordered_cancel_add_comm_monoid congr_arg_kind)) : strong_rank_condition (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83147 (h0 : functor.comp topological_space has_nndist pos) : @t1_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_83148 (h0 : monoid (with_bot to_additive.value_type)) : monoid.fg (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83149 (h1 : topological_space (non_unital_non_assoc_semiring std_gen)) : path_connected_space (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_83150 (h0 : prod (has_Sup congr_arg_kind) (has_Sup congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_83151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83152 (h0 : list (has_inv (complete_semilattice_Sup fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83153 (h0 : semiring (has_union (has_top (has_top (has_norm (has_norm (has_top num))))))) : is_noetherian_ring (has_union (has_top (has_top (has_norm (has_norm (has_top num)))))) := sorry --non-trivial
lemma new_lemma_83154 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : t0_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_83155 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_83156 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_83157 (h0 : topological_space (semigroup (option (option ennreal)))) : totally_separated_space (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_83158 (h0 : group (has_Inf (has_Inf name))) : normalizer_condition (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_83159 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_group_with_zero_nhd.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group_with_zero_nhd.{0} empty))  := sorry --non-trivial
lemma new_lemma_83160 (h0 : add_group (mul_zero_class (semiring (semiring empty)))) : is_add_cyclic (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83161 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) empty) : @locally_compact_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_83162 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_83163 (h0 : not (add_group (has_top empty) -> false)) : @is_add_cyclic.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_83164 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83165 (h0 : ring (complete_lattice (mul_one_class enat))) : strong_rank_condition (complete_lattice (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_83166 (h0 : topological_space (random_gen (has_norm fun_info))) : t0_space (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_83167 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_83168 (h0 : topological_space (measure_theory.measure_space (semiring num))) : normal_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_83169 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_83170 (h0 : group (semigroup (ring linarith.comp))) : group.fg (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_83171 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_83172 (h0 : set (has_compl to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_83173 (h0 : topological_space (boolean_algebra (boolean_algebra linarith.comp))) : totally_separated_space (boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_83174 (h0 : topological_space (comm_group (has_add linarith.comp))) : discrete_topology (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_83175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_83176 (h0 : topological_space (has_sub (semiring unsigned))) : normal_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_83177 (h0 : group (add_comm_monoid (has_neg linarith.comp))) : group.fg (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_83178 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_83179 (h0 : ring (has_pos_part (finset linarith.comp))) : is_principal_ideal_ring (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_83180 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) pos) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_83181 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_83182 (h0 : topological_space (add_cancel_monoid (boolean_algebra Type))) : topological_space.separable_space (add_cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_83183 (h0 : group (canonically_ordered_monoid (has_Inf Type))) : is_cyclic (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_83184 (h0 : topological_space (finset (normed_comm_ring (has_neg_part Type)))) : normal_space (finset (normed_comm_ring (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_83185 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_83186 (h0 : not (add_monoid (with_bot congr_arg_kind) -> false)) : @add_monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_83187 (h0 : functor.comp topological_space complete_distrib_lattice environment.implicit_infer_kind) : @preirreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83188 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) pos) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_83189 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf (has_add real)))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_83190 (h0 : list (boolean_algebra.core (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83191 (h0 : uniform_space (add_group (semiring (option (semiring (semiring num)))))) : separated_space (add_group (semiring (option (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_83192 (h0 : uniform_space (add_cancel_monoid (ring (ring linarith.comp)))) : complete_space (add_cancel_monoid (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_83193 (h0 : topological_space (has_top (has_top (semiring (semiring num))))) : irreducible_space (has_top (has_top (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_83194 (h0 : topological_space (plift (canonically_ordered_add_monoid empty))) : discrete_topology (plift (canonically_ordered_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_83195 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83196 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_83197 (h0 : add_group (add_right_cancel_monoid (has_top num))) : is_add_cyclic (add_right_cancel_monoid (has_top num)) := sorry --non-trivial
lemma new_lemma_83198 (h0 : functor.add_const (group (has_neg linarith.comp)) Type) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_83199 (h0 : add_monoid (has_neg (has_add pos))) : add_monoid.fg (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_83200 (h0 : topological_space (add_semigroup (finset (finset environment.implicit_infer_kind)))) : loc_path_connected_space (add_semigroup (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_83201 (h0 : functor.add_const (list (comm_group linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83202 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_83203 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) empty) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_83204 (h0 : ordered_comm_monoid (has_pos_part (has_add Type))) : has_exists_mul_of_le (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_83205 (h0 : filter (with_one (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83206 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_one.{0} (semiring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} (semiring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_83207 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83208 (h0 : not (monoid (with_one linarith.comp_source) -> false)) : @monoid.fg.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_83209 (h0 : topological_space (finset (has_to_string (has_pos_part pos)))) : totally_disconnected_space (finset (has_to_string (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_83210 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_83211 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_83212 (h0 : uniform_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_83213 (h0 : ring (semigroup (comm_group name))) : rank_condition (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_83214 (h0 : functor.add_const (uniform_space (semigroup pos)) linarith.comp) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83215 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : preconnected_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_83216 (h0 : add_group (semiring (has_norm linarith.comp))) : is_add_cyclic (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_83217 (h0 : group (comm_group (finset (has_to_string (has_add pos))))) : normalizer_condition (comm_group (finset (has_to_string (has_add pos)))) := sorry --non-trivial
lemma new_lemma_83218 (h0 : ring (add_comm_monoid (has_neg (ring (has_neg linarith.comp))))) : is_principal_ideal_ring (add_comm_monoid (has_neg (ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_83219 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_83220 (h0 : ordered_add_comm_monoid (finset (option (option ennreal)))) : archimedean (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_83221 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) unsigned) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83222 (h0 : topological_space (has_top (random_gen (random_gen (random_gen linarith.comp_source))))) : irreducible_space (has_top (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_83223 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_83224 (h0 : topological_space (semiring linarith.comp)) : preirreducible_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_83225 (h0 : functor.add_const (list (generalized_boolean_algebra Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83226 (h0 : functor.add_const (list (ordered_comm_ring pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83227 (h0 : uniform_space (with_bot to_additive.value_type)) : complete_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83228 (h0 : list (linear_ordered_comm_monoid_with_zero (add_cancel_monoid congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83229 (h0 : not (ring (random_gen fun_info) -> false)) : @rank_condition.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_83230 (h0 : canonically_ordered_comm_semiring fun_info -> canonically_ordered_comm_semiring fun_info -> Prop) : is_partial_order (canonically_ordered_comm_semiring fun_info) h0 := sorry --non-trivial
lemma new_lemma_83231 (h1 : group (has_top (random_gen (random_gen string_imp)))) : group.fg (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_83232 (h0 : group (free_add_monoid (semiring (semiring (semiring empty))))) : is_cyclic (free_add_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_83233 (h0 : filter (has_neg (has_zero (normed_comm_ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_83234 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_83235 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (ring (has_add pos))) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (ring.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83236 (h0 : prod (semigroup congr_arg_kind) (semigroup congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_83237 (h3 : list (has_emptyc num)) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_83238 (h0 : ring (complete_distrib_lattice (finset (has_nndist Type)))) : rank_condition (complete_distrib_lattice (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_83239 (h0 : topological_space (has_nndist (pseudo_metric_space pos))) : t0_space (has_nndist (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_83240 (h0 : group (boolean_algebra.core (has_neg_part (has_neg_part pos)))) : normalizer_condition (boolean_algebra.core (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_83241 (h0 : topological_space (has_zero (has_to_string (has_zero (option pos))))) : sequential_space (has_zero (has_to_string (has_zero (option pos)))) := sorry --non-trivial
lemma new_lemma_83242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : has_add (has_inv linarith.comp_source)) : @has_measurable_add.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 measurable_space.{0}) (has_inv.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_83243 (h0 : topological_space (random_gen (random_gen reducibility_hints))) : path_connected_space (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_83244 (h0 : function.extfun Type topological_space) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_83245 (h0 : complete_lattice (linear_ordered_comm_group (option ennreal))) : is_compactly_generated (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_83246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83247 (h0 : not (ring (simple_graph to_additive.value_type) -> false)) : @rank_condition.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_83248 (h0 : topological_space (normed_group char)) : locally_compact_space (normed_group char) := sorry --non-trivial
lemma new_lemma_83249 (h1 : complete_lattice (metric_space (denumerable to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (metric_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83250 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (option empty)) := sorry --non-trivial
lemma new_lemma_83251 (h0 : ordered_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) : has_exists_mul_of_le (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_83252 (h0 : uniform_space (div_inv_monoid fun_info)) : complete_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_83253 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf name))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_83254 (h0 : ring (simple_graph empty)) : is_domain (simple_graph empty) := sorry --non-trivial
lemma new_lemma_83255 (h0 : ring (has_nnnorm char)) : is_domain (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_83256 (h0 : topological_space (has_zero (has_add Type))) : regular_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_83257 (h0 : functor.add_const (ordered_add_comm_monoid (finset unsigned)) unsigned) : @archimedean.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83258 (h0 : functor.add_const (list (semigroup unsigned)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_83260 (h0 : topological_space (has_neg (has_neg_part (has_neg_part pos)))) : preconnected_space (has_neg (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_83261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_83262 (h0 : functor.add_const (uniform_space (ordered_ring empty)) empty) : @complete_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_83263 (h2 : uniform_space (distrib to_additive.value_type)) : complete_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83264 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_83265 (h0 : list (complete_lattice (denumerable char))) (h1 : ne h0 list.nil) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} char) (@list.last.{0} (complete_lattice.{0} (denumerable.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_83266 (h0 : function.extfun Type (functor.add_const (ring znum))) : @rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_83267 (h0 : ring (distrib (random_gen string.iterator_imp))) : is_domain (distrib (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_83268 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83269 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_83270 (h1 : topological_space (mul_one_class ereal)) (h2 : set (mul_one_class ereal)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_83271 (h0 : functor.add_const (complete_lattice (has_neg Type)) Type) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_83272 (h1 : string.iterator_imp -> string.iterator_imp -> string.iterator_imp) (h2 : string.iterator_imp) : right_identity h1 h2 := sorry --non-trivial
lemma new_lemma_83273 (h0 : ring (add_cancel_monoid environment.implicit_infer_kind)) : strong_rank_condition (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_83274 (h4 : topological_space fun_info) : locally_compact_space fun_info := sorry --non-trivial
lemma new_lemma_83275 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @sequential_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_83276 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_83277 (h0 : ring (complete_distrib_lattice (option (option empty)))) : strong_rank_condition (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_83278 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_83279 (h2 : uniform_space (semi_normed_ring char)) : complete_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_83280 (h0 : topological_space (finset (has_to_string pos))) : loc_path_connected_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_83281 (h0 : semiring (comm_group pos)) : is_noetherian_ring (comm_group pos) := sorry --non-trivial
lemma new_lemma_83282 (h0 : group (linear_ordered_field (option (option (option (option pos)))))) : group.fg (linear_ordered_field (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_83283 (h0 : functor.add_const (ring (add_comm_monoid pos)) pos) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_83284 (h0 : ordered_comm_monoid (has_Inf (ring pos))) : has_exists_mul_of_le (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_83285 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83286 (h0 : topological_space (cancel_monoid (has_add Type))) : locally_compact_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_83287 (h0 : uniform_space (random_gen (has_ssubset (uniform_space (semi_normed_comm_ring reducibility_hints))))) : complete_space (random_gen (has_ssubset (uniform_space (semi_normed_comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_83288 (h0 : group (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : group.fg (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83289 (h0 : not (complete_lattice (add_cancel_comm_monoid char) -> false)) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_83290 (h3 : filter (has_compl to_additive.value_type)) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_83291 (h1 : complete_lattice (distrib linarith.ineq)) : is_compactly_generated (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_83292 (h0 : filter (semigroup (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_83293 (h0 : not (topological_space (distrib linarith.comp_source) -> false)) : @t0_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_83294 (h0 : ring (measurable_space (has_union empty))) : is_domain (measurable_space (has_union empty)) := sorry --non-trivial
lemma new_lemma_83295 (h1 : group (has_emptyc (with_bot string_imp))) : group.fg (has_emptyc (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_83296 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83297 (h0 : topological_space (has_union (has_norm num))) : locally_compact_space (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_83298 (h0 : monoid (add_cancel_monoid (has_Inf linarith.comp))) : monoid.fg (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_83299 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83300 (h0 : not (uniform_space (complete_semilattice_Sup unsigned) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_83301 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part Type)) linarith.comp) : @archimedean.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83302 (h0 : topological_space (as_linear_order congr_arg_kind)) : loc_path_connected_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83303 (h0 : topological_space (simple_graph name)) : totally_separated_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_83304 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) empty h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_83305 (h0 : group (semiring (random_gen (random_gen linarith.ineq)))) : is_cyclic (semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83306 (h3 : uniform_space string.iterator_imp) : complete_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_83307 (h1 : ring (semi_normed_ring reducibility_hints)) : rank_condition (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_83308 (h0 : group (has_add (option pos))) : is_simple_group (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_83309 (h0 : not (filter (complete_linear_order empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_83310 (h0 : ordered_add_comm_monoid (ring (ring (has_add pos)))) : archimedean (ring (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_83311 (h1 : topological_space (has_norm linarith.comp)) : discrete_topology (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_83312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_83313 (h0 : topological_space (add_comm_monoid (option (option empty)))) : normal_space (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_83314 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83315 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83316 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83317 (h0 : functor.comp topological_space has_nndist ennreal) : @totally_disconnected_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_83318 (h0 : add_monoid (has_bot linarith.comp)) : add_monoid.fg (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_83319 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @totally_disconnected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_83320 (h0 : group (ring (has_neg (has_neg name)))) : group.fg (ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_83321 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @t1_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_83322 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_83323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_83324 (h0 : functor.comp monoid normed_comm_ring name) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_83325 (h0 : functor.add_const (group (left_cancel_monoid unsigned)) empty) : @is_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_83326 (h0 : functor.add_const (filter (has_neg unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83327 (h0 : ordered_add_comm_monoid (plift (option empty))) : archimedean (plift (option empty)) := sorry --non-trivial
lemma new_lemma_83328 (h0 : ring (has_lt (mul_one_class enat))) : rank_condition (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_83329 (h0 : prod (has_nndist (option pos)) (has_nndist (option pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_83330 (h0 : functor.add_const (group (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_83331 (h0 : group (mul_zero_class Type)) : normalizer_condition (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_83332 (h0 : add_group (semilattice_inf (semiring (semiring (semiring (semiring (semiring empty))))))) : is_add_cyclic (semilattice_inf (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_83333 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup char))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup char))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_83334 (h0 : ring (has_emptyc (random_gen fun_info))) : strong_rank_condition (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_83335 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (mul_zero_class unsigned))) : unique_factorization_monoid (mul_zero_class (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_83336 (h0 : ring (canonically_ordered_comm_semiring ennreal)) : is_domain (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_83337 (h1 : add_group (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_add_cyclic (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83338 (h0 : topological_space (comm_ring (linear_ordered_add_comm_group fun_info))) : path_connected_space (comm_ring (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_83339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83340 (h0 : functor.add_const (semiring (boolean_algebra Type)) (boolean_algebra linarith.comp)) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_83341 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83342 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_83343 (h0 : not (topological_space (fintype fun_info) -> false)) : @path_connected_space.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_83344 (h0 : functor.add_const (filter (has_to_string Type)) (has_neg pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83345 (h0 : topological_space (comm_group (semigroup (ring (option pos))))) : path_connected_space (comm_group (semigroup (ring (option pos)))) := sorry --non-trivial
lemma new_lemma_83346 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_83347 (h0 : functor.comp topological_space has_neg_part Type) : @loc_path_connected_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_83348 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83349 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : add_group (add_comm_semigroup fun_info)) : topological_add_group (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_83350 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_83351 (h0 : functor.add_const (topological_space (has_zero name)) pos) : @preconnected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83352 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) num) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_83353 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83354 (h0 : group (bin_tree (semiring unsigned))) : normalizer_condition (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_83355 (h5 : ring (distrib (random_gen char))) : rank_condition (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_83356 (h0 : functor.add_const (complete_lattice (comm_group pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83357 (h0 : functor.add_const Prop (generalized_boolean_algebra (ring Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_83358 (h0 : not (ring (has_lt to_additive.value_type) -> false)) : @rank_condition.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_83359 (h0 : functor.add_const (list (has_pos_part name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83360 (h0 : not (topological_space (uniform_space string.iterator_imp) -> false)) : @path_connected_space.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_83361 (h0 : add_group (has_le to_additive.value_type)) : is_add_cyclic (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83362 (h0 : filter (topological_space (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83363 (h0 : not (function.extfun Type (functor.add_const Prop) -> false)) : functor.add_const.run (function.extfun_app (classical.by_contradiction' h0) (has_norm num)) := sorry --non-trivial
lemma new_lemma_83364 (h0 : group (ordered_comm_ring (has_Inf Type))) : is_cyclic (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_83365 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_83366 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_83367 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83368 (h0 : topological_space congr_arg_kind) : topological_space.separable_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_83369 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_83370 (h0 : topological_space (normed_comm_ring pos)) : totally_disconnected_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_83371 (h0 : topological_space (cancel_monoid (has_neg_part environment.implicit_infer_kind))) : normal_space (cancel_monoid (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83372 (h0 : functor.add_const (function.extfun Type list) environment.implicit_infer_kind) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_83373 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83374 (h7 : not (ring (topological_space char) -> false)) : @is_domain.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h7)  := sorry --non-trivial
lemma new_lemma_83375 (h0 : topological_space Type) : preirreducible_space Type := sorry --non-trivial
lemma new_lemma_83376 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) num) : @group.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_83377 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83378 (h0 : topological_space (has_Sup unsigned)) : topological_space.separable_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_83379 (h1 : topological_space (nondiscrete_normed_field enat)) (h2 : has_sub (nondiscrete_normed_field enat)) : has_continuous_sub (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_83380 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @preirreducible_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_83381 (h0 : functor.add_const (ring (has_bot linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83382 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83383 (h0 : topological_space (measurable_space (semiring empty))) : totally_separated_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_83384 (h1 : topological_space (measurable_space (has_norm fun_info))) : totally_disconnected_space (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_83385 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_83386 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t0_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_83387 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83388 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83389 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : regular_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_83390 (h0 : functor.add_const (group (boolean_algebra.core name)) Type) : @group.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_83391 (h0 : functor.add_const (group (ring Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83392 (h0 : ring (has_to_string (has_neg (finset (has_neg linarith.comp))))) : rank_condition (has_to_string (has_neg (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_83393 (h0 : ring (has_nndist (has_zero pos))) : rank_condition (has_nndist (has_zero pos)) := sorry --non-trivial
lemma new_lemma_83394 (h0 : complete_lattice (monoid_with_zero (option (option ennreal)))) : is_compactly_generated (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_83395 (h0 : uniform_space (semiring linarith.comp)) : separated_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_83396 (h0 : filter (boolean_algebra (has_neg environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83397 (h0 : functor.add_const (group (ring name)) (boolean_algebra (has_neg Type))) : @normalizer_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) (boolean_algebra.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_83398 (h0 : functor.add_const (uniform_space (has_zero pos)) pos) : @complete_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_83399 (h1 : ring (complete_semilattice_Sup fun_info)) : rank_condition (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_83400 (h1 : ring (normed_field (normed_field linarith.ineq))) : strong_rank_condition (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83401 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) Type) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_83402 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : discrete_topology (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_83403 (h0 : functor.add_const (complete_lattice (semiring unsigned)) congr_arg_kind) : @is_atomistic.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83404 (h0 : complete_lattice (normed_linear_ordered_group (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83405 (h0 : functor.add_const (finset (boolean_algebra.core Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83406 (h0 : list (has_inner (option (option empty)) (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83407 (h0 : topological_space (finset (ring linarith.comp))) : topological_space.separable_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_83408 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid real)))) : preirreducible_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_83409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83410 (h0 : topological_space (monoid (option num))) : normal_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_83411 (h0 : ordered_comm_monoid (comm_group (comm_group unsigned))) : has_exists_mul_of_le (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_83412 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : locally_compact_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_83413 (h0 : topological_space (has_emptyc (has_top (has_top linarith.comp_source)))) : locally_compact_space (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_83414 (h0 : functor.add_const (filter (has_add name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83415 (h0 : topological_space (boolean_algebra.core (finset (ring name)))) : path_connected_space (boolean_algebra.core (finset (ring name))) := sorry --non-trivial
lemma new_lemma_83416 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_83417 (h0 : ring (ring (boolean_algebra Type))) : strong_rank_condition (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_83418 (h0 : topological_space (has_zero (measurable_space linarith.comp))) : preirreducible_space (has_zero (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_83419 (h0 : preorder (comm_group (has_neg_part pos))) (h1 : comm_group (has_neg_part pos) -> set pos) : filter.is_antitone_basis h1 := sorry --non-trivial
lemma new_lemma_83420 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83421 (h0 : ring (has_norm linarith.ineq)) : strong_rank_condition (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_83422 (h1 : complete_lattice (measurable_space (has_norm congr_arg_kind))) : is_atomistic (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_83423 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (ring (has_neg Type))) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_83424 (h1 : set (string.iterator_imp -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_83425 (h0 : topological_space (semiring linarith.comp_source)) : t0_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_83426 (h2 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83427 (h0 : functor.comp (functor.add_const (complete_lattice (pseudo_metric_space unsigned))) option pos) : @is_atomistic.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned)) (option.{0} pos) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned))) option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_83428 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) name) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_83429 (h0 : complete_lattice (non_assoc_semiring (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_83430 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83431 (h0 : topological_space (nondiscrete_normed_field (mul_one_class enat))) (h1 : add_group (nondiscrete_normed_field (mul_one_class enat))) : topological_add_group (nondiscrete_normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_83432 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_83433 (h0 : topological_space (comm_ring (random_gen (has_ssubset to_additive.value_type)))) : locally_compact_space (comm_ring (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_83434 (h0 : random_gen to_additive.value_type -> random_gen to_additive.value_type -> Prop) (h1 : random_gen to_additive.value_type) (h2 : rbtree (random_gen to_additive.value_type) h0) : rbtree.mem h1 h2 := sorry --non-trivial
lemma new_lemma_83435 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_83436 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_Inf (has_Inf linarith.comp))) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_83437 (h0 : list (ordered_comm_ring (finset (ring linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83438 (h0 : not (complete_lattice (has_nnnorm char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_83439 (h0 : add_monoid (has_pos_part pos)) : add_monoid.fg (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_83440 (h0 : semiring (normed_lattice_add_comm_group (sub_neg_monoid Type))) : is_noetherian_ring (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_83441 (h0 : topological_space (has_neg_part pos)) : regular_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_83442 (h0 : topological_space (has_append to_additive.value_type)) : path_connected_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83443 (h0 : not (ring (has_lt (has_lt linarith.comp_source)) -> false)) : @rank_condition.{0} (has_lt.{0} (has_lt.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} (has_lt.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_83444 (h0 : topological_space (ring (has_to_string Type))) : totally_disconnected_space (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_83445 (h0 : topological_space (complete_distrib_lattice name)) : discrete_topology (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_83446 (h0 : filter (has_inv (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83447 (h0 : list (list Prop)) : list.head (list.head (list.head (id (free_monoid.of h0)))) := sorry --non-trivial
lemma new_lemma_83448 (h0 : functor.add_const (filter (add_cancel_monoid name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83449 (h0 : prod (finset (semiring unsigned)) (finset (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_83450 (h0 : functor.add_const (add_group (has_Inf real)) Type) : @is_add_cyclic.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 1} (add_group.{0} (has_Inf.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_83451 (h0 : topological_space (has_ssubset (mul_one_class string_imp))) : totally_disconnected_space (has_ssubset (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_83452 (h0 : not (cancel_comm_monoid_with_zero (measure_theory.measure_space empty) -> false)) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_83453 (h0 : topological_space (has_inter num)) : t0_space (has_inter num) := sorry --non-trivial
lemma new_lemma_83454 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) unsigned) : @irreducible_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83455 (h0 : functor.add_const (topological_space pos) (option (option pos))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83456 (h0 : list (semigroup (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83457 (h0 : functor.add_const (function.extfun Type add_monoid) real) : @add_monoid.fg.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) real h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_83458 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83459 (h1 : complete_lattice congr_arg_kind) : complete_lattice.is_Sup_finite_compact congr_arg_kind := sorry --non-trivial
lemma new_lemma_83460 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_83461 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_83462 (h1 : empty -> empty -> Prop) (h2 : empty) (h3 : rbmap empty num h1) : rbmap.mem h2 h3 := sorry --non-trivial
lemma new_lemma_83463 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : totally_disconnected_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83464 (h0 : not (group fun_info -> false)) : @group.fg.{0} fun_info (@classical.by_contradiction'.{1} (group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_83465 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_83466 (h0 : uniform_space (ring (has_add (has_neg (ring (has_pos_part pos)))))) : complete_space (ring (has_add (has_neg (ring (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_83467 (h0 : filter (non_assoc_semiring empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83468 (h0 : uniform_space (with_one (linear_ordered_semiring empty))) : complete_space (with_one (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_83469 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83470 (h0 : add_monoid (has_nndist Type)) : add_monoid.fg (has_nndist Type) := sorry --non-trivial
lemma new_lemma_83471 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_83472 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_83473 (h0 : list (cancel_monoid (semigroup (semigroup (semigroup environment.implicit_infer_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83474 (h0 : list (has_top (random_gen (has_ssubset (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83475 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) num) : @preirreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_83476 (h0 : topological_space (complete_distrib_lattice pos)) : totally_disconnected_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_83477 (h2 : group (has_top linarith.ineq)) : is_cyclic (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_83478 (h0 : group (sub_neg_monoid (has_neg real))) : is_simple_group (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_83479 (h1 : topological_space (nondiscrete_normed_field (mul_one_class char))) (h2 : add_group (nondiscrete_normed_field (mul_one_class char))) : topological_add_group (nondiscrete_normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_83480 (h0 : ring (normed_group (has_norm (has_top fun_info)))) : strong_rank_condition (normed_group (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_83481 (h0 : functor.add_const (list (ordered_comm_monoid Type)) (has_add pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83482 (h0 : topological_space (has_nndist (has_nndist environment.implicit_infer_kind))) : discrete_topology (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83483 (h0 : topological_space (canonically_linear_ordered_monoid (has_add ennreal))) : t0_space (canonically_linear_ordered_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_83484 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @regular_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83485 (h0 : functor.comp (functor.comp topological_space canonically_ordered_comm_semiring) option name) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} (option.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} (option.{0} name) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) option.{0} name h0))  := sorry --non-trivial
lemma new_lemma_83486 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_83487 (h0 : uniform_space linarith.comp) : complete_space linarith.comp := sorry --non-trivial
lemma new_lemma_83488 (h0 : functor.add_const (filter (finset linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83489 (h0 : functor.add_const (semiring (has_neg environment.implicit_infer_kind)) (finset Type)) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (has_neg.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_83490 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83491 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83492 (h1 : has_le linarith.ineq) : no_bot_order linarith.ineq := sorry --non-trivial
lemma new_lemma_83493 (h0 : ring (has_inf name)) : rank_condition (has_inf name) := sorry --non-trivial
lemma new_lemma_83494 (h0 : functor.add_const (ring (ring unsigned)) linarith.comp) : @rank_condition.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83495 (h0 : list (has_neg (boolean_algebra linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83496 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_83497 (h3 : topological_space char) (h4 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_83498 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : discrete_topology (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_83499 (h1 : topological_space (simple_graph (mul_one_class string_imp))) : path_connected_space (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_83500 (h0 : ring (has_norm (has_top (random_gen (has_nnnorm (random_gen linarith.ineq)))))) : is_domain (has_norm (has_top (random_gen (has_nnnorm (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_83501 (h0 : topological_space (comm_semigroup (has_bot name))) : topological_space.separable_space (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_83502 (h1 : ring (has_top linarith.comp)) : rank_condition (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_83503 (h0 : topological_space (finset (has_add Type))) : topological_space.separable_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_83504 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83505 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : t1_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_83506 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @path_connected_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_83507 (h0 : function.extfun Type (functor.comp (functor.comp topological_space semigroup) semigroup)) : @t0_space.{0} (semigroup.{0} (semigroup.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (semigroup.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) semigroup.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) semigroup.{0}) h0 unsigned)))  := sorry --non-trivial
lemma new_lemma_83508 (h0 : topological_space (normed_group (semiring linarith.comp))) : totally_disconnected_space (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_83509 (h0 : group (has_neg_part (has_add (has_add (has_neg_part name))))) : group.fg (has_neg_part (has_add (has_add (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_83510 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) name) name) : @locally_compact_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) name) name h0))  := sorry --non-trivial
lemma new_lemma_83511 (h0 : add_group (add_cancel_monoid empty)) : is_add_cyclic (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_83512 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_83513 (h0 : topological_space (has_inv linarith.comp_source)) : t0_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_83514 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83515 (h0 : add_monoid (semigroup unsigned)) : add_monoid.fg (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_83516 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : locally_compact_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83517 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_83518 (h0 : group (has_top (semiring num))) : normalizer_condition (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_83519 (h0 : uniform_space (complete_distrib_lattice num)) : complete_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_83520 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83521 (h0 : functor.add_const (topological_space (linear_ordered_semiring empty)) unsigned) : @path_connected_space.{0} (linear_ordered_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83522 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @preirreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_83524 (h0 : uniform_space (metric_space num)) : complete_space (metric_space num) := sorry --non-trivial
lemma new_lemma_83525 (h0 : nat) (h1 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (sym.{0} bool h0) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h1 (sym.{0} bool h0))  := sorry --non-trivial
lemma new_lemma_83526 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_83527 (h0 : list (boolean_algebra.core (has_add ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83528 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83529 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_83530 (h0 : functor.add_const (add_group nnreal) empty) : @is_add_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (add_group.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_83531 (h0 : not (ring (topological_space reducibility_hints) -> false)) : @strong_rank_condition.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_83532 (h0 : topological_space (add_comm_monoid ennreal)) : preconnected_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_83533 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_83534 (h0 : char -> Prop) (h1 : set (derive_fintype.finset_in h0 -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_83535 (h0 : filter (linear_ordered_add_comm_group (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83536 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_83537 (h0 : uniform_space (mul_zero_class (has_nndist pos))) : complete_space (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_83538 (h0 : topological_space (plift (add_group num))) : path_connected_space (plift (add_group num)) := sorry --non-trivial
lemma new_lemma_83539 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83540 (h0 : filter (dlist (random_gen (has_nnnorm char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83541 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group (semiring empty))) : unique_factorization_monoid (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_83542 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) unsigned) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83543 (h0 : finset (free_add_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83544 (h0 : functor.add_const (ring (add_comm_monoid name)) linarith.comp) : @is_domain.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83545 (h0 : topological_space (has_zero (has_add Type))) : locally_compact_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_83546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_83547 (h0 : has_top (left_cancel_semigroup unsigned) -> has_top (left_cancel_semigroup unsigned) -> Prop) : is_strict_order (has_top (left_cancel_semigroup unsigned)) h0 := sorry --non-trivial
lemma new_lemma_83548 (h0 : not (ring (has_ssubset string_imp) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_83549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_83550 (h0 : ring (add_comm_monoid (finset environment.implicit_infer_kind))) : strong_rank_condition (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83551 (h0 : not (topological_space (has_sub num) -> false)) : @totally_separated_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_83552 (h0 : function.extfun Type (prod (has_nndist name))) : id_rel (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_83553 (h0 : functor.add_const (functor.add_const (uniform_space (ordered_comm_group unsigned)) unsigned) congr_arg_kind) : @separated_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_group.{0} unsigned)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (ordered_comm_group.{0} unsigned)) unsigned) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_83554 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_83555 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83556 (h0 : not (ring (semi_normed_comm_ring linarith.ineq) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_83557 (h0 : topological_space (has_nndist congr_arg_kind)) : totally_disconnected_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83558 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_83559 (h0 : ring (ring (boolean_algebra pos))) : is_domain (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_83560 (h0 : group (ordered_comm_group empty)) : is_cyclic (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_83561 (h0 : ordered_add_comm_monoid (add_comm_monoid (option unsigned))) : archimedean (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_83562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (ring ennreal)) := sorry --non-trivial
lemma new_lemma_83563 (h0 : list (ordered_comm_monoid (ordered_comm_ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83564 (h0 : uniform_space (id (with_bot to_additive.value_type))) : complete_space (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83565 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83566 (h0 : topological_space (has_inv (has_nnnorm linarith.ineq))) : path_connected_space (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83567 (h0 : functor.add_const (group (boolean_algebra pos)) name) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_83568 (h0 : topological_space (boolean_algebra (has_neg_part name))) : totally_disconnected_space (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_83569 (h0 : complete_lattice (add_comm_monoid (option pos))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_83570 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83571 (h0 : functor.add_const (filter (has_nndist ennreal)) (finset (finset pos))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83572 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_83573 (h0 : complete_lattice (semigroup (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_83574 (h0 : add_monoid (has_nndist (has_nndist environment.implicit_infer_kind))) : add_monoid.fg (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83575 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_83576 (h0 : group (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_83577 (h1 : topological_space (has_inv (random_gen linarith.comp_source))) : t0_space (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83578 (h1 : topological_space (topological_space fun_info)) : totally_disconnected_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_83579 (h0 : topological_space (has_norm (div_inv_monoid fun_info))) : totally_disconnected_space (has_norm (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_83580 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83581 (h0 : topological_space (normed_group (has_norm num))) : t0_space (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_83582 (h0 : group (measurable_space (random_gen (random_gen fun_info)))) : is_cyclic (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_83583 (h0 : ordered_comm_monoid (normed_comm_ring (has_add name))) : has_exists_mul_of_le (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_83584 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83585 (h0 : complete_lattice (normed_lattice_add_comm_group (has_neg (has_neg name)))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_83586 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83587 (h0 : topological_space (finset (normed_comm_ring Type))) : t1_space (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_83588 (h0 : ring (has_compl (mul_one_class to_additive.value_type))) : strong_rank_condition (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83589 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (distrib (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_83590 (h0 : ring (linear_ordered_add_comm_group (has_ssubset (div_inv_monoid (encodable fun_info))))) : is_domain (linear_ordered_add_comm_group (has_ssubset (div_inv_monoid (encodable fun_info)))) := sorry --non-trivial
lemma new_lemma_83591 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_83592 (h0 : topological_space (ring (has_Inf (has_Inf Type)))) : totally_separated_space (ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_83593 (h1 : ultrafilter Prop) : @ultrafilter.Lim.{0} Prop sierpinski_space h1  := sorry --non-trivial
lemma new_lemma_83594 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83595 (h0 : functor.add_const (group (mul_zero_class num)) num) : @group.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_83596 (h0 : topological_space (has_dist (option num))) : loc_path_connected_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_83597 (h0 : topological_space (has_nndist (has_to_string name))) : path_connected_space (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_83598 (h0 : cancel_comm_monoid_with_zero (add_comm_semigroup linarith.ineq)) (h1 : ring (gcd_monoid (add_comm_semigroup linarith.ineq))) : is_domain (gcd_monoid (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83599 (h1 : ring (monoid string_imp)) : is_domain (monoid string_imp) := sorry --non-trivial
lemma new_lemma_83600 (h0 : ring (comm_ring (metric_space reducibility_hints))) : is_domain (comm_ring (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_83601 (h0 : filter (measure_theory.measure_space empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83602 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @separated_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_83603 (h0 : filter (bin_tree unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83604 (h0 : functor.comp complete_lattice has_add Type) : @is_atomistic.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_83605 (h0 : ulower (ulower (ulower pnat))) (h1 : pnat) : pnat.coprime (ulower.up (ulower.up (ulower.up h0))) h1 := sorry --non-trivial
lemma new_lemma_83606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_83607 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one empty)) := sorry --non-trivial
lemma new_lemma_83608 (h0 : ring (has_top (with_bot (with_bot string_imp)))) : is_domain (has_top (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_83609 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_83610 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83611 (h0 : functor.add_const (group (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83612 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : normal_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_83613 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83614 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h1 : punit) : t0_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_83615 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_83616 (h0 : topological_space (boolean_algebra.core linarith.comp)) : totally_disconnected_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_83617 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class reducibility_hints))) (h1 : not (preorder (add_cancel_comm_monoid (mul_one_class reducibility_hints)) -> false)) : @order_topology.{0} (add_cancel_comm_monoid.{0} (mul_one_class.{0} reducibility_hints)) h0 (@classical.by_contradiction'.{1} (preorder.{0} (add_cancel_comm_monoid.{0} (mul_one_class.{0} reducibility_hints))) h1)  := sorry --non-trivial
lemma new_lemma_83618 (h0 : semiring (has_bot (has_bot (has_Inf real)))) : is_noetherian_ring (has_bot (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_83619 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_83620 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83621 (h0 : complete_lattice (finset empty)) : is_compactly_generated (finset empty) := sorry --non-trivial
lemma new_lemma_83622 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : t0_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_83623 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @normal_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83624 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group Type)))) : t1_space (add_cancel_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_83625 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_83626 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @preirreducible_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_83627 (h0 : uniform_space (has_zero (ring pos))) : separated_space (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_83628 (h0 : group (with_bot to_additive.value_type)) : normalizer_condition (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83629 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_83630 (h0 : add_group (complete_semilattice_Sup string_imp)) : is_add_cyclic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_83631 (h0 : uniform_space (has_to_string pos)) : complete_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_83632 (h0 : not (group (comm_ring reducibility_hints) -> false)) : @is_cyclic.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_83633 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_83634 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid pos)) (ring Type)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_83635 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_83636 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_83637 (h0 : ring (canonically_ordered_comm_semiring name)) : strong_rank_condition (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_83638 (h0 : add_group (linear_ordered_cancel_comm_monoid to_additive.value_type)) : is_add_cyclic (linear_ordered_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83640 (h0 : ring (has_lt (has_lt reducibility_hints))) : rank_condition (has_lt (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_83641 (h0 : ring environment.projection_info) : is_domain environment.projection_info := sorry --non-trivial
lemma new_lemma_83642 (h0 : finset (has_pos_part (has_add (has_add (has_add linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83643 (h0 : functor.add_const (uniform_space (has_zero Type)) name) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_83644 (h0 : functor.add_const (topological_space (has_neg Type)) (has_Inf name)) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_83645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_83646 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) Type) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_83647 (h0 : topological_space (add_cancel_monoid (has_to_string name))) : loc_path_connected_space (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_83648 (h0 : functor.add_const (semiring (boolean_algebra pos)) name) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_83649 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_83650 (h0 : fun_info -> fun_info -> fun_info) (h2 : fun_info) : right_identity h0 h2 := sorry --non-trivial
lemma new_lemma_83651 (h0 : functor.add_const (topological_space (ring name)) pos) : @preirreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83652 (h0 : group (normed_group (has_nnnorm char))) : group.fg (normed_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_83653 (h0 : group (comm_group (option ennreal))) : normalizer_condition (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_83654 (h1 : uniform_space (normed_field reducibility_hints)) : complete_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_83655 (h0 : topological_space (measurable_space (semiring (semiring (semiring linarith.comp))))) : preirreducible_space (measurable_space (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_83656 (h0 : functor.comp topological_space boolean_algebra.core pos) : @totally_separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_83657 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83658 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) (option (option pos))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83659 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83660 (h0 : topological_space (random_gen (has_inv (has_inv fun_info)))) : totally_disconnected_space (random_gen (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_83661 (h0 : complete_lattice std_gen) : complete_lattice.is_Sup_finite_compact std_gen := sorry --non-trivial
lemma new_lemma_83662 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83663 (h0 : topological_space (left_cancel_monoid (option (option empty)))) : normal_space (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_83664 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_83665 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_83666 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83667 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83668 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83669 (h2 : complete_lattice (semi_normed_comm_ring linarith.comp_source)) : is_compactly_generated (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_83670 (h0 : uniform_space (semiring (has_top (has_top linarith.ineq)))) : complete_space (semiring (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83671 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part real)))) : normal_space (boolean_algebra (has_Inf (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_83672 (h0 : not (ring (dlist char) -> false)) : @rank_condition.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_83673 (h0 : topological_space (has_union (has_norm (has_top empty)))) : discrete_topology (has_union (has_norm (has_top empty))) := sorry --non-trivial
lemma new_lemma_83674 (h0 : list (partial_order num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83675 (h0 : functor.add_const (ring (plift congr_arg_kind)) unsigned) : @rank_condition.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83676 (h0 : group (complete_distrib_lattice Type)) : group.fg (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_83677 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_83678 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @add_monoid.fg.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_83679 (h0 : fin has_zero.zero) : @t0_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_83680 (h0 : topological_space (has_dist (option unsigned))) : preirreducible_space (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_83681 (h2 : topological_space linarith.ineq) (h3 : set linarith.ineq) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_83682 (h0 : complete_lattice (has_to_string (has_add (has_neg_part Type)))) : is_atomistic (has_to_string (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_83683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83684 (h0 : ring (metric_space (semiring (semiring (semiring num))))) : is_principal_ideal_ring (metric_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_83685 (h0 : topological_space (add_group_with_zero_nhd congr_arg_kind)) : preconnected_space (add_group_with_zero_nhd congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83686 (h0 : functor.add_const (ring (has_neg unsigned)) Type) : @strong_rank_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_83687 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83688 (h0 : functor.add_const (ring (boolean_algebra name)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83689 (h0 : complete_lattice (dlist char)) : complete_lattice.is_Sup_finite_compact (dlist char) := sorry --non-trivial
lemma new_lemma_83690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_83691 (h0 : complete_lattice (random_gen (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_83692 (h0 : functor.add_const (functor.add_const Prop (has_nndist name)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83693 (h0 : ring (random_gen (comm_ring (random_gen char)))) : is_domain (random_gen (comm_ring (random_gen char))) := sorry --non-trivial
lemma new_lemma_83694 (h0 : topological_space (has_neg_part (add_comm_monoid (has_add linarith.comp)))) : irreducible_space (has_neg_part (add_comm_monoid (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_83695 (h0 : topological_space (add_cancel_monoid (finset name))) : path_connected_space (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_83696 (h0 : ring (simple_graph std_gen)) : rank_condition (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_83697 (h0 : functor.add_const (add_monoid (has_to_string pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83698 (h0 : ring (comm_semigroup (ordered_comm_monoid (has_Inf pos)))) : strong_rank_condition (comm_semigroup (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_83699 (h0 : ring (normed_comm_ring (has_nndist ennreal))) : rank_condition (normed_comm_ring (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_83700 (h0 : topological_space (has_Inf (ring (ring (ring Type))))) : totally_disconnected_space (has_Inf (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_83701 (h0 : function.extfun Type ring) : @is_domain.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83702 (h0 : function.extfun Type (functor.comp ring linear_ordered_field)) : @rank_condition.{0} (linear_ordered_field.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_field.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} linear_ordered_field.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83703 (h0 : group (has_emptyc (random_gen string_imp))) : normalizer_condition (has_emptyc (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_83704 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_83705 (h0 : cancel_comm_monoid_with_zero (partial_order (measurable_space.dynkin_system (add_group empty)))) : unique_factorization_monoid (partial_order (measurable_space.dynkin_system (add_group empty))) := sorry --non-trivial
lemma new_lemma_83706 (h2 : uniform_space (has_ssubset (has_nnnorm fun_info))) : complete_space (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_83707 (h0 : ordered_comm_monoid (comm_group (finset Type))) : has_exists_mul_of_le (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_83708 (h0 : group (has_nndist (finset (has_to_string (has_to_string Type))))) : group.fg (has_nndist (finset (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_83709 (h0 : finset (has_nndist (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83710 (h0 : ring (normed_lattice_add_comm_group (has_neg (has_neg pos)))) : strong_rank_condition (normed_lattice_add_comm_group (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_83711 (h0 : add_group (comm_group Type)) : is_add_cyclic (comm_group Type) := sorry --non-trivial
lemma new_lemma_83712 (h0 : topological_space (with_one unsigned)) : path_connected_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_83713 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83714 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_83715 (h0 : ordered_add_comm_monoid (left_cancel_monoid num)) : archimedean (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_83716 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (non_assoc_semiring num)) := sorry --non-trivial
lemma new_lemma_83717 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @loc_path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83718 (h1 : topological_space (with_one fun_info)) : t0_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_83719 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_bot empty)) := sorry --non-trivial
lemma new_lemma_83720 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_83721 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83722 (h1 : topological_space (has_add string_imp)) : totally_disconnected_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_83723 (h0 : topological_space (non_unital_non_assoc_semiring fun_info)) : totally_disconnected_space (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_83724 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83725 (h0 : monoid (normed_comm_ring (ring pos))) : monoid.fg (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_83726 (h0 : not (topological_space (div_inv_monoid to_additive.value_type) -> false)) : @t0_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_83727 (h0 : has_mem.mem (id linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_83728 (h0 : uniform_space (has_bot (finset (has_neg name)))) : complete_space (has_bot (finset (has_neg name))) := sorry --non-trivial
lemma new_lemma_83729 (h0 : topological_space (add_comm_monoid (has_add (has_Inf Type)))) : normal_space (add_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_83730 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_83731 (h1 : complete_lattice (has_ssubset (mul_one_class (mul_one_class (mul_one_class char))))) : is_compactly_generated (has_ssubset (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_83732 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83733 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83734 (h0 : topological_space (boolean_algebra (cancel_monoid environment.implicit_infer_kind))) : t1_space (boolean_algebra (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_83735 (h0 : functor.add_const (add_group (has_to_string Type)) (has_neg linarith.comp)) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_83736 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83737 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83739 (h0 : ring (has_Inf (has_add (has_neg linarith.comp)))) : is_domain (has_Inf (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_83740 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83741 (h0 : topological_space (has_nndist (has_add (comm_group Type)))) : t0_space (has_nndist (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_83742 (h2 : list (complete_semilattice_Sup (with_bot num))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_83743 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_83744 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_83745 (h0 : ring (ring (has_add (has_neg_part (has_add Type))))) : strong_rank_condition (ring (has_add (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_83746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_83747 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83748 (h0 : monoid (comm_semigroup (sub_neg_monoid pos))) : monoid.fg (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_83749 (h0 : group (encodable (has_nnnorm to_additive.value_type))) : is_cyclic (encodable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83750 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_83751 (h0 : group (has_to_string (has_nndist (ring linarith.comp)))) : group.fg (has_to_string (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_83752 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @preconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83753 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : t1_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_83754 (h0 : functor.comp topological_space semigroup ennreal) : @preirreducible_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_83755 (h0 : topological_space (has_to_string (finset (has_Inf (finset (has_add (has_add pos))))))) : path_connected_space (has_to_string (finset (has_Inf (finset (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_83756 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_83757 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_83758 (h0 : multiset (has_nnnorm char)) (h1 : not (multiset (has_nnnorm char) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_83759 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) num) : @t1_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_83760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_83761 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring name)) := sorry --non-trivial
lemma new_lemma_83762 (h0 : not (topological_space (canonically_ordered_monoid empty) -> false)) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (canonically_ordered_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_83763 (h0 : add_group (generalized_boolean_algebra (boolean_algebra.core linarith.comp))) : is_add_cyclic (generalized_boolean_algebra (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_83764 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid Type)) linarith.comp) : @is_domain.{1} (canonically_linear_ordered_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_linear_ordered_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83765 (h0 : complete_lattice (random_gen (has_norm empty))) : is_compactly_generated (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_83766 (h0 : ring (ring congr_arg_kind)) : is_principal_ideal_ring (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83767 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83768 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @sequential_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_83769 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_83770 (h0 : functor.add_const (complete_lattice (has_add unsigned)) pos) : @is_compactly_generated.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_83771 (h0 : complete_lattice empty) : is_atomistic empty := sorry --non-trivial
lemma new_lemma_83772 (h0 : add_group (semiring (semiring num))) : is_add_cyclic (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_83773 (h1 : has_neg (simple_graph std_gen)) (h2 : measurable_space (simple_graph std_gen)) : has_measurable_neg (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_83774 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : regular_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_83775 (h0 : topological_space (has_norm unsigned)) : discrete_topology (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_83776 (h0 : topological_space (comm_group (boolean_algebra (finset (measurable_space (has_nndist pos)))))) : normal_space (comm_group (boolean_algebra (finset (measurable_space (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_83777 (h0 : group (has_bot (has_add real))) : group.fg (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_83778 (h0 : topological_space (has_norm (has_top (has_top (random_gen num))))) : totally_separated_space (has_norm (has_top (has_top (random_gen num)))) := sorry --non-trivial
lemma new_lemma_83779 (h0 : not (add_group (semi_normed_ring char) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_83780 (h0 : uniform_space (id (semiring congr_arg_kind))) : separated_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_83781 (h0 : monoid (add_left_cancel_semigroup congr_arg_kind)) : monoid.fg (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83783 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (finset Type)) : @archimedean.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (finset.{1} Type) h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_83784 (h0 : not (topological_space (id empty) -> false)) : @discrete_topology.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_83785 (h2 : add_group (simple_graph to_additive.value_type)) : is_add_cyclic (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83786 (h0 : group (has_bot (has_nndist (has_add (has_add (has_Inf linarith.comp)))))) : normalizer_condition (has_bot (has_nndist (has_add (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_83787 (h0 : topological_space (has_bot (comm_semigroup (ordered_comm_monoid (has_bot real))))) : locally_compact_space (has_bot (comm_semigroup (ordered_comm_monoid (has_bot real)))) := sorry --non-trivial
lemma new_lemma_83788 (h0 : not (topological_space (has_norm unsigned) -> false)) : @preirreducible_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_83789 (h0 : ordered_comm_monoid (complete_distrib_lattice (option pos))) : has_exists_mul_of_le (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_83790 (h0 : monoid (plift (has_edist (option empty)))) : monoid.fg (plift (has_edist (option empty))) := sorry --non-trivial
lemma new_lemma_83791 (h1 : has_lt (normed_field (normed_field std_gen))) : no_max_order (normed_field (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_83792 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid unsigned)))) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_83793 (h0 : topological_space (measurable_space.dynkin_system (option unsigned))) : totally_separated_space (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_83794 (h0 : not (add_group (has_emptyc congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_83795 (h0 : topological_space (group_with_zero unsigned)) : sequential_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_83796 (h0 : filter (boolean_algebra (has_to_string (has_to_string (finset (finset pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_83797 (h1 : group (has_emptyc (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_83798 (h0 : ordered_add_comm_monoid (cancel_monoid (boolean_algebra (ring Type)))) : archimedean (cancel_monoid (boolean_algebra (ring Type))) := sorry --non-trivial
lemma new_lemma_83799 (h0 : list (linear_ordered_add_comm_group (dlist (has_one (has_inv (has_norm fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83800 (h0 : functor.add_const (ring (generalized_boolean_algebra name)) (has_add pos)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_83801 (h0 : ring (has_dist empty)) : strong_rank_condition (has_dist empty) := sorry --non-trivial
lemma new_lemma_83802 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_83803 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_83805 (h0 : topological_space (distrib (semi_normed_ring char))) : path_connected_space (distrib (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_83806 (h0 : add_group (has_compl linarith.ineq)) : is_add_cyclic (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_83807 (h0 : not (complete_lattice (ordered_ring unsigned) -> false)) : @is_atomistic.{0} (ordered_ring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (ordered_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_83808 (h0 : function.extfun Type (functor.add_const (topological_space (as_linear_order congr_arg_kind)))) : @totally_separated_space.{0} (as_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (as_linear_order.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_83809 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83810 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_83811 (h0 : group (semigroup (has_nndist Type))) : group.fg (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_83812 (h1 : complete_lattice (distrib (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83813 (h0 : list (has_to_string (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83814 (h0 : topological_space (has_le (mul_one_class linarith.comp_source))) : totally_disconnected_space (has_le (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83815 (h0 : ring (has_neg (has_Inf (has_Inf linarith.comp)))) : rank_condition (has_neg (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_83816 (h0 : topological_space (has_bot (has_Inf Type))) : totally_separated_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_83817 (h0 : list (simple_graph (has_add (ring pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83818 (h0 : complete_lattice (order_dual to_additive.value_type)) : is_atomistic (order_dual to_additive.value_type) := sorry --non-trivial
lemma new_lemma_83819 (h0 : ring (has_ssubset fun_info)) : is_domain (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_83820 (h0 : uniform_space ennreal) : complete_space ennreal := sorry --non-trivial
lemma new_lemma_83821 (h0 : add_group (simple_graph (has_Inf linarith.comp))) : is_add_cyclic (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_83822 (h0 : ring (normed_group (with_bot string_imp))) : is_domain (normed_group (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_83823 (h0 : add_group (has_emptyc (has_top (has_top num)))) : is_add_cyclic (has_emptyc (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_83824 (h2 : ring (denumerable (random_gen char))) : is_domain (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_83825 (h0 : topological_space (normed_group (random_gen linarith.ineq))) : totally_separated_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_83826 (h0 : ring (dlist (random_gen to_additive.value_type))) : strong_rank_condition (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83827 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83828 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_83829 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_atomistic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83830 (h0 : ring (has_dist congr_arg_kind)) : rank_condition (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83831 (h0 : topological_space (generalized_boolean_algebra (generalized_boolean_algebra Type))) : path_connected_space (generalized_boolean_algebra (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_83832 (h0 : functor.add_const (uniform_space (normed_comm_ring ennreal)) name) : @complete_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_83833 (h0 : functor.add_const (list (semigroup Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83834 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring empty)))))) : complete_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_83835 (h0 : topological_space (cancel_monoid (ring name))) : irreducible_space (cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_83836 (h0 : topological_space (ring (has_Inf (has_Inf (has_Inf name))))) : regular_space (ring (has_Inf (has_Inf (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_83837 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83838 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero comm_group)) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_83839 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @sequential_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83840 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @t0_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83841 (h0 : list (ordered_comm_ring linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83842 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_83843 (h3 : ring (distrib (has_ssubset char))) : is_domain (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_83844 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_83845 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @totally_separated_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83846 (h0 : complete_lattice (semigroup empty)) : is_compactly_generated (semigroup empty) := sorry --non-trivial
lemma new_lemma_83847 (h1 : topological_space (with_one (with_bot linarith.comp_source))) : t0_space (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83848 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen linarith.ineq))))) : t0_space (normed_group (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_83849 (h0 : monoid (add_right_cancel_monoid unsigned)) : monoid.fg (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_83850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_83851 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83852 (h0 : topological_space (with_bot (semiring (semiring empty)))) : t0_space (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_83854 (h0 : measurable_space (mul_one_class char)) (h1 : measure_theory.measure (mul_one_class char)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_83855 (h1 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) fun_info)  := sorry --non-trivial
lemma new_lemma_83856 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83857 (h0 : complete_lattice (has_zero (comm_group name))) : complete_lattice.is_Sup_finite_compact (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_83858 (h0 : functor.add_const (list (linear_order unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83859 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83860 (h0 : topological_space (comm_group (option pos))) : loc_path_connected_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_83861 (h0 : group (has_compl (random_gen fun_info))) : group.fg (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_83862 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83863 (h0 : list (has_Sup congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83864 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_83865 (h0 : functor.add_const (ring (has_to_string empty)) num) : @is_principal_ideal_ring.{0} (has_to_string.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_83866 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_83867 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_83868 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot (has_norm (semiring (semiring (has_norm fun_info))))))) : @add_monoid.fg.{0} (with_bot.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} fun_info))))) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} fun_info))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} fun_info)))))) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_83869 (h0 : group (has_to_string (finset (has_add name)))) : group.fg (has_to_string (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_83870 (h0 : uniform_space (has_add (has_nnnorm (has_ssubset (has_ssubset linarith.comp_source))))) : complete_space (has_add (has_nnnorm (has_ssubset (has_ssubset linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_83871 (h0 : group (mul_zero_class Type)) : is_cyclic (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_83872 (h0 : ordered_comm_monoid (has_add (has_neg name))) : has_exists_mul_of_le (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_83873 (h0 : uniform_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83874 (h0 : group (normed_lattice_add_comm_group (has_add linarith.comp))) : is_simple_group (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_83875 (h0 : filter (has_inv (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_83876 (h0 : complete_lattice (linear_ordered_comm_group_with_zero (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_83877 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) (has_pos_part pos)) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_83878 (h0 : topological_space (has_Inf (has_add (has_to_string (has_add linarith.comp))))) : discrete_topology (has_Inf (has_add (has_to_string (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_83879 (h0 : functor.add_const (fin has_zero.zero) real) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_83880 (h0 : group (pseudo_metric_space (option empty))) : is_cyclic (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_83881 (h0 : functor.add_const (ring (ordered_comm_group unsigned)) (option (option empty))) : @is_domain.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_83882 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83883 (h0 : functor.add_const (topological_space (plift empty)) congr_arg_kind) : @topological_space.separable_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_83884 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_83885 (h0 : list (normed_comm_ring (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_83886 (h0 : uniform_space (preorder (semiring empty))) : separated_space (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_83887 (h0 : functor.add_const (monoid (sub_neg_monoid linarith.comp)) linarith.comp) : @monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83888 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero canonically_ordered_comm_semiring)) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} canonically_ordered_comm_semiring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_83889 (h0 : add_monoid (has_pos_part (has_Inf (has_pos_part real)))) : add_monoid.fg (has_pos_part (has_Inf (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_83890 (h0 : functor.add_const (ordered_add_comm_monoid (finset empty)) num) : @archimedean.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_83891 (h0 : measure_theory.outer_measure linarith.comp_source) (h1 : set linarith.comp_source) : measure_theory.outer_measure.is_caratheodory h0 h1 := sorry --non-trivial
lemma new_lemma_83892 (h1 : ring (complete_semilattice_Sup (random_gen linarith.comp))) : strong_rank_condition (complete_semilattice_Sup (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_83893 (h0 : functor.add_const (ring (non_assoc_semiring unsigned)) empty) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_83894 (h0 : monoid (normed_linear_ordered_group congr_arg_kind)) : monoid.fg (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_83895 (h0 : filter (comm_group (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_83896 (h0 : not (monoid (has_one num) -> false)) : @monoid.fg.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_83897 (h0 : ring (complete_distrib_lattice (has_to_string (has_to_string (has_to_string num))))) : rank_condition (complete_distrib_lattice (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_83898 (h2 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h2)  := sorry --non-trivial
lemma new_lemma_83899 (h0 : function.extfun Type (functor.comp filter option)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_83900 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring empty)))) : is_atomistic (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83901 (h0 h1 : pnat) : pnat.coprime h0 (id (id (id (id (id (id h1)))))) := sorry --non-trivial
lemma new_lemma_83902 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) Type) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_83903 (h0 : group (omega_complete_partial_order (semiring (semiring empty)))) : is_cyclic (omega_complete_partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_83904 (h0 : not (uniform_space (add_right_cancel_monoid linarith.comp) -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_83905 (h1 : complete_lattice (semi_normed_ring (comm_ring reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_83906 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid real))) : path_connected_space (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_83907 (h1 : ring (has_append (random_gen linarith.comp_source))) : is_domain (has_append (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_83908 (h0 : topological_space (group_with_zero (option ennreal))) : discrete_topology (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_83909 (h0 : topological_space (has_add pos)) : regular_space (has_add pos) := sorry --non-trivial
lemma new_lemma_83910 (h0 : topological_space (has_to_string (has_to_string (has_to_string unsigned)))) : totally_separated_space (has_to_string (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_83911 (h0 : finset (semigroup (has_neg (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83912 (h0 : functor.add_const (complete_lattice pos) (finset (has_neg pos))) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) (finset.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_83913 (h2 : complete_lattice enat) : complete_lattice.is_Sup_finite_compact enat := sorry --non-trivial
lemma new_lemma_83914 (h0 : uniform_space (with_bot (semiring empty))) : separated_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_83915 (h0 : add_group (ordered_ring unsigned)) : is_add_cyclic (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_83916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_83917 (h1 : topological_space (add_comm_semigroup (normed_field reducibility_hints))) (h2 : add_group (add_comm_semigroup (normed_field reducibility_hints))) : topological_add_group (add_comm_semigroup (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_83918 (h1 : uniform_space (normed_group string_imp)) : complete_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_83919 (h0 : complete_lattice (has_add (has_add real))) : is_atomistic (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_83920 (h0 : topological_space (add_cancel_comm_monoid linarith.ineq)) : totally_disconnected_space (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_83921 (h0 : functor.add_const (group (ordered_comm_monoid pos)) linarith.comp) : @is_cyclic.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83922 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_83923 (h0 : functor.add_const (uniform_space (semigroup pos)) Type) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_83924 (h0 : not (topological_space (comm_ring linarith.ineq) -> false)) : @path_connected_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_83925 (h0 : topological_space (finset (option (option (option (option ennreal)))))) : totally_separated_space (finset (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_83926 (h0 : topological_space (has_to_string (option (option (option ennreal))))) : loc_path_connected_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_83927 (h0 : topological_space (normed_comm_ring (has_to_string linarith.comp))) : loc_path_connected_space (normed_comm_ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_83928 (h0 : option (complete_lattice (ordered_ring empty))) (h1 : complete_lattice (ordered_ring empty)) : is_compactly_generated (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_83929 (h0 : semiring (has_pos_part (has_bot (has_Inf Type)))) : is_noetherian_ring (has_pos_part (has_bot (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_83930 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) environment.implicit_infer_kind) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_83931 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_83932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_83933 (h0 : topological_space (linear_ordered_add_comm_group_with_top std_gen)) : t0_space (linear_ordered_add_comm_group_with_top std_gen) := sorry --non-trivial
lemma new_lemma_83934 (h0 : topological_space (simple_graph name)) : path_connected_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_83935 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option empty))) : normal_space (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_83936 (h0 : group (complete_semilattice_Sup (random_gen (random_gen linarith.ineq)))) : group.fg (complete_semilattice_Sup (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_83937 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @totally_separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_83938 (h0 : ring (with_bot (semiring empty))) : rank_condition (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_83939 (h0 : fin has_zero.zero) : @sequential_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_83940 (h0 : topological_space (cancel_monoid (semigroup pos))) : discrete_topology (cancel_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_83941 (h0 : ordered_comm_monoid (normed_comm_ring (finset linarith.comp))) : has_exists_mul_of_le (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_83942 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_83943 (h0 : functor.add_const (group (has_pos_part pos)) Type) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_83944 (h0 : uniform_space (with_one empty)) : complete_space (with_one empty) := sorry --non-trivial
lemma new_lemma_83945 (h2 : set (mul_one_class std_gen)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_83946 (h0 : functor.add_const (add_monoid (ordered_comm_group empty)) empty) : @add_monoid.fg.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_83947 (h0 : functor.comp topological_space comm_group Type) : @t0_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_83948 (h0 : list (measurable_space (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_83949 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option empty)))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_83950 (h0 : functor.add_const (filter (comm_group ennreal)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83951 (h0 : uniform_space (has_neg (has_to_string (has_to_string pos)))) : separated_space (has_neg (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_83952 (h0 : topological_space (encodable (random_gen to_additive.value_type))) : irreducible_space (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_83953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_83954 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_83955 (h0 : complete_lattice (topological_space (has_nnnorm (comm_ring (comm_ring char))))) : is_compactly_generated (topological_space (has_nnnorm (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_83956 (h0 : functor.add_const (group (finset Type)) linarith.comp) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_83957 (h0 : topological_space (finset (ring linarith.comp))) : preconnected_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_83958 (h0 : functor.add_const (filter (add_cancel_monoid pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_83959 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_83960 (h0 : fin has_zero.zero) : @preconnected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_83961 (h0 : topological_space (normed_comm_ring (has_dist empty))) : totally_disconnected_space (normed_comm_ring (has_dist empty)) := sorry --non-trivial
lemma new_lemma_83962 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_83963 (h0 : group (boolean_algebra (has_add linarith.comp))) : is_simple_group (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_83964 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_83965 (h0 : ring (has_top (random_gen char))) : is_domain (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_83966 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_Inf real)))) : totally_disconnected_space (normed_lattice_add_comm_group (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_83967 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) name) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_83968 (h0 : complete_lattice (id real)) : is_compactly_generated (id real) := sorry --non-trivial
lemma new_lemma_83969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_83970 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_83971 (h0 : functor.add_const (ring Type) name) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_83972 (h0 : topological_space (normed_group (random_gen string_imp))) : t0_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_83973 (h0 : complete_lattice (simple_graph linarith.ineq)) : complete_lattice.is_Sup_finite_compact (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_83974 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @locally_compact_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83975 (h2 : topological_space (uniform_space linarith.ineq)) : path_connected_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_83976 (h0 : complete_lattice (ring (option pos))) : is_compactly_generated (ring (option pos)) := sorry --non-trivial
lemma new_lemma_83977 (h0 : functor.add_const (group (cancel_monoid Type)) unsigned) : @is_simple_group.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_83978 (h0 : ring (add_comm_monoid (has_Inf real))) : rank_condition (add_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_83979 (h0 : uniform_space (left_cancel_monoid empty)) : complete_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_83980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_83981 (h0 : complete_lattice (has_dist (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (has_dist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_83982 (h0 : finset (add_comm_monoid (comm_group name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_83983 (h0 : topological_space (finset (has_add (sub_neg_monoid (has_Inf pos))))) : path_connected_space (finset (has_add (sub_neg_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_83984 (h0 : ring (canonically_ordered_comm_semiring num)) : rank_condition (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_83985 (h0 : topological_space (has_inner (option unsigned) unsigned)) : t0_space (has_inner (option unsigned) unsigned) := sorry --non-trivial
lemma new_lemma_83986 (h0 : uniform_space (comm_group (add_cancel_monoid linarith.comp))) : complete_space (comm_group (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_83987 (h3 : topological_space ereal) : path_connected_space ereal := sorry --non-trivial
lemma new_lemma_83988 (h0 : group (semigroup (option ennreal))) : normalizer_condition (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_83989 (h2 : ring (mul_one_class environment.projection_info)) : rank_condition (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_83990 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_83991 (h0 : add_group (linear_ordered_field (option unsigned))) : is_add_cyclic (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_83992 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (ordered_comm_monoid (has_Inf Type)))))) : totally_disconnected_space (has_pos_part (has_Inf (has_Inf (ordered_comm_monoid (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_83993 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_83994 (h0 : topological_space (has_edist (option (option empty)))) : t0_space (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_83995 (h0 : complete_lattice (has_inter (option ennreal))) : complete_lattice.is_Sup_finite_compact (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_83996 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : t1_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_83997 (h0 : functor.add_const Prop (boolean_algebra.core linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_83998 (h0 : ring (has_Inf (has_nndist linarith.comp))) : is_domain (has_Inf (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_83999 (h0 : pfun fun_info std_gen) (h1 : set std_gen) (h2 : fun_info) : pfun.core h0 h1 h2 := sorry --non-trivial
lemma new_lemma_84000 (h0 : topological_space (boolean_algebra (has_pos_part Type))) : irreducible_space (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_84001 (h0 : topological_space (ordered_comm_ring (has_to_string pos))) : t1_space (ordered_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_84002 (h1 : ring (simple_graph std_gen)) : rank_condition (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_84003 (h0 : group (with_one string_imp)) : group.fg (with_one string_imp) := sorry --non-trivial
lemma new_lemma_84004 (h0 : group (comm_ring (complete_semilattice_Sup char))) : group.fg (comm_ring (complete_semilattice_Sup char)) := sorry --non-trivial
lemma new_lemma_84005 (h0 : topological_space (add_comm_semigroup ereal)) : t0_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_84006 (h0 : prod (semiring (semiring (semiring unsigned))) (semiring (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_84007 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_84008 (h0 : list (has_nndist (comm_group (comm_group (comm_group pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_84009 (h2 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h2 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84010 (h0 : ring (has_neg (has_to_string (has_to_string pos)))) : is_domain (has_neg (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_84011 (h2 : not (topological_space (add_cancel_comm_monoid char) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_84012 (h0 : complete_lattice (denumerable (has_nnnorm char))) : is_compactly_generated (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_84013 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_84014 (h0 : topological_space (dlist (comm_ring string_imp))) : t0_space (dlist (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_84015 (h0 : add_group (normed_lattice_add_comm_group (has_neg (has_neg name)))) : is_add_cyclic (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_84016 (h0 : ring (add_cancel_monoid (finset (finset (finset pos))))) : rank_condition (add_cancel_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_84017 (h0 : topological_space (has_pos_part (has_bot (has_Inf real)))) : preirreducible_space (has_pos_part (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_84018 (h0 : add_monoid (has_to_string (boolean_algebra (ring Type)))) : add_monoid.fg (has_to_string (boolean_algebra (ring Type))) := sorry --non-trivial
lemma new_lemma_84019 (h0 : linarith.ineq -> linarith.ineq -> Prop) (h1 : set linarith.ineq) : set.bounded h0 h1 := sorry --non-trivial
lemma new_lemma_84020 (h0 : ring (semigroup (has_zero (has_neg (has_add linarith.comp))))) : rank_condition (semigroup (has_zero (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_84021 (h0 : complete_lattice (normed_comm_ring (finset (finset linarith.comp)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_84022 (h0 : ereal -> ereal) (h1 : char -> ereal -> ereal) (h2 : ereal) (h5 : list char) : function.is_fixed_pt h0 (list.foldr h1 h2 h5) := sorry --non-trivial
lemma new_lemma_84023 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_one.{0} (has_norm.{0} (has_norm.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} (has_norm.{0} (has_norm.{0} empty))))  := sorry --non-trivial
lemma new_lemma_84024 (h1 : ring (with_zero linarith.ineq)) : is_domain (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_84025 (h0 : filter (has_neg_part (option (finset ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84026 (h0 : group (comm_ring (has_nnnorm char))) : is_cyclic (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_84027 (h0 : complete_lattice (normed_field (mul_one_class (random_gen reducibility_hints)))) : is_compactly_generated (normed_field (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_84028 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : preconnected_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_84029 (h0 : topological_space (comm_ring (random_gen reducibility_hints))) : t0_space (comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_84030 (h1 : complete_lattice (has_compl (has_nnnorm char))) : is_compactly_generated (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_84031 (h0 : topological_space (has_neg_part (has_neg_part name))) : regular_space (has_neg_part (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_84032 (h0 : ring (comm_monoid (semiring empty))) : is_domain (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_84033 (h0 : topological_space (plift (semiring (semiring (semiring unsigned))))) : irreducible_space (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_84034 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (has_Inf name)) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_84035 (h0 : ring (simple_graph unsigned)) : is_domain (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_84036 (h0 : not (uniform_space (add_cancel_comm_monoid reducibility_hints) -> false)) : @complete_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_84037 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid Type)) name) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84038 (h0 : function.extfun (prod linarith.comp linarith.comp) (fun (x : prod linarith.comp linarith.comp), Prop)) (h1 : function.extfun Type (prod linarith.comp)) : symmetrize_rel (function.extfun_app h0) (function.extfun_app h1 linarith.comp) := sorry --non-trivial
lemma new_lemma_84039 (h0 : add_monoid (comm_group Type)) : add_monoid.fg (comm_group Type) := sorry --non-trivial
lemma new_lemma_84040 (h0 : topological_space (has_top (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : t0_space (has_top (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_84041 (h0 : functor.comp topological_space has_neg_part Type) : @normal_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_84042 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) name) : @is_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_84043 (h0 : not (has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_84044 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) (has_neg pos)) : @is_simple_group.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84045 (h0 : has_mem.mem (has_one (semiring empty)) has_emptyc.emptyc) : @path_connected_space.{0} (has_one.{0} (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84046 (h0 : list (has_to_string (add_comm_monoid (finset (finset Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84047 (h0 : functor.add_const (filter (has_to_string pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84048 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_84049 (h0 : functor.add_const (ordered_comm_monoid (pseudo_metric_space pos)) (option (option (option pos)))) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (pseudo_metric_space.{0} pos)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_84050 (h0 : not (uniform_space (has_one linarith.comp) -> false)) : @complete_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84051 (h0 : topological_space (generalized_boolean_algebra name)) : discrete_topology (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_84052 (h0 : add_group (has_Inf (has_add name))) : is_add_cyclic (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_84053 (h1 : not (group (measurable_space congr_arg_kind) -> false)) : @normalizer_condition.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_84054 (h0 : topological_space (linear_ordered_comm_group_with_zero fun_info)) (h1 : preorder (linear_ordered_comm_group_with_zero fun_info)) : order_closed_topology (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_84055 (h0 : group (has_inv (random_gen fun_info))) : is_cyclic (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_84056 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) Type) : @regular_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_84057 (h0 : uniform_space (has_nnnorm (denumerable (denumerable (denumerable char))))) : complete_space (has_nnnorm (denumerable (denumerable (denumerable char)))) := sorry --non-trivial
lemma new_lemma_84058 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) Type) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) (has_zero name)) := sorry --non-trivial
lemma new_lemma_84059 (h0 : functor.add_const (functor.add_const (topological_space znum) empty) empty) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} znum) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_84060 (h1 : uniform_space (dlist to_additive.value_type)) : complete_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84061 (h0 : uniform_space (is_R_or_C congr_arg_kind)) : separated_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84062 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} pos (@function.extfun_app.{2 1} Type semiring.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_84063 (h0 : monoid (add_group (has_top empty))) : monoid.fg (add_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_84064 (h0 : ring (comm_ring (has_append (has_append (has_lt linarith.comp_source))))) : strong_rank_condition (comm_ring (has_append (has_append (has_lt linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_84065 (h0 : functor.add_const (list (has_add linarith.comp)) (ring name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84066 (h0 : uniform_space (has_Inf (ring (ring (has_add pos))))) : separated_space (has_Inf (ring (ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_84067 (h0 : ring (comm_monoid (has_bot (option empty)))) : is_domain (comm_monoid (has_bot (option empty))) := sorry --non-trivial
lemma new_lemma_84068 (h0 : topological_space (has_to_string (has_neg (ring linarith.comp)))) : sequential_space (has_to_string (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_84069 (h0 : ordered_add_comm_monoid (preorder empty)) : archimedean (preorder empty) := sorry --non-trivial
lemma new_lemma_84070 (h0 : group (has_inv (has_inv (has_norm (has_norm linarith.ineq))))) : is_cyclic (has_inv (has_inv (has_norm (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_84071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_84072 (h1 : set (linear_ordered_comm_group_with_zero string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_84073 (h2 : complete_lattice (has_nnnorm linarith.ineq)) : is_compactly_generated (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_84074 (h0 : topological_space (boolean_algebra (has_bot (has_bot pos)))) : discrete_topology (boolean_algebra (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_84075 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_84076 (h0 : ring (canonically_ordered_monoid (has_add linarith.comp))) : is_principal_ideal_ring (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_84077 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_84078 (h0 : topological_space (has_scalar name Type)) : locally_compact_space (has_scalar name Type) := sorry --non-trivial
lemma new_lemma_84079 (h0 : string_imp -> string_imp -> Prop) (h1 : string_imp) (h2 : thunk string_imp) : @eqv_gen.{0} string_imp h0 h1 (@trace_call_stack.{0} string_imp h2)  := sorry --non-trivial
lemma new_lemma_84080 (h0 : finset (has_neg_part congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84081 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_84082 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84083 (h0 : group (has_to_string (option (option name)))) : group.fg (has_to_string (option (option name))) := sorry --non-trivial
lemma new_lemma_84084 (h0 : topological_space (boolean_algebra (ordered_comm_monoid real))) : locally_compact_space (boolean_algebra (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_84085 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_84086 (h0 : not (topological_space (semiring (semiring unsigned)) -> false)) : @totally_separated_space.{0} (semiring.{0} (semiring.{0} unsigned)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_84087 (h0 : group (has_nndist (ring name))) : normalizer_condition (has_nndist (ring name)) := sorry --non-trivial
lemma new_lemma_84088 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core linarith.comp)) unsigned) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84089 (h0 : functor.add_const (ring (finset pos)) (has_neg pos)) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84090 (h0 : uniform_space (has_norm linarith.comp_source)) : complete_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_84091 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_84092 (h0 : functor.add_const (semiring (normed_linear_ordered_group num)) congr_arg_kind) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_84093 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_84094 (h1 : filter (denumerable fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_84095 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_84096 (h0 : ring (semigroup (option name))) : strong_rank_condition (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_84097 (h1 : ring (denumerable (semi_normed_ring fun_info))) : strong_rank_condition (denumerable (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_84098 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84099 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_84100 (h3 : ring (distrib char)) : strong_rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_84101 (h0 : group (comm_semigroup (sub_neg_monoid pos))) : is_simple_group (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_84102 (h0 : topological_space (has_zero unsigned)) : normal_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_84103 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_84104 (h0 : functor.comp ring canonically_ordered_comm_semiring ennreal) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_84105 (h0 : topological_space (semiring (semiring empty))) : totally_separated_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_84106 (h0 : functor.add_const (finset (generalized_boolean_algebra Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84107 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : sequential_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_84108 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_84109 (h0 : functor.add_const (add_monoid (has_nndist pos)) linarith.comp) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84110 (h0 : not (ring (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84111 (h0 : complete_lattice (has_le (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (has_le (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_84112 (h0 : topological_space (semigroup (finset (normed_linear_ordered_group linarith.comp)))) : preconnected_space (semigroup (finset (normed_linear_ordered_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_84113 (h0 : functor.comp filter add_cancel_monoid pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_84114 (h0 : set (linear_ordered_comm_group_with_zero linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_84115 (h0 : topological_space (has_nndist num)) : discrete_topology (has_nndist num) := sorry --non-trivial
lemma new_lemma_84116 (h0 : ring (linear_ordered_semiring (has_norm num))) : strong_rank_condition (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_84117 (h0 : ring (add_comm_monoid (has_add name))) : strong_rank_condition (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_84118 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) num) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_84119 (h0 : has_mul (monoid empty)) (h1 : function.extfun Type monoid) : is_regular (function.extfun_app h1 empty) := sorry --non-trivial
lemma new_lemma_84120 (h0 : group (ring (has_Inf name))) : is_simple_group (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_84121 (h0 : topological_space (comm_semigroup (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type)))))))) : discrete_topology (comm_semigroup (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type))))))) := sorry --non-trivial
lemma new_lemma_84122 (h0 : topological_space (ring (option (option ennreal)))) : normal_space (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_84123 (h0 : topological_space (simple_graph linarith.comp)) : discrete_topology (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_84124 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84125 (h0 : filter (normed_comm_ring (finset (finset name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84126 (h0 : fun_info -> fun_info -> fun_info) : is_idempotent fun_info h0 := sorry --non-trivial
lemma new_lemma_84127 (h0 : group (non_assoc_semiring (semiring (semiring empty)))) : group.fg (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_84128 (h0 : topological_space (random_gen (semiring (has_norm (has_norm empty))))) : totally_separated_space (random_gen (semiring (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_84129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_84130 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_84131 (h0 : list (has_bot linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84132 (h0 : uniform_space (boolean_algebra.core (has_neg pos))) : separated_space (boolean_algebra.core (has_neg pos)) := sorry --non-trivial
lemma new_lemma_84133 (h0 : uniform_space (canonically_ordered_add_monoid unsigned)) : complete_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_84134 (h0 : functor.add_const (ordered_add_comm_monoid (omega_complete_partial_order unsigned)) (semiring unsigned)) : @archimedean.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (omega_complete_partial_order.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_84135 (h0 : functor.comp cancel_comm_monoid_with_zero ordered_comm_group congr_arg_kind) : @unique_factorization_monoid.{0} (ordered_comm_group.{0} congr_arg_kind) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} ordered_comm_group.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_84136 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @normal_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_84137 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string pos)) Type) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_84138 (h0 : ordered_comm_monoid (semigroup linarith.comp)) : has_exists_mul_of_le (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_84139 (h0 : topological_space string -> Prop) (h1 : Exists (fun (x : topological_space string), h0 x)) : @totally_disconnected_space.{0} string (@classical.some.{1} (topological_space.{0} string) h0 h1)  := sorry --non-trivial
lemma new_lemma_84140 (h0 : topological_space (denumerable linarith.ineq)) : locally_compact_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_84141 (h3 : group (topological_space to_additive.value_type)) : is_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84142 (h1 : topological_space (has_emptyc to_additive.value_type)) : irreducible_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84143 (h0 : has_lt (semi_normed_comm_ring (linear_ordered_comm_group_with_zero linarith.comp_source))) : no_max_order (semi_normed_comm_ring (linear_ordered_comm_group_with_zero linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84144 (h0 : uniform_space (boolean_algebra.core (finset name))) : complete_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_84145 (h2 : ring (normed_field to_additive.value_type)) : strong_rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84146 (h0 : functor.comp topological_space has_nndist (option pos)) : @loc_path_connected_space.{0} (has_nndist.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84147 (h0 : set (string.iterator_imp -> mul_one_class (add_comm_semigroup fun_info))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_84148 (h0 : topological_space (with_one (dlist (has_norm (distrib_lattice to_additive.value_type))))) : locally_compact_space (with_one (dlist (has_norm (distrib_lattice to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_84149 (h0 : topological_space (semi_normed_comm_ring environment.projection_info)) : path_connected_space (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_84150 (h0 : topological_space (has_zero pos)) : regular_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_84151 (h0 : topological_space (finset (boolean_algebra pos))) : t1_space (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_84152 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84153 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_84154 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_84155 (h1 : has_mem.mem (semi_normed_comm_ring (random_gen char)) has_emptyc.emptyc) : @is_domain.{0} (semi_normed_comm_ring.{0} (random_gen.{0} char)) (@finset.pi.empty.{1 0} Type ring.{0} (semi_normed_comm_ring.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_84156 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_84157 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_84158 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_84159 (h1 : complete_lattice (has_one linarith.comp)) : is_compactly_generated (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_84160 (h0 : group (denumerable to_additive.value_type)) : is_cyclic (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84161 (h0 : list (has_to_string (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_84162 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84163 (h0 : topological_space (with_one (has_sub unsigned))) : irreducible_space (with_one (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_84164 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_84165 (h0 : prod (finset Type) (finset Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_84166 (h0 : group (linear_ordered_semiring (has_norm (has_norm linarith.ineq)))) : group.fg (linear_ordered_semiring (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_84167 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (id linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84168 (h0 : function.extfun Type group) : @group.fg.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84169 (h0 : functor.add_const (function.extfun Type ring) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} linarith.comp) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84170 (h0 : topological_space (metric_space (has_norm (semiring linarith.comp)))) : totally_disconnected_space (metric_space (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_84171 (h0 : complete_lattice (simple_graph empty)) : is_compactly_generated (simple_graph empty) := sorry --non-trivial
lemma new_lemma_84172 (h0 : set (mul_one_class ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_84173 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @preconnected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_84174 (h0 : ring (add_cancel_comm_monoid num)) : strong_rank_condition (add_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_84175 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84176 (h0 : functor.add_const (ring (ordered_comm_ring Type)) pos) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_84177 (h0 : finset (linear_order empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84178 (h0 : not (ring (normed_field linarith.ineq) -> false)) : @is_domain.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84179 (h1 : prod (add_comm_semigroup char) (add_comm_semigroup char)) : set.diagonal (add_comm_semigroup char) h1 := sorry --non-trivial
lemma new_lemma_84180 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_84181 (h0 : functor.add_const (uniform_space (semigroup Type)) environment.implicit_infer_kind) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84182 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_84183 (h0 : pnat) (h1 : ulower pnat) (h2 : list (ulower pnat)) : pnat.coprime h0 (ulower.up (list.ilast' h1 h2)) := sorry --non-trivial
lemma new_lemma_84184 (h0 : semiring (normed_lattice_add_comm_group (has_add real))) : is_noetherian_ring (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_84185 (h0 : topological_space (bin_tree (semiring unsigned))) : irreducible_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84187 (h0 : group (has_ssubset (mul_one_class (mul_one_class char)))) : is_cyclic (has_ssubset (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_84188 (h0 : uniform_space (partial_order (semiring unsigned))) : complete_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84189 (h0 : functor.add_const (topological_space (finset pos)) name) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_84190 (h0 : topological_space (uniform_space (mul_one_class linarith.ineq))) (h1 : not (preorder (uniform_space (mul_one_class linarith.ineq)) -> false)) : order_topology (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84191 (h1 : ring (distrib_lattice fun_info)) : rank_condition (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_84192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_84193 (h0 : functor.add_const (ring (has_zero Type)) name) : @rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84194 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84195 (h0 : ring (add_cancel_monoid (has_pos_part pos))) : is_domain (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_84196 (h0 : ring (has_pos_part (has_neg (has_nndist Type)))) : is_domain (has_pos_part (has_neg (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_84197 (h0 : group (has_lt fun_info)) : is_cyclic (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_84198 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84199 (h0 : not (group (topological_space linarith.ineq) -> false)) : @is_cyclic.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84200 (h0 : topological_space (ring (normed_comm_ring linarith.comp))) : path_connected_space (ring (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_84201 (h0 : functor.comp ring has_add (has_to_string (has_to_string congr_arg_kind))) : @rank_condition.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} congr_arg_kind))) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} (has_to_string.{0} (has_to_string.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_84202 (h0 : topological_space (complete_linear_order unsigned)) : irreducible_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_84203 (h0 : ring (left_cancel_monoid (option empty))) : rank_condition (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_84204 (h1 : complete_lattice (add_monoid (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_84205 (h0 : filter (with_bot (has_inv (has_inv (with_bot string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84206 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg (uniform_space.core (has_neg Type))))) : unique_factorization_monoid (has_pos_part (has_neg (uniform_space.core (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_84207 (h1 : has_union linarith.comp -> has_union linarith.comp -> has_union linarith.comp) : is_idempotent (has_union linarith.comp) h1 := sorry --non-trivial
lemma new_lemma_84208 (h0 : uniform_space (add_comm_monoid (option (option unsigned)))) : separated_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_84209 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84210 (h0 : group (has_add (has_bot (has_Inf pos)))) : group.fg (has_add (has_bot (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_84211 (h0 : functor.add_const (filter (semigroup unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84212 (h0 : topological_space (ring (has_neg name))) : topological_space.separable_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_84213 (h0 : functor.add_const (finset (has_to_string pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84214 (h0 : ring (with_one (has_norm empty))) : strong_rank_condition (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_84215 (h0 : ring (finset (has_to_string pos))) : rank_condition (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_84216 (h0 : uniform_space (canonically_ordered_comm_semiring (boolean_algebra.core pos))) : separated_space (canonically_ordered_comm_semiring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_84217 (h0 : not (topological_space (metric_space unsigned) -> false)) : @topological_space.separable_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_84218 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_84219 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @t0_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84220 (h0 : group string.iterator_imp) (h1 : complete_lattice (group_topology string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (group_topology string.iterator_imp) := sorry --non-trivial
lemma new_lemma_84221 (h0 : function.extfun (finset Type) (has_mem.mem (semiring unsigned))) : @rank_condition.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_84222 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra pos)) (ordered_ring pos)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (ordered_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84223 (h0 : group (partial_order (has_top empty))) : group.fg (partial_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_84224 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part real))) : preconnected_space (canonically_ordered_comm_semiring (has_neg_part real)) := sorry --non-trivial
lemma new_lemma_84225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84226 (h0 : group (ring (option unsigned))) : group.fg (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_84227 (h0 : measurable_space (mul_one_class string.iterator_imp)) (h1 : measure_theory.measure (mul_one_class string.iterator_imp)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_84228 (h0 : topological_space (cancel_monoid (add_cancel_monoid environment.implicit_infer_kind))) : loc_path_connected_space (cancel_monoid (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_84229 (h0 : functor.add_const Prop (has_nndist empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_84230 (h0 : group (has_zero (ring Type))) : is_simple_group (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_84231 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84232 (h0 : topological_space (finset (has_add pos))) : sequential_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_84233 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_84234 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) (has_to_string Type)) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84235 (h0 : ring (ordered_comm_group (option empty))) : is_domain (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_84236 (h0 : semiring (ordered_comm_monoid (ring (has_add (ring pos))))) : is_noetherian_ring (ordered_comm_monoid (ring (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_84237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : unique_factorization_monoid nnreal := sorry --non-trivial
lemma new_lemma_84238 (h0 : topological_space (has_nndist (comm_group Type))) : totally_separated_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_84239 (h0 : add_group (has_neg (has_to_string pos))) : is_add_cyclic (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_84240 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_84241 (h2 : ring (has_top (random_gen to_additive.value_type))) : rank_condition (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84242 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_Inf (has_add (has_add (has_Inf pos))))))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_Inf (has_add (has_add (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_84243 (h0 : ring (comm_ring (topological_space char))) : strong_rank_condition (comm_ring (topological_space char)) := sorry --non-trivial
lemma new_lemma_84244 (h0 : functor.add_const (filter (simple_graph linarith.comp)) (ring (has_add pos))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84245 (h0 : topological_space (ordered_comm_group empty)) : path_connected_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_84246 (h0 : fin has_zero.zero) : @complete_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_84247 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84248 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset linarith.comp)) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_84249 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_84250 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84251 (h0 : group (has_top (has_top (random_gen linarith.comp_source)))) : group.fg (has_top (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_84252 (h1 : not (uniform_space (measurable_space congr_arg_kind) -> false)) : @complete_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_84253 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_84254 (h0 : uniform_space (ordered_comm_monoid (has_add Type))) : complete_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_84255 (h0 : add_monoid (partial_order (semiring num))) : add_monoid.fg (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_84256 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : regular_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_84257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84258 (h0 : not (finset (mul_zero_class empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_84259 (h0 : ring (measurable_space (semiring num))) : strong_rank_condition (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_84260 (h0 : functor.add_const (finset (semigroup Type)) (comm_group name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84261 (h0 : group (has_neg_part (comm_group (comm_group name)))) : normalizer_condition (has_neg_part (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_84262 (h0 : complete_lattice (normed_lattice_add_comm_group (has_bot (has_add (has_add real))))) : is_atomistic (normed_lattice_add_comm_group (has_bot (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_84263 (h0 : functor.add_const (function.extfun Type topological_space) (finset (finset linarith.comp))) : @path_connected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84264 (h1 : add_group (comm_ring linarith.ineq)) : is_add_cyclic (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_84265 (h0 : function.extfun Type group) : @is_cyclic.{0} (group_with_zero.{0} (has_inter.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} (has_inter.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_84266 (h0 : prod (has_one num) (has_one num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_84267 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84268 (h0 : topological_space (distrib_lattice (has_nnnorm char))) : totally_disconnected_space (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_84269 (h0 : fin has_zero.zero) : @monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@matrix.vec_empty.{0} (monoid.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_84270 (h0 : complete_lattice (semiring (has_top (has_norm unsigned)))) : is_atomistic (semiring (has_top (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_84271 (h0 : ordered_comm_monoid (ordered_comm_ring (ring (has_zero (ring (ring (has_add pos))))))) : has_exists_mul_of_le (ordered_comm_ring (ring (has_zero (ring (ring (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_84272 (h0 : uniform_space (has_top (has_nnnorm char))) : complete_space (has_top (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_84273 (h0 : has_mem.mem (with_bot (has_norm empty)) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84274 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) pos) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84275 (h4 : preorder (add_comm_semigroup char)) (h5 : set (add_comm_semigroup char)) : set.is_pwo h5 := sorry --non-trivial
lemma new_lemma_84276 (h0 : group (option (partial_order empty))) : normalizer_condition (option (partial_order empty)) := sorry --non-trivial
lemma new_lemma_84277 (h0 : ring (has_top (has_top empty))) : rank_condition (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_84278 (h0 : not (topological_space (with_zero linarith.ineq) -> false)) : @t0_space.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84279 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_84280 (h1 : ring (has_add string_imp)) : strong_rank_condition (has_add string_imp) := sorry --non-trivial
lemma new_lemma_84281 (h0 : monoid (semiring (semiring unsigned))) : monoid.fg (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84282 (h0 : not (complete_lattice (has_div linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84283 (h0 : topological_space (ordered_ring empty)) : path_connected_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_84284 (h0 : topological_space (has_edist unsigned)) : t0_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_84285 (h0 : topological_space (boolean_algebra.core linarith.comp)) : preconnected_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_84286 (h0 : group (has_one (has_top unsigned))) : is_cyclic (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_84287 (h0 : not (ring (measurable_space empty) -> false)) : @is_domain.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84288 (h0 : complete_lattice (has_to_string (has_neg_part (comm_group (has_neg_part name))))) : is_compactly_generated (has_to_string (has_neg_part (comm_group (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_84289 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_84290 (h0 : complete_lattice (boolean_algebra.core (finset (finset name)))) : is_atomistic (boolean_algebra.core (finset (finset name))) := sorry --non-trivial
lemma new_lemma_84291 (h0 : topological_space (add_group (has_inf linarith.comp))) : t0_space (add_group (has_inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_84292 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : path_connected_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84293 (h2 : add_group (non_unital_non_assoc_semiring string_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_84294 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_84295 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_84296 (h0 : topological_space auto.case_option) : topological_space.separable_space auto.case_option := sorry --non-trivial
lemma new_lemma_84297 (h0 : functor.add_const (uniform_space (has_nndist unsigned)) (option pos)) : @complete_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84298 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring (ordered_ring Type))) : @regular_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (ring.{1} (ordered_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_84299 (h0 : ring (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : strong_rank_condition (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84300 (h0 : functor.add_const (ring (boolean_algebra Type)) linarith.comp) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84301 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_84302 (h0 : prod (has_nndist congr_arg_kind) (has_nndist congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_84303 (h0 : not (ring (metric_space num) -> false)) : @is_principal_ideal_ring.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84304 (h0 : functor.add_const (topological_space (has_add name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84305 (h0 : complete_lattice (boolean_algebra (has_pos_part (has_add Type)))) : is_compactly_generated (boolean_algebra (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_84306 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_84307 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_comm_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84308 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) : irreducible_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_84309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84310 (h0 : functor.comp cancel_comm_monoid_with_zero has_zero ennreal) : @unique_factorization_monoid.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_84311 (h0 : uniform_space (has_nndist stieltjes_function)) : complete_space (has_nndist stieltjes_function) := sorry --non-trivial
lemma new_lemma_84312 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_84313 (h0 : group (random_gen (random_gen (has_inv string_imp)))) : group.fg (random_gen (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_84314 (h0 : uniform_space (semigroup (has_add (has_add (has_add (has_add Type)))))) : complete_space (semigroup (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_84315 (h0 : uniform_space (boolean_algebra.core linarith.comp)) : complete_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_84316 (h0 : topological_space (mul_zero_class (boolean_algebra name))) : totally_disconnected_space (mul_zero_class (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_84317 (h0 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_84318 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : totally_separated_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_84319 (h0 : complete_lattice (with_zero (has_nnnorm (linear_ordered_add_comm_group fun_info)))) : is_compactly_generated (with_zero (has_nnnorm (linear_ordered_add_comm_group fun_info))) := sorry --non-trivial
lemma new_lemma_84320 (h0 : complete_lattice (has_top num)) : is_atomistic (has_top num) := sorry --non-trivial
lemma new_lemma_84321 (h0 : ordered_add_comm_monoid (semigroup (has_add (has_add (has_add linarith.comp))))) : archimedean (semigroup (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_84322 (h0 : topological_space (semiring (semiring congr_arg_kind))) : totally_disconnected_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84323 (h0 : topological_space (with_one (has_inv fun_info))) : irreducible_space (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_84324 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_84325 (h0 : group (dlist (random_gen linarith.comp_source))) : is_cyclic (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84326 (h0 : function.extfun Type ring) : @is_domain.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_84327 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84328 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_neg name))) : archimedean (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_84329 (h0 : ring (canonically_ordered_comm_semiring (option (option unsigned)))) : is_domain (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_84330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84331 (h0 : not (ring (has_star unsigned) -> false)) : @rank_condition.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_84332 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_84333 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84334 (h0 : topological_space (boolean_algebra.core (has_to_string linarith.comp))) : discrete_topology (boolean_algebra.core (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_84335 (h0 : group (distrib_lattice (has_top linarith.comp_source))) : normalizer_condition (distrib_lattice (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84336 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf (has_Inf linarith.comp))))) : discrete_topology (canonically_ordered_monoid (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_84337 (h1 : not (ring (has_ssubset linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_84338 (h0 : not (topological_space (group_with_zero num) -> false)) : @locally_compact_space.{0} (group_with_zero.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (group_with_zero.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84339 (h0 : complete_lattice (normed_field enat)) : is_compactly_generated (normed_field enat) := sorry --non-trivial
lemma new_lemma_84340 (h0 : not (ring (has_one fun_info) -> false)) : @is_domain.{0} (has_one.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_84341 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84342 (h0 : filter (has_pos_part Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84343 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84344 (h0 : group (has_nnnorm string.iterator_imp)) : is_cyclic (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_84345 (h0 : topological_space (preorder num)) : topological_space.separable_space (preorder num) := sorry --non-trivial
lemma new_lemma_84346 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84347 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84348 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84349 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_84350 (h0 : functor.add_const (filter (has_neg pos)) (finset pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84351 (h0 : topological_space (simple_graph pos)) : t0_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_84352 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84353 (h0 : topological_space (has_norm (semiring (semiring (semiring unsigned))))) : irreducible_space (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_84354 (h0 : not (ring (plift num) -> false)) : @is_principal_ideal_ring.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_84355 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_84356 (h0 : functor.comp ring has_to_string (finset pos)) : @is_domain.{0} (has_to_string.{0} (finset.{0} pos)) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84357 (h0 : topological_space (has_nnnorm std_gen)) : t0_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_84358 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84359 (h0 : functor.comp topological_space pseudo_metric_space ennreal) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_84360 (h0 : list (complete_semilattice_Sup (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84361 (h0 : topological_space (metric_space (has_top (has_top (has_top unsigned))))) : path_connected_space (metric_space (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_84362 (h0 : group (sub_neg_monoid pos)) : is_cyclic (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_84363 (h0 : uniform_space (add_right_cancel_monoid (semiring (has_norm unsigned)))) : separated_space (add_right_cancel_monoid (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_84364 (h0 : add_group (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_84365 (h0 : functor.add_const (ring (comm_group Type)) name) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84366 (h0 : functor.add_const (uniform_space (has_neg name)) linarith.comp) : @separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84367 (h0 : functor.comp topological_space has_to_string name) : @discrete_topology.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_84368 (h0 : topological_space (has_Inf (has_Inf (has_Inf Type)))) : locally_compact_space (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_84369 (h0 : topological_space (omega_complete_partial_order unsigned)) : t1_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_84370 (h0 : functor.add_const Prop (has_to_string (has_add (add_comm_monoid Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_84371 (h0 : function.extfun Type (functor.add_const (ring pos))) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_84372 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_84373 (h0 : add_group (cancel_monoid (has_add environment.implicit_infer_kind))) : is_add_cyclic (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_84374 (h0 : functor.add_const (list (has_Sup unsigned)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84375 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_84376 (h1 : ring (normed_field (has_nnnorm (random_gen (random_gen char))))) : is_domain (normed_field (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_84377 (h0 : topological_space (has_Inf pos)) : t0_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_84378 (h0 : functor.add_const (monoid (finset name)) Type) : @monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_84379 (h0 : not (list (denumerable (random_gen fun_info)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_84380 (h0 : group (comm_ring (random_gen linarith.ineq))) : is_cyclic (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84381 (h0 : not (topological_space (encodable linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_84382 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84383 (h0 : ring (has_neg linarith.comp)) : rank_condition (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_84384 (h2 : add_group (normed_field linarith.comp_source)) : is_add_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_84385 (h0 : ring (topological_space fun_info)) : is_domain (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_84386 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84387 (h0 : filter (add_cancel_monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84388 (h0 : functor.add_const (uniform_space (has_star empty)) num) : @separated_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_84389 (h0 : function.extfun nat fin) : @archimedean.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84390 (h0 : not (complete_lattice (ordered_comm_semiring empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (ordered_comm_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84391 (h0 : topological_space (complete_linear_order (has_top num))) : t0_space (complete_linear_order (has_top num)) := sorry --non-trivial
lemma new_lemma_84392 (h0 : ordered_add_comm_monoid (has_to_string name)) : archimedean (has_to_string name) := sorry --non-trivial
lemma new_lemma_84393 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf Type)) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84394 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_84395 (h0 : function.extfun Type (functor.add_const (add_group (linear_ordered_comm_monoid_with_zero empty)))) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_84396 (h0 : list (has_compl (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84397 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) unsigned) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84398 (h0 : topological_space (add_comm_semigroup char)) (h1 : set (set (add_comm_semigroup char))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_84399 (h1 : topological_space (non_unital_non_assoc_semiring (has_lt (has_lt reducibility_hints)))) : path_connected_space (non_unital_non_assoc_semiring (has_lt (has_lt reducibility_hints))) := sorry --non-trivial
lemma new_lemma_84400 (h0 : function.extfun Type (functor.add_const (filter pos))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_84401 (h0 : topological_space (normed_group (has_norm (random_gen fun_info)))) : path_connected_space (normed_group (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_84402 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84403 (h0 : ring (add_cancel_monoid (has_zero linarith.comp))) : rank_condition (add_cancel_monoid (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_84404 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84405 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84406 (h0 : topological_space (ring (normed_comm_ring (finset (has_neg (has_neg Type)))))) : totally_disconnected_space (ring (normed_comm_ring (finset (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_84407 (h0 : monoid (plift (add_left_cancel_semigroup unsigned))) : monoid.fg (plift (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_84408 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84409 (h0 : uniform_space (random_gen (has_ssubset char))) : complete_space (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_84410 (h0 : topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) : locally_compact_space (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84411 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_84412 (h0 : uniform_space (has_norm (has_top num))) : complete_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_84413 (h0 : functor.add_const (ring (as_linear_order unsigned)) empty) : @is_principal_ideal_ring.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_84414 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_84415 (h0 : not (topological_space (non_unital_non_assoc_semiring string_imp) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_84416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_84417 (h0 : ring (has_nnnorm string_imp)) : is_domain (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_84418 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) (semiring empty)) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_84419 (h0 : list (finset (has_add environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84420 (h0 : function.extfun nat fin) : @is_simple_group.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84421 (h0 : ring (random_gen (mul_one_class char))) : strong_rank_condition (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_84422 (h0 : functor.comp add_group comm_group Type) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_84423 (h0 : functor.add_const (complete_lattice (finset name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_84424 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_84425 (h0 : topological_space (generalized_boolean_algebra pos)) : locally_compact_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_84426 (h0 : linarith.comp_source -> Prop) (h1 : set linarith.comp_source) (h2 : linarith.comp_source) : set.sep h0 h1 h2 := sorry --non-trivial
lemma new_lemma_84427 (h0 : add_group (add_comm_monoid (has_neg_part pos))) : is_add_cyclic (add_comm_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_84428 (h0 : topological_space (add_comm_semigroup ereal)) : path_connected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_84429 (h0 : ring (add_right_cancel_monoid (semiring (semiring (semiring unsigned))))) : is_principal_ideal_ring (add_right_cancel_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_84430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84431 (h1 : complete_lattice (with_one fun_info)) : is_compactly_generated (with_one fun_info) := sorry --non-trivial
lemma new_lemma_84432 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84433 (h0 : functor.add_const (topological_space (filter empty)) empty) : @topological_space.separable_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_84434 (h0 : topological_space (has_compl (random_gen string_imp))) : locally_compact_space (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_84435 (h1 : not (uniform_space (has_nnnorm reducibility_hints) -> false)) : @complete_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_84436 (h1 : ring (distrib_lattice (has_nnnorm linarith.ineq))) : rank_condition (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84437 (h0 : topological_space (has_add environment.implicit_infer_kind)) : topological_space.separable_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_84438 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @t0_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_84439 (h1 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : locally_compact_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84441 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_84442 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84443 (h0 : group (has_bot (sub_neg_monoid name))) : group.fg (has_bot (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_84444 (h0 : add_monoid (boolean_algebra.core (option name))) : add_monoid.fg (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_84445 (h0 : topological_space (has_pos_part (has_nndist pos))) : preconnected_space (has_pos_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_84446 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_84447 (h1 : topological_space (uniform_space (distrib enat))) : path_connected_space (uniform_space (distrib enat)) := sorry --non-trivial
lemma new_lemma_84448 (h0 : group (has_nnnorm int)) : is_cyclic (has_nnnorm int) := sorry --non-trivial
lemma new_lemma_84449 (h0 : monoid (random_gen unsigned)) : monoid.fg (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_84450 (h1 : uniform_space reducibility_hints) : complete_space reducibility_hints := sorry --non-trivial
lemma new_lemma_84451 (h0 : finset (has_star (semiring (semiring (semiring num))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84452 (h0 : functor.add_const (ring (boolean_algebra pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84453 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84454 (h0 : functor.add_const (semiring (has_zero name)) name) : @is_noetherian_ring.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_84455 (h0 : monoid (has_top (comm_ring (has_norm linarith.ineq)))) : monoid.fg (has_top (comm_ring (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_84456 (h0 : cancel_comm_monoid_with_zero (has_add (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_84457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84458 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_84459 (h0 : finset (has_zero pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84460 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_84461 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84462 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero (option (option empty)))) : unique_factorization_monoid (linear_ordered_comm_monoid_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_84463 (h0 : ring (has_neg_part unsigned)) : is_principal_ideal_ring (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_84464 (h0 : group (generalized_boolean_algebra (has_Inf pos))) : group.fg (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_84465 (h0 : list (boolean_algebra.core (boolean_algebra name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84466 (h0 : uniform_space (has_inter (option (option empty)))) : complete_space (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_84467 (h0 : topological_space (option (semiring num))) : t1_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_84468 (h0 : monoid (ordered_comm_monoid (has_add linarith.comp))) : monoid.fg (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_84469 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @preconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_84470 (h0 : ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) : archimedean (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_84471 (h0 : add_monoid (boolean_algebra.core empty)) : add_monoid.fg (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_84472 (h0 : environment.implicit_infer_kind -> environment.implicit_infer_kind) (h1 : environment.implicit_infer_kind) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_84473 (h0 : topological_space (finset empty)) : discrete_topology (finset empty) := sorry --non-trivial
lemma new_lemma_84474 (h0 : ring (bin_tree unsigned)) : is_principal_ideal_ring (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_84475 (h0 : list (has_bot unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84476 (h0 : functor.add_const Prop (has_top (semiring (semiring (semiring (semiring (semiring empty))))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_84477 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84478 (h0 : simple_graph linarith.comp_source) (h1 : linarith.comp_source) : set.finite (simple_graph.neighbor_set h0 h1) := sorry --non-trivial
lemma new_lemma_84479 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_monoid.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_84480 (h0 : finset (has_neg (has_neg environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84481 (h0 : functor.add_const (finset (add_right_cancel_monoid num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84482 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_84483 (h0 : topological_space (has_Inf real)) : discrete_topology (has_Inf real) := sorry --non-trivial
lemma new_lemma_84484 (h2 : topological_space (add_left_cancel_monoid to_additive.value_type)) : path_connected_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84485 (h0 : functor.add_const (topological_space (has_dist empty)) ennreal) : @loc_path_connected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_84486 (h0 : ordered_comm_monoid (has_to_string (has_add (has_neg_part unsigned)))) : has_exists_mul_of_le (has_to_string (has_add (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_84487 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_84488 (h0 : function.extfun Type ring) : @rank_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_84489 (h0 : functor.comp ring has_add Type) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_84490 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring name)) : archimedean (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_84491 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84492 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @normal_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_84493 (h0 : functor.add_const (monoid (filter empty)) empty) : @monoid.fg.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_84494 (h0 : topological_space (normed_group (has_norm linarith.comp))) : discrete_topology (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_84495 (h0 : topological_space (comm_group Type)) : totally_disconnected_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_84496 (h0 : topological_space (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : t0_space (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_84497 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (option unsigned))) : unique_factorization_monoid (boolean_algebra (option unsigned)) := sorry --non-trivial
lemma new_lemma_84498 (h0 : topological_space (with_bot (semiring (semiring congr_arg_kind)))) : discrete_topology (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_84499 (h0 : uniform_space (cancel_monoid (option (option empty)))) : separated_space (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_84500 (h0 : complete_lattice (with_one (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_84501 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : irreducible_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84502 (h0 : topological_space (complete_distrib_lattice (finset pos))) : loc_path_connected_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_84503 (h0 : topological_space (multiplicative (mul_one_class linarith.comp_source))) : totally_disconnected_space (multiplicative (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84504 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84505 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_84506 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84507 (h0 : ring (add_comm_monoid (option (option pos)))) : strong_rank_condition (add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_84508 (h0 : add_monoid (has_top (semiring empty))) : add_monoid.fg (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_84509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_84510 (h0 : not (ring (has_append linarith.comp_source) -> false)) : @is_domain.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_84511 (h0 : ring (has_union (has_norm (semiring unsigned)))) : rank_condition (has_union (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_84512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_84513 (h0 : ring (has_neg_part (cancel_monoid Type))) : strong_rank_condition (has_neg_part (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_84514 (h1 : not (complete_lattice (semi_normed_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_84515 (h0 : complete_lattice (uniform_space (mul_one_class (metric_space char)))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class (metric_space char))) := sorry --non-trivial
lemma new_lemma_84516 (h0 : topological_space (complete_linear_order empty)) : irreducible_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_84517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_84518 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg Type)) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_84519 (h0 : cancel_comm_monoid_with_zero (has_neg_part unsigned)) : unique_factorization_monoid (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_84520 (h0 : uniform_space (finset (has_pos_part pos))) : separated_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_84521 (h0 : group (canonically_ordered_add_monoid num)) : normalizer_condition (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_84522 (h0 : ring (topological_space (has_lt linarith.comp_source))) : rank_condition (topological_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84523 (h0 : filter (has_zero (option (ring (ring pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84524 (h0 : uniform_space (with_one (has_top (has_top (has_top to_additive.value_type))))) : complete_space (with_one (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_84525 (h0 : topological_space (has_to_string linarith.comp)) : sequential_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_84526 (h0 : topological_space (has_add (has_sdiff pos))) : t0_space (has_add (has_sdiff pos)) := sorry --non-trivial
lemma new_lemma_84527 (h0 : functor.add_const (finset (ordered_comm_ring Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84528 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84529 (h1 : uniform_space (has_top (encodable string_imp))) : complete_space (has_top (encodable string_imp)) := sorry --non-trivial
lemma new_lemma_84530 (h0 : ring (has_zero (has_add (has_to_string (finset (finset pos)))))) : strong_rank_condition (has_zero (has_add (has_to_string (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_84531 (h0 : ring (complete_distrib_lattice (has_bot Type))) : strong_rank_condition (complete_distrib_lattice (has_bot Type)) := sorry --non-trivial
lemma new_lemma_84532 (h0 : topological_space (semigroup pos)) : topological_space.separable_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_84533 (h0 : functor.add_const (list (measurable_space.dynkin_system unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84534 (h0 : ring (has_star congr_arg_kind)) : is_principal_ideal_ring (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84535 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84536 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_84537 (h0 : topological_space (metric_space num)) : topological_space.separable_space (metric_space num) := sorry --non-trivial
lemma new_lemma_84538 (h0 : topological_space (canonically_linear_ordered_monoid congr_arg_kind)) : totally_disconnected_space (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84539 (h0 : functor.comp group comm_group environment.implicit_infer_kind) : @normalizer_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84540 (h0 : ring (measure_theory.measure_space (random_gen linarith.comp_source))) : is_domain (measure_theory.measure_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84541 (h0 : group (semigroup (has_pos_part linarith.comp))) : group.fg (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_84542 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_84544 (h0 : finset (finset (has_pos_part (has_pos_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84545 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84546 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84548 (h0 : topological_space (has_star (semiring unsigned))) : path_connected_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84549 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_84550 (h0 : functor.comp group comm_group environment.implicit_infer_kind) : @is_cyclic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84551 (h1 : complete_lattice (denumerable (random_gen char))) : is_compactly_generated (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_84552 (h0 : complete_lattice (has_norm (random_gen (random_gen num)))) : is_compactly_generated (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_84553 (h0 : ring (has_neg (has_add unsigned))) : strong_rank_condition (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_84554 (h0 : functor.add_const (topological_space (finset name)) name) : @topological_space.separable_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_84555 (h3 : topological_space enat) : totally_disconnected_space enat := sorry --non-trivial
lemma new_lemma_84556 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_84557 (h0 : not (uniform_space (encodable linarith.ineq) -> false)) : @complete_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_84558 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) (boolean_algebra name)) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_84559 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @is_add_cyclic.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_84560 (h0 : fin has_zero.zero) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84561 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_84562 (h0 : functor.add_const (complete_lattice (semigroup pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84563 (h0 : topological_space (ring congr_arg_kind)) : topological_space.separable_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84564 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : irreducible_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84565 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @is_atomistic.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_84566 (h0 : filter (semigroup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84567 (h0 : ordered_add_comm_monoid (has_pos_part (has_add linarith.comp))) : archimedean (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_84568 (h0 : group (denumerable (random_gen (has_nnnorm char)))) : is_cyclic (denumerable (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_84569 (h0 : functor.comp complete_lattice has_to_string name) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_84570 (h0 : topological_space (has_compl (has_ssubset to_additive.value_type))) : t0_space (has_compl (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84571 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (finset (finset linarith.comp)))) : archimedean (generalized_boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_84572 (h0 : functor.add_const (semiring (has_to_string Type)) (has_neg pos)) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84573 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_84574 (h0 : monoid (bin_tree unsigned)) : monoid.fg (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_84575 (h0 : not (topological_space (id num) -> false)) : @topological_space.separable_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_84576 (h2 : filter (distrib_lattice to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_84577 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_84578 (h0 : not (semiring (mul_zero_class congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_84579 (h0 : topological_space (complete_semilattice_Sup string_imp)) : irreducible_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_84580 (h0 : functor.add_const (group (cancel_monoid ennreal)) name) : @is_cyclic.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_84581 (h1 : has_mem.mem fun_info has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_84582 (h0 : topological_space (ring pos)) : totally_disconnected_space (ring pos) := sorry --non-trivial
lemma new_lemma_84583 (h0 : topological_space (measurable_space (id (semiring (has_top empty))))) : path_connected_space (measurable_space (id (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_84584 (h0 : not (has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_84585 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84586 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84587 (h1 : topological_space linarith.comp) : normal_space linarith.comp := sorry --non-trivial
lemma new_lemma_84588 (h0 : ring (simple_graph enat)) : rank_condition (simple_graph enat) := sorry --non-trivial
lemma new_lemma_84589 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : t0_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_84590 (h0 : functor.add_const (ring (has_pos_part pos)) linarith.comp) : @rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84591 (h0 : add_group (canonically_linear_ordered_monoid num)) : is_add_cyclic (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_84592 (h0 : functor.add_const (ring (has_neg name)) Type) : @is_domain.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_84593 (h0 : ring (semiring (has_top to_additive.value_type))) : rank_condition (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84594 (h0 : ring (has_ssubset (has_nnnorm fun_info))) : is_domain (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_84595 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core name)) name) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_84596 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_84597 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_nndist pos))) : unique_factorization_monoid (boolean_algebra.core (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_84598 (h0 : ring (normed_field (metric_space (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (normed_field (metric_space (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_84599 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84600 (h0 : add_group (mul_one_class ereal) -> Prop) (h1 : Exists (fun (x : add_group (mul_one_class ereal)), h0 x)) : @is_add_cyclic.{0} (mul_one_class.{0} ereal) (@classical.some.{1} (add_group.{0} (mul_one_class.{0} ereal)) h0 h1)  := sorry --non-trivial
lemma new_lemma_84601 (h0 : ring (has_add (has_add (has_add (has_add (has_add (has_add pos))))))) : rank_condition (has_add (has_add (has_add (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_84602 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_84603 (h0 : set (mul_one_class fun_info -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_84604 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_84605 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) pos) : @irreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_84606 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_84607 (h1 : uniform_space (has_lt linarith.comp_source)) : complete_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_84608 (h0 : topological_space (sub_neg_monoid (has_neg name))) : normal_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_84609 (h0 : complete_lattice (normed_comm_ring (option empty))) : is_atomistic (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_84610 (h0 : has_lt (has_nnnorm (mul_one_class string.iterator_imp))) : no_max_order (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_84611 (h0 : topological_space (has_div char)) : t0_space (has_div char) := sorry --non-trivial
lemma new_lemma_84612 (h0 : topological_space (has_ssubset (has_top linarith.ineq))) : locally_compact_space (has_ssubset (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84613 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84614 (h0 : uniform_space (has_dist (option empty))) : complete_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_84615 (h0 : topological_space (has_union unsigned)) : discrete_topology (has_union unsigned) := sorry --non-trivial
lemma new_lemma_84616 (h0 : has_mem.mem (has_compl linarith.ineq) has_emptyc.emptyc) : @rank_condition.{0} (has_compl.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_compl.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_84617 (h0 : ring (linear_order std_gen)) : strong_rank_condition (linear_order std_gen) := sorry --non-trivial
lemma new_lemma_84618 (h0 : not (cancel_comm_monoid_with_zero (measurable_space.dynkin_system num) -> false)) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84619 (h0 : function.extfun Type topological_space) : @t0_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84620 (h0 : topological_space (mul_one_class enat)) (h1 : set (mul_one_class enat)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_84621 (h0 : function.extfun Type topological_space) : @t1_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84622 (h0 : ring (complete_semilattice_Sup unsigned)) : is_domain (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_84623 (h0 : list (has_dist (option (comm_monoid unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84624 (h0 : semiring (complete_lattice (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))))) (h1 : complete_lattice (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) : even h1 := sorry --non-trivial
lemma new_lemma_84625 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_zero pos)) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84626 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_84627 (h0 : list (simple_graph (generalized_boolean_algebra (has_add (has_add pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84628 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84629 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) Type) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_84630 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) real) : @loc_path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) real h0)  := sorry --non-trivial
lemma new_lemma_84631 (h0 : group (plift (has_top (has_top (has_top empty))))) : is_cyclic (plift (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_84632 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) (has_neg_part linarith.comp)) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_84633 (h0 : Prop -> ereal) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_84634 (h0 : uniform_space (has_add (ring Type))) : separated_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_84635 (h0 : complete_lattice (add_comm_monoid (has_add pos))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_84636 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : preirreducible_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_84637 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_84638 (h0 : group (plift (option empty))) : normalizer_condition (plift (option empty)) := sorry --non-trivial
lemma new_lemma_84639 (h0 : functor.add_const (uniform_space (semigroup Type)) unsigned) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84640 (h0 : list (ordered_cancel_add_comm_monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84641 (h1 : measurable_space (random_gen (comm_ring (denumerable to_additive.value_type)))) : measurable_singleton_class (random_gen (comm_ring (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_84642 (h0 : topological_space (has_nndist empty)) : preirreducible_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_84643 (h0 : add_group (has_norm (has_top (has_inv (linear_ordered_add_comm_group to_additive.value_type))))) : is_add_cyclic (has_norm (has_top (has_inv (linear_ordered_add_comm_group to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_84644 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84645 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_84646 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid Type))) : irreducible_space (canonically_linear_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_84647 (h0 : group (with_one (random_gen (random_gen linarith.ineq)))) : is_cyclic (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_84648 (h0 : topological_space (has_Inf (has_pos_part pos))) : preirreducible_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_84649 (h0 : functor.add_const (group (has_neg_part name)) (has_neg (has_neg_part Type))) : @is_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} name)) (has_neg.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_84650 (h1 : topological_space enat) (h2 : set enat) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_84651 (h0 : uniform_space (with_bot (semiring congr_arg_kind))) : separated_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84652 (h0 : topological_space (as_linear_order empty)) : irreducible_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_84653 (h0 : group (add_comm_monoid (has_Inf (has_Inf pos)))) : is_simple_group (add_comm_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_84654 (h0 : group (has_inter unsigned)) : group.fg (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_84655 (h1 : ring (linear_ordered_comm_group_with_zero reducibility_hints)) : rank_condition (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_84656 (h0 : topological_space (is_R_or_C (semiring (semiring empty)))) : path_connected_space (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_84657 (h0 : functor.add_const (ordered_add_comm_monoid (measurable_space.dynkin_system empty)) unsigned) : @archimedean.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (measurable_space.dynkin_system.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84658 (h0 : functor.add_const (add_group (normed_comm_ring environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_84659 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_84660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_84661 (h0 : functor.add_const (ring (has_star unsigned)) (semiring empty)) : @strong_rank_condition.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_84662 (h0 : add_group (random_gen (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (random_gen (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_84663 (h1 : filter (has_norm linarith.comp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_84664 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_84665 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_84666 (h3 : topological_space (has_nnnorm char)) : t0_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_84667 (h3 : not (ring (random_gen fun_info) -> false)) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h3)  := sorry --non-trivial
lemma new_lemma_84668 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : normal_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_84669 (h0 : functor.add_const (topological_space (comm_group pos)) (comm_group Type)) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84670 (h0 : ring (boolean_algebra (comm_group (comm_group Type)))) : rank_condition (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_84671 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : locally_compact_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_84672 (h0 : complete_lattice (with_bot (with_bot linarith.ineq))) : is_compactly_generated (with_bot (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84673 (h1 : add_group (measurable_space (random_gen (with_bot string_imp)))) : is_add_cyclic (measurable_space (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_84674 (h0 : group (normed_lattice_add_comm_group real)) : normalizer_condition (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_84675 (h0 : ordered_comm_monoid (semigroup (option (option pos)))) : has_exists_mul_of_le (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_84676 (h0 : ring (has_add to_additive.value_type)) : rank_condition (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84677 (h0 : functor.add_const (cancel_comm_monoid_with_zero (group_with_zero ennreal)) num) : @unique_factorization_monoid.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_84678 (h0 : topological_space (measurable_space num)) : irreducible_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_84679 (h0 : function.extfun Type topological_space) : @normal_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84680 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : normal_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84681 (h0 : semiring (add_comm_monoid (has_add (has_to_string (finset name))))) : is_noetherian_ring (add_comm_monoid (has_add (has_to_string (finset name)))) := sorry --non-trivial
lemma new_lemma_84682 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_84683 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_84684 (h0 : group (canonically_ordered_comm_semiring (has_neg_part Type))) : normalizer_condition (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_84685 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) (ring pos)) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84686 (h0 : monoid (measurable_space (semiring unsigned))) : monoid.fg (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84687 (h0 : filter (has_nndist (cancel_monoid ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84688 (h0 : topological_space (has_nndist (has_add Type))) : path_connected_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_84689 (h0 : topological_space (with_bot (semiring congr_arg_kind))) : irreducible_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84690 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84691 (h0 : topological_space (has_nnnorm (has_ssubset (has_ssubset (has_nnnorm char))))) : locally_compact_space (has_nnnorm (has_ssubset (has_ssubset (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_84692 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_84693 (h0 : not (group (has_top linarith.comp_source) -> false)) : @group.fg.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_84694 (h0 : complete_lattice (measurable_space (with_bot linarith.ineq))) : is_atomistic (measurable_space (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84695 (h0 : group (ordered_comm_ring (has_bot real))) : group.fg (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_84696 (h0 : complete_lattice (with_bot (has_inv (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_84697 (h0 : not (complete_lattice (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_84698 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) (ring pos)) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84699 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core unsigned)) : unique_factorization_monoid (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_84700 (h0 : group (has_norm (has_norm (has_norm linarith.comp)))) : normalizer_condition (has_norm (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_84701 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) name) : @is_atomistic.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_84702 (h0 : group (partial_order (semiring num))) : normalizer_condition (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_84703 (h0 : topological_space (has_neg ennreal)) : totally_disconnected_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_84704 (h0 : set (uniform_space linarith.comp_source)) (h1 : uniform_space linarith.comp_source -> uniform_space linarith.comp_source -> Prop) : set.well_founded_on h0 h1 := sorry --non-trivial
lemma new_lemma_84705 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_84706 (h0 : topological_space (random_gen (has_norm (semiring linarith.comp)))) : totally_separated_space (random_gen (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_84707 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84708 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_84709 (h0 : filter (order_dual (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84710 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) unsigned) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84711 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_84712 (h0 : function.extfun Type topological_space) : @normal_space.{0} (omega_complete_partial_order.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_84713 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_84714 (h2 : linarith.comp_source -> Prop) : Exists h2 := sorry --non-trivial
lemma new_lemma_84715 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84716 (h0 : has_star (mul_zero_class unsigned) -> has_star (mul_zero_class unsigned) -> has_star (mul_zero_class unsigned)) : is_right_cancel (has_star (mul_zero_class unsigned)) h0 := sorry --non-trivial
lemma new_lemma_84717 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84718 (h0 : complete_lattice (add_cancel_monoid (has_add pos))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_84719 (h0 : group (has_add to_additive.value_type)) : is_cyclic (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84720 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_84721 (h0 : topological_space (denumerable string_imp)) : totally_disconnected_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_84722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84723 (h0 : ring (with_one (random_gen (random_gen (random_gen fun_info))))) : is_domain (with_one (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_84724 (h0 : not (complete_lattice (measurable_space (has_top linarith.ineq)) -> false)) : is_compactly_generated (measurable_space (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84725 (h0 : topological_space (has_to_string (has_neg (has_neg (has_neg (has_add Type)))))) : t1_space (has_to_string (has_neg (has_neg (has_neg (has_add Type))))) := sorry --non-trivial
lemma new_lemma_84726 (h0 h1 : multiset (has_compl reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_84727 (h0 : topological_space (partial_order (semiring (semiring (semiring (semiring (semiring empty))))))) : irreducible_space (partial_order (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_84728 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (mul_one_class num)) := sorry --non-trivial
lemma new_lemma_84729 (h0 : semiring (linear_ordered_comm_group congr_arg_kind)) : is_noetherian_ring (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84730 (h0 : complete_lattice (semigroup (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84731 (h0 : topological_space (has_norm (has_norm empty))) : discrete_topology (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_84732 (h0 : topological_space (has_top (has_norm (has_norm (preorder num))))) : t0_space (has_top (has_norm (has_norm (preorder num)))) := sorry --non-trivial
lemma new_lemma_84733 (h0 : function.extfun nat fin) : @separated_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84734 (h1 : topological_space (comm_ring to_additive.value_type)) : t0_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84735 (h0 : functor.add_const (group (comm_group linarith.comp)) Type) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_84736 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp)  := sorry --non-trivial
lemma new_lemma_84737 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_84738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_84739 (h0 : topological_space (simple_graph to_additive.value_type)) : totally_disconnected_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84740 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_84741 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_84742 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_84743 (h0 : set (has_div (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_84744 (h0 : functor.add_const (uniform_space (finset linarith.comp)) (has_neg linarith.comp)) : @complete_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_84745 (h0 : ring (left_cancel_semigroup num)) : strong_rank_condition (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_84746 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84747 (h0 : group (has_nndist (has_add (has_to_string ennreal)))) : is_simple_group (has_nndist (has_add (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_84748 (h0 : group (has_norm (has_norm unsigned))) : is_cyclic (has_norm (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_84749 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : has_exists_mul_of_le (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_84750 (h1 : topological_space (has_inv to_additive.value_type)) : totally_disconnected_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84751 (h0 : std_gen -> std_gen) (h1 : std_gen) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_84752 (h0 : ordered_comm_monoid (boolean_algebra.core (comm_group (comm_group pos)))) : has_exists_mul_of_le (boolean_algebra.core (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_84753 (h0 : ring (has_le linarith.comp_source)) : is_domain (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_84754 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @regular_space.{0} (has_neg.{0} (has_nndist.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 (has_nndist.{0} pos)))  := sorry --non-trivial
lemma new_lemma_84755 (h0 : ring (linear_ordered_semiring (semiring congr_arg_kind))) : strong_rank_condition (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84756 (h0 : topological_space (has_top to_additive.value_type)) (h1 : has_sup (has_top to_additive.value_type)) : has_continuous_sup (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84757 (h0 : not (topological_space (comm_ring (has_nnnorm linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_84758 (h0 : complete_lattice (linear_ordered_field congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84759 (h1 : topological_space (has_emptyc (random_gen linarith.comp_source))) : irreducible_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_84760 (h0 : topological_space (ordered_comm_ring (ordered_comm_ring real))) : loc_path_connected_space (ordered_comm_ring (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_84761 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_84762 (h1 : add_group (mul_one_class string.iterator_imp)) : is_add_cyclic (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_84763 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) Type) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_84764 (h0 : group (comm_semigroup (has_Inf (has_Inf real)))) : normalizer_condition (comm_semigroup (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_84765 (h0 : ring (linear_ordered_cancel_comm_monoid num)) : is_domain (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_84766 (h2 : topological_space environment.projection_info) (h3 : add_group environment.projection_info) : topological_add_group environment.projection_info := sorry --non-trivial
lemma new_lemma_84767 (h0 : uniform_space (mul_one_class enat)) (h1 : group (mul_one_class enat)) : uniform_group (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_84768 (h0 : topological_space (add_cancel_monoid (ring (ring (has_add Type))))) : totally_separated_space (add_cancel_monoid (ring (ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_84769 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_84770 (h6 : topological_space (semi_normed_ring fun_info)) : t0_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_84771 (h0 : complete_lattice (normed_group fun_info)) : is_atomistic (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_84772 (h0 : topological_space (option (comm_group pos))) : totally_disconnected_space (option (comm_group pos)) := sorry --non-trivial
lemma new_lemma_84773 (h0 : topological_space (comm_ring (random_gen string_imp))) : t0_space (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_84774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84775 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group (option ennreal))) : archimedean (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_84776 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84777 (h0 : ring (cancel_monoid (has_neg_part (has_add name)))) : strong_rank_condition (cancel_monoid (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_84778 (h0 : ring (comm_ring (fintype (option fun_info)))) : is_domain (comm_ring (fintype (option fun_info))) := sorry --non-trivial
lemma new_lemma_84779 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84780 (h0 : not (topological_space (fintype char) -> false)) : @locally_compact_space.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_84781 (h0 : function.extfun nat fin) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84782 (h0 : uniform_space (generalized_boolean_algebra (ring Type))) : complete_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_84783 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph Type)) (ring (has_neg (has_Inf Type)))) : @archimedean.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (simple_graph.{1} Type)) (ring.{1} (has_neg.{1} (has_Inf.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_84784 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (ordered_comm_ring pos)) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (ordered_comm_ring.{0} pos) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_84785 (h0 : not (add_monoid (measurable_space.dynkin_system num) -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84786 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @normal_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_84787 (h1 : topological_space (has_inv string_imp)) : totally_disconnected_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_84788 (h0 : uniform_space (left_cancel_monoid (semiring num))) : complete_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_84789 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_84790 (h0 : ring (add_comm_semigroup reducibility_hints)) : strong_rank_condition (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_84791 (h0 : topological_space (comm_group (monoid_with_zero ennreal))) : totally_disconnected_space (comm_group (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_84792 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84793 (h0 : add_monoid (has_pos_part Type)) : add_monoid.fg (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_84794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_84795 (h0 : function.extfun Type group) : @group.fg.{0} (omega_complete_partial_order.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_84796 (h0 : uniform_space (linear_ordered_field (option empty))) : complete_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_84797 (h0 : uniform_space (has_bot (option unsigned))) : separated_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_84798 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_84799 (h0 : topological_space (add_left_cancel_semigroup empty)) : totally_separated_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_84800 (h0 : not (add_group (has_norm num) -> false)) : @is_add_cyclic.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84801 (h0 : ring (has_inter (option ennreal))) : strong_rank_condition (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_84802 (h0 : complete_lattice (semiring (has_top num))) : complete_lattice.is_Sup_finite_compact (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_84803 (h0 : group (option (semiring unsigned))) : normalizer_condition (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84804 (h0 : ring (normed_lattice_add_comm_group name)) : strong_rank_condition (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_84805 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) unsigned) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) unsigned h0) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_84806 (h0 : topological_space (random_gen (semiring congr_arg_kind))) : preirreducible_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84807 (h0 : preorder fun_info) (h1 : set fun_info) : bdd_below h1 := sorry --non-trivial
lemma new_lemma_84808 (h0 : topological_space (has_Inf (has_add Type))) : discrete_topology (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_84809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_84810 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_84811 (h0 : topological_space (has_to_string num)) : discrete_topology (has_to_string num) := sorry --non-trivial
lemma new_lemma_84812 (h0 : finset (comm_group (ring (has_neg_part (semigroup ennreal))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_84813 (h0 : not (filter (distrib_lattice char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_84814 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_dist empty)) := sorry --non-trivial
lemma new_lemma_84815 (h0 : list (normed_comm_ring (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_84816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_84817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_84818 (h0 : add_group (simple_graph empty)) : is_add_cyclic (simple_graph empty) := sorry --non-trivial
lemma new_lemma_84819 (h0 : topological_space (has_inter (option empty))) : preconnected_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_84820 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84821 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84822 (h0 : add_group (add_group (random_gen char))) : is_add_cyclic (add_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_84823 (h0 : ring (add_cancel_comm_monoid (mul_one_class linarith.ineq))) : strong_rank_condition (add_cancel_comm_monoid (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84824 (h0 : ordered_add_comm_monoid (has_to_string (has_to_string Type))) : archimedean (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_84825 (h0 : functor.add_const (ring (mul_zero_class pos)) Type) : @strong_rank_condition.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_84826 (h0 : functor.add_const (filter (ordered_comm_ring pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84827 (h0 : functor.add_const (finset (plift num)) (semiring (semiring (semiring num)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84828 (h0 : functor.add_const (group (canonically_ordered_monoid real)) pos) : @group.fg.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_monoid.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_84829 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra Type))) : totally_disconnected_space (canonically_ordered_comm_semiring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_84830 (h0 : functor.add_const (add_monoid (finset name)) (has_to_string pos)) : @add_monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} name)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84831 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @topological_space.separable_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_84832 (h0 : ring (normed_field (mul_one_class environment.projection_info))) : is_domain (normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_84833 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84834 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_84835 (h1 h2 : multiset (measurable_space fun_info)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_84836 (h0 : functor.add_const (topological_space (add_right_cancel_monoid congr_arg_kind)) empty) : @loc_path_connected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_84837 (h0 : group (normed_lattice_add_comm_group (has_add linarith.comp))) : normalizer_condition (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_84838 (h0 : has_le fun_info) (h1 : fun_info) : is_bot h1 := sorry --non-trivial
lemma new_lemma_84839 (h0 : functor.add_const (function.extfun Type filter) (has_neg linarith.comp)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_84840 (h0 : ring (has_zero environment.implicit_infer_kind)) : strong_rank_condition (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_84841 (h0 : topological_space (comm_semigroup (has_add real))) : totally_disconnected_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_84842 (h0 : functor.add_const (add_group (has_neg pos)) pos) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_84843 (h0 : not (has_mem.mem (has_emptyc empty) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_84844 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84845 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84846 (h0 : not (uniform_space (random_gen (comm_ring string.iterator_imp)) -> false)) : @complete_space.{0} (random_gen.{0} (comm_ring.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (comm_ring.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_84847 (h0 : functor.add_const (ring (boolean_algebra Type)) name) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84848 (h0 : filter (has_to_string (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84849 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @t0_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_84850 (h0 : filter (has_norm (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_84851 (h0 : semiring (normed_comm_ring Type)) : is_noetherian_ring (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_84852 (h0 : functor.add_const (filter (add_comm_monoid unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84853 (h0 : not (ring (normed_field char) -> false)) : @strong_rank_condition.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_84854 (h0 : ring (canonically_ordered_comm_semiring (option empty))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_84855 (h0 : functor.add_const (ring (has_pos_part Type)) name) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84856 (h5 : ring (semi_normed_ring string_imp)) : rank_condition (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_84857 (h0 : ring (add_group (semiring (semiring num)))) : rank_condition (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_84858 (h0 : ring (has_union (id congr_arg_kind))) : rank_condition (has_union (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84859 (h0 : topological_space (has_norm (ordered_comm_semiring unsigned))) : totally_separated_space (has_norm (ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_84860 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_84861 (h0 : complete_lattice (measurable_space (has_inv to_additive.value_type))) : is_atomistic (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84862 (h0 : topological_space (cancel_monoid linarith.comp)) : topological_space.separable_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_84863 (h0 : not (group (measure_theory.measure_space empty) -> false)) : @group.fg.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_84864 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_84865 (h0 : not (monoid (with_bot linarith.comp) -> false)) : @monoid.fg.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84866 (h0 : ring (sub_neg_monoid (has_add name))) : is_principal_ideal_ring (sub_neg_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_84867 (h0 : functor.add_const (ring (ordered_comm_ring pos)) pos) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_84868 (h0 : ring (finset (has_Inf linarith.comp))) : strong_rank_condition (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_84869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_84870 (h0 : topological_space (group_with_zero (option (option (option (option congr_arg_kind)))))) : loc_path_connected_space (group_with_zero (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_84871 (h0 : topological_space (has_one (semiring (semiring congr_arg_kind)))) : path_connected_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_84872 (h0 : topological_space (comm_ring (dlist string_imp))) : t0_space (comm_ring (dlist string_imp)) := sorry --non-trivial
lemma new_lemma_84873 (h0 : topological_space (ordered_comm_ring real)) : sequential_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_84874 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (boolean_algebra.core Type)) : @loc_path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84875 (h0 : ordered_add_comm_monoid (comm_group (finset (option ennreal)))) : archimedean (comm_group (finset (option ennreal))) := sorry --non-trivial
lemma new_lemma_84876 (h0 : topological_space (canonically_ordered_monoid (has_bot real))) : path_connected_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_84877 (h0 : monoid_with_zero (option (option (option ennreal))) -> monoid_with_zero (option (option (option ennreal))) -> Prop) : is_symm (monoid_with_zero (option (option (option ennreal)))) h0 := sorry --non-trivial
lemma new_lemma_84878 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_84879 (h0 : topological_space (has_to_string (semigroup (semigroup name)))) : preconnected_space (has_to_string (semigroup (semigroup name))) := sorry --non-trivial
lemma new_lemma_84880 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid linarith.comp)))) : sequential_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_84881 (h0 : has_mem.mem Type has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{1} Type (@finset.pi.empty.{2 1} (Type 1) complete_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_84882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_84883 (h0 : has_neg (bin_tree (option ennreal)) -> has_neg (bin_tree (option ennreal)) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_84884 (h0 : group (add_cancel_comm_monoid (option unsigned))) : is_cyclic (add_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_84885 (h0 : functor.add_const (ordered_comm_monoid (ring linarith.comp)) pos) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_84886 (h0 : not (list (has_add fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_84887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_84888 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg (has_Inf name))) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg.{0} (has_Inf.{0} name)) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_84889 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : totally_disconnected_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_84890 (h0 : ring (linear_ordered_comm_group_with_zero char)) : strong_rank_condition (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_84891 (h0 : topological_space (add_comm_monoid (has_neg_part (has_neg_part Type)))) : totally_separated_space (add_comm_monoid (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_84892 (h0 : topological_space (has_dist empty)) : locally_compact_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_84893 (h0 : topological_space (has_nndist (has_neg_part pos))) : sequential_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_84894 (h0 : complete_lattice (has_div string_imp)) : complete_lattice.is_Sup_finite_compact (has_div string_imp) := sorry --non-trivial
lemma new_lemma_84895 (h0 : measurable_space (nondiscrete_normed_field enat)) (h1 : measure_theory.measure (nondiscrete_normed_field enat)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_84896 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_84897 (h0 : topological_space (has_bot (option (option empty)))) : irreducible_space (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_84898 (h0 : ring (comm_ring (random_gen char))) : is_domain (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_84899 (h0 : add_group (encodable linarith.ineq)) : is_add_cyclic (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_84900 (h0 : functor.add_const (complete_lattice (has_add pos)) (finset pos)) : @is_compactly_generated.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_84901 (h0 : semiring (semiring (semiring (semiring (semiring unsigned))))) : is_noetherian_ring (semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_84902 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_84903 (h0 : group (normed_comm_ring (finset ennreal))) : is_simple_group (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_84904 (h0 : uniform_space (with_one (has_nnnorm linarith.ineq))) : complete_space (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_84905 (h0 : topological_space (simple_graph (ring linarith.comp))) : discrete_topology (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_84906 (h0 : add_group (id num)) : is_add_cyclic (id num) := sorry --non-trivial
lemma new_lemma_84907 (h0 : topological_space (monoid congr_arg_kind)) : t0_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84908 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84909 (h0 : add_monoid (ordered_comm_ring (sub_neg_monoid Type))) : add_monoid.fg (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_84910 (h0 : group (has_pos_part (has_Inf (has_Inf real)))) : group.fg (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_84911 (h0 : functor.add_const (uniform_space (has_to_string Type)) Type) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_84912 (h0 : ring (distrib_lattice (random_gen (has_norm (comm_ring linarith.ineq))))) : rank_condition (distrib_lattice (random_gen (has_norm (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_84913 (h0 : add_monoid (with_one (semiring congr_arg_kind))) : add_monoid.fg (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_84914 (h0 : set (has_add (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_84915 (h0 : uniform_space (has_neg (mul_one_class linarith.comp))) : separated_space (has_neg (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_84916 (h0 : complete_lattice (has_top num)) : is_compactly_generated (has_top num) := sorry --non-trivial
lemma new_lemma_84917 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_84918 (h0 : topological_space (simple_graph (has_Inf (has_Inf linarith.comp)))) : irreducible_space (simple_graph (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_84919 (h0 : topological_space (id (has_inv to_additive.value_type))) : t0_space (id (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_84920 (h0 : complete_lattice (has_inv (has_nnnorm (random_gen char)))) : is_compactly_generated (has_inv (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_84921 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_84922 (h0 : filter (preorder congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84923 (h0 : topological_space (mul_zero_class (boolean_algebra.core Type))) : preirreducible_space (mul_zero_class (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_84924 (h0 : group (generalized_boolean_algebra Type)) : is_simple_group (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_84925 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_nndist.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_84926 (h0 : ring (has_star (semiring empty))) : strong_rank_condition (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_84927 (h0 : add_group (comm_semigroup (has_add (sub_neg_monoid Type)))) : is_add_cyclic (comm_semigroup (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_84928 (h0 : functor.add_const (monoid (normed_comm_ring Type)) (has_add Type)) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (normed_comm_ring.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84929 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_84930 (h0 : complete_lattice (has_add (normed_linear_ordered_group linarith.comp))) : is_compactly_generated (has_add (normed_linear_ordered_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_84931 (h0 : topological_space (has_norm (has_norm (semiring num)))) : path_connected_space (has_norm (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_84932 (h0 : function.extfun Type (functor.add_const (function.extfun Type ring))) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0})) h0 environment.implicit_infer_kind)) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_84933 (h0 : ring (denumerable (comm_ring reducibility_hints))) : rank_condition (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_84934 (h0 : ordered_comm_monoid (comm_group Type)) : has_exists_mul_of_le (comm_group Type) := sorry --non-trivial
lemma new_lemma_84935 (h0 : topological_space (has_add ennreal)) : irreducible_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_84936 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (ring (finset linarith.comp))) : @add_monoid.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (ring.{0} (finset.{0} linarith.comp)) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_84937 (h0 : has_lt (has_lt to_additive.value_type)) : no_max_order (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84939 (h0 : set (set (random_gen to_additive.value_type))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_84940 (h0 : filter (finset (finset Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_84941 (h0 : topological_space (has_sub unsigned)) : preirreducible_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_84942 (h0 : functor.add_const (complete_lattice (comm_group Type)) (has_add Type)) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (comm_group.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84943 (h0 : group (has_neg (has_to_string (has_to_string Type)))) : is_simple_group (has_neg (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_84944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_84945 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) (has_neg_part name)) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_84946 (h0 : topological_space (has_top (semiring fun_info))) : totally_disconnected_space (has_top (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_84947 (h0 : set (has_div fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_84948 (h0 : topological_space (add_left_cancel_semigroup ennreal)) (h1 : function.extfun (add_left_cancel_semigroup ennreal) (fun (x : add_left_cancel_semigroup ennreal), Prop)) : is_totally_separated (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_84949 (h0 : add_monoid (has_Sup unsigned)) : add_monoid.fg (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_84950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group nat)) := sorry --non-trivial
lemma new_lemma_84951 (h0 : topological_space (has_add (has_zero (ring linarith.comp)))) : regular_space (has_add (has_zero (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_84952 (h0 : not (uniform_space (has_div string.iterator_imp) -> false)) : @complete_space.{0} (has_div.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_84953 (h0 : not (topological_space (encodable fun_info) -> false)) : @path_connected_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_84954 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @regular_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_84955 (h0 : not (complete_lattice (measure_theory.measure_space num) -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_84956 (h0 : topological_space (has_Inf name)) : discrete_topology (has_Inf name) := sorry --non-trivial
lemma new_lemma_84957 (h0 : not (monoid num -> false)) : @monoid.fg.{0} num (@classical.by_contradiction'.{1} (monoid.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_84958 (h0 : functor.comp ordered_comm_monoid has_to_string name) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} name h0))  := sorry --non-trivial
lemma new_lemma_84959 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_84960 (h0 : list (add_comm_monoid (has_add (has_nndist name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_84961 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : regular_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_84962 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class char)))) : totally_disconnected_space (mul_one_class (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_84963 (h0 : topological_space (has_bot (has_add (normed_lattice_add_comm_group Type)))) : discrete_topology (has_bot (has_add (normed_lattice_add_comm_group Type))) := sorry --non-trivial
lemma new_lemma_84964 (h0 : ring (has_nndist (option (option (option ennreal))))) : is_domain (has_nndist (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_84965 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_84966 (h0 : ring (add_cancel_monoid (has_to_string (has_to_string (has_neg linarith.comp))))) : is_principal_ideal_ring (add_cancel_monoid (has_to_string (has_to_string (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_84967 (h3 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_84968 (h1 : ring (random_gen to_additive.value_type)) : is_domain (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_84969 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : totally_disconnected_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_84970 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) num) : @loc_path_connected_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_84971 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_84972 (h0 : group (has_ssubset fun_info)) : is_cyclic (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_84973 (h0 : functor.add_const (group (normed_comm_ring pos)) (has_to_string Type)) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_84974 (h0 : function.extfun Type group) : @group.fg.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_84975 (h0 : complete_lattice (semigroup (boolean_algebra (add_cancel_monoid name)))) : is_atomistic (semigroup (boolean_algebra (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_84976 (h0 : uniform_space (comm_ring linarith.ineq)) : complete_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_84977 (h0 : functor.add_const (complete_lattice (has_Sup empty)) unsigned) : @is_atomistic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84978 (h0 : functor.add_const (monoid (add_comm_monoid name)) Type) : @monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_84979 (h0 : functor.add_const (filter (monoid empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_84980 (h0 : ring (semigroup (mul_one_class (has_neg (ring Type))))) : is_principal_ideal_ring (semigroup (mul_one_class (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_84981 (h0 : function.extfun Type (prod (has_union empty))) : id_rel (function.extfun_app h0 (has_union empty)) := sorry --non-trivial
lemma new_lemma_84982 (h0 : not (complete_lattice (has_add fun_info) -> false)) : @is_compactly_generated.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_84983 (h0 : topological_space (pseudo_emetric_space congr_arg_kind)) : t0_space (pseudo_emetric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_84984 (h0 : not (filter char -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_84985 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_84986 (h0 : topological_space (has_inv (random_gen string_imp))) : t0_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_84987 (h0 : add_group (generalized_boolean_algebra (has_neg (finset Type)))) : is_add_cyclic (generalized_boolean_algebra (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_84988 (h0 : Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_84989 (h0 : topological_space (semigroup (comm_monoid (option name)))) : totally_disconnected_space (semigroup (comm_monoid (option name))) := sorry --non-trivial
lemma new_lemma_84990 (h0 : monoid (finset (has_pos_part Type))) : monoid.fg (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_84991 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84992 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_84993 (h0 : functor.add_const (group (preorder congr_arg_kind)) unsigned) : @normalizer_condition.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_84994 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @preirreducible_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_84995 (h0 : topological_space (comm_ring (normed_field (metric_space (has_lt linarith.comp_source))))) : path_connected_space (comm_ring (normed_field (metric_space (has_lt linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_84996 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_84997 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_84998 (h0 : complete_lattice (has_nndist (mul_zero_class unsigned))) : complete_lattice.is_Sup_finite_compact (has_nndist (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_84999 (h0 : add_group (conditionally_complete_linear_order linarith.comp_source)) : is_add_cyclic (conditionally_complete_linear_order linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85000 (h0 : ring (comm_semigroup (has_Inf real))) : is_principal_ideal_ring (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_85001 (h3 : ring (semi_normed_comm_ring (has_ssubset char))) : is_domain (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_85002 (h0 : group (has_top (semiring empty))) : normalizer_condition (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_85003 (h0 : has_lt std_gen) : no_min_order std_gen := sorry --non-trivial
lemma new_lemma_85004 (h0 : measurable_space enat) (h2 : filter enat) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_85005 (h0 : topological_space (complete_distrib_lattice (option (option (option unsigned))))) : irreducible_space (complete_distrib_lattice (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_85006 (h0 : list (comm_ring string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85007 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_85008 (h1 : ring (random_gen congr_arg_kind)) : rank_condition (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85009 (h0 : uniform_space (nondiscrete_normed_field (mul_one_class reducibility_hints))) : complete_space (nondiscrete_normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85010 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_85011 (h0 : functor.add_const (uniform_space (ordered_comm_ring Type)) Type) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_85012 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system (semiring (semiring (semiring empty))))) : unique_factorization_monoid (measurable_space.dynkin_system (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_85013 (h0 : uniform_space (has_top (has_inv (has_top linarith.comp_source)))) : complete_space (has_top (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85014 (h0 : topological_space (boolean_algebra (has_add Type))) : loc_path_connected_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_85015 (h0 : has_mem.mem (complete_semilattice_Sup (has_top linarith.comp_source)) has_emptyc.emptyc) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type add_group.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_85016 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_neg pos)) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_85017 (h0 : ring (cancel_monoid (option ennreal))) : is_principal_ideal_ring (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_85018 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85019 (h0 : topological_space (plift (partial_order unsigned))) : totally_separated_space (plift (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_85020 (h0 : Type) (h1 : topological_space (mul_zero_class h0)) (h2 : heq (topological_space.nonempty_compacts (mul_zero_class h0)) (bin_tree empty)) (h3 : finset (topological_space.nonempty_compacts (mul_zero_class h0))) : finset.nonempty (heq.elim h2 h3) := sorry --non-trivial
lemma new_lemma_85021 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85022 (h0 : list (boolean_algebra (has_to_string (has_to_string unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85023 (h1 : uniform_space (has_compl char)) : complete_space (has_compl char) := sorry --non-trivial
lemma new_lemma_85024 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85025 (h0 : functor.comp ring has_neg pos) : @strong_rank_condition.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_85026 (h0 : ring (ring (has_pos_part Type))) : rank_condition (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_85027 (h1 : group (topological_space (has_nnnorm to_additive.value_type))) : is_cyclic (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85028 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85029 (h0 : complete_lattice (omega_complete_partial_order num)) : complete_lattice.is_Sup_finite_compact (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_85030 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_85031 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_85032 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_85033 (h0 : functor.add_const (add_group (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85034 (h0 : list (ordered_comm_group (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85035 (h0 : functor.add_const Prop (add_comm_monoid name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85036 (h0 : topological_space (comm_group (add_comm_monoid environment.implicit_infer_kind))) : t1_space (comm_group (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_85037 (h0 : functor.comp topological_space canonically_ordered_comm_semiring unsigned) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_85038 (h0 : ring (ring empty)) : is_domain (ring empty) := sorry --non-trivial
lemma new_lemma_85039 (h0 : topological_space (has_neg (semigroup (has_add environment.implicit_infer_kind)))) : topological_space.separable_space (has_neg (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_85040 (h0 : topological_space (comm_semigroup (has_bot (ordered_comm_monoid pos)))) : preirreducible_space (comm_semigroup (has_bot (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_85041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_85042 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_85043 (h0 : add_monoid (id (random_gen (semiring num)))) : add_monoid.fg (id (random_gen (semiring num))) := sorry --non-trivial
lemma new_lemma_85044 (h0 : not (ring (has_ssubset reducibility_hints) -> false)) : @is_domain.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_85045 (h0 : not (has_mem.mem (semiring (random_gen linarith.comp_source)) has_emptyc.emptyc -> false)) : @is_domain.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} (random_gen.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_85046 (h0 : ring (has_bot name)) : is_domain (has_bot name) := sorry --non-trivial
lemma new_lemma_85047 (h0 : group (normed_field (has_lt string.iterator_imp))) : is_cyclic (normed_field (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_85048 (h0 : functor.add_const (add_group (has_nndist Type)) Type) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_85049 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_85050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_85051 (h0 : filter (has_top (has_top to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85052 (h0 : complete_lattice (has_union empty)) : is_atomistic (has_union empty) := sorry --non-trivial
lemma new_lemma_85053 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @t0_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_85054 (h0 : topological_space (semiring (semiring empty))) : t0_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_85055 (h0 : not (add_group (has_lt string_imp) -> false)) : @is_add_cyclic.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_85056 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85057 (h0 : functor.add_const (group (finset linarith.comp)) pos) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_85058 (h0 : not (group (has_emptyc (add_group_with_zero_nhd fun_info)) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} (add_group_with_zero_nhd.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} (add_group_with_zero_nhd.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_85059 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_85060 (h0 : functor.add_const (ring (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85061 (h0 : topological_space (normed_group (option (option empty)))) : t1_space (normed_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_85062 (h0 : comm_semigroup real -> comm_semigroup real -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_85063 (h0 : complete_lattice auto.case_option) : is_compactly_generated auto.case_option := sorry --non-trivial
lemma new_lemma_85064 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_85065 (h0 : topological_space (canonically_ordered_monoid name)) : regular_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_85066 (h0 : ring (comm_group linarith.comp)) : rank_condition (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_85067 (h0 : topological_space (ring (has_add pos))) : t0_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_85068 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85069 (h0 : topological_space (normed_group num)) : totally_separated_space (normed_group num) := sorry --non-trivial
lemma new_lemma_85070 (h0 : topological_space (linear_ordered_comm_group empty)) : loc_path_connected_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_85071 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : t1_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_85072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_85073 (h1 : monoid (distrib_lattice linarith.comp_source)) : monoid.fg (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85074 (h1 : ring ereal) : is_domain ereal := sorry --non-trivial
lemma new_lemma_85075 (h0 : topological_space (plift (option num))) : totally_disconnected_space (plift (option num)) := sorry --non-trivial
lemma new_lemma_85076 (h0 : ordered_add_comm_monoid (left_cancel_monoid empty)) : archimedean (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_85077 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85078 (h1 : ring (has_top (random_gen (random_gen linarith.ineq)))) : rank_condition (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_85079 (h0 : ring (group_with_zero (option num))) : strong_rank_condition (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_85080 (h0 : functor.add_const (uniform_space (has_star empty)) (semiring empty)) : @separated_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_85081 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_85082 (h0 : group (has_add (ring (has_add pos)))) : group.fg (has_add (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_85083 (h0 : functor.add_const (group (left_cancel_monoid num)) num) : @is_cyclic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_85084 (h0 : uniform_space (complete_semilattice_Sup string_imp)) : complete_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_85085 (h0 : functor.add_const (group (left_cancel_monoid congr_arg_kind)) unsigned) : @normalizer_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85086 (h0 : topological_space (has_Inf (ring linarith.comp))) : totally_separated_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_85087 (h0 : topological_space (has_bot (has_add real))) : totally_separated_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_85088 (h3 : uniform_space (non_unital_non_assoc_semiring reducibility_hints)) : complete_space (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_85089 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) (finset Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85090 (h1 : ring (uniform_space (mul_one_class (random_gen linarith.comp_source)))) : strong_rank_condition (uniform_space (mul_one_class (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85091 (h0 : topological_space (has_union (has_union empty))) : totally_disconnected_space (has_union (has_union empty)) := sorry --non-trivial
lemma new_lemma_85092 (h0 : topological_space (has_add (ring name))) : preconnected_space (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_85093 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) pos) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_85094 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : totally_disconnected_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_85095 (h0 : topological_space (fintype fun_info)) : totally_disconnected_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_85096 (h0 : functor.comp group boolean_algebra name) : @is_cyclic.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_85097 (h2 : add_group (non_unital_non_assoc_semiring linarith.comp_source)) : is_add_cyclic (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85098 (h0 : semiring (has_Inf (ring pos))) : is_noetherian_ring (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_85099 (h1 : topological_space (simple_graph string.iterator_imp)) : path_connected_space (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_85100 (h0 : finset (has_to_string pos) -> finset (has_to_string pos) -> Prop) : is_symm (finset (has_to_string pos)) h0 := sorry --non-trivial
lemma new_lemma_85101 (h0 : group (comm_ring (random_gen (random_gen (random_gen char))))) : group.fg (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_85102 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_85103 (h0 : list (dlist (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85104 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_85106 (h0 : ring (linear_ordered_add_comm_group linarith.ineq)) : is_domain (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_85107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_85108 (h0 : topological_space (normed_comm_ring (finset Type))) : topological_space.separable_space (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_85109 (h0 : topological_space (boolean_algebra.core (option empty))) : irreducible_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_85110 (h3 : complete_lattice linarith.comp_source) : is_atomistic linarith.comp_source := sorry --non-trivial
lemma new_lemma_85111 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_85112 (h0 : ring (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_85113 (h0 : topological_space (add_group linarith.comp)) : discrete_topology (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_85114 (h0 : add_group (has_nnnorm (simple_graph (mul_one_class (normed_field linarith.comp_source))))) : is_add_cyclic (has_nnnorm (simple_graph (mul_one_class (normed_field linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_85115 (h1 : group (has_nnnorm (has_nnnorm reducibility_hints))) : is_cyclic (has_nnnorm (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85116 (h0 : topological_space (comm_group (finset Type))) : topological_space.separable_space (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_85117 (h0 : topological_space (semiring (semiring unsigned))) : path_connected_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_85118 (h0 : complete_lattice (semiring (has_top (semiring (has_norm (has_top unsigned)))))) : is_compactly_generated (semiring (has_top (semiring (has_norm (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_85119 (h1 : list (comm_ring to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_85120 (h0 : filter (has_pos_part (has_Inf (has_neg (has_neg (normed_comm_ring Type)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_85121 (h0 : topological_space (semiring (random_gen empty))) : path_connected_space (semiring (random_gen empty)) := sorry --non-trivial
lemma new_lemma_85122 (h0 : list (has_to_string environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85123 (h0 : ring (has_add (has_add (finset Type)))) : is_principal_ideal_ring (has_add (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_85124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_85125 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group name)) name) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85126 (h0 : monoid (has_union (has_top congr_arg_kind))) : monoid.fg (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85127 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85128 (h0 : filter (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_85129 (h0 : topological_space (normed_comm_ring (option (option (option empty))))) : path_connected_space (normed_comm_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_85130 (h0 : topological_space (with_one (has_one (has_top ennreal)))) : totally_separated_space (with_one (has_one (has_top ennreal))) := sorry --non-trivial
lemma new_lemma_85131 (h0 : topological_space (has_pos_part (ordered_comm_ring (has_Inf (has_Inf Type))))) : path_connected_space (has_pos_part (ordered_comm_ring (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_85132 (h0 : ring (has_nndist (boolean_algebra linarith.comp))) : is_domain (has_nndist (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_85133 (h0 : not (topological_space (simple_graph (distrib enat)) -> false)) : @t0_space.{0} (simple_graph.{0} (distrib.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} (distrib.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_85134 (h0 : complete_lattice (left_cancel_monoid empty)) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_85135 (h0 : topological_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : regular_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_85136 (h0 : topological_space (has_neg (has_neg linarith.comp))) : preconnected_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_85137 (h0 : ring (has_nndist (has_add (finset (has_add unsigned))))) : is_principal_ideal_ring (has_nndist (has_add (finset (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_85138 (h0 : complete_lattice (semi_normed_comm_ring string.iterator_imp)) : is_compactly_generated (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_85139 (h0 : complete_lattice (cancel_monoid (has_nndist Type))) : is_atomistic (cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_85140 (h0 : set (has_compl (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_85141 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid name))) : discrete_topology (canonically_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_85142 (h0 : ordered_comm_monoid (has_Inf (has_add (has_add Type)))) : has_exists_mul_of_le (has_Inf (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_85143 (h0 : ring (add_comm_monoid (option (option (option (option ennreal)))))) : strong_rank_condition (add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_85144 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_85145 (h0 : topological_space (has_nndist unsigned)) : topological_space.separable_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_85146 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core pos)) pos) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_85147 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_85148 (h0 : topological_space (has_edist empty)) : normal_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_85149 (h0 : ordered_add_comm_monoid (has_nndist empty)) : archimedean (has_nndist empty) := sorry --non-trivial
lemma new_lemma_85150 (h0 : ring (has_top congr_arg_kind)) : rank_condition (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85151 (h0 : not (multiset (has_div char) -> false)) (h1 : multiset (has_div char)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_85152 (h0 : topological_space (has_top (with_bot fun_info))) : totally_disconnected_space (has_top (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_85153 (h0 : topological_space (with_bot (semiring (semiring empty)))) : totally_disconnected_space (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85154 (h0 : topological_space (simple_graph (has_add (has_Inf pos)))) : regular_space (simple_graph (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_85155 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_85156 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @topological_space.separable_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_85157 (h1 : topological_space (simple_graph reducibility_hints)) (h2 : preorder (simple_graph reducibility_hints)) : order_closed_topology (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_85158 (h0 : topological_space (semi_normed_comm_ring char)) (h1 : add_group (semi_normed_comm_ring char)) : topological_add_group (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_85159 (h0 : has_neg (has_lt linarith.comp_source)) (h1 : measurable_space (has_lt linarith.comp_source)) : has_measurable_neg (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85160 (h1 : uniform_space (has_compl string_imp)) : complete_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_85161 (h0 : topological_space (option (ordered_cancel_comm_monoid unsigned))) : t0_space (option (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_85162 (h0 : not (group (semiring fun_info) -> false)) : @normalizer_condition.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_85163 (h0 : topological_space (has_repr (has_add unsigned))) : normal_space (has_repr (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_85164 (h0 : add_group (distrib_lattice (with_bot (random_gen to_additive.value_type)))) : is_add_cyclic (distrib_lattice (with_bot (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_85165 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_85166 (h0 : group (has_to_string num)) : group.fg (has_to_string num) := sorry --non-trivial
lemma new_lemma_85167 (h0 : complete_lattice (has_bot (has_bot (has_add real)))) : is_compactly_generated (has_bot (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_85168 (h0 : topological_space (comm_group (has_add Type))) : preirreducible_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_85169 (h0 : topological_space (has_zero (finset name))) : irreducible_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_85170 (h0 : functor.add_const (group (add_comm_monoid Type)) name) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_85171 (h0 : ring (semi_normed_comm_ring (random_gen to_additive.value_type))) : strong_rank_condition (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85172 (h0 : topological_space (group_with_zero congr_arg_kind)) : t1_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85173 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_85174 (h0 : complete_lattice (has_zero (has_nndist name))) : is_compactly_generated (has_zero (has_nndist name)) := sorry --non-trivial
lemma new_lemma_85175 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_85176 (h0 : topological_space (add_comm_semigroup (nondiscrete_normed_field char))) (h1 : preorder (add_comm_semigroup (nondiscrete_normed_field char))) : order_closed_topology (add_comm_semigroup (nondiscrete_normed_field char)) := sorry --non-trivial
lemma new_lemma_85177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_85178 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @totally_separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_85179 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_85180 (h0 : cancel_comm_monoid_with_zero (free_add_monoid (semiring (semiring empty)))) : unique_factorization_monoid (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85181 (h0 : functor.add_const (ordered_add_comm_monoid pos) unsigned) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85182 (h0 : topological_space (has_add (ordered_comm_monoid (has_nndist (ordered_comm_monoid real))))) : normal_space (has_add (ordered_comm_monoid (has_nndist (ordered_comm_monoid real)))) := sorry --non-trivial
lemma new_lemma_85183 (h0 : topological_space (with_one (semiring num))) : totally_separated_space (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_85184 (h0 : topological_space (has_div (mul_one_class to_additive.value_type)) -> Prop) (h1 : Exists (fun (x : topological_space (has_div (mul_one_class to_additive.value_type))), h0 x)) (h2 : preorder (has_div (mul_one_class to_additive.value_type))) : @order_closed_topology.{0} (has_div.{0} (mul_one_class.{0} to_additive.value_type)) (@classical.some.{1} (topological_space.{0} (has_div.{0} (mul_one_class.{0} to_additive.value_type))) h0 h1) h2  := sorry --non-trivial
lemma new_lemma_85185 (h0 : semiring (has_inner empty congr_arg_kind)) : is_noetherian_ring (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85186 (h0 : functor.comp topological_space has_to_string pos) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_85187 (h0 : finset (has_pos_part (has_Inf (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85188 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_85189 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85190 (h0 : function.extfun Type uniform_space) : @separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_85191 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) unsigned) : @locally_compact_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85192 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_Inf name)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_Inf.{0} name) h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85193 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : totally_disconnected_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_85194 (h0 : list (boolean_algebra (has_add (has_add (has_to_string (has_neg_part Type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85195 (h2 : list Prop) : list.head h2 := sorry --non-trivial
lemma new_lemma_85196 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_85197 (h0 : functor.add_const (topological_space (has_to_string ennreal)) num) : @t0_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_85198 (h0 : prod (has_dist num) (has_dist num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_85199 (h1 : set char) : set.finite h1 := sorry --non-trivial
lemma new_lemma_85200 (h0 : add_group (has_edist (semiring empty))) : is_add_cyclic (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_85201 (h0 : functor.add_const (finset (finset name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85202 (h0 : group (normed_group (has_inv (has_inv (has_inv (has_inv fun_info)))))) : normalizer_condition (normed_group (has_inv (has_inv (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_85203 (h0 : functor.comp add_monoid has_neg Type) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} add_monoid.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_85204 (h0 : monoid (has_one (semiring (semiring empty)))) : monoid.fg (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85205 (h0 : topological_space (has_append (random_gen (random_gen char)))) : t0_space (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_85206 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_85207 (h0 : add_monoid (has_nndist unsigned)) : add_monoid.fg (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_85208 (h0 : topological_space (has_neg congr_arg_kind)) : discrete_topology (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85209 (h0 : ring (ordered_comm_ring (has_Inf (has_add (canonically_linear_ordered_monoid Type))))) : rank_condition (ordered_comm_ring (has_Inf (has_add (canonically_linear_ordered_monoid Type)))) := sorry --non-trivial
lemma new_lemma_85210 (h0 : functor.add_const (group (semigroup environment.implicit_infer_kind)) (has_to_string Type)) : @is_simple_group.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_85211 (h0 : functor.add_const (ordered_comm_monoid (finset name)) (has_Inf name)) : @has_exists_mul_of_le.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} name)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85212 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) (has_nndist (has_neg_part (boolean_algebra name)))) : @complete_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) (has_nndist.{0} (has_neg_part.{0} (boolean_algebra.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_85213 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_85214 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_85215 (h1 : filter (has_emptyc to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_85216 (h0 : functor.add_const (group (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_85217 (h0 : semiring (metric_space num)) : is_noetherian_ring (metric_space num) := sorry --non-trivial
lemma new_lemma_85218 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) Type) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_85219 (h0 : complete_lattice (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_compactly_generated (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85220 (h0 : semiring (normed_group (has_norm unsigned))) : is_noetherian_ring (normed_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_85221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85222 (h0 : uniform_space (semiring (semiring (semiring empty)))) : separated_space (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85223 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85224 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85225 (h1 : not (topological_space (distrib string_imp) -> false)) : @totally_disconnected_space.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_85226 (h1 : ring (has_ssubset linarith.comp_source)) : is_domain (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85227 (h0 : functor.add_const (group (option num)) num) : @normalizer_condition.{0} (option.{0} num) (@functor.add_const.run.{0 0} (group.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_85228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_85229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_85230 (h0 : topological_space (has_inf (option (option pos)))) : preconnected_space (has_inf (option (option pos))) := sorry --non-trivial
lemma new_lemma_85231 (h0 : add_monoid (with_bot (semiring congr_arg_kind))) : add_monoid.fg (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85232 (h0 : uniform_space (has_edist empty)) : complete_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_85233 (h0 : ring (has_top (has_norm (random_gen linarith.comp_source)))) : strong_rank_condition (has_top (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85234 (h0 : not (add_group (semi_normed_comm_ring linarith.ineq) -> false)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_85235 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_monoid name)) (has_add linarith.comp)) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} name)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_85236 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_85237 (h0 : ring (with_one (random_gen (random_gen linarith.comp_source)))) : rank_condition (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85238 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_85239 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_85240 (h0 : functor.add_const (uniform_space (left_cancel_monoid num)) empty) : @separated_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_85241 (h0 : topological_space (linear_ordered_semiring (semiring (random_gen (semiring linarith.comp))))) : discrete_topology (linear_ordered_semiring (semiring (random_gen (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_85242 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : totally_disconnected_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85243 (h0 : topological_space (has_ssubset enat)) : path_connected_space (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_85244 (h0 : monoid (has_zero (has_pos_part (semigroup (has_pos_part linarith.comp))))) : monoid.fg (has_zero (has_pos_part (semigroup (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_85245 (h0 : set linarith.comp_source) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_85246 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85247 (h0 : not (ring (has_lt string_imp) -> false)) : @is_domain.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_85248 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) empty) : @preirreducible_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_85249 (h0 : group (canonically_linear_ordered_monoid name)) : is_cyclic (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_85250 (h0 : complete_lattice (has_to_string (ordered_comm_monoid linarith.comp))) : is_atomistic (has_to_string (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_85251 (h0 : topological_space (measurable_space congr_arg_kind)) : totally_disconnected_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85252 (h0 : topological_space (bin_tree (has_top num))) : path_connected_space (bin_tree (has_top num)) := sorry --non-trivial
lemma new_lemma_85253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_85254 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring (with_bot linarith.comp))))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring (with_bot linarith.comp)))) := sorry --non-trivial
lemma new_lemma_85255 (h0 : complete_lattice (option num)) : is_compactly_generated (option num) := sorry --non-trivial
lemma new_lemma_85256 (h0 : uniform_space (simple_graph (option (option (option empty))))) : separated_space (simple_graph (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_85257 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_85258 (h0 : functor.add_const (complete_lattice ennreal) ennreal) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_85259 (h0 : group (has_add (finset (has_neg (has_nndist pos))))) : normalizer_condition (has_add (finset (has_neg (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_85260 (h0 : group (has_neg_part Type)) : is_cyclic (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_85261 (h0 : functor.add_const (group (boolean_algebra.core empty)) empty) : @group.fg.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_85262 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85263 (h0 : topological_space (id unsigned)) : normal_space (id unsigned) := sorry --non-trivial
lemma new_lemma_85264 (h0 : add_monoid (finset linarith.comp)) : add_monoid.fg (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_85265 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_85266 (h0 : topological_space (finset (has_to_string name))) : totally_disconnected_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_85267 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) pos) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_85268 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85269 (h0 : finset (has_zero (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85270 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core Type))) : locally_compact_space (boolean_algebra.core (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_85271 (h0 : functor.add_const (topological_space (has_zero name)) pos) : @locally_compact_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_85272 (h0 : not (topological_space (denumerable (has_nnnorm linarith.ineq)) -> false)) : @path_connected_space.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_85273 (h0 : ring (denumerable (random_gen string_imp))) : strong_rank_condition (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_85274 (h0 : functor.add_const (list (has_to_string linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85275 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup empty)))) : @is_atomistic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_85276 (h0 : ring (normed_lattice_add_comm_group pos)) : rank_condition (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_85277 (h3 : topological_space (nondiscrete_normed_field ereal)) : totally_disconnected_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_85278 (h0 : monoid (add_left_cancel_semigroup (option unsigned))) : monoid.fg (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_85279 (h0 : topological_space (bin_tree num)) : totally_separated_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_85280 (h0 : topological_space (comm_group (has_nndist name))) : topological_space.separable_space (comm_group (has_nndist name)) := sorry --non-trivial
lemma new_lemma_85281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_85282 (h0 : ordered_add_comm_monoid (boolean_algebra (has_neg (finset linarith.comp)))) : archimedean (boolean_algebra (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_85283 (h1 : add_group (has_add (has_append to_additive.value_type))) : is_add_cyclic (has_add (has_append to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85284 (h0 : topological_space (has_neg_part (add_cancel_monoid name))) : t1_space (has_neg_part (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_85285 (h0 : topological_space (has_Inf Type)) : t0_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_85286 (h0 : has_coe (add_comm_semigroup (mul_one_class (mul_one_class fun_info))) Prop) (h1 : add_comm_semigroup (mul_one_class (mul_one_class fun_info))) : @coe_b.{1 1} (add_comm_semigroup.{0} (mul_one_class.{0} (mul_one_class.{0} fun_info))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_85287 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85288 (h0 : topological_space (boolean_algebra (comm_group (add_comm_monoid environment.implicit_infer_kind)))) : normal_space (boolean_algebra (comm_group (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_85289 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_85290 (h0 : functor.add_const (ring (sub_neg_monoid linarith.comp)) (has_neg name)) : @is_domain.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85291 (h1 : add_group (normed_field (comm_ring (comm_ring string_imp)))) : is_add_cyclic (normed_field (comm_ring (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_85292 (h0 : uniform_space (measurable_space fun_info)) : separated_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_85293 (h0 : functor.add_const (semiring (has_zero ennreal)) name) : @is_noetherian_ring.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_85294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_85295 (h0 : functor.add_const (list (has_add name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85296 (h0 : ring (denumerable (denumerable to_additive.value_type))) : is_domain (denumerable (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85297 (h0 : group (comm_semigroup (comm_semigroup Type))) : is_simple_group (comm_semigroup (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_85298 (h0 : functor.add_const (ring (has_to_string ennreal)) num) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_85299 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @irreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_85300 (h1 : prod (has_dist std_gen) (has_dist std_gen)) : set.diagonal (has_dist std_gen) h1 := sorry --non-trivial
lemma new_lemma_85301 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85302 (h1 : ring (has_ssubset (mul_one_class linarith.ineq))) : is_domain (has_ssubset (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85303 (h0 : semiring (complete_distrib_lattice (comm_group (comm_group Type)))) : is_noetherian_ring (complete_distrib_lattice (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_85304 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) (comm_group Type)) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_85305 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85306 (h0 : ring (simple_graph environment.projection_info)) : rank_condition (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_85307 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_85308 (h0 : not (add_group (bin_tree congr_arg_kind) -> false)) : @is_add_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_85309 (h0 : functor.add_const (ring (linear_ordered_add_comm_group_with_top pos)) Type) : @rank_condition.{0} (linear_ordered_add_comm_group_with_top.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (linear_ordered_add_comm_group_with_top.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_85310 (h0 : ring (complete_linear_order (semiring unsigned))) : rank_condition (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_85311 (h0 : group (has_norm (has_norm linarith.comp_source))) : normalizer_condition (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85312 (h0 : topological_space (has_pos_part (has_add (boolean_algebra.core linarith.comp)))) : locally_compact_space (has_pos_part (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_85313 (h0 : functor.add_const (list (has_dist unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85314 (h0 : functor.add_const (group (complete_distrib_lattice unsigned)) num) : @is_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_85315 (h0 : topological_space (cancel_monoid (option (option empty)))) : irreducible_space (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_85316 (h0 : ordered_add_comm_monoid (has_dist (option unsigned))) : archimedean (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_85317 (h0 : topological_space (ring (has_add (has_add Type)))) : t1_space (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_85318 (h1 : ring (has_top fun_info)) : is_domain (has_top fun_info) := sorry --non-trivial
lemma new_lemma_85319 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_85320 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85321 (h0 : topological_space (has_norm (has_top linarith.comp))) : discrete_topology (has_norm (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_85322 (h0 : list (has_add (has_add (has_add (has_neg pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85323 (h0 : topological_space (has_bot (has_bot (has_bot linarith.comp)))) : normal_space (has_bot (has_bot (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_85324 (h0 : function.extfun Type (functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)))) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85325 (h0 : functor.add_const (group (uniform_space empty)) empty) : @is_cyclic.{0} (uniform_space.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (uniform_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_85326 (h0 : topological_space (has_compl (mul_one_class (has_ssubset reducibility_hints)))) : path_connected_space (has_compl (mul_one_class (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_85327 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_85328 (h0 : topological_space (has_to_string (add_cancel_monoid unsigned))) : regular_space (has_to_string (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_85329 (h0 : ordered_semiring (has_add (has_add Type))) (h1 : ring (has_add (floor_semiring (has_add (has_add Type))))) : is_principal_ideal_ring (has_add (floor_semiring (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_85330 (h0 : complete_lattice (has_add environment.implicit_infer_kind)) : is_atomistic (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_85331 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_85332 (h0 : functor.add_const (group (has_to_string unsigned)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_85334 (h0 : uniform_space (has_star (option (option (option (option empty)))))) : separated_space (has_star (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_85335 (h0 : function.extfun Type group) : @is_cyclic.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85336 (h0 : topological_space (add_comm_semigroup reducibility_hints)) : totally_disconnected_space (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_85337 (h0 : complete_lattice (semigroup congr_arg_kind)) : is_compactly_generated (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85338 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_85339 (h0 : topological_space (has_one (semiring empty))) : totally_separated_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_85340 (h0 : list (measurable_space.dynkin_system unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85341 (h1 : topological_space (has_emptyc (random_gen to_additive.value_type))) : t0_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85342 (h4 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h4 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85343 (h0 : finset (has_nndist (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85344 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_85345 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85346 (h0 : group (complete_distrib_lattice (has_Inf pos))) : group.fg (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_85347 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) (has_neg_part Type)) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_85348 (h0 : topological_space (has_to_string (has_add pos))) : loc_path_connected_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_85349 (h0 : not (group (option congr_arg_kind) -> false)) : @normalizer_condition.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_85350 (h0 : functor.add_const (functor.add_const (ring linarith.comp) pos) linarith.comp) : @is_principal_ideal_ring.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_85351 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_85352 (h0 : set (linarith.ineq -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_85353 (h0 : functor.add_const (complete_lattice (semigroup name)) (has_neg name)) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85354 (h1 : topological_space (division_ring linarith.ineq)) : totally_disconnected_space (division_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_85355 (h0 : semiring (has_to_string (comm_group pos))) : is_noetherian_ring (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_85356 (h0 : topological_space (has_pos_part name)) : loc_path_connected_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_85357 (h0 : uniform_space (has_top linarith.comp_source)) : complete_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85358 (h0 : function.extfun nat fin) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_85359 (h0 : functor.add_const (finset (simple_graph linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85360 (h0 : topological_space (has_nndist (finset name))) : topological_space.separable_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_85361 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_85362 (h0 : ordered_comm_monoid (ordered_comm_monoid linarith.comp)) : has_exists_mul_of_le (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_85363 (h0 : list (canonically_linear_ordered_monoid (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85364 (h0 : topological_space (ordered_comm_ring (has_add Type))) : totally_disconnected_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_85365 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_85366 (h0 : complete_lattice (normed_comm_ring (has_pos_part (finset Type)))) : is_compactly_generated (normed_comm_ring (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_85367 (h0 : function.extfun Type (functor.comp ring canonically_ordered_comm_semiring)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_85368 (h0 : ring (has_one (semiring (has_norm (semiring congr_arg_kind))))) : rank_condition (has_one (semiring (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_85369 (h0 : functor.add_const (add_group (simple_graph linarith.comp)) (ring (ring Type))) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (simple_graph.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_85370 (h0 : group (random_gen char)) : is_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_85371 (h0 : ring (semigroup (finset (boolean_algebra linarith.comp)))) : rank_condition (semigroup (finset (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_85372 (h0 : topological_space (metric_space (has_norm num))) : irreducible_space (metric_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_85373 (h0 : topological_space (has_neg (comm_group Type))) : regular_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_85374 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) unsigned) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85375 (h0 : functor.add_const (topological_space (has_add name)) name) : @t1_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85376 (h0 : fin has_zero.zero) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_85377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_85378 (h0 : complete_lattice (with_one (semiring (semiring (semiring empty))))) : is_atomistic (with_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_85379 (h2 : complete_lattice (distrib (denumerable fun_info))) : complete_lattice.is_Sup_finite_compact (distrib (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_85380 (h1 : ring (normed_field auto.case_option)) : strong_rank_condition (normed_field auto.case_option) := sorry --non-trivial
lemma new_lemma_85381 (h0 : functor.add_const (topological_space (monoid pos)) name) : @path_connected_space.{0} (monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_85382 (h0 : topological_space (comm_ring (random_gen (random_gen string_imp)))) : t0_space (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_85383 (h0 : functor.add_const (monoid (has_Sup empty)) unsigned) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85384 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_85385 (h0 : set (has_le std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_85386 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : t0_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85387 (h0 : topological_space (has_bot (has_neg pos))) : normal_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_85388 (h0 : topological_space (random_gen (random_gen congr_arg_kind))) : path_connected_space (random_gen (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85389 (h0 : functor.add_const (ring (has_Inf linarith.comp)) (has_nndist name)) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85390 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_85391 (h0 : fin has_zero.zero) : @complete_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_85392 (h0 : topological_space (semigroup (semiring empty))) : loc_path_connected_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_85393 (h0 : monoid (group_with_zero (option ennreal))) : monoid.fg (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_85394 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_85395 (h0 : ring (semi_normed_comm_ring (has_neg char))) : is_domain (semi_normed_comm_ring (has_neg char)) := sorry --non-trivial
lemma new_lemma_85396 (h0 : function.extfun Type topological_space) : @t1_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85397 (h0 : set (random_gen enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_85398 (h0 : ring (normed_linear_ordered_group char)) : rank_condition (normed_linear_ordered_group char) := sorry --non-trivial
lemma new_lemma_85399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_85400 (h0 : has_top to_additive.value_type -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_85401 (h0 : group (add_cancel_monoid linarith.comp)) : is_simple_group (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_85402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_85403 (h1 : not (complete_lattice (uniform_space linarith.comp_source) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85404 (h0 : topological_space (add_cancel_monoid (option (option ennreal)))) : irreducible_space (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_85405 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85406 (h0 : group (linear_ordered_semiring (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (linear_ordered_semiring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_85407 (h0 : add_monoid (simple_graph (finset linarith.comp))) : add_monoid.fg (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_85408 (h0 : add_group (plift (semiring (semiring empty)))) : is_add_cyclic (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85409 (h0 : topological_space (has_Sup (add_left_cancel_semigroup unsigned))) : normal_space (has_Sup (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_85410 (h0 : functor.add_const (ring (has_zero pos)) name) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_85411 (h0 : list (cancel_monoid (has_neg_part name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85412 (h0 : ring (finset (option Type))) : strong_rank_condition (finset (option Type)) := sorry --non-trivial
lemma new_lemma_85413 (h0 : list (topological_space (denumerable linarith.ineq))) (h1 : ne h0 list.nil) : @totally_disconnected_space.{0} (denumerable.{0} linarith.ineq) (@list.last.{0} (topological_space.{0} (denumerable.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_85414 (h0 : topological_space (boolean_algebra.core name)) : locally_compact_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_85415 (h0 : ordered_add_comm_monoid (ordered_comm_group empty)) : archimedean (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_85416 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85417 (h0 : uniform_space (has_one unsigned)) : separated_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_85418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_85419 (h0 : ring (has_nndist (finset (finset pos)))) : rank_condition (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_85420 (h0 : functor.add_const (semiring (has_zero pos)) Type) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_85421 (h0 : fin has_zero.zero) : @separated_space.{0} (has_nndist.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_nndist.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_85422 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_85423 (h0 : topological_space (nondiscrete_normed_field char)) : t0_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_85424 (h0 : not (ring (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @is_domain.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_85425 (h0 : topological_space (monoid (option (option empty)))) : preirreducible_space (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_85426 (h0 : uniform_space (partial_order unsigned)) : separated_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_85427 (h0 : complete_lattice (has_neg pos)) : is_compactly_generated (has_neg pos) := sorry --non-trivial
lemma new_lemma_85428 (h1 : topological_space (normed_field (left_cancel_semigroup reducibility_hints))) : t0_space (normed_field (left_cancel_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85429 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_85430 (h0 : topological_space (semiring (random_gen congr_arg_kind))) : t0_space (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85431 (h2 : uniform_space (with_one fun_info)) : complete_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_85432 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85433 (h0 : add_monoid (canonically_ordered_comm_semiring (normed_comm_ring name))) : add_monoid.fg (canonically_ordered_comm_semiring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_85434 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_85435 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @preirreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_85436 (h0 : ordered_comm_monoid (ordered_comm_ring (has_pos_part real))) : has_exists_mul_of_le (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_85437 (h0 : group (with_one (random_gen (random_gen linarith.comp_source)))) : group.fg (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85438 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_85439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_85440 (h0 : ring (boolean_algebra (normed_group linarith.comp))) : rank_condition (boolean_algebra (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_85441 (h0 : topological_space (boolean_algebra.core (option unsigned))) : totally_disconnected_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_85442 (h0 : pfun (add_cancel_comm_monoid string_imp) (topological_space (semi_normed_ring linarith.comp_source))) (h1 : coe_sort (pfun.dom h0)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@pfun.as_subtype.{0 0} (add_cancel_comm_monoid.{0} string_imp) (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h0 h1)  := sorry --non-trivial
lemma new_lemma_85443 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_85444 (h0 : not (complete_lattice (topological_space (has_nnnorm linarith.comp_source)) -> false)) : is_compactly_generated (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85445 (h0 : topological_space (plift (has_Sup congr_arg_kind))) : discrete_topology (plift (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85446 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_to_string Type)) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_85447 (h4 h5 : multiset (normed_field (normed_field char))) : multiset.subset h4 h5 := sorry --non-trivial
lemma new_lemma_85448 (h2 : ring (measurable_space linarith.comp)) : strong_rank_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_85449 (h0 : functor.add_const (function.extfun Type add_group) ennreal) : @is_add_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) ennreal h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_85450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85451 (h1 : uniform_space (denumerable (has_nnnorm (has_nnnorm char)))) : complete_space (denumerable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_85452 (h0 : complete_lattice (has_lt string.iterator_imp)) : is_compactly_generated (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_85453 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (option pos))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_85454 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @totally_separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_85455 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid unsigned)) : unique_factorization_monoid (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_85456 (h0 : topological_space (has_to_string (has_to_string (has_to_string unsigned)))) : normal_space (has_to_string (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_85457 (h0 : complete_lattice (boolean_algebra.core (has_zero name))) : is_compactly_generated (boolean_algebra.core (has_zero name)) := sorry --non-trivial
lemma new_lemma_85458 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @totally_separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_85459 (h0 : topological_space (has_add (has_neg Type))) : preirreducible_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_85460 (h0 : fin has_zero.zero) : @regular_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_85461 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85462 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_85463 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85464 (h0 : monoid (has_norm (has_inv fun_info))) : monoid.fg (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_85465 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85466 (h1 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_85467 (h0 : ring (simple_graph (mul_one_class reducibility_hints))) : rank_condition (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85468 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_85469 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring empty))) : unique_factorization_monoid (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_85470 (h0 : group (has_neg (ring environment.implicit_infer_kind))) : group.fg (has_neg (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_85471 (h0 : functor.add_const (semiring (has_zero linarith.comp)) pos) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_85472 (h0 : add_group (id (has_top linarith.comp_source))) : add_group.fg (id (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85473 (h0 : topological_space (boolean_algebra (semigroup (comm_group name)))) : sequential_space (boolean_algebra (semigroup (comm_group name))) := sorry --non-trivial
lemma new_lemma_85474 (h0 : not (group (has_inv (has_nnnorm linarith.comp_source)) -> false)) : @is_cyclic.{0} (has_inv.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_85475 (h0 : topological_space (measurable_space (semiring linarith.comp))) : path_connected_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_85476 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) name) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_85477 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) Type) : @is_atomistic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_85478 (h0 : list (has_add (has_add (has_add environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85479 (h0 : functor.add_const (uniform_space (ring name)) name) : @separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85480 (h0 : uniform_space string.iterator) (h1 : filter string.iterator) : cauchy h1 := sorry --non-trivial
lemma new_lemma_85481 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm char))) : complete_space (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_85482 (h0 : ring (random_gen (has_top unsigned))) : strong_rank_condition (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_85483 (h0 : topological_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real)))) : t1_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_85484 (h0 : list (finset (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85485 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @sequential_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_85486 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85487 (h0 : monoid (linear_ordered_semiring (has_norm fun_info))) : monoid.fg (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_85488 (h0 : add_monoid (boolean_algebra (ring (ring (ring (has_add Type)))))) : add_monoid.fg (boolean_algebra (ring (ring (ring (has_add Type))))) := sorry --non-trivial
lemma new_lemma_85489 (h0 : group (plift (option unsigned))) : is_cyclic (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_85490 (h0 : not (topological_space (option num) -> false)) : @t0_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_85491 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_85492 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_85493 (h0 : ring (comm_group (has_add (has_add (has_add (has_add Type)))))) : is_principal_ideal_ring (comm_group (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_85494 (h0 : complete_lattice (has_star (semiring empty))) : is_compactly_generated (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_85495 (h0 : complete_lattice (ring environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_85496 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_85497 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_85498 (h0 : uniform_space (has_Inf (has_Inf name))) : complete_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_85499 (h0 : uniform_space (with_bot congr_arg_kind)) : complete_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85500 (h1 : measurable_space (nondiscrete_normed_field environment.projection_info)) (h2 : measure_theory.measure (nondiscrete_normed_field environment.projection_info)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_85501 (h0 : prod (linear_order (option (option unsigned))) (linear_order (option (option unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_85502 (h0 : ring (has_neg_part (has_add Type))) : rank_condition (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_85503 (h0 : group (measurable_space (has_inv (has_inv (has_top (has_inv (has_inv (has_top fun_info)))))))) : group.fg (measurable_space (has_inv (has_inv (has_top (has_inv (has_inv (has_top fun_info))))))) := sorry --non-trivial
lemma new_lemma_85504 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @preirreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_85505 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid empty)) (option (option (option empty)))) : @archimedean.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_85506 (h0 : ordered_comm_monoid (ring (finset linarith.comp))) : has_exists_mul_of_le (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_85507 (h0 : functor.add_const (topological_space (plift num)) congr_arg_kind) : @preirreducible_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_85508 (h0 : topological_space (add_comm_monoid (has_neg Type))) : preconnected_space (add_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_85509 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option empty))) : unique_factorization_monoid (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_85510 (h0 : complete_lattice (has_emptyc (has_top fun_info))) : is_atomistic (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_85511 (h0 : uniform_space (complete_distrib_lattice empty)) : complete_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_85512 (h0 : monoid (has_one (has_top empty))) : monoid.fg (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_85513 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85514 (h0 : function.extfun Type group) : @normalizer_condition.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_85515 (h0 : semiring (has_add (has_Inf Type))) : is_noetherian_ring (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_85516 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_85517 (h0 : topological_space (has_neg_part (has_neg_part (cancel_monoid num)))) : loc_path_connected_space (has_neg_part (has_neg_part (cancel_monoid num))) := sorry --non-trivial
lemma new_lemma_85518 (h0 : functor.add_const Prop (non_assoc_semiring num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85519 (h0 : add_group (generalized_boolean_algebra (ring pos))) : is_add_cyclic (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_85520 (h0 : add_group (semigroup (ring Type))) : is_add_cyclic (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_85521 (h0 : topological_space (ring (option ennreal))) : preconnected_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_85522 (h0 : uniform_space (add_cancel_monoid empty)) : separated_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_85523 (h0 : functor.add_const (ring (normed_comm_ring name)) environment.implicit_infer_kind) : @is_domain.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85524 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85525 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85526 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85527 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_85528 (h0 : topological_space (has_norm (measurable_space linarith.ineq))) : totally_separated_space (has_norm (measurable_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85529 (h0 : filter (complete_distrib_lattice name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_85530 (h0 : add_group (add_comm_monoid congr_arg_kind)) : is_add_cyclic (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85531 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_85532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85533 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_85534 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_85535 (h0 : functor.add_const (topological_space (finset pos)) pos) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_85536 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_85537 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_85538 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part Type)))) : t0_space (boolean_algebra (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_85539 (h0 : uniform_space (cancel_monoid Type)) : separated_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_85540 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_85541 (h0 : nat) (h1 : composition h0 -> congr_arg_kind -> congr_arg_kind) : left_commutative h1 := sorry --non-trivial
lemma new_lemma_85542 (h0 : topological_space (comm_semigroup (ordered_comm_monoid pos))) : preirreducible_space (comm_semigroup (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_85543 (h0 : functor.add_const Prop (has_add (measurable_space (measurable_space name)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85544 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85545 (h0 : functor.add_const (topological_space (has_add name)) name) : @preirreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85546 (h0 : uniform_space (mul_one_class ereal)) : complete_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_85547 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85548 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (cancel_monoid name)) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85549 (h0 : not (topological_space (has_compl reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_85550 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_85551 (h0 : monoid (has_add (add_comm_monoid linarith.comp))) : monoid.fg (has_add (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_85552 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85553 (h0 : topological_space (normed_field (topological_space reducibility_hints))) : t0_space (normed_field (topological_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85554 (h2 : has_le (has_ssubset char)) (h3 : has_ssubset char) : is_max h3 := sorry --non-trivial
lemma new_lemma_85555 (h0 : group (normed_lattice_add_comm_group (comm_semigroup pos))) : is_simple_group (normed_lattice_add_comm_group (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_85556 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_85557 (h0 : topological_space (normed_lattice_add_comm_group name)) : preirreducible_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_85558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85559 (h1 : add_group (with_bot linarith.comp_source)) : is_add_cyclic (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85560 (h0 : ring (with_bot (semiring num))) : strong_rank_condition (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_85561 (h1 : metric_space linarith.comp_source -> metric_space linarith.comp_source -> metric_space linarith.comp_source) : left_commutative h1 := sorry --non-trivial
lemma new_lemma_85562 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85563 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85564 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_85565 (h0 : not (add_group (add_group unsigned) -> false)) : @is_add_cyclic.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_85566 (h0 : ordered_add_comm_monoid (ring (ordered_ring Type))) : archimedean (ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_85567 (h0 : functor.add_const (functor.comp complete_lattice finset unsigned) (option pos)) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) unsigned (@functor.comp.run.{0 0 0} complete_lattice.{0} finset.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} finset.{0} unsigned) (option.{0} pos) h0)))  := sorry --non-trivial
lemma new_lemma_85568 (h0 : topological_space (has_zero (finset pos))) : preconnected_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_85569 (h0 : functor.add_const (add_group (normed_comm_ring Type)) unsigned) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (normed_comm_ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85570 (h0 : filter (with_bot (random_gen (has_norm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85571 (h0 : topological_space (has_neg name)) : t0_space (has_neg name) := sorry --non-trivial
lemma new_lemma_85572 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_85573 (h0 : group (has_append to_additive.value_type)) : is_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_85574 (h0 : monoid (linear_ordered_field (option congr_arg_kind))) : monoid.fg (linear_ordered_field (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_85575 (h0 : filter (distrib_lattice (random_gen (with_bot (random_gen string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85576 (h0 : group (canonically_linear_ordered_monoid (has_add pos))) : is_simple_group (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_85577 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_85578 (h0 : not (uniform_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_85579 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero (option (option empty)))) : archimedean (linear_ordered_comm_monoid_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_85580 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (encodable string_imp)) := sorry --non-trivial
lemma new_lemma_85581 (h1 : add_group (normed_field (comm_ring string_imp))) : is_add_cyclic (normed_field (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_85582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_85583 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_85584 (h0 : topological_space (add_comm_monoid (option unsigned))) : topological_space.separable_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_85585 (h0 : complete_lattice (has_div std_gen)) : is_compactly_generated (has_div std_gen) := sorry --non-trivial
lemma new_lemma_85586 (h0 : ring (has_append (random_gen (has_nnnorm linarith.comp_source)))) : strong_rank_condition (has_append (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_85587 (h0 : complete_lattice (comm_semigroup name)) : complete_lattice.is_Sup_finite_compact (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_85588 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) Type) : @normal_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_85589 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @separated_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type uniform_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_85590 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_85591 (h0 : semiring (has_add (has_Inf (sub_neg_monoid real)))) : is_noetherian_ring (has_add (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_85592 (h0 : has_lt (has_lt (canonically_linear_ordered_monoid string.iterator_imp))) : no_max_order (has_lt (canonically_linear_ordered_monoid string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_85593 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_85594 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_85595 (h0 : ring (has_lt (has_zero string.iterator_imp))) : rank_condition (has_lt (has_zero string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_85596 (h0 : topological_space (has_neg_part ennreal)) : totally_separated_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_85597 (h2 : ring (distrib linarith.comp_source)) : rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85598 (h0 : topological_space (add_comm_monoid (has_add name))) : irreducible_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_85599 (h0 : uniform_space (has_norm num)) : complete_space (has_norm num) := sorry --non-trivial
lemma new_lemma_85600 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_85601 (h0 : topological_space enat) : path_connected_space enat := sorry --non-trivial
lemma new_lemma_85602 (h0 : prod (ring pos) (ring pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_85603 (h1 h2 : multiset (add_comm_semigroup char)) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_85604 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85605 (h0 : topological_space (has_zero (has_Inf Type))) : totally_disconnected_space (has_zero (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_85606 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_85607 (h0 : functor.comp topological_space has_to_string pos) : @regular_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_85608 (h0 : topological_space (semigroup (comm_group Type))) : totally_disconnected_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_85609 (h0 : topological_space (semigroup (finset (finset Type)))) : normal_space (semigroup (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_85610 (h0 : topological_space (semigroup (has_neg name))) : totally_disconnected_space (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_85611 (h0 : functor.add_const (topological_space (has_neg Type)) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85612 (h0 : topological_space (ordered_comm_semiring num)) : totally_disconnected_space (ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_85613 (h0 : uniform_space (has_to_string (option ennreal))) : complete_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_85614 (h0 : topological_space (generalized_boolean_algebra pos)) : loc_path_connected_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_85615 (h0 : topological_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid num))) : totally_separated_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_85616 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (has_neg_part Type)) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_85617 (h0 : finset (pseudo_metric_space unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85618 (h1 : topological_space (has_lt string_imp)) (h2 : not (preorder (has_lt string_imp) -> false)) : @order_topology.{0} (has_lt.{0} string_imp) h1 (@classical.by_contradiction'.{1} (preorder.{0} (has_lt.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_85619 (h0 : topological_space (has_bot (has_bot (has_Inf real)))) : t0_space (has_bot (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_85620 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_85621 (h0 : fin has_zero.zero) : @regular_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_85622 (h0 : filter (group_with_zero (option (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_85623 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85624 (h0 : group (normed_group unsigned)) : group.fg (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_85625 (h0 : functor.add_const (add_group (semigroup Type)) pos) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_85626 (h0 : functor.add_const (semiring (boolean_algebra real)) name) : @is_noetherian_ring.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_85627 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_85628 (h0 : group (cancel_monoid num)) : is_simple_group (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_85629 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_85630 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_85631 (h0 : filter (has_Sup (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85632 (h0 : group (has_bot (has_Inf linarith.comp))) : is_simple_group (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_85633 (h0 : linear_ordered_field (boolean_algebra.core pos) -> linear_ordered_field (boolean_algebra.core pos) -> Prop) : is_symm (linear_ordered_field (boolean_algebra.core pos)) h0 := sorry --non-trivial
lemma new_lemma_85634 (h0 : topological_space (id (with_bot linarith.ineq))) : t0_space (id (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85635 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @t0_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_85636 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) num)  := sorry --non-trivial
lemma new_lemma_85637 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid pos)) pos) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_85638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85639 (h0 : complete_lattice (has_bot (has_neg name))) : complete_lattice.is_Sup_finite_compact (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_85640 (h0 : functor.add_const (complete_lattice (semigroup (mul_one_class linarith.comp))) Type) : @is_compactly_generated.{0} (semigroup.{0} (mul_one_class.{0} linarith.comp)) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} (mul_one_class.{0} linarith.comp))) Type h0)  := sorry --non-trivial
lemma new_lemma_85641 (h1 : ring (denumerable char)) (h2 : ring (subring (denumerable char))) : is_domain (subring (denumerable char)) := sorry --non-trivial
lemma new_lemma_85642 (h0 : ring (has_ssubset (random_gen (denumerable to_additive.value_type)))) : strong_rank_condition (has_ssubset (random_gen (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_85643 (h0 : add_monoid (has_star (semiring (semiring num)))) : add_monoid.fg (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_85644 (h0 : ordered_ring (non_assoc_semiring congr_arg_kind) -> ordered_ring (non_assoc_semiring congr_arg_kind) -> Prop) : is_trans (ordered_ring (non_assoc_semiring congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_85645 (h0 : topological_space (has_pos_part (finset real))) : locally_compact_space (has_pos_part (finset real)) := sorry --non-trivial
lemma new_lemma_85646 (h0 : not (topological_space (has_norm empty) -> false)) : @locally_compact_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_85647 (h0 : fin has_zero.zero) : @separated_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_85648 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85649 (h0 : topological_space (canonically_ordered_monoid congr_arg_kind)) : preirreducible_space (canonically_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85650 (h0 : functor.comp group cancel_monoid name) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_85651 (h1 : list (denumerable (with_one (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_85652 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85653 (h0 : topological_space (ring (semigroup Type))) : t0_space (ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_85654 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85655 (h2 : topological_space (has_add linarith.ineq)) : totally_disconnected_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_85656 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_85657 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_85658 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg pos)) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg.{0} pos) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_85659 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_85660 (h2 : complete_lattice (with_zero string_imp)) : is_compactly_generated (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_85661 (h0 : ring (has_zero (has_Inf (has_add (has_pos_part linarith.comp))))) : is_domain (has_zero (has_Inf (has_add (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_85662 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85663 (h0 : topological_space (has_dist unsigned)) : preirreducible_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_85664 (h0 : finset (has_neg_part (mul_zero_class unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85665 (h0 : functor.comp topological_space complete_distrib_lattice linarith.comp) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85666 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_85667 (h0 : complete_lattice (has_sub empty)) : is_compactly_generated (has_sub empty) := sorry --non-trivial
lemma new_lemma_85668 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_85669 (h0 : functor.add_const (complete_lattice (has_add ennreal)) (option ennreal)) : @is_compactly_generated.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_85670 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : locally_compact_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85671 (h0 : functor.add_const (ring (has_to_string name)) name) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85672 (h0 : complete_lattice (comm_group (finset pos))) : is_compactly_generated (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_85673 (h0 : topological_space (has_zero (has_to_string (has_neg environment.implicit_infer_kind)))) : path_connected_space (has_zero (has_to_string (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_85674 (h0 : topological_space (boolean_algebra.core unsigned)) : discrete_topology (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_85675 (h1 : ring (has_inv char)) : strong_rank_condition (has_inv char) := sorry --non-trivial
lemma new_lemma_85676 (h4 h5 : multiset (nondiscrete_normed_field enat)) : multiset.disjoint h4 h5 := sorry --non-trivial
lemma new_lemma_85677 (h0 : functor.add_const Prop (generalized_boolean_algebra (has_nndist Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85678 (h0 : Type) (h1 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (parser h0) (@function.extfun_app.{2 1} Type ring.{0} h1 (parser h0))  := sorry --non-trivial
lemma new_lemma_85679 (h0 : uniform_space (has_nnnorm std_gen)) : complete_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_85680 (h0 : ring (has_add (finset (finset pos)))) : is_domain (has_add (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_85681 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85682 (h0 : uniform_space (has_zero (option pos))) : complete_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_85683 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_85684 (h1 : has_lt (nondiscrete_normed_field (normed_field (normed_field linarith.ineq)))) : no_max_order (nondiscrete_normed_field (normed_field (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_85685 (h0 : uniform_space (has_add string_imp)) : complete_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_85686 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class (mul_one_class std_gen))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_85687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_85688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85689 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_85690 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_85691 (h0 : list (finset (boolean_algebra Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85692 (h0 : ring (div_inv_monoid string_imp)) : is_domain (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_85693 (h0 : ring (semigroup (has_add (has_add (add_comm_monoid (has_add Type)))))) : rank_condition (semigroup (has_add (has_add (add_comm_monoid (has_add Type))))) := sorry --non-trivial
lemma new_lemma_85694 (h0 : complete_lattice (semigroup (has_add (has_add name)))) : is_compactly_generated (semigroup (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_85695 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (preorder num)) := sorry --non-trivial
lemma new_lemma_85696 (h0 : not (ring (with_zero linarith.ineq) -> false)) : @strong_rank_condition.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_85697 (h0 : add_group (measurable_space (random_gen to_additive.value_type))) : is_add_cyclic (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_85698 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_85699 (h0 : functor.add_const Prop (boolean_algebra.core (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85700 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : topological_space.separable_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_85701 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @sequential_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_85702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85703 (h0 : ring (semigroup congr_arg_kind)) : rank_condition (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85704 (h1 : ring (random_gen (has_add fun_info))) : is_domain (random_gen (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_85705 (h0 : functor.add_const (topological_space (has_zero name)) name) : @loc_path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_85706 (h0 : functor.add_const (function.extfun (Type 1) ring) environment.implicit_infer_kind) : @rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_85707 (h0 : filter (has_union (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85708 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85709 (h0 : functor.add_const (group (comm_monoid empty)) empty) : @normalizer_condition.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_85710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_85711 (h0 : ring (boolean_algebra.core congr_arg_kind)) : rank_condition (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85712 (h0 : ring (finset (normed_comm_ring (normed_comm_ring linarith.comp)))) : is_domain (finset (normed_comm_ring (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_85713 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_Inf (ring Type))) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_Inf.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_85714 (h1 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_compactly_generated.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_85715 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_85716 (h0 : not (topological_space (normed_group empty) -> false)) : @irreducible_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_85717 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add Type)))) : regular_space (canonically_ordered_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_85718 (h0 h1 : multiset (mul_one_class ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_85719 (h0 : functor.add_const (semiring (has_zero Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85720 (h0 : topological_space (add_group (has_norm unsigned))) : discrete_topology (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_85721 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid Type)) : unique_factorization_monoid (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_85722 (h0 : has_lt (has_inter (normed_field (normed_field (normed_field char))))) : no_max_order (has_inter (normed_field (normed_field (normed_field char)))) := sorry --non-trivial
lemma new_lemma_85723 (h0 : filter (left_cancel_semigroup congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85724 (h0 : topological_space (boolean_algebra.core empty)) : locally_compact_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_85725 (h0 : function.extfun Type topological_space) : @normal_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_85726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_85727 (h0 : functor.add_const (group (ordered_comm_ring pos)) Type) : @is_simple_group.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_85728 (h0 : add_group (id (random_gen num))) : is_add_cyclic (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_85729 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85730 (h0 : ring (fintype (has_nnnorm fun_info))) : is_domain (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_85731 (h0 : fin has_zero.zero) : matrix.vec_empty (id (matrix.vec_empty (matrix.vec_empty (id (matrix.vec_empty h0))))) := sorry --non-trivial
lemma new_lemma_85732 (h0 : finset (as_linear_order empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85733 (h0 : function.extfun Type ring) : @is_domain.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_85734 (h0 : ring (nondiscrete_normed_field string.iterator_imp)) : strong_rank_condition (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_85735 (h0 : topological_space (normed_group (has_inv linarith.ineq))) : irreducible_space (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85736 (h0 : functor.add_const (list (has_neg linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85737 (h0 : functor.add_const (complete_lattice (plift num)) num) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_85738 (h0 : function.extfun Type ring) : @is_domain.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_85739 (h0 : semiring (ordered_comm_monoid (ring Type))) : is_noetherian_ring (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_85740 (h1 : complete_lattice (distrib char)) : complete_lattice.is_Sup_finite_compact (distrib char) := sorry --non-trivial
lemma new_lemma_85741 (h0 : not (prod (ordered_semiring unsigned) (ordered_semiring unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_85742 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring num)) unsigned) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85743 (h0 : complete_lattice (add_cancel_monoid ennreal)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_85744 (h0 : complete_lattice (omega_complete_partial_order congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85745 (h0 : complete_lattice (with_one to_additive.value_type)) : is_compactly_generated (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_85746 (h0 : topological_space (add_left_cancel_monoid linarith.ineq)) : totally_disconnected_space (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_85747 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_85748 (h0 : topological_space (finset (has_add (finset pos)))) : totally_separated_space (finset (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_85749 (h0 : group (linear_ordered_add_comm_group (has_top linarith.ineq))) : is_cyclic (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85750 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85751 (h0 : ordered_comm_monoid (has_nndist (mul_zero_class name))) : has_exists_mul_of_le (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_85752 (h0 : topological_space (complete_distrib_lattice unsigned)) : t1_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_85753 (h0 : topological_space (add_monoid fun_info)) : totally_disconnected_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_85754 (h0 : ring (has_top (add_group unsigned))) : is_domain (has_top (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_85755 (h2 : set (set ereal)) (h3 : set ereal) : measurable_space.dynkin_system.generate_has h2 h3 := sorry --non-trivial
lemma new_lemma_85756 (h0 : topological_space (measurable_space.dynkin_system empty)) : preirreducible_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_85757 (h3 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_85758 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : irreducible_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_85759 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : irreducible_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_85760 (h0 : functor.comp topological_space pseudo_metric_space name) : @t0_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_85761 (h0 : topological_space (has_ssubset (semi_normed_ring fun_info))) : t0_space (has_ssubset (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_85762 (h0 : finset (boolean_algebra.core (complete_distrib_lattice unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85763 (h0 : monoid (has_top (has_inv linarith.comp_source))) : monoid.fg (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85764 (h0 : functor.add_const (complete_lattice (has_add ennreal)) unsigned) : @is_atomistic.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85765 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85766 (h0 : topological_space (comm_group (ring (has_nndist environment.implicit_infer_kind)))) : sequential_space (comm_group (ring (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_85767 (h1 : ring (has_div reducibility_hints)) : strong_rank_condition (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_85768 (h0 : monoid (linear_ordered_add_comm_group linarith.ineq)) : monoid.fg (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_85769 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_85770 (h0 : topological_space (dlist (div_inv_monoid fun_info))) : path_connected_space (dlist (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_85771 (h0 : functor.add_const (add_monoid (comm_group ennreal)) (has_neg_part name)) : @add_monoid.fg.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} ennreal)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_85772 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : has_lt (quot h0)) : no_max_order (quot h0) := sorry --non-trivial
lemma new_lemma_85773 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_85774 (h1 : topological_space (random_gen (has_nnnorm (random_gen char)))) : t0_space (random_gen (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_85775 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85776 (h0 : group (has_top (with_bot string_imp))) : is_cyclic (has_top (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_85777 (h0 : topological_space (linear_ordered_semiring (has_norm linarith.comp))) : preirreducible_space (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_85778 (h0 : filter (boolean_algebra (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_85779 (h0 : functor.add_const (group (ring pos)) environment.implicit_infer_kind) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_85780 (h0 : add_group (has_compl (random_gen (random_gen char)))) : is_add_cyclic (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_85781 (h0 : topological_space (has_bot (sub_neg_monoid name))) : t0_space (has_bot (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_85782 (h0 : topological_space (bin_tree (semiring empty))) : t1_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_85783 (h0 : topological_space (has_Inf (has_bot (has_bot (has_bot (has_bot pos)))))) : totally_separated_space (has_Inf (has_bot (has_bot (has_bot (has_bot pos))))) := sorry --non-trivial
lemma new_lemma_85784 (h0 : ordered_add_comm_monoid (cancel_monoid (cancel_monoid (has_add Type)))) : archimedean (cancel_monoid (cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_85785 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @preirreducible_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85786 (h1 : ring (has_inv (random_gen string_imp))) : strong_rank_condition (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_85787 (h0 : list (boolean_algebra (finset (has_zero pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85788 (h0 : uniform_space (comm_monoid congr_arg_kind)) : separated_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85789 (h0 : group (mul_zero_class (finset pos))) : is_cyclic (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_85790 (h0 : group (complete_distrib_lattice (has_Inf (ring (has_add pos))))) : normalizer_condition (complete_distrib_lattice (has_Inf (ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_85791 (h0 : topological_space (pseudo_metric_space (option (mul_zero_class pos)))) : totally_separated_space (pseudo_metric_space (option (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_85792 (h0 : not (ring (has_add linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_85793 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @normal_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_85794 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_85795 (h0 : complete_lattice (has_zero (has_add (has_add (finset (finset linarith.comp)))))) : is_compactly_generated (has_zero (has_add (has_add (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_85796 (h0 : topological_space (add_cancel_monoid (has_neg_part Type))) : preirreducible_space (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_85797 (h0 h1 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @has_continuous_add.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0)) (@finset.pi.empty.{1 0} Type has_add.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_85798 (h0 : filter (denumerable (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85799 (h0 : functor.add_const (group (is_R_or_C empty)) empty) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_85800 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_85801 (h0 : complete_lattice (normed_comm_ring (comm_group name))) : is_atomistic (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_85802 (h0 : list (has_neg_part (finset ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85803 (h2 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85804 (h0 : fin has_zero.zero) : @t1_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_85805 (h0 : has_lt (nondiscrete_normed_field (mul_one_class (normed_field std_gen)))) : no_max_order (nondiscrete_normed_field (mul_one_class (normed_field std_gen))) := sorry --non-trivial
lemma new_lemma_85806 (h0 : functor.add_const (group (has_neg congr_arg_kind)) num) : @is_cyclic.{0} (has_neg.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_85807 (h0 : complete_lattice (has_zero (has_to_string unsigned))) : is_atomistic (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_85808 (h0 : filter (boolean_algebra.core (has_add (has_add pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_85809 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_neg name))) : unique_factorization_monoid (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_85810 (h0 : list (complete_distrib_lattice (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85811 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_85812 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_85813 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_85814 (h0 : topological_space (normed_linear_ordered_group (option unsigned))) : irreducible_space (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_85815 (h0 : topological_space (has_zero Type)) : preirreducible_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_85816 (h0 : linear_ordered_add_comm_group_with_top (option empty) -> congr_arg_kind -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_85817 (h0 : group (with_bot (random_gen string_imp))) : normalizer_condition (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_85818 (h0 : uniform_space (has_to_string (has_add (has_neg pos)))) : separated_space (has_to_string (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_85819 (h0 : topological_space (has_ssubset (has_nnnorm (has_ssubset (has_ssubset char))))) : path_connected_space (has_ssubset (has_nnnorm (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_85820 (h0 : uniform_space (complete_semilattice_Sup to_additive.value_type)) : complete_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_85821 (h1 : not (ring (has_append linarith.comp_source) -> false)) : @rank_condition.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_85822 (h0 : topological_space (has_add (has_to_string (has_to_string ennreal)))) : preconnected_space (has_add (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_85823 (h0 : add_group (has_add pos)) : is_add_cyclic (has_add pos) := sorry --non-trivial
lemma new_lemma_85824 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_85825 (h0 : ring (monoid_with_zero pos)) : is_principal_ideal_ring (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_85826 (h0 : prod (complete_linear_order num) (complete_linear_order num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_85827 (h0 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_85828 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_85829 (h2 : add_group (distrib fun_info)) : is_add_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_85830 (h0 : functor.add_const (ring (finset unsigned)) unsigned) : @is_principal_ideal_ring.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85831 (h0 : semiring (has_dist unsigned)) : is_noetherian_ring (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_85832 (h0 : std_gen -> std_gen -> Prop) (h1 : std_gen) (h2 : rbtree std_gen h0) : nonempty (rbtree.mem h1 h2) := sorry --non-trivial
lemma new_lemma_85833 (h0 : topological_space (group_with_zero (option (option ennreal)))) : topological_space.separable_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_85834 (h0 : functor.add_const (group (ordered_comm_ring pos)) linarith.comp) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85835 (h0 : ring (div_inv_monoid linarith.ineq)) : is_domain (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_85836 (h0 : ordered_add_comm_monoid (finset (option (option (option (option ennreal)))))) : archimedean (finset (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_85837 (h0 : ring (plift empty)) : rank_condition (plift empty) := sorry --non-trivial
lemma new_lemma_85838 (h0 : topological_space (ring (comm_group name))) : loc_path_connected_space (ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_85839 (h0 : topological_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) : path_connected_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_85840 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_85841 (h0 : topological_space (finset Type)) : totally_separated_space (finset Type) := sorry --non-trivial
lemma new_lemma_85842 (h0 : add_group (complete_distrib_lattice (option (option pos)))) : is_add_cyclic (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_85843 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_bot real)) := sorry --non-trivial
lemma new_lemma_85844 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @normal_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_85845 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85846 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_85847 (h0 : ordered_add_comm_monoid (has_nndist (comm_group (comm_group pos)))) : archimedean (has_nndist (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_85848 (h0 : topological_space (has_inv to_additive.value_type)) : t0_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_85849 (h1 : function.extfun (finset Type) (has_mem.mem (has_top to_additive.value_type))) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} to_additive.value_type)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_85850 (h0 : monoid (has_nndist (has_neg (has_neg (has_neg (has_neg Type)))))) : monoid.fg (has_nndist (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_85851 (h0 : ring (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_85852 (h0 : topological_space (ring (semigroup (has_neg (finset (finset (finset Type))))))) : topological_space.separable_space (ring (semigroup (has_neg (finset (finset (finset Type)))))) := sorry --non-trivial
lemma new_lemma_85853 (h0 : monoid (has_add (option ennreal))) : monoid.fg (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_85854 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_85855 (h0 : list (normed_comm_ring (has_neg_part pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85856 (h0 : topological_space (has_top (random_gen linarith.ineq))) : irreducible_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85857 (h0 : has_mem.mem (with_one (random_gen fun_info)) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} (random_gen.{0} fun_info)) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_85858 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_85859 (h1 : ring string_imp) : is_domain string_imp := sorry --non-trivial
lemma new_lemma_85860 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : locally_compact_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_85861 (h0 : topological_space (has_compl (comm_ring char))) : totally_disconnected_space (has_compl (comm_ring char)) := sorry --non-trivial
lemma new_lemma_85862 (h0 : topological_space (id (has_top fun_info))) : discrete_topology (id (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_85863 (h0 : ring (distrib (mul_one_class linarith.ineq))) : strong_rank_condition (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_85864 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_85865 (h0 : functor.comp list pseudo_metric_space (has_add pos)) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_85866 (h0 : topological_space (canonically_ordered_comm_semiring (finset ennreal))) : totally_disconnected_space (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_85867 (h0 : ring (has_neg_part (has_nndist ennreal))) : strong_rank_condition (has_neg_part (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_85868 (h0 : ring (ordered_comm_ring (ring Type))) : rank_condition (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_85869 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_85870 (h0 : ring (semigroup ennreal)) : strong_rank_condition (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_85871 (h0 : topological_space (canonically_ordered_add_monoid empty)) : totally_separated_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_85872 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_85873 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_85874 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_85875 (h0 : topological_space (complete_distrib_lattice (finset name))) : t1_space (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_85876 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_85877 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_85878 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_85879 (h0 : topological_space (encodable (has_nnnorm linarith.comp_source))) : t0_space (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_85880 (h0 : functor.add_const (function.extfun Type filter) (ring environment.implicit_infer_kind)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (finset name)) := sorry --non-trivial
lemma new_lemma_85881 (h0 : group (free_add_monoid congr_arg_kind)) : is_cyclic (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_85882 (h1 : set (semi_normed_ring linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_85883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85884 (h0 : ring (comm_group (finset (has_to_string pos)))) : strong_rank_condition (comm_group (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_85885 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add Type))) : has_exists_mul_of_le (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_85886 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85887 (h0 : topological_space (boolean_algebra.core (comm_group (semigroup unsigned)))) : irreducible_space (boolean_algebra.core (comm_group (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_85888 (h0 : topological_space (ring (has_nndist linarith.comp))) : topological_space.separable_space (ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_85889 (h0 : ring (has_add (has_neg linarith.comp))) : strong_rank_condition (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_85890 (h0 : functor.add_const (group (boolean_algebra.core name)) unsigned) : @group.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_85891 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85892 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) empty) : @is_atomistic.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_85893 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85894 (h0 : group (cancel_monoid empty)) : group.fg (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_85895 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space num))) : @rank_condition.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_85896 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) pos) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_85897 (h0 : not (list (add_right_cancel_monoid congr_arg_kind) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_85898 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} (normed_comm_ring.{0} name)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} (normed_comm_ring.{0} name)))  := sorry --non-trivial
lemma new_lemma_85899 (h0 : functor.add_const (filter (has_Inf name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85900 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_85901 (h0 : ring (ordered_comm_ring (ring Type))) : strong_rank_condition (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_85902 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_85903 (h0 : not (complete_lattice (simple_graph string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_85904 (h0 : add_monoid (has_to_string (has_to_string name))) : add_monoid.fg (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_85905 (h0 : not (topological_space (has_one unsigned) -> false)) : @path_connected_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_85906 (h1 : topological_space (has_nnnorm (has_inv (has_ssubset (has_nnnorm (has_inv string_imp)))))) : path_connected_space (has_nnnorm (has_inv (has_ssubset (has_nnnorm (has_inv string_imp))))) := sorry --non-trivial
lemma new_lemma_85907 (h0 : monoid (comm_group (has_nndist ennreal))) : monoid.fg (comm_group (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_85908 (h0 : topological_space (mul_zero_class (semiring (has_top (has_top empty))))) : irreducible_space (mul_zero_class (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_85909 (h0 : topological_space (boolean_algebra Type)) : discrete_topology (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_85910 (h0 : list (monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85911 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_85912 (h0 : complete_lattice (semi_normed_ring (semi_normed_ring reducibility_hints))) : is_compactly_generated (semi_normed_ring (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_85913 (h0 : functor.add_const Prop (has_top (semiring congr_arg_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_85914 (h0 : uniform_space (semiring num)) : complete_space (semiring num) := sorry --non-trivial
lemma new_lemma_85915 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85916 (h0 : semiring (canonically_ordered_comm_semiring (finset Type))) : is_noetherian_ring (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_85917 (h0 : group (id (semiring (linear_ordered_semiring empty)))) : group.fg (id (semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_85918 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85919 (h0 : functor.add_const (filter (has_add Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_85920 (h0 : group (add_comm_monoid (comm_semigroup Type))) : is_cyclic (add_comm_monoid (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_85921 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_85922 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (order_dual.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (order_dual.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85923 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : topological_space.separable_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_85924 (h0 : not (uniform_space (linear_ordered_semiring unsigned) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_85925 (h0 : fin has_zero.zero) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_85926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_85927 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup name)) := sorry --non-trivial
lemma new_lemma_85928 (h0 : functor.add_const (group (has_pos_part pos)) (has_nndist (ordered_ring (has_neg (has_add Type))))) : @group.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) (has_nndist.{1} (ordered_ring.{1} (has_neg.{1} (has_add.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_85929 (h0 : topological_space (has_neg_part ennreal)) : path_connected_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_85930 (h0 : topological_space (ring (option pos))) : loc_path_connected_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_85931 (h0 : functor.comp topological_space cancel_monoid unsigned) : @discrete_topology.{0} (cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_85932 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_85933 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (sub_neg_monoid (ordered_comm_monoid (has_neg Type))))) : archimedean (normed_lattice_add_comm_group (sub_neg_monoid (ordered_comm_monoid (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_85934 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85935 (h0 : functor.add_const (function.extfun Type monoid) (ring Type)) : @monoid.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) (ring.{1} Type) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85936 (h0 : set (has_nnnorm reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_85937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_85938 (h0 : topological_space (add_comm_monoid name)) : totally_disconnected_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_85939 (h2 : add_group (add_comm_semigroup ereal)) : is_add_cyclic (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_85940 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85941 (h0 : topological_space (has_union linarith.comp)) : preirreducible_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_85942 (h0 : topological_space (has_emptyc (has_inv fun_info))) : t0_space (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_85943 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_add (has_to_string unsigned))) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (has_add.{0} (has_to_string.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_85944 (h0 : list (add_cancel_monoid (finset (finset linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_85945 (h0 : topological_space (has_emptyc (has_top fun_info))) : totally_separated_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_85946 (h0 : not (filter (metric_space unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_85947 (h0 : topological_space (boolean_algebra.core (has_add (has_to_string Type)))) : t1_space (boolean_algebra.core (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_85948 (h0 : topological_space (option (semiring (semiring empty)))) : totally_separated_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85949 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : totally_disconnected_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_85950 (h0 : fin has_zero.zero) : @discrete_topology.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_85951 (h2 : add_group (mul_one_class fun_info)) : is_add_cyclic (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_85952 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_85953 (h0 : not (topological_space (has_top num) -> false)) : @preirreducible_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_85954 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @normalizer_condition.{0} unsigned (@finset.pi.empty.{1 0} Type group.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_85955 (h0 : ring (has_top (semiring (semiring empty)))) : is_domain (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_85956 (h0 : topological_space (has_add unsigned)) : path_connected_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_85957 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) (ring pos)) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_85958 (h0 : group (has_emptyc (has_top (has_inv fun_info)))) : normalizer_condition (has_emptyc (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_85959 (h0 : topological_space (boolean_algebra.core (finset Type))) : path_connected_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_85960 (h0 : add_group (semi_normed_ring (has_ssubset fun_info))) : is_add_cyclic (semi_normed_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_85961 (h0 : add_monoid (add_right_cancel_monoid (semiring unsigned))) : add_monoid.fg (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_85962 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85963 (h0 : list (normed_comm_ring (option (option (option (option (option (option (option (option ennreal)))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_85964 (h0 : group (id to_additive.value_type)) : group.fg (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_85965 (h0 : topological_space (semigroup (has_pos_part Type))) : topological_space.separable_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_85966 (h0 : function.extfun Type (functor.add_const (group ennreal))) : @is_cyclic.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} ennreal)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_85967 (h0 : add_monoid (linear_ordered_semiring (semiring linarith.comp))) : add_monoid.fg (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_85968 (h0 : topological_space (boolean_algebra (ring Type))) : loc_path_connected_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_85969 (h0 : topological_space (has_to_string (has_add Type))) : preconnected_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_85970 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : preconnected_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_85971 (h0 : complete_lattice (has_neg (has_pos_part pos))) : complete_lattice.is_Sup_finite_compact (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_85972 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_85973 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_85974 (h0 : uniform_space (id (has_inv fun_info))) : complete_space (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_85975 (h0 : topological_space (plift (semiring (has_top (has_top empty))))) : topological_space.separable_space (plift (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_85976 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_85977 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid name)) linarith.comp) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_85979 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_85980 (h0 : topological_space (finset (option unsigned))) : normal_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_85981 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_85982 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_ssubset.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_85983 (h0 : topological_space (monoid_with_zero (option ennreal))) : preconnected_space (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_85984 (h0 : topological_space (has_neg_part (complete_distrib_lattice name))) : topological_space.separable_space (has_neg_part (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_85985 (h0 : finset (add_cancel_monoid (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_85986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85987 (h0 : add_monoid (add_right_cancel_monoid (semiring empty))) : add_monoid.fg (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_85988 (h0 : function.extfun (nat -> Prop) subtype) : pnat.prime (function.extfun_app h0 (fun (n : nat), has_lt.lt has_zero.zero n)) := sorry --non-trivial
lemma new_lemma_85989 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_85990 (h0 : topological_space (pseudo_metric_space (option unsigned))) : normal_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_85991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_85992 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option (option pos))))) : complete_space (ordered_cancel_add_comm_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_85993 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_85994 (h0 : ordered_comm_monoid (ring (has_neg_part linarith.comp))) : has_exists_mul_of_le (ring (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_85995 (h0 : functor.add_const (ring (has_to_string Type)) (has_neg pos)) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_85996 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_85997 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_85998 (h0 : ring (has_top (has_norm empty))) : strong_rank_condition (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_85999 (h1 : topological_space (add_comm_semigroup std_gen)) : t0_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_86000 (h0 : functor.add_const (ordered_comm_monoid (pseudo_metric_space pos)) name) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (pseudo_metric_space.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_86001 (h0 : functor.add_const (topological_space znum) unsigned) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86002 (h0 : topological_space (has_neg ennreal)) : t0_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_86003 (h0 : functor.add_const (uniform_space (has_add Type)) linarith.comp) : @separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86004 (h0 : ring (with_one char)) : rank_condition (with_one char) := sorry --non-trivial
lemma new_lemma_86005 (h0 : functor.add_const (monoid (has_nndist linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86006 (h0 : group (generalized_boolean_algebra (ordered_ring pos))) : is_simple_group (generalized_boolean_algebra (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_86007 (h0 : functor.add_const (add_group znum) (option unsigned)) : @is_add_cyclic.{0} znum (@functor.add_const.run.{0 0} (add_group.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_86008 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_86009 (h0 : add_group (has_norm (random_gen (random_gen fun_info)))) : is_add_cyclic (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_86010 (h0 : not (topological_space (linear_ordered_add_comm_group_with_top reducibility_hints) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group_with_top.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group_with_top.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_86011 (h0 : topological_space (has_add (has_add (has_add Type)))) : irreducible_space (has_add (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_86012 (h0 : topological_space (comm_group (option (has_add pos)))) : preconnected_space (comm_group (option (has_add pos))) := sorry --non-trivial
lemma new_lemma_86013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_inf.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inf.{0} empty))  := sorry --non-trivial
lemma new_lemma_86014 (h0 : monoid (non_assoc_semiring unsigned)) : monoid.fg (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_86015 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) Type) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86016 (h0 : uniform_space congr_arg_kind) : separated_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_86017 (h0 : functor.add_const (topological_space (has_star unsigned)) congr_arg_kind) : @irreducible_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86019 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) linarith.comp) : @complete_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86020 (h0 : topological_space (linear_order empty)) : preirreducible_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_86021 (h3 : topological_space (has_ssubset (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (has_ssubset (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86022 (h0 : group (linear_ordered_comm_group (option unsigned))) : is_cyclic (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_86023 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86024 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86025 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) unsigned) : @loc_path_connected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86026 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type)))) : totally_disconnected_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_86027 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : preirreducible_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86028 (h0 : function.extfun Type group) : @is_simple_group.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type group.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_86029 (h0 : group (comm_ring (mul_one_class char))) : is_cyclic (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_86030 (h0 : topological_space (semiring (has_norm empty))) : totally_separated_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_86031 (h0 : functor.add_const (complete_lattice (semigroup name)) linarith.comp) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86032 (h0 : ring (has_add (has_repr pos))) : rank_condition (has_add (has_repr pos)) := sorry --non-trivial
lemma new_lemma_86033 (h0 : functor.add_const (topological_space (ring unsigned)) pos) : @normal_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_86034 (h0 : topological_space (add_comm_monoid (has_neg name))) : sequential_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_86035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_86036 (h1 : set (semi_normed_comm_ring string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_86037 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_86038 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_86039 (h0 : filter (sub_neg_monoid (has_pos_part (finset (has_pos_part linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86040 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86041 (h0 : add_group (has_norm (has_norm congr_arg_kind))) : is_add_cyclic (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86042 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_86043 (h1 : not (topological_space (normed_field linarith.comp_source) -> false)) : @path_connected_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_86044 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring name)) : @path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} name) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_86045 (h0 : list (generalized_boolean_algebra name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86046 (h1 : group (topological_space linarith.ineq)) : group.fg (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_86047 (h0 : topological_space (has_one (has_norm unsigned))) : irreducible_space (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_86048 (h2 : measurable_space linarith.ineq) (h3 : measure_theory.measure linarith.ineq) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_86049 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_86050 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_86051 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_86052 (h0 : topological_space (with_one (has_inv (has_inv (comm_ring fun_info))))) : irreducible_space (with_one (has_inv (has_inv (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_86053 (h0 : add_group (boolean_algebra (ring (has_neg linarith.comp)))) : is_add_cyclic (boolean_algebra (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_86054 (h0 : topological_space (semi_normed_ring enat)) : path_connected_space (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_86055 (h0 : functor.add_const (topological_space (has_zero name)) name) : @sequential_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_86056 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_86057 (h0 : functor.add_const (functor.add_const (functor.add_const Prop empty) (option (option empty))) empty) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_86058 (h0 : ordered_add_comm_monoid (comm_semigroup Type)) : archimedean (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_86059 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @locally_compact_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_86060 (h0 : set (has_lt string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_86061 (h0 : topological_space (add_cancel_monoid (option (option (option (option (option ennreal))))))) : totally_disconnected_space (add_cancel_monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_86062 (h0 : functor.add_const Prop (semiring num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86063 (h0 : topological_space (left_cancel_semigroup empty)) : t1_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_86064 (h0 : list (add_cancel_monoid (semigroup environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86065 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_86066 (h0 : topological_space (linear_ordered_semiring (has_norm linarith.comp))) : totally_disconnected_space (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_86067 (h0 : complete_lattice (add_comm_monoid linarith.comp)) : is_compactly_generated (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_86068 (h0 : functor.add_const (topological_space (semigroup name)) name) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_86069 (h0 : not (cancel_comm_monoid_with_zero (has_top num) -> false)) : @unique_factorization_monoid.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86070 (h0 : not (add_group (linear_ordered_semiring num) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86071 (h0 : not (add_group (distrib fun_info) -> false)) : @is_add_cyclic.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_86072 (h0 : group (encodable (comm_ring (random_gen linarith.ineq)))) : is_cyclic (encodable (comm_ring (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_86073 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) : t0_space (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_86074 (h0 : add_monoid (normed_group (semiring empty))) : add_monoid.fg (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_86075 (h0 : measurable_space (nondiscrete_normed_field (normed_field (normed_field (normed_field (normed_field std_gen)))))) (h1 : filter (nondiscrete_normed_field (normed_field (normed_field (normed_field (normed_field std_gen)))))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_86076 (h0 : complete_lattice (semiring (has_norm (has_top linarith.comp_source)))) : is_compactly_generated (semiring (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86077 (h0 : topological_space (has_to_string (boolean_algebra linarith.comp))) : totally_separated_space (has_to_string (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_86078 (h0 : ordered_comm_monoid (boolean_algebra.core unsigned)) : has_exists_mul_of_le (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_86079 (h0 : list (id (has_norm (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_86081 (h0 : uniform_space (normed_group (has_union linarith.comp))) : complete_space (normed_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_86082 (h1 : topological_space (nondiscrete_normed_field fun_info)) (h2 : set (nondiscrete_normed_field fun_info)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_86083 (h0 : not (topological_space (has_compl linarith.ineq) -> false)) : @t0_space.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_86084 (h0 : not (group (option congr_arg_kind) -> false)) : @group.fg.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86085 (h0 : semiring (cancel_monoid (option num))) : is_noetherian_ring (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_86086 (h0 : add_monoid (has_dist empty)) (h1 : has_dist empty) : is_add_unit h1 := sorry --non-trivial
lemma new_lemma_86087 (h0 : group (has_Inf pos)) : group.fg (has_Inf pos) := sorry --non-trivial
lemma new_lemma_86088 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_86089 (h0 : ring (bin_tree (option unsigned))) : rank_condition (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_86090 (h0 : functor.add_const (ring (has_neg_part pos)) linarith.comp) : @rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86091 (h0 : topological_space (cancel_monoid (has_add (has_add name)))) : totally_separated_space (cancel_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_86092 (h0 : topological_space (has_ssubset to_additive.value_type)) (h1 : add_group (has_ssubset to_additive.value_type)) : topological_add_group (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86093 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_86094 (h0 : topological_space (sub_neg_monoid (has_add pos))) : regular_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_86095 (h0 : functor.add_const (ordered_comm_monoid (has_neg unsigned)) name) : @has_exists_mul_of_le.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_86096 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86097 (h1 : set (ereal -> add_comm_semigroup fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_86098 (h0 : filter (finset (finset (finset (has_Inf environment.implicit_infer_kind))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86099 (h0 : monoid (comm_semigroup name)) : monoid.fg (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_86100 (h0 : uniform_space (has_edist (option empty))) : complete_space (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_86101 (h0 : functor.add_const (cancel_comm_monoid_with_zero (measurable_space.dynkin_system unsigned)) unsigned) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86102 (h0 : not (uniform_space (has_union linarith.comp) -> false)) : @complete_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_86103 (h0 : functor.add_const (group (free_add_monoid congr_arg_kind)) unsigned) : @group.fg.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86104 (h0 : ring (mul_one_class reducibility_hints)) : rank_condition (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_86105 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) (has_neg_part Type)) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_add.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_86106 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86107 (h0 : functor.comp topological_space has_neg_part pos) : @discrete_topology.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_86108 (h0 : functor.add_const (ring (free_add_monoid unsigned)) unsigned) : @strong_rank_condition.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86109 (h0 : group (id unsigned)) : group.fg (id unsigned) := sorry --non-trivial
lemma new_lemma_86110 (h0 : list (has_Inf (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86111 (h0 : group (add_monoid (has_nnnorm (has_nnnorm (comm_ring linarith.comp_source))))) : is_cyclic (add_monoid (has_nnnorm (has_nnnorm (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_86112 (h0 : group (linear_ordered_comm_ring congr_arg_kind)) : normalizer_condition (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86113 (h0 : topological_space (random_gen (has_top linarith.comp_source))) : path_connected_space (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86114 (h0 : filter (div_inv_monoid char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86115 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_86116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_86117 (h0 : complete_lattice (finset (has_pos_part (ring Type)))) : is_compactly_generated (finset (has_pos_part (ring Type))) := sorry --non-trivial
lemma new_lemma_86118 (h0 h1 : multiset (semi_normed_comm_ring linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_86119 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_86120 (h0 : ordered_comm_monoid (ordered_comm_monoid (finset name))) : has_exists_mul_of_le (ordered_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_86121 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86122 (h0 : functor.add_const (ring (bin_tree congr_arg_kind)) congr_arg_kind) : @is_principal_ideal_ring.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86123 (h0 : topological_space (has_le (has_ssubset reducibility_hints))) : path_connected_space (has_le (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_86124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86125 (h0 : uniform_space (distrib_lattice (has_nnnorm linarith.comp_source))) : complete_space (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86126 (h0 : list (normed_linear_ordered_group (semiring (semiring (semiring (semiring unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86127 (h0 : functor.add_const (finset (has_add Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86128 (h0 : topological_space (has_nnnorm fun_info)) : locally_compact_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_86129 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : t0_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_86130 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_86131 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid environment.implicit_infer_kind) pos) pos) : @archimedean.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} environment.implicit_infer_kind) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_86132 (h0 : ordered_add_comm_monoid (has_union unsigned)) : archimedean (has_union unsigned) := sorry --non-trivial
lemma new_lemma_86133 (h0 : topological_space (has_norm (has_nnnorm fun_info))) : path_connected_space (has_norm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_86134 (h0 : ring (has_nnnorm linarith.ineq)) : rank_condition (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_86135 (h0 : ring (add_comm_monoid (comm_group (comm_group (has_to_string linarith.comp))))) : rank_condition (add_comm_monoid (comm_group (comm_group (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_86136 (h0 : topological_space (has_to_string congr_arg_kind)) : path_connected_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86137 (h0 : topological_space (linear_ordered_comm_ring num)) : topological_space.separable_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_86138 (h0 : complete_lattice (ordered_cancel_add_comm_monoid num) -> Prop) (h1 : Exists (fun (x : complete_lattice (ordered_cancel_add_comm_monoid num)), h0 x)) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} num) (@classical.some.{1} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_86139 (h0 : not (ring (non_assoc_semiring unsigned) -> false)) : @is_domain.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86141 (h0 : functor.comp topological_space finset pos) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_86142 (h0 : topological_space (has_neg (option ennreal))) : topological_space.separable_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_86143 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @totally_disconnected_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_86144 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) num) : @t0_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_86145 (h0 : function.extfun Type group) : @group.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_86146 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_86147 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86148 (h0 : with_top Prop) (h1 : ne h0 has_top.top) : with_top.untop h0 h1 := sorry --non-trivial
lemma new_lemma_86149 (h0 : topological_space (has_bot (has_Inf (sub_neg_monoid (has_Inf real))))) : t1_space (has_bot (has_Inf (sub_neg_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_86150 (h0 : functor.add_const (topological_space (partial_order num)) congr_arg_kind) : @discrete_topology.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86151 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_86152 (h0 : group (comm_group pos)) : group.fg (comm_group pos) := sorry --non-trivial
lemma new_lemma_86153 (h0 : group (has_pos_part (finset (finset pos)))) : group.fg (has_pos_part (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_86154 (h0 : topological_space (has_top char)) : path_connected_space (has_top char) := sorry --non-trivial
lemma new_lemma_86155 (h0 : set (distrib (has_div string_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_86156 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) pos) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86157 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_86158 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_86159 (h1 : topological_space (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp))))))) : t0_space (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_86160 (h0 : topological_space (semi_normed_ring (mul_one_class char))) : path_connected_space (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_86161 (h0 : ring (has_ssubset (random_gen (random_gen linarith.comp_source)))) : rank_condition (has_ssubset (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86162 (h0 : not (add_group (uniform_space char) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_86163 (h0 : has_le (has_compl linarith.comp_source)) (h1 : bounded_order (has_compl linarith.comp_source)) : is_simple_order (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86164 (h2 : ereal -> ereal -> Prop) (h3 : set ereal) : zorn.chain h2 h3 := sorry --non-trivial
lemma new_lemma_86165 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_add_monoid (option empty))) : unique_factorization_monoid (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_86166 (h0 : topological_space (nondiscrete_normed_field (mul_one_class fun_info))) (h1 : set (nondiscrete_normed_field (mul_one_class fun_info))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_86167 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_86168 (h0 : group (div_inv_monoid linarith.ineq)) : is_cyclic (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_86169 (h0 : complete_lattice (metric_space (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (metric_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86170 (h0 : functor.add_const (functor.add_const Prop (has_Inf pos)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86171 (h1 h2 : multiset (normed_field ereal)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_86172 (h0 : functor.add_const (group (has_add Type)) linarith.comp) : @is_simple_group.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_86174 (h0 : finset (generalized_boolean_algebra (has_to_string (has_Inf linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86175 (h2 : std_gen -> std_gen -> Prop) : is_equiv std_gen h2 := sorry --non-trivial
lemma new_lemma_86176 (h0 : ring (has_top unsigned)) : rank_condition (has_top unsigned) := sorry --non-trivial
lemma new_lemma_86177 (h0 : group (semigroup (has_to_string Type))) : is_simple_group (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_86178 (h0 : group (normed_comm_ring (add_cancel_monoid (comm_group (add_comm_monoid unsigned))))) : normalizer_condition (normed_comm_ring (add_cancel_monoid (comm_group (add_comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_86179 (h1 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_86180 (h0 : add_monoid (complete_linear_order (semiring (semiring num)))) : add_monoid.fg (complete_linear_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_86181 (h0 : group (linear_ordered_add_comm_group char)) : group.fg (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_86182 (h0 : add_group (has_Sup empty)) : is_add_cyclic (has_Sup empty) := sorry --non-trivial
lemma new_lemma_86183 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) (add_comm_monoid (has_to_string Type))) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} unsigned)) (add_comm_monoid.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86184 (h0 : topological_space (has_bot (semiring (semiring (semiring unsigned))))) : loc_path_connected_space (has_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_86185 (h0 : ring (canonically_linear_ordered_monoid (ordered_comm_monoid (has_add name)))) : strong_rank_condition (canonically_linear_ordered_monoid (ordered_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_86186 (h0 : ring (group_with_zero congr_arg_kind)) : is_domain (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86187 (h0 : has_lt (has_nnnorm (has_nnnorm linarith.comp_source))) : no_max_order (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86188 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_86189 (h0 : functor.add_const (topological_space (semigroup unsigned)) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86190 (h0 : not (complete_lattice (add_right_cancel_monoid num) -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86191 (h0 : set string) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_86192 (h0 : finset (has_to_string (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86193 (h0 : not (list (linear_ordered_comm_ring empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_86194 (h0 : functor.add_const (group (semigroup congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86195 (h1 : topological_space environment.projection_info) : path_connected_space environment.projection_info := sorry --non-trivial
lemma new_lemma_86196 (h0 : uniform_space (semiring (semiring (has_norm (semiring (has_norm congr_arg_kind)))))) : separated_space (semiring (semiring (has_norm (semiring (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_86197 (h0 : set (set std_gen)) (h1 : std_gen) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_86198 (h0 : topological_space (has_dist num)) : totally_disconnected_space (has_dist num) := sorry --non-trivial
lemma new_lemma_86199 (h0 : ring (has_one (semiring (semiring empty)))) : strong_rank_condition (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_86200 (h0 : topological_space (semiring (has_top congr_arg_kind))) : totally_disconnected_space (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86201 (h0 : functor.add_const (complete_lattice (has_zero name)) (comm_group (has_to_string pos))) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) (comm_group.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_86202 (h0 : semiring (comm_group Type)) : is_noetherian_ring (comm_group Type) := sorry --non-trivial
lemma new_lemma_86203 (h0 : functor.add_const (topological_space (has_add name)) Type) : @preirreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86204 (h0 : add_group (metric_space (has_top unsigned))) : is_add_cyclic (metric_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_86205 (h1 : group (has_one congr_arg_kind)) : group.fg (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86206 (h0 : topological_space (boolean_algebra (boolean_algebra.core name))) : t1_space (boolean_algebra (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_86207 (h0 : filter (has_pos_part (has_pos_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86208 (h1 : not (topological_space (semi_normed_ring char) -> false)) : @t0_space.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_86209 (h0 : filter (linear_ordered_semiring (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86210 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : discrete_topology (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_86211 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_86212 (h1 : function.extfun Type monoid) : @monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type monoid.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_86213 (h0 : topological_space (normed_field (random_gen reducibility_hints))) : t0_space (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_86214 (h0 : group (mul_zero_class (mul_zero_class (pseudo_metric_space pos)))) : group.fg (mul_zero_class (mul_zero_class (pseudo_metric_space pos))) := sorry --non-trivial
lemma new_lemma_86215 (h0 : topological_space (comm_group (boolean_algebra.core environment.implicit_infer_kind))) : preirreducible_space (comm_group (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86216 (h0 : topological_space (has_nnnorm fun_info)) : path_connected_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_86217 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_86218 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86219 (h0 : functor.add_const (functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) empty) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_86220 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_86221 (h0 : ordered_add_comm_monoid (linear_ordered_comm_ring (semiring empty))) : archimedean (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_86222 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86223 (h0 : ring (fintype (has_nnnorm to_additive.value_type))) : is_domain (fintype (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86224 (h1 : ring (has_div linarith.comp_source)) : rank_condition (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86225 (h0 : group (semigroup (has_neg Type))) : group.fg (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_86226 (h0 : finset (normed_comm_ring (has_neg_part (has_neg_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86227 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_86228 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @loc_path_connected_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_86229 (h0 : functor.add_const (topological_space (finset Type)) pos) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_86230 (h0 : group empty) : is_cyclic empty := sorry --non-trivial
lemma new_lemma_86231 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86232 (h0 : uniform_space (add_comm_monoid empty)) : separated_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_86233 (h0 : not (ring (with_one num) -> false)) : @rank_condition.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86234 (h0 : not (topological_space (mul_one_class char) -> false)) : @totally_disconnected_space.{0} (mul_one_class.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_86235 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup empty)))) : @is_atomistic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_86236 (h0 : group (linear_ordered_field (has_to_string congr_arg_kind))) : group.fg (linear_ordered_field (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86237 (h0 : topological_space (random_gen string_imp)) (h1 : not (preorder (random_gen string_imp) -> false)) : @order_topology.{0} (random_gen.{0} string_imp) h0 (@classical.by_contradiction'.{1} (preorder.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_86238 (h0 : topological_space (group_with_zero (option (option (option ennreal))))) : t0_space (group_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_86239 (h0 : functor.add_const (filter (has_neg pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86240 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86241 (h0 : group (has_to_string (boolean_algebra.core unsigned))) : is_cyclic (has_to_string (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_86242 (h0 : topological_space (filter unsigned)) : irreducible_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_86243 (h0 : topological_space (ordered_ring empty)) : totally_separated_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_86244 (h0 : complete_lattice (has_to_string (comm_group unsigned))) : is_compactly_generated (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_86245 (h0 : topological_space (semiring congr_arg_kind)) : normal_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86247 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86248 (h0 : ring (topological_space (mul_one_class reducibility_hints))) : strong_rank_condition (topological_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_86249 (h0 : topological_space (has_bot (comm_semigroup real))) : t0_space (has_bot (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_86250 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86251 (h1 : ring (nondiscrete_normed_field enat)) : is_domain (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_86252 (h0 : ring (complete_distrib_lattice (finset pos))) : strong_rank_condition (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_86253 (h0 : topological_space (mul_zero_class linarith.comp)) : regular_space (mul_zero_class linarith.comp) := sorry --non-trivial
lemma new_lemma_86254 (h0 : ordered_comm_monoid (normed_comm_ring (has_add pos))) : has_exists_mul_of_le (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_86255 (h0 : preorder to_additive.value_type) (h1 : function.extfun to_additive.value_type (fun (x : to_additive.value_type), Prop)) : bdd_below (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_86256 (h0 : ring (has_zero unsigned)) : strong_rank_condition (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_86257 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero unsigned)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_86258 (h0 : has_mem.mem num has_emptyc.emptyc) : @normalizer_condition.{0} num (@finset.pi.empty.{1 0} Type group.{0} num h0)  := sorry --non-trivial
lemma new_lemma_86259 (h0 : topological_space (comm_monoid (semiring num))) : locally_compact_space (comm_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_86260 (h0 : filter (linear_ordered_semiring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86261 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_86262 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_86263 (h0 : uniform_space (complete_distrib_lattice congr_arg_kind)) : complete_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86264 (h0 : functor.add_const Prop (has_to_string (option (option pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86265 (h0 : topological_space (mul_zero_class (has_nndist ennreal))) : preconnected_space (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_86266 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_86267 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_86268 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg (has_neg name)))) : separated_space (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_86269 (h0 : functor.add_const (functor.add_const (finset Type) linarith.comp) Type) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_86270 (h0 : complete_lattice (semiring (random_gen linarith.comp))) : is_compactly_generated (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_86271 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_86272 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid name)) Type) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86273 (h0 : filter (plift linarith.comp)) (h1 : function.extfun (plift linarith.comp) (fun (x : plift linarith.comp), Prop)) : @filter.limsup.{0 1} Prop (plift.{1} linarith.comp) (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 (@function.extfun_app.{2 1} (plift.{1} linarith.comp) (λ (x : plift.{1} linarith.comp), Prop) h1)  := sorry --non-trivial
lemma new_lemma_86274 (h0 : ring (linear_ordered_comm_group_with_zero fun_info)) : strong_rank_condition (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_86275 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_86276 (h0 : not (function.extfun Type topological_space -> false)) (h1 : set (mul_zero_class num)) : @is_preconnected.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} num)) h1  := sorry --non-trivial
lemma new_lemma_86277 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @t0_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_86278 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} (has_norm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_86279 (h0 : add_monoid (has_bot (has_Inf Type))) : add_monoid.fg (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_86280 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) (measurable_space.dynkin_system unsigned)) : @irreducible_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) (measurable_space.dynkin_system.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_86281 (h0 : preorder (add_comm_semigroup (add_comm_semigroup fun_info))) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup (add_comm_semigroup fun_info)), h2)) := sorry --non-trivial
lemma new_lemma_86282 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_well_founded.{1} name) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_well_founded.{1} name))  := sorry --non-trivial
lemma new_lemma_86283 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_86284 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_86285 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_86286 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86287 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_86288 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_86289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_86290 (h0 : topological_space (boolean_algebra (has_add (finset linarith.comp)))) : t1_space (boolean_algebra (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_86291 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86292 (h0 : functor.add_const (uniform_space (has_zero Type)) pos) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_86293 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_86294 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @normalizer_condition.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_86295 (h0 : topological_space (has_pos_part (has_add pos))) : totally_separated_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_86296 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (finset Type)) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (finset.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_86297 (h0 : complete_lattice (simple_graph pos)) : is_compactly_generated (simple_graph pos) := sorry --non-trivial
lemma new_lemma_86298 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) (has_Inf linarith.comp)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_86299 (h0 : topological_space (metric_space (semiring unsigned))) : path_connected_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_86300 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86301 (h0 : list (has_to_string (has_neg_part (has_neg_part (has_add Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86302 (h0 : monoid (add_group (semiring unsigned))) : monoid.fg (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_86303 (h0 : ring (ring (has_neg name))) : strong_rank_condition (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_86304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_86305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_86306 (h0 : cancel_comm_monoid_with_zero (option (option ennreal))) : unique_factorization_monoid (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_86307 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_86308 (h0 : fin has_zero.zero) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86309 (h0 : ring (option congr_arg_kind)) : is_domain (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86310 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_ssubset reducibility_hints)))) : t0_space (semi_normed_comm_ring (has_nnnorm (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_86311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_86312 (h0 : complete_lattice (boolean_algebra (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_86313 (h0 : functor.add_const (topological_space znum) unsigned) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86314 (h0 : set (has_compl environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_86315 (h0 : group (measurable_space.dynkin_system (has_top empty))) : is_cyclic (measurable_space.dynkin_system (has_top empty)) := sorry --non-trivial
lemma new_lemma_86316 (h0 : list (comm_ring (has_nnnorm char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86317 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (semiring (semiring unsigned)))) : unique_factorization_monoid (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_86318 (h0 : uniform_space (boolean_algebra (has_neg (ring (finset (finset pos)))))) : complete_space (boolean_algebra (has_neg (ring (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_86319 (h0 : semiring (has_well_founded unsigned)) (h1 : has_well_founded unsigned) : odd h1 := sorry --non-trivial
lemma new_lemma_86320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_86321 (h0 : monoid (metric_space (has_norm (semiring num)))) : monoid.fg (metric_space (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_86322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) empty)  := sorry --non-trivial
lemma new_lemma_86323 (h0 : topological_space (normed_group (has_norm unsigned))) : locally_compact_space (normed_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_86324 (h0 : list (distrib_lattice (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86325 (h0 : topological_space (has_norm (has_one (semiring linarith.comp)))) : discrete_topology (has_norm (has_one (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_86326 (h0 : functor.add_const (functor.add_const (complete_lattice linarith.comp) linarith.comp) pos) : @is_compactly_generated.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_86327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_86328 (h0 : function.extfun Type measurable_space) (h1 : function.extfun Type has_div) : @has_measurable_div₂.{0} fun_info (@function.extfun_app.{2 1} Type measurable_space.{0} h0 fun_info) (@function.extfun_app.{2 1} Type has_div.{0} h1 fun_info)  := sorry --non-trivial
lemma new_lemma_86329 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_86330 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_equiv linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_86331 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) real) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_86332 (h0 : not (group (random_gen (random_gen (mul_one_class reducibility_hints))) -> false)) : @is_cyclic.{0} (random_gen.{0} (random_gen.{0} (mul_one_class.{0} reducibility_hints))) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} (random_gen.{0} (mul_one_class.{0} reducibility_hints)))) h0)  := sorry --non-trivial
lemma new_lemma_86333 (h0 : ring (mul_zero_class congr_arg_kind)) : is_domain (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86334 (h0 : functor.add_const (function.extfun (Type 1) semiring) name) : @is_noetherian_ring.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_86335 (h0 : not (functor.add_const Prop (semiring unsigned) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_86336 (h0 : topological_space (has_union empty)) : t0_space (has_union empty) := sorry --non-trivial
lemma new_lemma_86337 (h0 : functor.add_const (group (semiring unsigned)) empty) : @normalizer_condition.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_86338 (h0 : uniform_space (has_compl (mul_one_class (mul_one_class string_imp)))) : complete_space (has_compl (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_86339 (h0 : complete_lattice (semiring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_86340 (h0 : topological_space (random_gen (random_gen to_additive.value_type))) : path_connected_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86341 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86342 (h0 : functor.add_const (ring (has_nndist Type)) (has_add pos)) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86343 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @loc_path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86344 (h0 h1 : multiset (has_nnnorm linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_86345 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86346 (h0 : not (uniform_space (option congr_arg_kind) -> false)) : @complete_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86347 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : locally_compact_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86348 (h0 : ring (has_union (has_norm (has_norm linarith.comp)))) : rank_condition (has_union (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_86349 (h0 : functor.add_const (list (add_comm_monoid unsigned)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86350 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86351 (h0 : ring (boolean_algebra.core (semigroup (has_add Type)))) : rank_condition (boolean_algebra.core (semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_86352 (h0 : functor.add_const (ring (boolean_algebra.core name)) pos) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_86353 (h0 : topological_space fun_info) (h1 : preorder fun_info) : order_closed_topology fun_info := sorry --non-trivial
lemma new_lemma_86354 (h0 : complete_lattice (random_gen (has_norm unsigned))) : is_atomistic (random_gen (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_86355 (h0 : functor.add_const (function.extfun Type complete_lattice) (finset linarith.comp)) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (finset.{0} linarith.comp) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_86356 (h0 : functor.add_const (topological_space (has_zero pos)) ennreal) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_86357 (h0 : topological_space (has_inter congr_arg_kind)) : t1_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86358 (h0 : group (has_ssubset (random_gen linarith.comp_source))) : group.fg (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86360 (h0 : prod (add_group (semiring num)) (add_group (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_86361 (h0 : ring (add_cancel_comm_monoid (mul_one_class to_additive.value_type))) : strong_rank_condition (add_cancel_comm_monoid (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86362 (h0 : ordered_comm_monoid (ring (has_neg (finset linarith.comp)))) : has_exists_mul_of_le (ring (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_86363 (h0 : list (measurable_space.dynkin_system (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86364 (h0 : group (normed_group (random_gen string_imp))) : normalizer_condition (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_86365 (h0 : option (topological_space (add_comm_semigroup fun_info))) (h1 : topological_space (add_comm_semigroup fun_info)) : path_connected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_86366 (h0 : add_group (has_norm (has_top linarith.comp_source))) : is_add_cyclic (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86367 (h0 : finset (has_neg pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_86369 (h0 : ring (add_cancel_monoid (linear_ordered_comm_group ennreal))) : is_domain (add_cancel_monoid (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_86370 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @preconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86371 (h0 : fin has_zero.zero) : @t0_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_86372 (h0 : list (linear_ordered_comm_group (comm_monoid num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86373 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @t0_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_86374 (h0 : topological_space (semi_normed_comm_ring (has_inv linarith.ineq))) : totally_disconnected_space (semi_normed_comm_ring (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86375 (h0 : topological_space (dlist (denumerable (has_nnnorm string_imp)))) : t0_space (dlist (denumerable (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_86376 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_neg pos))) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (has_neg.{0} pos)) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_86377 (h0 : topological_space (complete_distrib_lattice (has_Inf real))) : discrete_topology (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_86378 (h0 : topological_space (non_assoc_semiring (option empty))) : totally_separated_space (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_86379 (h0 : group (add_semigroup (option (option empty)))) : is_cyclic (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_86380 (h0 : function.extfun Type (functor.comp uniform_space has_neg_part)) : @separated_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_86381 (h0 : topological_space (has_Inf (has_neg (has_Inf name)))) : locally_compact_space (has_Inf (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_86382 (h0 : topological_space (has_norm (semiring empty))) : discrete_topology (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_86383 (h0 : complete_lattice (cancel_monoid Type)) : complete_lattice.is_Sup_finite_compact (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_86384 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86385 (h0 : ring (canonically_linear_ordered_monoid (option ennreal))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_86386 (h0 : topological_space (ordered_comm_monoid Type)) : preconnected_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_86387 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86388 (h0 : monoid (normed_group (random_gen fun_info))) : monoid.fg (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_86389 (h0 : topological_space (generalized_boolean_algebra (has_Inf name))) : loc_path_connected_space (generalized_boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_86390 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_86391 (h0 : functor.add_const (complete_lattice (partial_order num)) empty) : @is_atomistic.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_86392 (h0 : topological_space (add_cancel_monoid (has_Inf name))) : sequential_space (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_86393 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) pos) : @is_simple_group.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86394 (h0 : uniform_space (has_add (has_neg (ring linarith.comp)))) : separated_space (has_add (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_86395 (h2 : set (ereal -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_86396 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_86397 (h0 : mul_one_class linarith.comp_source -> uniform_space (normed_field reducibility_hints)) : @complete_space.{0} (normed_field.{0} reducibility_hints) (@infi.{0 1} (uniform_space.{0} (normed_field.{0} reducibility_hints)) (@uniform_space.has_Inf.{0} (normed_field.{0} reducibility_hints)) (mul_one_class.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_86398 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86399 (h0 : topological_space (pseudo_metric_space num)) : discrete_topology (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_86400 (h0 : not (ring (random_gen linarith.ineq) -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_86401 (h0 : topological_space (ring (finset Type))) : locally_compact_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_86402 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part Type)) (has_neg pos)) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_pos_part.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86403 (h4 : not (topological_space (topological_space linarith.comp_source) -> false)) : @t0_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h4)  := sorry --non-trivial
lemma new_lemma_86404 (h0 : complete_lattice (ring (comm_group (comm_group Type)))) : is_compactly_generated (ring (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_86405 (h0 : fin has_zero.zero) : @separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86406 (h0 : uniform_space (ring (boolean_algebra Type))) : separated_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_86407 (h0 : prod (has_to_string (option ennreal)) (has_to_string (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_86408 (h2 : measurable_space char) (h3 : topological_space char) (h4 : measure_theory.measure char) : measure_theory.measure.outer_regular h4 := sorry --non-trivial
lemma new_lemma_86409 (h0 : ring (has_norm (has_top linarith.comp_source))) : strong_rank_condition (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86410 (h0 : uniform_space (canonically_ordered_monoid (has_add linarith.comp))) : separated_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_86411 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86412 (h0 : ring (random_gen (random_gen (random_gen fun_info)))) : strong_rank_condition (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_86413 (h0 : functor.add_const (topological_space (has_bot empty)) (semiring num)) : @path_connected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_86414 (h0 : topological_space (simple_graph (has_Inf pos))) : irreducible_space (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_86415 (h0 : add_group (bin_tree empty)) : is_add_cyclic (bin_tree empty) := sorry --non-trivial
lemma new_lemma_86416 (h0 : topological_space (has_compl (mul_one_class char))) : totally_disconnected_space (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_86417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_86418 (h0 : ring (semiring (semiring linarith.comp))) : rank_condition (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_86419 (h0 : add_group (random_gen (random_gen to_additive.value_type))) : is_add_cyclic (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86420 (h0 : topological_space (has_nndist (has_Inf real))) : preconnected_space (has_nndist (has_Inf real)) := sorry --non-trivial
lemma new_lemma_86421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86422 (h0 : not (multiset (semi_normed_ring (linear_ordered_add_comm_group_with_top string.iterator_imp)) -> false)) (h1 : multiset (semi_normed_ring (linear_ordered_add_comm_group_with_top string.iterator_imp))) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_86423 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_86424 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86425 (h0 : has_neg (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type))) (h1 : measurable_space (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type))) : has_measurable_neg (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86426 (h0 : group (add_cancel_monoid (has_to_string pos))) : normalizer_condition (add_cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_86427 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) (comm_group (comm_group Type))) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) (comm_group.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86428 (h0 : uniform_space (ring (canonically_ordered_comm_semiring linarith.comp))) : complete_space (ring (canonically_ordered_comm_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_86429 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_86430 (h1 : topological_space enat) (h2 : add_group enat) : topological_add_group enat := sorry --non-trivial
lemma new_lemma_86431 (h0 : add_monoid (canonically_ordered_monoid (has_neg pos))) : add_monoid.fg (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_86432 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_86433 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core pos))) : topological_space.separable_space (ordered_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_86434 (h0 : functor.add_const (uniform_space (has_zero Type)) linarith.comp) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86435 (h0 : topological_space (normed_group unsigned)) : totally_disconnected_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_86436 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @discrete_topology.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86437 (h0 : topological_space (has_norm (with_bot (has_top linarith.comp)))) : discrete_topology (has_norm (with_bot (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_86438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86439 (h0 : semiring (add_semigroup (option (option (option empty))))) : is_noetherian_ring (add_semigroup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_86440 (h0 : filter (has_top congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86441 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : loc_path_connected_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_86442 (h0 : functor.add_const (add_group (has_nndist pos)) (has_to_string unsigned)) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) (has_to_string.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_86443 (h1 : set (add_comm_semigroup linarith.ineq -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_86444 (h0 : group (with_bot (has_norm (random_gen to_additive.value_type)))) : is_cyclic (with_bot (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_86445 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero empty)) (option unsigned)) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_86446 (h0 : group (complete_semilattice_Sup (random_gen congr_arg_kind))) : is_cyclic (complete_semilattice_Sup (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86447 (h1 : topological_space ereal) : path_connected_space ereal := sorry --non-trivial
lemma new_lemma_86448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_86449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (option ennreal)) := sorry --non-trivial
lemma new_lemma_86450 (h0 : not (monoid (measurable_space.dynkin_system congr_arg_kind) -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86451 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @path_connected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_86452 (h1 : complete_lattice (rel linarith.comp_source (has_compl complex))) : is_compactly_generated (rel linarith.comp_source (has_compl complex)) := sorry --non-trivial
lemma new_lemma_86453 (h0 : not (topological_space (normed_field (has_ssubset reducibility_hints)) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} (has_ssubset.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (has_ssubset.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_86454 (h0 : add_group (id (has_norm fun_info))) : is_add_cyclic (id (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_86455 (h0 : complete_lattice (normed_comm_ring (ring Type))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_86456 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86457 (h0 : ring (has_to_string (add_comm_monoid environment.implicit_infer_kind))) : strong_rank_condition (has_to_string (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86458 (h0 : functor.add_const (semiring (complete_distrib_lattice real)) pos) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_86459 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_86460 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_86461 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class (has_nnnorm char)))) : path_connected_space (add_cancel_comm_monoid (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_86462 (h0 : ordered_add_comm_monoid (sub_neg_monoid (sub_neg_monoid Type))) : archimedean (sub_neg_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_86463 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_86464 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_86465 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86466 (h0 : not (ring (normed_group congr_arg_kind) -> false)) : @rank_condition.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86467 (h0 : ring (boolean_algebra.core (finset environment.implicit_infer_kind))) : is_principal_ideal_ring (boolean_algebra.core (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86468 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_86469 (h0 : has_mem.mem (complete_semilattice_Sup (has_emptyc linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} (has_emptyc.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_86470 (h0 : topological_space (boolean_algebra.core (has_zero congr_arg_kind))) : preconnected_space (boolean_algebra.core (has_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86471 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_86472 (h0 : group (has_one empty)) : normalizer_condition (has_one empty) := sorry --non-trivial
lemma new_lemma_86473 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86474 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm fun_info))) : t0_space (add_cancel_comm_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_86475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg_part.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0})) (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_86476 (h0 : group (has_to_string (has_to_string unsigned))) : normalizer_condition (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_86477 (h0 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class to_additive.value_type)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_86478 (h0 : complete_lattice (has_inv (has_inv linarith.comp_source))) : is_compactly_generated (has_inv (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86479 (h5 : topological_space (simple_graph environment.projection_info)) (h6 : set (simple_graph environment.projection_info)) : is_path_connected h6 := sorry --non-trivial
lemma new_lemma_86480 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : t0_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86481 (h0 : functor.add_const (ordered_add_comm_monoid (has_inter unsigned)) empty) : @archimedean.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_inter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_86482 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class unsigned)) unsigned) : @unique_factorization_monoid.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86483 (h0 : group (with_one (has_norm (has_norm (has_norm empty))))) : is_cyclic (with_one (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_86484 (h0 : functor.add_const (group znum) (option num)) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_86485 (h0 : functor.add_const (functor.add_const Prop Type) (has_add name)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86486 (h0 : topological_space (measurable_space.dynkin_system (add_group (add_group linarith.comp)))) : discrete_topology (measurable_space.dynkin_system (add_group (add_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_86487 (h0 : topological_space (normed_group (random_gen string_imp))) : path_connected_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_86488 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_86489 (h0 : topological_space (has_pos_part (ring Type))) : t0_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_86490 (h0 : functor.add_const (add_group (has_inner unsigned num)) empty) : @is_add_cyclic.{0} (has_inner.{0 0} unsigned num) (@functor.add_const.run.{0 0} (add_group.{0} (has_inner.{0 0} unsigned num)) empty h0)  := sorry --non-trivial
lemma new_lemma_86491 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : t1_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_86492 (h0 : add_monoid (simple_graph (ordered_comm_ring Type))) : add_monoid.fg (simple_graph (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_86493 (h1 : has_nnnorm linarith.ineq -> has_nnnorm linarith.ineq -> Prop) : is_strict_order (has_nnnorm linarith.ineq) h1 := sorry --non-trivial
lemma new_lemma_86494 (h0 : prod (has_inner empty unsigned) (has_inner empty unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_86495 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_86496 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_86497 (h0 : functor.add_const (semiring (finset linarith.comp)) (has_pos_part linarith.comp)) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_86498 (h0 : group (has_Inf (sub_neg_monoid (has_add (has_Inf Type))))) : normalizer_condition (has_Inf (sub_neg_monoid (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_86499 (h0 : uniform_space (has_Inf (ring Type))) : separated_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_86500 (h0 : ring (has_star (semiring congr_arg_kind))) : is_principal_ideal_ring (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_86502 (h0 : complete_lattice (boolean_algebra (sub_neg_monoid real))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_86503 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_86504 (h0 : topological_space (complete_distrib_lattice (ring (ring environment.implicit_infer_kind)))) : preconnected_space (complete_distrib_lattice (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_86505 (h0 : add_monoid (monoid (option (option (option (option num)))))) : add_monoid.fg (monoid (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_86506 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_86508 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_86509 (h0 : topological_space (metric_space (comm_ring (metric_space reducibility_hints)))) : totally_disconnected_space (metric_space (comm_ring (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_86510 (h0 : complete_lattice (has_nndist (has_add ennreal))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_86511 (h0 : finset (cancel_monoid (ring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86512 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86513 (h0 : list (complete_distrib_lattice (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86514 (h0 : group (cancel_monoid (has_add (has_add name)))) : group.fg (cancel_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_86515 (h1 : topological_space (semiring (has_norm (has_norm (has_norm fun_info))))) : path_connected_space (semiring (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_86516 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86517 (h0 : topological_space (has_pos_part (has_pos_part pos))) : path_connected_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_86518 (h1 : ring (measurable_space string_imp)) : is_domain (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_86519 (h0 : add_group (has_norm unsigned)) : is_add_cyclic (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_86520 (h0 : comm_semiring (denumerable (has_nnnorm fun_info))) (h1 : not (ideal (denumerable (has_nnnorm fun_info)) -> false)) : ideal.is_primary (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_86521 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_86522 (h0 : topological_space (mul_zero_class name)) : t1_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_86523 (h0 : uniform_space (has_append (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : complete_space (has_append (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_86524 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_86525 (h0 : complete_lattice (has_nnnorm std_gen)) : is_compactly_generated (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_86526 (h0 : ring (ring (option ennreal)) -> ring (ring (option ennreal)) -> Prop) : is_symm (ring (ring (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_86527 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86528 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @complete_lattice.is_Sup_finite_compact.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_86529 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86530 (h0 : ring (has_neg_part ennreal)) : is_domain (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_86531 (h0 : function.extfun Type ring) : @rank_condition.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_86532 (h0 : functor.add_const (list (ordered_comm_ring pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86533 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86534 (h0 : reducibility_hints -> reducibility_hints -> Prop) (h1 : topological_space (quot h0)) : t0_space (quot h0) := sorry --non-trivial
lemma new_lemma_86535 (h0 : complete_lattice (has_Inf (has_add pos))) : is_compactly_generated (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_86536 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86537 (h0 : uniform_space (uniform_space linarith.comp_source)) : complete_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86538 (h0 : topological_space (has_zero (has_zero (finset (ring (has_add pos)))))) : t0_space (has_zero (has_zero (finset (ring (has_add pos))))) := sorry --non-trivial
lemma new_lemma_86539 (h3 : topological_space (mul_one_class linarith.ineq)) (h4 : add_group (mul_one_class linarith.ineq)) : topological_add_group (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_86540 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_86541 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86542 (h0 : filter (id (pseudo_emetric_space (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86543 (h0 : topological_space (has_emptyc linarith.comp_source)) : totally_disconnected_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86544 (h0 : finset (has_inter (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86545 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset Type)) : @normal_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} Type) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_86546 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring congr_arg_kind))) : unique_factorization_monoid (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86547 (h0 : topological_space (normed_group (has_top (has_ssubset linarith.ineq)))) : totally_disconnected_space (normed_group (has_top (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_86548 (h0 : cancel_comm_monoid_with_zero (is_R_or_C (semiring (semiring (semiring empty))))) : unique_factorization_monoid (is_R_or_C (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_86549 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86550 (h0 h1 : multiset (fintype string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_86551 (h0 : group (with_bot (has_top (has_top to_additive.value_type)))) : is_cyclic (with_bot (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_86552 (h0 : topological_space (semigroup (option (option (option (option (option (option empty)))))))) : preirreducible_space (semigroup (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_86553 (h0 : functor.add_const (filter (has_neg linarith.comp)) (has_zero linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86554 (h0 : topological_space (has_norm (has_top linarith.comp_source))) : irreducible_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86555 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg pos)))) : t0_space (sub_neg_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_86556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86557 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_86558 (h0 : group (topological_space (mul_one_class (mul_one_class fun_info)))) : is_cyclic (topological_space (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_86559 (h0 : complete_lattice (generalized_boolean_algebra real)) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_86560 (h0 : topological_space (ring ennreal)) : totally_disconnected_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_86561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} pos (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_86562 (h0 : functor.add_const (ordered_add_comm_monoid (has_add Type)) linarith.comp) : @archimedean.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86563 (h0 : topological_space (has_norm to_additive.value_type)) : totally_separated_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86564 (h0 : topological_space (dlist (denumerable linarith.ineq))) : path_connected_space (dlist (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86565 (h0 : topological_space (semigroup (has_pos_part (has_pos_part (has_pos_part (finset linarith.comp)))))) : regular_space (semigroup (has_pos_part (has_pos_part (has_pos_part (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_86566 (h0 : not (ring (preorder congr_arg_kind) -> false)) : @strong_rank_condition.{0} (preorder.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (preorder.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86567 (h0 : semiring fun_info) (h1 : fun_info) : odd h1 := sorry --non-trivial
lemma new_lemma_86568 (h0 : add_group (filter (option empty))) : is_add_cyclic (filter (option empty)) := sorry --non-trivial
lemma new_lemma_86569 (h4 : topological_space (nondiscrete_normed_field enat)) (h5 : set (nondiscrete_normed_field enat)) : is_path_connected h5 := sorry --non-trivial
lemma new_lemma_86570 (h0 : topological_space (semigroup (finset linarith.comp))) : normal_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_86571 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86572 (h0 : functor.add_const (uniform_space (preorder num)) congr_arg_kind) : @separated_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86573 (h0 : topological_space (ordered_comm_ring (has_neg (has_Inf (has_add (has_neg pos)))))) : loc_path_connected_space (ordered_comm_ring (has_neg (has_Inf (has_add (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_86574 (h0 : complete_lattice (has_compl fun_info)) : complete_lattice.is_Sup_finite_compact (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_86575 (h1 : complete_lattice empty) : complete_lattice.is_Sup_finite_compact empty := sorry --non-trivial
lemma new_lemma_86576 (h0 : uniform_space (with_one (id linarith.comp))) : complete_space (with_one (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_86577 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) (h1 : add_group (linear_ordered_comm_group_with_zero linarith.comp_source)) : topological_add_group (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86578 (h0 : topological_space (has_zero (has_add unsigned))) : t1_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_86579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_86580 (h0 : ring (encodable (has_nnnorm linarith.ineq))) : strong_rank_condition (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86581 (h0 : set (simple_graph reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_86582 (h0 : filter (comm_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86583 (h0 : functor.add_const (monoid (cancel_monoid Type)) linarith.comp) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86584 (h0 : functor.add_const (list (has_zero name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86585 (h0 : group (with_one (has_norm (has_norm (semiring (semiring num)))))) : normalizer_condition (with_one (has_norm (has_norm (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_86586 (h0 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_86587 (h0 : list (has_to_string (has_add (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86588 (h0 : ring (has_to_string (has_add (ring linarith.comp)))) : rank_condition (has_to_string (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_86589 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86590 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) name) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_86591 (h0 : complete_lattice (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86592 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @totally_separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86593 (h0 : filter (has_norm linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86594 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_86595 (h0 : group (ring (ring Type))) : normalizer_condition (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_86596 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_86597 (h1 : function.extfun Type ring) : @is_domain.{0} char (@function.extfun_app.{2 1} Type ring.{0} h1 char)  := sorry --non-trivial
lemma new_lemma_86598 (h0 : topological_space (has_to_string (option pos))) : t0_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_86599 (h0 : filter (has_to_string (add_left_cancel_monoid (ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86600 (h0 : complete_lattice (simple_graph (has_neg Type))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_86601 (h0 : functor.add_const (topological_space (has_pos_part Type)) (has_to_string pos)) : @t0_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86602 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_86603 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_86604 (h1 : preorder (nondiscrete_normed_field linarith.ineq)) (h2 : set (nondiscrete_normed_field linarith.ineq)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_86605 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86606 (h1 : topological_space (has_nnnorm (normed_field reducibility_hints))) : totally_disconnected_space (has_nnnorm (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_86607 (h0 : ring (monoid congr_arg_kind)) : is_principal_ideal_ring (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86608 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86609 (h0 : topological_space (has_nnnorm std_gen)) (h1 : preorder (has_nnnorm std_gen)) : order_closed_topology (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_86610 (h0 : add_monoid (linear_ordered_comm_monoid_with_zero (option unsigned))) : add_monoid.fg (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_86611 (h0 : not (topological_space (distrib (comm_ring (comm_ring (has_nnnorm (comm_ring linarith.ineq))))) -> false)) : @totally_disconnected_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.ineq))))) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.ineq)))))) h0)  := sorry --non-trivial
lemma new_lemma_86612 (h1 : complete_lattice (measurable_space congr_arg_kind)) : is_compactly_generated (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86613 (h0 : ring (id num)) : is_domain (id num) := sorry --non-trivial
lemma new_lemma_86614 (h0 : add_group (uniform_space (comm_ring linarith.comp_source))) : is_add_cyclic (uniform_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86615 (h0 : functor.add_const (uniform_space (option empty)) (semiring (semiring (semiring empty)))) : @separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_86616 (h0 : group (has_top (with_bot string_imp))) : normalizer_condition (has_top (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_86617 (h0 : fin has_zero.zero) : @separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_86618 (h0 : empty -> empty -> empty) : is_associative empty h0 := sorry --non-trivial
lemma new_lemma_86619 (h0 : has_to_string (has_zero congr_arg_kind) -> has_to_string (has_zero congr_arg_kind) -> Prop) : is_symm (has_to_string (has_zero congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_86620 (h0 : ring (measurable_space (has_norm (semiring linarith.comp)))) : rank_condition (measurable_space (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_86621 (h0 : ring (has_add (has_inv linarith.ineq))) : is_domain (has_add (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86622 (h0 : ring (measurable_space.dynkin_system num)) : rank_condition (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_86623 (h0 : not (group (denumerable char) -> false)) : @group.fg.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_86624 (h0 : topological_space (has_zero (has_to_string linarith.comp))) : t1_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_86625 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86626 (h1 : not (group (has_ssubset string.iterator_imp) -> false)) : @is_cyclic.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_86627 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_86628 (h0 : functor.add_const (function.extfun Type filter) empty) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) name) := sorry --non-trivial
lemma new_lemma_86629 (h0 : topological_space (linear_ordered_field (option name))) : path_connected_space (linear_ordered_field (option name)) := sorry --non-trivial
lemma new_lemma_86630 (h0 : cancel_comm_monoid_with_zero (mul_zero_class ennreal)) : unique_factorization_monoid (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_86631 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_86632 (h0 : topological_space (has_Inf (has_add linarith.comp))) : locally_compact_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_86633 (h1 : uniform_space (dlist fun_info)) : complete_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_86634 (h0 : functor.comp topological_space linear_ordered_field (finset pos)) : @totally_disconnected_space.{0} (linear_ordered_field.{0} (finset.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86635 (h0 : ring (omega_complete_partial_order empty)) : is_domain (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_86636 (h0 : topological_space (has_Inf (has_neg Type))) : totally_separated_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_86637 (h0 : topological_space (comm_group (has_add Type))) : sequential_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_86638 (h0 : functor.add_const (semiring (semigroup Type)) name) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_86639 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_86640 (h0 : functor.add_const (complete_lattice (has_neg_part name)) unsigned) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_86641 (h1 : uniform_space (comm_ring fun_info)) : complete_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_86642 (h0 : finset (ordered_comm_group congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86643 (h0 : functor.add_const (ring (semigroup linarith.comp)) Type) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86644 (h2 : has_lt enat) : no_max_order enat := sorry --non-trivial
lemma new_lemma_86645 (h0 : group (normed_comm_ring linarith.comp)) : normalizer_condition (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_86646 (h0 : not (topological_space (metric_space unsigned) -> false)) : @preirreducible_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86647 (h0 : functor.add_const (topological_space Type) (normed_comm_ring pos)) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86648 (h0 : complete_lattice (normed_group (has_ssubset (random_gen fun_info)))) : is_compactly_generated (normed_group (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_86649 (h0 : ring (option (option (option unsigned)))) : is_domain (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_86650 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_86651 (h0 : semiring (has_Inf (has_add (has_add name)))) : is_noetherian_ring (has_Inf (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_86652 (h0 : functor.add_const (ring (has_zero pos)) (finset environment.implicit_infer_kind)) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_86653 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring empty)))) : t1_space (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_86654 (h0 : ring (ordered_comm_semiring (denumerable linarith.comp_source))) : rank_condition (ordered_comm_semiring (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86655 (h0 : not (ring (simple_graph (mul_one_class string_imp)) -> false)) : @rank_condition.{0} (simple_graph.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_86656 (h1 : topological_space (metric_space linarith.comp)) : totally_separated_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_86657 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) ennreal) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_86658 (h0 : topological_space (has_dist (comm_monoid unsigned))) : path_connected_space (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_86659 (h0 : ring (add_comm_monoid (add_comm_monoid ennreal))) : strong_rank_condition (add_comm_monoid (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_86660 (h0 : topological_space (has_norm (has_norm (semiring num)))) : t0_space (has_norm (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_86661 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @normal_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_86662 (h0 : ordered_comm_monoid (has_Inf (has_add (has_add (has_add (has_add pos)))))) : has_exists_mul_of_le (has_Inf (has_add (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_86663 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @sequential_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86664 (h0 : monoid (measurable_space.dynkin_system unsigned)) : monoid.fg (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_86665 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_86666 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_total_preorder linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_86667 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_86668 (h1 : uniform_space (distrib (comm_ring (comm_ring (comm_ring linarith.comp_source))))) : complete_space (distrib (comm_ring (comm_ring (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_86669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86670 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_86671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_86672 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : totally_disconnected_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86673 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_86674 (h0 : functor.comp topological_space mul_zero_class Type) : @path_connected_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_86675 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_86676 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_86677 (h0 : not (ring (has_compl (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) -> false)) : @rank_condition.{0} (has_compl.{0} (has_ssubset.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (has_ssubset.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_86678 (h1 : topological_space (semiring (has_emptyc to_additive.value_type))) : totally_separated_space (semiring (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86679 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86680 (h0 : filter (encodable (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86681 (h0 : complete_lattice (denumerable fun_info)) : is_compactly_generated (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_86682 (h0 : functor.add_const (ordered_comm_monoid (has_to_string name)) name) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_86683 (h0 : complete_lattice (normed_group (has_top (has_top linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86684 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_86685 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_86686 (h0 : complete_lattice (id linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_86688 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @group.fg.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_86689 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_Inf linarith.comp)) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_86690 (h0 : functor.add_const (topological_space (simple_graph Type)) linarith.comp) : @totally_separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86691 (h0 : char -> char -> Prop) : is_total_preorder char h0 := sorry --non-trivial
lemma new_lemma_86692 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (finset Type))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_86693 (h1 : topological_space (semi_normed_comm_ring string_imp)) : path_connected_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_86694 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_86695 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86696 (h2 : topological_space (add_comm_semigroup fun_info)) : path_connected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_86697 (h0 : monoid (linear_ordered_add_comm_group (with_bot (random_gen to_additive.value_type)))) : monoid.fg (linear_ordered_add_comm_group (with_bot (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_86698 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_86699 (h0 : topological_space (id string_imp)) (h1 : option (topological_space (id string_imp))) : t0_space (id string_imp) := sorry --non-trivial
lemma new_lemma_86700 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra name)) Type) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86701 (h0 : topological_space (finset (finset name))) : irreducible_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_86702 (h0 : group (has_to_string (option unsigned))) : is_cyclic (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_86703 (h0 : fin has_zero.zero) (h1 : pnat) : pnat.coprime (matrix.vec_empty (id h0)) h1 := sorry --non-trivial
lemma new_lemma_86704 (h0 : ordered_add_comm_monoid (has_zero num)) : archimedean (has_zero num) := sorry --non-trivial
lemma new_lemma_86705 (h0 : not (topological_space (with_bot num) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86706 (h0 : complete_lattice (measure_theory.measure_space congr_arg_kind)) : is_compactly_generated (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86707 (h0 : topological_space std_gen) : totally_disconnected_space std_gen := sorry --non-trivial
lemma new_lemma_86708 (h0 : topological_space (normed_group (denumerable (denumerable string_imp)))) : path_connected_space (normed_group (denumerable (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_86709 (h0 : topological_space (add_cancel_monoid (ring (has_neg Type)))) : regular_space (add_cancel_monoid (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_86710 (h0 : with_bot fun_info -> string_imp -> string_imp) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_86711 (h0 : complete_lattice (normed_group num)) : complete_lattice.is_Sup_finite_compact (normed_group num) := sorry --non-trivial
lemma new_lemma_86712 (h0 : topological_space (has_Inf (has_add (has_add (finset linarith.comp))))) : path_connected_space (has_Inf (has_add (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_86713 (h1 : not (add_group (semi_normed_comm_ring string_imp) -> false)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_86714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_86715 (h0 : functor.add_const (add_monoid (has_nndist environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86716 (h0 : complete_lattice (boolean_algebra.core num)) : is_atomistic (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_86717 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86718 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) pos) : @is_compactly_generated.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_86719 (h0 : functor.add_const (list (has_dist ennreal)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86720 (h0 : set (char -> mul_one_class char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_86721 (h0 : has_lt fun_info) : no_max_order fun_info := sorry --non-trivial
lemma new_lemma_86722 (h0 : functor.add_const Prop (has_add name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86723 (h0 : functor.comp list has_neg (has_add unsigned)) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_86724 (h0 : group (has_inv (random_gen (has_nnnorm linarith.comp_source)))) : group.fg (has_inv (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_86725 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) Type) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86726 (h0 : cancel_comm_monoid_with_zero (has_inter unsigned)) : unique_factorization_monoid (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_86727 (h0 : semigroup (option pos) -> semigroup (option pos) -> Prop) : is_symm (semigroup (option pos)) h0 := sorry --non-trivial
lemma new_lemma_86728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86729 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_86730 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_86731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_86732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86733 (h0 : list (comm_ring (random_gen (has_ssubset (div_inv_monoid string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86734 (h0 : not (complete_lattice (complete_semilattice_Sup unsigned) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86735 (h1 : complete_lattice (random_gen (has_nnnorm string_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_86736 (h0 : group (ordered_comm_ring (sub_neg_monoid real))) : is_simple_group (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_86737 (h0 : semiring (ordered_comm_ring (has_add (has_add linarith.comp)))) : is_noetherian_ring (ordered_comm_ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_86738 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_86739 (h0 : unsigned -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_86740 (h0 : group (has_emptyc linarith.comp_source)) : normalizer_condition (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86741 (h0 : group (add_comm_monoid (comm_group (comm_group Type)))) : is_simple_group (add_comm_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_86742 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86743 (h0 : topological_space (sub_neg_monoid name)) : loc_path_connected_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_86744 (h0 : topological_space (with_bot (semiring num))) : totally_separated_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_86745 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_86746 (h0 : monoid (add_comm_monoid (finset ennreal))) : monoid.fg (add_comm_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_86747 (h2 : topological_space (random_gen char)) : t0_space (random_gen char) := sorry --non-trivial
lemma new_lemma_86748 (h0 : topological_space (cancel_monoid (has_to_string (has_to_string (has_to_string num))))) : totally_disconnected_space (cancel_monoid (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_86749 (h2 : group (semi_normed_ring to_additive.value_type)) : is_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86750 (h0 : functor.add_const (group (has_neg_part name)) Type) : @group.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_86751 (h1 : ring (has_append char)) : rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_86752 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_86753 (h0 : functor.add_const (finset (has_to_string pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86754 (h0 : functor.add_const (list (has_add pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86755 (h0 : finset (ring (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86756 (h0 : topological_space (simple_graph (mul_one_class to_additive.value_type))) : totally_disconnected_space (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86757 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_86758 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86759 (h0 : functor.add_const (ring (comm_group name)) linarith.comp) : @rank_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86760 (h0 : topological_space (has_Inf (ring (ring (ring name))))) : regular_space (has_Inf (ring (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_86761 (h0 : topological_space (option (has_Sup congr_arg_kind))) : totally_disconnected_space (option (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_86762 (h0 : uniform_space (with_one (has_top (semiring unsigned)))) : separated_space (with_one (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_86763 (h0 : topological_space (with_one (random_gen (random_gen (has_norm (random_gen string_imp)))))) : irreducible_space (with_one (random_gen (random_gen (has_norm (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_86764 (h0 : functor.const Prop ereal) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_86765 (h0 : complete_lattice (has_inv (random_gen linarith.ineq))) : is_compactly_generated (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86766 (h0 : functor.add_const (add_group (add_comm_monoid name)) name) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_86767 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86769 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : normal_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_86770 (h0 : functor.add_const (complete_lattice (ordered_comm_ring linarith.comp)) pos) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_86771 (h0 : topological_space (cancel_monoid congr_arg_kind)) : t0_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86772 (h0 : topological_space (has_zero (option unsigned))) : sequential_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_86773 (h0 : topological_space (with_one linarith.comp_source)) : t0_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_86774 (h0 : not (topological_space (simple_graph linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_86775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86776 (h0 : ring (comm_ring (random_gen (random_gen string_imp)))) : rank_condition (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_86777 (h0 : add_monoid (ring (option (option (option empty))))) : add_monoid.fg (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_86778 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (ring (has_neg Type))) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86779 (h0 : list (normed_group linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_86780 (h0 : functor.add_const (finset (add_cancel_monoid linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86781 (h0 : function.extfun Type ring) : @is_domain.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_86782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86783 (h0 : group (has_append (has_nnnorm (random_gen linarith.ineq)))) : is_cyclic (has_append (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_86784 (h0 : group (generalized_boolean_algebra name)) : is_simple_group (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_86785 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) empty) : @t1_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_86786 (h0 h1 h2 : int) : int.modeq h0 h1 h2 := sorry --non-trivial
lemma new_lemma_86787 (h0 : filter (mul_zero_class (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_86788 (h0 : linarith.ineq -> linarith.ineq -> Prop) (h1 : set linarith.ineq) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_86789 (h0 : functor.add_const (uniform_space (linear_ordered_comm_group num)) empty) : @complete_space.{0} (linear_ordered_comm_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_86790 (h0 : topological_space (simple_graph (has_Inf (has_Inf pos)))) : totally_separated_space (simple_graph (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_86791 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_86792 (h0 : uniform_space (has_union (has_top (has_top empty)))) : complete_space (has_union (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_86793 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @normal_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86794 (h0 : functor.add_const (topological_space (semiring empty)) num) : @irreducible_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_86795 (h0 : topological_space (sub_neg_monoid (has_bot (has_add real)))) : regular_space (sub_neg_monoid (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_86796 (h0 : complete_lattice (has_div (uniform_space (uniform_space enat)))) : complete_lattice.is_Sup_finite_compact (has_div (uniform_space (uniform_space enat))) := sorry --non-trivial
lemma new_lemma_86797 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_86798 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @normal_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_86799 (h0 : functor.add_const (complete_lattice (semigroup Type)) (boolean_algebra Type)) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_86800 (h0 : ring (complete_semilattice_Sup (has_nnnorm fun_info))) : rank_condition (complete_semilattice_Sup (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_86801 (h0 : topological_space (canonically_linear_ordered_monoid num)) : discrete_topology (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_86802 (h0 : fin has_zero.zero) : @complete_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_86803 (h0 : uniform_space (metric_space (has_top empty))) : complete_space (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_86804 (h0 : topological_space (boolean_algebra.core linarith.comp)) : irreducible_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_86805 (h0 : topological_space (add_cancel_monoid (has_Inf linarith.comp))) : regular_space (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_86806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ring pos)) := sorry --non-trivial
lemma new_lemma_86807 (h0 : functor.add_const (filter (boolean_algebra unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86808 (h0 : uniform_space (measurable_space.dynkin_system (has_norm linarith.comp))) : complete_space (measurable_space.dynkin_system (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_86809 (h3 : ring (has_ssubset reducibility_hints)) : is_domain (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_86810 (h0 : add_group (with_bot linarith.ineq)) : is_add_cyclic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_86811 (h1 : ring (fintype (random_gen (random_gen string_imp)))) : strong_rank_condition (fintype (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_86812 (h0 : group (complete_distrib_lattice (has_pos_part linarith.comp))) : normalizer_condition (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_86813 (h0 : ordered_comm_monoid (has_nndist (ring environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86814 (h0 : topological_space (has_nndist (finset (has_pos_part (has_Inf linarith.comp))))) : sequential_space (has_nndist (finset (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_86815 (h0 : list (has_inner num num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_86816 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @locally_compact_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86817 (h0 : functor.comp topological_space has_zero (option ennreal)) : @regular_space.{0} (has_zero.{0} (option.{0} ennreal)) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_86818 (h0 : function.extfun Type group) : @is_cyclic.{0} empty (@function.extfun_app.{2 1} Type group.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_86819 (h2 : topological_space (has_compl (has_ssubset (has_ssubset (has_ssubset char))))) : t0_space (has_compl (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_86820 (h1 : has_mem.mem linarith.comp has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_86821 (h0 : filter (add_comm_monoid (add_cancel_monoid (comm_group Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86822 (h0 : topological_space (has_dist empty)) : path_connected_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_86823 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @locally_compact_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86824 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : preconnected_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_86825 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option unsigned))) : topological_space.separable_space (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_86826 (h0 : not (topological_space (partial_order empty) -> false)) : @normal_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_86827 (h1 : ring (has_emptyc (random_gen linarith.comp))) : strong_rank_condition (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_86828 (h0 : topological_space (plift unsigned)) : topological_space.separable_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_86829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86830 (h0 : add_group (monoid_with_zero pos)) : is_add_cyclic (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_86831 (h0 : add_group (div_inv_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : is_add_cyclic (div_inv_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_86832 (h0 : uniform_space (add_cancel_comm_monoid (has_lt string.iterator_imp))) : complete_space (add_cancel_comm_monoid (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_86833 (h0 : add_group (add_cancel_comm_monoid unsigned)) : is_add_cyclic (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_86834 (h0 : topological_space (has_emptyc fun_info)) : t0_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_86835 (h0 : topological_space (has_to_string (has_add (finset pos)))) : regular_space (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_86836 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_86837 (h0 : group (linear_ordered_field (option (option auto.case_option)))) : is_cyclic (linear_ordered_field (option (option auto.case_option))) := sorry --non-trivial
lemma new_lemma_86838 (h0 : topological_space (pseudo_metric_space (option pos))) : totally_separated_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_86839 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86840 (h0 : not (uniform_space (uniform_space linarith.ineq) -> false)) : @complete_space.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_86841 (h0 : metric_space (normed_comm_ring pos)) (h1 : set (normed_comm_ring pos)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_86842 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_86843 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : path_connected_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_86844 (h3 : add_group string.iterator_imp) : is_add_cyclic string.iterator_imp := sorry --non-trivial
lemma new_lemma_86845 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_86846 (h0 : not (group (has_norm linarith.comp_source) -> false)) : @group.fg.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_86847 (h0 : ring (option name)) : is_principal_ideal_ring (option name) := sorry --non-trivial
lemma new_lemma_86848 (h0 : topological_space (has_append to_additive.value_type)) : totally_disconnected_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86849 (h0 : function.extfun nat fin) : @separated_space.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_nndist.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_86850 (h0 : functor.add_const Prop (linear_ordered_comm_group congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86851 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : totally_separated_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_86852 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_86853 (h0 : topological_space (linear_order (option (option empty)))) : totally_separated_space (linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_86854 (h0 : ring (free_add_monoid (semiring (option (option (option (option unsigned))))))) : rank_condition (free_add_monoid (semiring (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_86855 (h2 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h2) num)  := sorry --non-trivial
lemma new_lemma_86856 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_86857 (h0 : functor.add_const (group (boolean_algebra.core linarith.comp)) name) : @is_simple_group.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_86858 (h0 : uniform_space (generalized_boolean_algebra (boolean_algebra.core linarith.comp))) : complete_space (generalized_boolean_algebra (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_86859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_86860 (h0 : topological_space (has_bot (has_bot (has_bot (has_bot name))))) : sequential_space (has_bot (has_bot (has_bot (has_bot name)))) := sorry --non-trivial
lemma new_lemma_86861 (h0 : with_bot (function.extfun Type group)) (h1 : function.extfun (eq h0 has_bot.bot) (fun (x : eq h0 has_bot.bot), false)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@with_bot.unbot.{1} (function.extfun.{2 1} Type group.{0}) h0 (@function.extfun_app.{0 0} (@eq.{2} (with_bot.{1} (function.extfun.{2 1} Type group.{0})) h0 (@has_bot.bot.{1} (with_bot.{1} (function.extfun.{2 1} Type group.{0})) (@with_bot.has_bot.{1} (function.extfun.{2 1} Type group.{0})))) (λ (x : @eq.{2} (with_bot.{1} (function.extfun.{2 1} Type group.{0})) h0 (@has_bot.bot.{1} (with_bot.{1} (function.extfun.{2 1} Type group.{0})) (@with_bot.has_bot.{1} (function.extfun.{2 1} Type group.{0})))), false) h1)) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_86862 (h0 : function.extfun Type (prod (has_neg linarith.comp))) : set.diagonal (has_neg linarith.comp) (function.extfun_app h0 (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_86863 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_86864 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_86865 (h0 : functor.add_const (add_monoid (add_comm_monoid pos)) real) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_86866 (h0 : group (has_add (option pos))) : normalizer_condition (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_86867 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp))) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_86868 (h0 : not (complete_lattice (has_union unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86869 (h0 : topological_space (complete_distrib_lattice (finset pos))) : preconnected_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_86870 (h0 : functor.add_const (functor.comp complete_lattice has_neg pos) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} pos (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} complete_lattice.{0} has_neg.{0} pos) Type h0))  := sorry --non-trivial
lemma new_lemma_86871 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring congr_arg_kind)) : unique_factorization_monoid (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86873 (h0 : not (topological_space (has_star unsigned) -> false)) : @topological_space.separable_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86874 (h0 : group (semigroup (option (option ennreal)))) : normalizer_condition (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_86875 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86876 (h0 : complete_lattice (partial_order (ordered_cancel_comm_monoid unsigned))) : is_compactly_generated (partial_order (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_86877 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_86878 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_86879 (h0 : ring (encodable (random_gen (random_gen (has_nnnorm linarith.ineq))))) : rank_condition (encodable (random_gen (random_gen (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_86880 (h1 : complete_lattice (with_one (random_gen string_imp))) : is_compactly_generated (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_86881 (h0 : topological_space (ordered_comm_ring (has_add real))) : normal_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_86882 (h0 : functor.add_const (ring (has_zero pos)) (ring (boolean_algebra environment.implicit_infer_kind))) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_86883 (h0 : add_group linarith.comp) : is_add_cyclic linarith.comp := sorry --non-trivial
lemma new_lemma_86884 (h0 : not (topological_space (div_inv_monoid linarith.ineq) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_86885 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @discrete_topology.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_86886 (h0 : topological_space (normed_comm_ring (comm_group (comm_group unsigned)))) : preconnected_space (normed_comm_ring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_86887 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) empty) : @t0_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_86888 (h0 : linear_ordered_field (linear_ordered_field ennreal) -> linear_ordered_field (linear_ordered_field ennreal) -> Prop) : is_symm (linear_ordered_field (linear_ordered_field ennreal)) h0 := sorry --non-trivial
lemma new_lemma_86889 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_86890 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86891 (h0 : function.extfun Type (functor.add_const (monoid (generalized_boolean_algebra linarith.comp)))) : @monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_86892 (h0 : has_top (has_top unsigned) -> has_top (has_top unsigned) -> Prop) : is_strict_order (has_top (has_top unsigned)) h0 := sorry --non-trivial
lemma new_lemma_86893 (h0 : topological_space (has_compl reducibility_hints)) : path_connected_space (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_86894 (h0 : add_monoid (add_comm_monoid (ring linarith.comp))) : add_monoid.fg (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_86895 (h0 : not (topological_space (comm_ring reducibility_hints) -> false)) : @t0_space.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_86896 (h0 : uniform_space (monoid congr_arg_kind)) : separated_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86897 (h0 : complete_lattice (ordered_comm_group empty)) : is_compactly_generated (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_86898 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_86899 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86900 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86901 (h0 : functor.add_const (topological_space (ring Type)) (has_neg (has_neg (has_neg (has_Inf linarith.comp))))) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_neg.{0} (has_neg.{0} (has_neg.{0} (has_Inf.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_86902 (h0 : group (has_bot (semiring empty))) : is_cyclic (has_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_86903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_86904 (h0 : preorder ereal) (h1 : set ereal) : set.ord_connected h1 := sorry --non-trivial
lemma new_lemma_86905 (h0 : topological_space (has_add (finset (finset environment.implicit_infer_kind)))) : loc_path_connected_space (has_add (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_86906 (h0 : finset (boolean_algebra (has_Inf (has_pos_part (has_pos_part (has_pos_part (has_pos_part linarith.comp))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86907 (h0 : ring (generalized_boolean_algebra string_imp)) : is_domain (generalized_boolean_algebra string_imp) := sorry --non-trivial
lemma new_lemma_86908 (h0 : ring (id (has_top (semiring empty)))) : strong_rank_condition (id (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_86909 (h0 : add_group (has_bot linarith.comp)) : is_add_cyclic (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_86910 (h0 : not (ulower Prop -> false)) : @ulower.up.{0} Prop encodable.Prop (@classical.by_contradiction'.{1} (@ulower.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_86911 (h0 : not (uniform_space (has_to_string num) -> false)) : @separated_space.{0} (has_to_string.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_to_string.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86912 (h0 : not (cancel_comm_monoid_with_zero (semiring num) -> false)) : @unique_factorization_monoid.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_86913 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_86914 (h0 : function.extfun Type uniform_space) : separated_space empty := sorry --non-trivial
lemma new_lemma_86915 (h0 : group (normed_group congr_arg_kind)) : is_cyclic (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_86916 (h0 : not (topological_space (semiring unsigned) -> false)) : @normal_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86917 (h0 : group (fintype fun_info)) : is_cyclic (fintype fun_info) := sorry --non-trivial
lemma new_lemma_86918 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_86919 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_86920 (h0 : functor.add_const (add_group (has_Inf Type)) pos) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_86921 (h0 : topological_space (has_top fun_info)) : totally_disconnected_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_86922 (h0 : topological_space (random_gen (has_norm (has_norm num)))) : t0_space (random_gen (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_86923 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @normal_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_86924 (h0 : functor.comp topological_space has_neg Type) : @locally_compact_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_86925 (h0 : topological_space (boolean_algebra (has_add pos))) : irreducible_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_86926 (h0 : fin has_zero.zero) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_86927 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_pos_part real)))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_86928 (h0 : not (ring (distrib_lattice char) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_86929 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_add real))) : has_exists_mul_of_le (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_86930 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_86931 (h0 : topological_space (add_cancel_monoid (semigroup environment.implicit_infer_kind))) : discrete_topology (add_cancel_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86932 (h0 : function.extfun Type ring) : @is_domain.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_86933 (h0 : uniform_space (distrib_lattice num)) : separated_space (distrib_lattice num) := sorry --non-trivial
lemma new_lemma_86934 (h0 : ordered_add_comm_monoid (ring Type)) : archimedean (ring Type) := sorry --non-trivial
lemma new_lemma_86935 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @monoid.fg.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_86936 (h0 : ring (has_top to_additive.value_type)) : strong_rank_condition (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86937 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) (has_to_string environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_86938 (h0 : topological_space (ring (has_add (has_add environment.implicit_infer_kind)))) : preirreducible_space (ring (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_86939 (h0 : topological_space (normed_field (comm_ring linarith.ineq))) : t0_space (normed_field (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_86940 (h0 : uniform_space (add_comm_monoid (comm_group pos))) : complete_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_86941 (h1 : measurable_space (has_ssubset (mul_one_class (mul_one_class environment.projection_info)))) (h2 : filter (has_ssubset (mul_one_class (mul_one_class environment.projection_info)))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_86942 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid Type)) (finset environment.implicit_infer_kind)) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (cancel_monoid.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_86943 (h0 : semiring (with_one (semiring (semiring (semiring (semiring (semiring unsigned))))))) : is_noetherian_ring (with_one (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_86944 (h0 : uniform_space (has_edist (option (option (option unsigned))))) : complete_space (has_edist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_86945 (h0 : semiring (normed_field fun_info)) (h1 : ideal (normed_field fun_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_86946 (h0 h1 : multiset std_gen) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_86947 (h0 : complete_lattice (with_zero to_additive.value_type)) : is_compactly_generated (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_86948 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_86949 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_86950 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : topological_space.separable_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_86951 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_86952 (h0 : complete_lattice (finset name)) : is_compactly_generated (finset name) := sorry --non-trivial
lemma new_lemma_86953 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) (has_neg (has_neg (has_neg (has_neg (ring Type)))))) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} (ring.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_86954 (h0 : topological_space (has_neg_part (has_neg_part environment.implicit_infer_kind))) : preconnected_space (has_neg_part (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86955 (h0 : topological_space (comm_group (boolean_algebra.core (comm_group environment.implicit_infer_kind)))) : sequential_space (comm_group (boolean_algebra.core (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_86956 (h0 : functor.add_const (group (option pos)) pos) : @is_simple_group.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86957 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_86958 (h0 : topological_space (semiring linarith.comp)) : totally_separated_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_86959 (h0 : functor.add_const Prop (semiring (semiring empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_86960 (h0 : group (with_zero linarith.ineq)) : group.fg (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_86961 (h0 : function.extfun Type (functor.add_const (list linarith.comp))) : list.nodup (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_86962 (h5 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_86963 (h0 : functor.add_const (group (boolean_algebra.core Type)) Type) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_86964 (h0 : finset (has_zero (cancel_monoid environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86965 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_86966 (h0 : function.extfun Type (functor.add_const (add_group (add_comm_monoid environment.implicit_infer_kind)))) : @is_add_cyclic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind))) h0 name))  := sorry --non-trivial
lemma new_lemma_86967 (h0 : ring (has_neg (finset linarith.comp))) : strong_rank_condition (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_86968 (h0 : ring (canonically_ordered_add_monoid (option (option (option (option empty)))))) : rank_condition (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_86969 (h0 : complete_lattice (comm_ring (random_gen (random_gen fun_info)))) : is_compactly_generated (comm_ring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_86970 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option unsigned))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_86971 (h0 : topological_space (complete_semilattice_Sup (has_norm empty))) : totally_disconnected_space (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_86972 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_Inf pos)) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_86973 (h0 : finset (left_cancel_monoid (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_86974 (h0 : not (topological_space (normed_group unsigned) -> false)) : @totally_separated_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86975 (h0 : filter (linear_ordered_field (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_86976 (h0 : functor.add_const (topological_space (free_add_monoid num)) (semiring num)) : @totally_disconnected_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_86977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86978 (h0 : uniform_space (complete_distrib_lattice (finset name))) : complete_space (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_86979 (h0 : ring (ordered_cancel_add_comm_monoid (option unsigned))) : rank_condition (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_86980 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) congr_arg_kind) : @path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_86981 (h0 h1 : multiset (has_compl (mul_one_class fun_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_86982 (h0 : topological_space (plift (semiring empty))) : totally_separated_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_86983 (h0 : complete_lattice (has_zero (normed_comm_ring environment.implicit_infer_kind))) : is_atomistic (has_zero (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_86984 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg Type)) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_86985 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @sequential_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_86986 (h0 : topological_space (has_zero (option unsigned))) : topological_space.separable_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_86987 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string linarith.comp)) Type) : @unique_factorization_monoid.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_86988 (h0 : not (complete_lattice (plift unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_86989 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86990 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_86991 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86992 (h0 : semiring (canonically_ordered_comm_semiring (has_to_string pos))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_86993 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ring.{0} name) (@matrix.vec_empty.{0} (ring.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_86994 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_86995 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_86996 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_86997 (h0 : add_group (has_div (mul_one_class (mul_one_class std_gen)))) : is_add_cyclic (has_div (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_86998 (h0 : ring (has_inv (has_pos_part linarith.comp_source))) : rank_condition (has_inv (has_pos_part linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_86999 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) (finset linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87000 (h0 : finset (add_comm_monoid (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_87001 (h0 : functor.add_const (ring (add_comm_monoid (has_to_string pos))) environment.implicit_infer_kind) : @is_domain.{0} (add_comm_monoid.{0} (has_to_string.{0} pos)) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} (has_to_string.{0} pos))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87002 (h0 : topological_space (simple_graph (option unsigned))) : totally_separated_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_87003 (h1 : complete_lattice (semi_normed_ring (has_nnnorm reducibility_hints))) : is_compactly_generated (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_87004 (h0 : topological_space (has_neg pos)) : t0_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_87005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_87006 (h0 : thunk pnat) (h1 : nat) (h2 : ulower (vector pnat (has_add.add h1 has_one.one))) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@vector.last.{0} h1 pnat (@ulower.up.{0} (vector.{0} pnat (@has_add.add.{0} nat nat.has_add h1 (@has_one.one.{0} nat nat.has_one))) (@encodable.vector.{0} pnat encodable.pnat (@has_add.add.{0} nat nat.has_add h1 (@has_one.one.{0} nat nat.has_one))) h2))  := sorry --non-trivial
lemma new_lemma_87007 (h0 : monoid (id (with_bot string_imp))) : monoid.fg (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_87008 (h0 : not (topological_space (add_right_cancel_monoid linarith.comp) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87009 (h0 : group (canonically_ordered_comm_semiring (cancel_monoid name))) : normalizer_condition (canonically_ordered_comm_semiring (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_87010 (h0 : topological_space (free_add_monoid empty)) : t1_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_87011 (h0 : topological_space (has_union (semiring (semiring congr_arg_kind)))) : locally_compact_space (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_87012 (h0 : topological_space (sub_neg_monoid (has_add (has_Inf pos)))) : totally_separated_space (sub_neg_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_87013 (h0 : filter (has_nndist (comm_group (comm_group (boolean_algebra name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_87014 (h0 : functor.comp add_monoid semigroup name) : @add_monoid.fg.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_87015 (h0 : functor.add_const (topological_space (option congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_87016 (h0 : ring (add_left_cancel_monoid (has_nnnorm to_additive.value_type))) : is_domain (add_left_cancel_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87017 (h0 : monoid (random_gen (has_norm linarith.comp))) : monoid.fg (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_87018 (h0 : semiring (monoid (option (option pos)))) : is_noetherian_ring (monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_87019 (h0 : topological_space (has_top (has_inv fun_info))) : t0_space (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_87020 (h2 : uniform_space (add_cancel_comm_monoid to_additive.value_type)) : complete_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87021 (h0 : topological_space (has_one unsigned)) : path_connected_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_87022 (h1 : add_monoid (semiring (has_norm (has_norm linarith.comp)))) : add_monoid.fg (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_87023 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_87024 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @t1_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_87025 (h0 : group (boolean_algebra.core (normed_comm_ring Type))) : is_cyclic (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_87026 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (has_add pos)) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (has_add.{0} pos) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_87027 (h0 : complete_lattice (topological_space (has_ssubset char))) : complete_lattice.is_Sup_finite_compact (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_87028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87029 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @complete_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_87030 (h0 : ring (has_nndist (has_neg (finset (has_nndist linarith.comp))))) : is_principal_ideal_ring (has_nndist (has_neg (finset (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_87031 (h0 : ring (right_cancel_semigroup (semiring (semiring num)))) : is_principal_ideal_ring (right_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_87032 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_87033 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_87034 (h0 : ring (linear_ordered_comm_group_with_zero (metric_space string_imp))) : is_domain (linear_ordered_comm_group_with_zero (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_87035 (h0 : monoid (semigroup (comm_group (has_neg linarith.comp)))) : monoid.fg (semigroup (comm_group (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_87036 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87037 (h0 : functor.add_const (add_monoid (add_comm_monoid name)) Type) : @add_monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_87038 (h0 : topological_space (id (has_norm to_additive.value_type))) : t0_space (id (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87039 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_87040 (h0 : functor.add_const (topological_space (mul_zero_class num)) (semiring (semiring empty))) : @t1_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87041 (h0 : semiring (has_to_string (has_to_string unsigned))) : is_noetherian_ring (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_87042 (h1 : group (comm_ring (has_top (comm_ring (random_gen (random_gen linarith.comp_source)))))) : is_cyclic (comm_ring (has_top (comm_ring (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_87043 (h0 : ring (has_bot (has_neg name))) : is_principal_ideal_ring (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_87044 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_87045 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup ereal)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_87046 (h0 : ring (has_Inf (has_Inf real))) : rank_condition (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_87047 (h0 : functor.add_const (group (has_neg pos)) environment.implicit_infer_kind) : @group.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87048 (h0 : add_monoid (boolean_algebra (has_add linarith.comp))) : add_monoid.fg (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_87049 (h0 : topological_space (has_emptyc (random_gen (random_gen congr_arg_kind)))) : irreducible_space (has_emptyc (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_87050 (h0 : topological_space (ordered_comm_ring (finset Type))) : totally_separated_space (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_87051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_87052 (h0 : not (filter (with_zero (has_nnnorm linarith.ineq)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_87053 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : loc_path_connected_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_87054 (h0 : functor.add_const (complete_lattice (ordered_comm_semiring environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ordered_comm_semiring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_87055 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid empty)) num) : @unique_factorization_monoid.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_87056 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_87057 (h0 : filter (distrib_lattice (random_gen (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87058 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_87059 (h0 : functor.add_const (group (add_cancel_monoid ennreal)) linarith.comp) : @is_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87060 (h0 : topological_space (comm_group (has_add pos))) : preconnected_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_87061 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87062 (h0 : filter (cancel_monoid (has_add (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87063 (h0 : has_mem.mem (ordered_cancel_add_comm_monoid congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_87064 (h0 : topological_space (has_top (has_norm (has_norm (semiring linarith.comp))))) : irreducible_space (has_top (has_norm (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_87065 (h1 h2 : list std_gen) : list.is_infix h1 h2 := sorry --non-trivial
lemma new_lemma_87066 (h0 : add_monoid char) : add_monoid.fg char := sorry --non-trivial
lemma new_lemma_87067 (h0 : topological_space (has_add (has_add (has_add name)))) : preirreducible_space (has_add (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_87068 (h0 : functor.add_const (function.extfun Type semiring) unsigned) : @is_noetherian_ring.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) unsigned h0) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87069 (h0 : complete_lattice (div_inv_monoid (random_gen (distrib fun_info)))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (random_gen (distrib fun_info))) := sorry --non-trivial
lemma new_lemma_87070 (h0 : enat -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_87071 (h0 : monoid (cancel_monoid environment.implicit_infer_kind)) : monoid.fg (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_87072 (h0 : add_monoid (comm_group (has_neg_part num))) : add_monoid.fg (comm_group (has_neg_part num)) := sorry --non-trivial
lemma new_lemma_87073 (h0 : topological_space (has_add (has_pos_part pos))) : locally_compact_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_87074 (h0 : functor.add_const (group (has_to_string pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87075 (h0 : add_group (random_gen (metric_space char))) : is_add_cyclic (random_gen (metric_space char)) := sorry --non-trivial
lemma new_lemma_87076 (h0 : finset (has_nndist (normed_linear_ordered_group Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_87077 (h0 : list (add_comm_monoid (option congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87078 (h0 : group (has_Inf (has_add (has_pos_part (has_add (has_add (ring (has_Inf pos)))))))) : group.fg (has_Inf (has_add (has_pos_part (has_add (has_add (ring (has_Inf pos))))))) := sorry --non-trivial
lemma new_lemma_87079 (h0 : topological_space (uniform_space (has_nnnorm reducibility_hints))) : path_connected_space (uniform_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_87080 (h0 : function.extfun Type ring) : @is_domain.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_87081 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_zero (has_zero Type))) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_zero.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87082 (h0 : cancel_comm_monoid_with_zero (linear_order unsigned)) : unique_factorization_monoid (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_87083 (h0 : topological_space (linear_ordered_comm_group_with_zero char)) : path_connected_space (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_87084 (h0 : functor.add_const Prop (mul_zero_class (has_neg_part ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_87085 (h0 : topological_space (has_neg (has_add (has_add environment.implicit_infer_kind)))) : t0_space (has_neg (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_87086 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_semigroup empty)) := sorry --non-trivial
lemma new_lemma_87087 (h0 : functor.add_const (function.extfun Type add_group) (has_pos_part Type)) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) (has_pos_part.{1} Type) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87088 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_add linarith.comp)) : @t1_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_87089 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87090 (h0 : ring (ordered_ring (option (option (option unsigned))))) : is_principal_ideal_ring (ordered_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_87091 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) name) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_87092 (h0 : add_monoid (has_add (has_Inf (has_Inf linarith.comp)))) : add_monoid.fg (has_add (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_87093 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_87094 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_inter (option num))) := sorry --non-trivial
lemma new_lemma_87095 (h0 : list (simple_graph (option num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_87096 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @sequential_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87097 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) linarith.comp) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87098 (h0 : add_group (has_pos_part (has_Inf (ordered_comm_monoid real)))) : is_add_cyclic (has_pos_part (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_87099 (h0 : ring (add_group num)) : is_principal_ideal_ring (add_group num) := sorry --non-trivial
lemma new_lemma_87100 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87101 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_87102 (h0 : not (group (left_cancel_semigroup empty) -> false)) : @is_cyclic.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87103 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_87104 (h0 : functor.add_const (add_monoid (has_pos_part pos)) Type) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_87105 (h0 : topological_space (distrib_lattice fun_info)) : path_connected_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_87106 (h1 : not (add_group (topological_space string_imp) -> false)) : @is_add_cyclic.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_87107 (h0 : topological_space (has_one (id linarith.comp))) : totally_disconnected_space (has_one (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_87108 (h1 : ring (measurable_space (random_gen (semiring linarith.comp)))) : strong_rank_condition (measurable_space (random_gen (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_87109 (h0 : group (semigroup (comm_group Type))) : is_simple_group (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_87110 (h0 : monoid (has_norm (semiring congr_arg_kind))) : monoid.fg (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87111 (h0 : topological_space (comm_ring (has_append (add_cancel_comm_monoid linarith.comp_source)))) : totally_disconnected_space (comm_ring (has_append (add_cancel_comm_monoid linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_87112 (h0 : not (ring (dlist to_additive.value_type) -> false)) : @is_domain.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_87113 (h0 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} num) (@id.{1} (group.{0} (has_emptyc.{0} num)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} num)))  := sorry --non-trivial
lemma new_lemma_87114 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87115 (h0 : not (topological_space (ordered_ring num) -> false)) : @path_connected_space.{0} (ordered_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_87116 (h0 : group (normed_group string_imp)) : group.fg (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_87117 (h0 : monoid (has_norm (random_gen (random_gen linarith.comp_source)))) : monoid.fg (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_87118 (h0 : finset (ordered_comm_monoid (has_Inf (has_Inf name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_87119 (h2 : set (normed_field to_additive.value_type)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_87120 (h0 : functor.add_const (functor.add_const (complete_lattice pos) linarith.comp) (add_comm_monoid pos)) : @is_atomistic.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} pos) linarith.comp) (add_comm_monoid.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_87121 (h0 : group (has_norm (has_ssubset to_additive.value_type))) : group.fg (has_norm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87122 (h0 : complete_lattice (id (with_bot (with_bot to_additive.value_type)))) : is_atomistic (id (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_87123 (h4 : uniform_space (has_append char)) : complete_space (has_append char) := sorry --non-trivial
lemma new_lemma_87124 (h1 : topological_space (dlist to_additive.value_type)) : irreducible_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87125 (h0 : topological_space (add_comm_semigroup ereal)) (h1 : set (add_comm_semigroup ereal)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_87126 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87127 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87128 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87129 (h0 : topological_space (ordered_comm_ring (ring (ordered_comm_monoid linarith.comp)))) : regular_space (ordered_comm_ring (ring (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_87130 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @normal_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87131 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87132 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) pos) : @is_atomistic.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_87133 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87134 (h0 : group (has_union (has_norm empty))) : is_cyclic (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_87135 (h0 : group (preorder (option empty))) : is_cyclic (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_87136 (h0 : ring (normed_comm_ring (has_pos_part pos))) : is_principal_ideal_ring (normed_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_87137 (h0 : functor.add_const (topological_space (boolean_algebra name)) (ring pos)) : @t0_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87138 (h0 : function.extfun Type (functor.add_const (ring znum))) : @is_domain.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_87139 (h0 : topological_space (comm_semigroup name)) : regular_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_87140 (h0 : ring (mul_one_class ereal)) : strong_rank_condition (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_87141 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) (has_neg_part environment.implicit_infer_kind)) : @is_atomistic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) (has_neg_part.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_87142 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_87143 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} pos)))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} pos)))))))  := sorry --non-trivial
lemma new_lemma_87144 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87145 (h0 : set (char -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_87146 (h0 : ordered_add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) : archimedean (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_87147 (h0 : topological_space (semigroup congr_arg_kind)) : preconnected_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87148 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87149 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_87150 (h0 : topological_space (semigroup linarith.comp)) : topological_space.separable_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_87151 (h0 : functor.add_const (ring (boolean_algebra.core name)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87152 (h0 : topological_space (boolean_algebra (finset (has_to_string pos)))) : regular_space (boolean_algebra (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_87153 (h2 : uniform_space (linear_ordered_add_comm_group string_imp)) : complete_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_87154 (h0 : functor.add_const (topological_space auto.case_option) num) : @locally_compact_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_87155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87156 (h0 : group (normed_group (has_nnnorm linarith.ineq))) : is_cyclic (normed_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_87157 (h0 : uniform_space (linear_ordered_cancel_comm_monoid (semiring (semiring (semiring unsigned))))) : complete_space (linear_ordered_cancel_comm_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_87158 (h0 : topological_space (metric_space (semiring num))) : t1_space (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_87159 (h0 : list (mul_zero_class (has_nndist unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87160 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_87161 (h0 : add_monoid (has_zero linarith.comp)) : add_monoid.fg (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_87162 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_87163 (h0 : list (has_nndist (finset (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_87164 (h0 : list (has_Inf (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87165 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_87166 (h0 : functor.add_const (topological_space (finset name)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87167 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_87168 (h0 : set (simple_graph (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_87169 (h0 : monoid (comm_group (has_add name))) : monoid.fg (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_87170 (h0 : ring (normed_field (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (normed_field (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_87171 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87172 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_87173 (h0 : functor.add_const (topological_space name) empty) : @irreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_87174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_87175 (h0 : uniform_space (normed_group (semiring unsigned))) : separated_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_87176 (h0 : functor.add_const (list (semigroup linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87177 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87178 (h0 : add_monoid (mul_zero_class (semiring num))) : add_monoid.fg (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_87179 (h0 : complete_lattice (has_bot (has_add real))) : complete_lattice.is_Sup_finite_compact (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_87180 (h0 : functor.comp group has_nndist ennreal) : @normalizer_condition.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_87181 (h0 : functor.add_const (uniform_space (has_nndist name)) pos) : @complete_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_87182 (h0 : functor.add_const (add_group (has_to_string Type)) unsigned) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87183 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_87184 (h0 : topological_space (dlist (comm_ring (has_nnnorm (comm_ring char))))) : t0_space (dlist (comm_ring (has_nnnorm (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_87185 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_87186 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87187 (h0 : group (has_zero (has_to_string Type))) : is_simple_group (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_87188 (h0 : ordered_add_comm_monoid (finset num)) : archimedean (finset num) := sorry --non-trivial
lemma new_lemma_87189 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_87190 (h0 : topological_space (boolean_algebra (ring (has_add Type)))) : t0_space (boolean_algebra (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_87191 (h0 : filter (add_cancel_monoid (cancel_monoid ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87192 (h0 : complete_lattice (has_nndist environment.implicit_infer_kind)) : is_atomistic (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_87193 (h0 : monoid (measure_theory.measure_space (has_top (semiring (has_top (semiring (semiring empty))))))) : monoid.fg (measure_theory.measure_space (has_top (semiring (has_top (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_87194 (h2 : topological_space std_gen) (h3 : preorder std_gen) : order_topology std_gen := sorry --non-trivial
lemma new_lemma_87195 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_87196 (h0 : complete_lattice (has_to_string Type)) : is_compactly_generated (has_to_string Type) := sorry --non-trivial
lemma new_lemma_87197 (h0 : ring (lex char)) : strong_rank_condition (lex char) := sorry --non-trivial
lemma new_lemma_87198 (h0 : topological_space (metric_space complex)) : normal_space (metric_space complex) := sorry --non-trivial
lemma new_lemma_87199 (h0 : functor.add_const (uniform_space (has_zero pos)) name) : @complete_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_87200 (h0 : complete_lattice (has_emptyc (has_inv linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_87201 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_87202 (h0 : topological_space (has_to_string (has_Inf pos))) : locally_compact_space (has_to_string (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_87203 (h0 : topological_space (preorder (option unsigned))) : normal_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_87204 (h0 : filter (has_neg (option (option num)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_87205 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87206 (h0 : topological_space (metric_space num)) : path_connected_space (metric_space num) := sorry --non-trivial
lemma new_lemma_87207 (h0 : function.extfun nat fin) : @separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_87208 (h0 : semiring (has_pos_part (has_neg Type))) : is_noetherian_ring (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_87209 (h0 : monoid (semigroup (finset (ring Type)))) : monoid.fg (semigroup (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_87210 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_87211 (h0 : semiring (has_pos_part (ring (has_neg pos)))) : is_noetherian_ring (has_pos_part (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_87212 (h0 : not (ring (random_gen char) -> false)) : @strong_rank_condition.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_87213 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_87214 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (has_nndist linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_87215 (h0 : group (has_to_string (has_to_string (has_to_string (has_to_string Type))))) : is_simple_group (has_to_string (has_to_string (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_87216 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87217 (h0 : add_group (distrib (has_nndist (add_cancel_comm_monoid string_imp)))) : is_add_cyclic (distrib (has_nndist (add_cancel_comm_monoid string_imp))) := sorry --non-trivial
lemma new_lemma_87218 (h0 : prod (is_R_or_C (option unsigned)) (is_R_or_C (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_87219 (h0 : topological_space (add_comm_monoid unsigned)) : sequential_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_87220 (h0 : topological_space (add_left_cancel_semigroup num)) : preirreducible_space (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_87221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87222 (h0 : topological_space (metric_space unsigned)) : totally_disconnected_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_87223 (h0 : group (simple_graph (has_add linarith.comp))) : normalizer_condition (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_87224 (h0 : functor.add_const (topological_space (filter empty)) (semiring (semiring empty))) : @locally_compact_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87225 (h0 : functor.add_const (complete_lattice (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87226 (h2 : random_gen to_additive.value_type -> Prop) (h3 : ring (linear_ordered_add_comm_group (derive_fintype.finset_in h2))) : rank_condition (linear_ordered_add_comm_group (derive_fintype.finset_in h2)) := sorry --non-trivial
lemma new_lemma_87227 (h0 : add_group (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : is_add_cyclic (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87228 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid (has_pos_part (sub_neg_monoid Type))))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid (has_pos_part (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_87229 (h0 : group (distrib (has_nnnorm fun_info))) : is_cyclic (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_87230 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_87231 (h0 : topological_space (has_top (semiring (has_top empty)))) : discrete_topology (has_top (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_87232 (h0 : list (has_emptyc (has_top (has_top (has_top (has_norm fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87233 (h1 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : is_atomistic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87234 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_87235 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : t0_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_87236 (h3 : topological_space std_gen) : totally_disconnected_space std_gen := sorry --non-trivial
lemma new_lemma_87237 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) (has_add name)) : @is_atomistic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_87238 (h0 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @discrete_topology.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_87239 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_dist empty)) := sorry --non-trivial
lemma new_lemma_87240 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) ennreal) : @t1_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_87241 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87242 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87243 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_87244 (h0 : topological_space (normed_group (semiring empty))) : totally_disconnected_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_87245 (h0 : group unsigned) : is_cyclic unsigned := sorry --non-trivial
lemma new_lemma_87246 (h0 : functor.add_const (ring environment.implicit_infer_kind) name) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_87247 (h0 : topological_space (linear_ordered_field (monoid_with_zero (option pos)))) : totally_separated_space (linear_ordered_field (monoid_with_zero (option pos))) := sorry --non-trivial
lemma new_lemma_87248 (h0 : not (topological_space (has_union unsigned) -> false)) : @locally_compact_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_87249 (h0 : topological_space (has_Inf (boolean_algebra name))) : topological_space.separable_space (has_Inf (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_87250 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_87251 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_87252 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_87253 (h0 : add_monoid (finset (ring (has_neg Type)))) : add_monoid.fg (finset (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_87254 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87255 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87256 (h0 : not (topological_space (normed_field reducibility_hints) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_87257 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) name) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_87258 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_87259 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_87260 (h0 : functor.add_const (list (add_cancel_monoid name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87261 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @t0_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_87262 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87263 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_87264 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87265 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_87266 (h0 : ring (sub_neg_monoid (has_Inf Type))) : strong_rank_condition (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_87267 (h0 : monoid (left_cancel_semigroup empty)) : monoid.fg (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_87268 (h0 : add_monoid (has_nndist (has_to_string linarith.comp))) : add_monoid.fg (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_87269 (h0 : functor.add_const (complete_lattice Type) (finset pos)) : @is_compactly_generated.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87270 (h1 : complete_lattice (complete_semilattice_Sup congr_arg_kind)) : is_atomistic (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87271 (h0 : function.extfun (Type 1) (functor.comp topological_space normed_comm_ring)) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} normed_comm_ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_87272 (h0 : group (comm_monoid congr_arg_kind)) : group.fg (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87273 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) (has_neg name)) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_87274 (h0 : add_group (with_one (has_top (has_top fun_info)))) : is_add_cyclic (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_87275 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (omega_complete_partial_order.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_87276 (h0 : functor.add_const (filter (has_to_string pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87278 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_87279 (h0 : topological_space (canonically_linear_ordered_monoid (option num))) : loc_path_connected_space (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_87280 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @loc_path_connected_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_87281 (h0 : functor.add_const (list (has_nndist linarith.comp)) (ring environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_87283 (h0 : topological_space (comm_group name)) : totally_separated_space (comm_group name) := sorry --non-trivial
lemma new_lemma_87284 (h0 : semiring (bin_tree (semiring empty))) : is_noetherian_ring (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_87285 (h0 : set (has_ssubset char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_87286 (h0 : not (ring (has_ssubset (mul_one_class char)) -> false)) : @rank_condition.{0} (has_ssubset.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_87287 (h0 : topological_space (random_gen (has_ssubset (has_ssubset (has_ssubset reducibility_hints))))) : totally_disconnected_space (random_gen (has_ssubset (has_ssubset (has_ssubset reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_87288 (h0 : function.extfun Type group) : @group.fg.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87289 (h0 : cancel_comm_monoid_with_zero (ring (option (option (option (option empty)))))) : unique_factorization_monoid (ring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_87290 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_87291 (h0 : functor.add_const (function.extfun (Type 1) group) (ring Type)) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{1} Type) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_87292 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_87293 (h0 : functor.add_const (filter (finset name)) (finset (has_add Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87294 (h0 : complete_lattice (has_inner empty congr_arg_kind)) : is_compactly_generated (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87295 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_comm_group unsigned)) ennreal) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_group.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_87296 (h0 : topological_space (distrib_lattice linarith.ineq)) : totally_disconnected_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_87297 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87298 (h0 : nat -> Prop -> Prop) (h1 : nat) (h3 : Prop) : nat.repeat h0 h1 h3 := sorry --non-trivial
lemma new_lemma_87299 (h0 : functor.add_const (topological_space (finset name)) Type) : @topological_space.separable_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_87300 (h1 : pseudo_emetric_space fun_info) (h2 : pseudo_emetric_space std_gen) (h3 : ring (isometric fun_info std_gen)) : strong_rank_condition (isometric fun_info std_gen) := sorry --non-trivial
lemma new_lemma_87301 (h0 : topological_space (with_one empty)) : discrete_topology (with_one empty) := sorry --non-trivial
lemma new_lemma_87302 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87303 (h0 : has_mem.mem (with_one (has_top empty)) has_zero.zero) : @discrete_topology.{0} (with_one.{0} (has_top.{0} empty)) (@multiset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87304 (h0 : fin has_zero.zero) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (normed_lattice_add_comm_group.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_87305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inv nat)) := sorry --non-trivial
lemma new_lemma_87306 (h0 : cancel_comm_monoid_with_zero (has_neg (add_comm_monoid name))) : unique_factorization_monoid (has_neg (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_87307 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_pos_part pos))) : archimedean (complete_distrib_lattice (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_87308 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @irreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_87309 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra)) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_87310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87311 (h1 : ring (has_add char)) : is_domain (has_add char) := sorry --non-trivial
lemma new_lemma_87312 (h5 : topological_space (mul_one_class environment.projection_info)) : totally_disconnected_space (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_87313 (h0 : functor.add_const (complete_lattice (has_to_string environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_87314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87315 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_Inf (comm_semigroup real)))) : unique_factorization_monoid (ordered_comm_ring (has_Inf (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_87316 (h0 : complete_lattice (denumerable string_imp)) : is_atomistic (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_87317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_87318 (h0 : ring (has_to_string fun_info)) : strong_rank_condition (has_to_string fun_info) := sorry --non-trivial
lemma new_lemma_87319 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_87320 (h0 : functor.comp ring boolean_algebra.core name) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_87321 (h0 : ring (has_dist (comm_monoid unsigned))) : strong_rank_condition (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_87322 (h0 : monoid (monoid ennreal)) : monoid.fg (monoid ennreal) := sorry --non-trivial
lemma new_lemma_87323 (h0 : add_group (uniform_space (uniform_space string_imp))) : is_add_cyclic (uniform_space (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_87324 (h0 : ring (option (semiring empty))) : is_principal_ideal_ring (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_87325 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_87326 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87327 (h0 : functor.add_const Prop (complete_distrib_lattice (finset Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_87328 (h0 : topological_space (has_bot (has_bot real))) : totally_separated_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_87329 (h0 : group (monoid ennreal)) : group.fg (monoid ennreal) := sorry --non-trivial
lemma new_lemma_87330 (h0 : group (has_add (has_nnnorm linarith.ineq))) : is_cyclic (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_87331 (h0 : functor.add_const (functor.comp ring add_comm_monoid name) unsigned) : @rank_condition.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0} name) unsigned h0)))  := sorry --non-trivial
lemma new_lemma_87332 (h0 : functor.add_const (ring (add_comm_monoid Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87333 (h0 : complete_lattice (partial_order (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_87334 (h0 : has_coe (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) Prop) (h1 : nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} (add_comm_semigroup.{0} linarith.ineq))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_87335 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87336 (h0 : has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_87337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_87338 (h0 : topological_space (partial_order (semiring num))) : discrete_topology (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_87339 (h0 : functor.comp topological_space has_nndist pos) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_87340 (h0 : group (has_add Type)) : group.fg (has_add Type) := sorry --non-trivial
lemma new_lemma_87341 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87342 (h0 : functor.add_const Prop (ordered_comm_monoid pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_87343 (h0 : function.extfun Type (prod (linear_ordered_field empty))) : id_rel (function.extfun_app h0 (linear_ordered_field empty)) := sorry --non-trivial
lemma new_lemma_87344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_87345 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @discrete_topology.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) Type)  := sorry --non-trivial
lemma new_lemma_87346 (h0 : has_zero (monoid_with_zero ennreal) -> has_zero (monoid_with_zero ennreal) -> Prop) : is_symm (has_zero (monoid_with_zero ennreal)) h0 := sorry --non-trivial
lemma new_lemma_87347 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : regular_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_87348 (h0 : semiring (has_ssubset environment.projection_info)) (h1 : ideal (has_ssubset environment.projection_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_87349 (h0 : functor.add_const (topological_space (boolean_algebra (ring (has_nndist (finset linarith.comp))))) (finset pos)) : @locally_compact_space.{0} (boolean_algebra.{0} (ring.{0} (has_nndist.{0} (finset.{0} linarith.comp)))) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} (ring.{0} (has_nndist.{0} (finset.{0} linarith.comp))))) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87350 (h0 : functor.add_const (monoid (has_to_string environment.implicit_infer_kind)) (finset pos)) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87351 (h0 : group (has_bot (has_Inf (has_add pos)))) : group.fg (has_bot (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_87352 (h0 : list (complete_distrib_lattice (has_nndist name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_87353 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (semigroup (add_comm_monoid Type)))) : archimedean (complete_distrib_lattice (semigroup (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_87354 (h0 : functor.add_const (ring (has_nndist name)) pos) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_87355 (h0 : topological_space (is_R_or_C (semiring (semiring empty)))) : loc_path_connected_space (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_87356 (h1 : topological_space (topological_space to_additive.value_type)) : path_connected_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87357 (h0 : topological_space (ordered_comm_monoid pos)) : path_connected_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_87358 (h0 : monoid (metric_space (semiring (semiring linarith.comp)))) : monoid.fg (metric_space (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_87359 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid num)) num) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_87360 (h0 : not (complete_lattice congr_arg_kind -> false)) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@classical.by_contradiction'.{1} (complete_lattice.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_87361 (h0 : filter (add_monoid fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87362 (h0 : not (ring (add_monoid (linear_ordered_add_comm_group linarith.ineq)) -> false)) : @is_domain.{0} (add_monoid.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} (linear_ordered_add_comm_group.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_87363 (h0 : filter (has_neg (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87364 (h0 : topological_space (has_Inf (finset linarith.comp))) : t0_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_87365 (h0 : functor.add_const (list (ring Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87366 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @normal_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87367 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (sub_neg_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_87368 (h1 : complete_lattice (has_lt std_gen)) : complete_lattice.is_Sup_finite_compact (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_87369 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add (has_add Type)))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_87370 (h0 : complete_lattice (cancel_monoid (option (option (option num))))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_87371 (h0 : functor.add_const (list (add_cancel_monoid Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87372 (h1 h2 : multiset (normed_field environment.projection_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_87373 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @normal_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_87374 (h1 : add_group (semi_normed_comm_ring linarith.ineq)) : is_add_cyclic (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_87375 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @totally_separated_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_87376 (h0 : topological_space (ring name)) : irreducible_space (ring name) := sorry --non-trivial
lemma new_lemma_87377 (h0 : topological_space (bin_tree congr_arg_kind)) : totally_separated_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87378 (h0 : monoid (left_cancel_semigroup num)) : monoid.fg (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_87379 (h0 : functor.add_const (topological_space (monoid_with_zero pos)) pos) : @t0_space.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_87380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87381 (h0 : not (group (normed_field (random_gen reducibility_hints)) -> false)) : @is_cyclic.{0} (normed_field.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_87382 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid name))) : preirreducible_space (canonically_linear_ordered_monoid (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_87383 (h0 : complete_lattice (has_zero (has_add (has_add linarith.comp)))) : is_compactly_generated (has_zero (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_87384 (h0 : group (linear_ordered_add_comm_group (random_gen linarith.ineq))) : group.fg (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_87385 (h0 : ordered_add_comm_monoid (preorder congr_arg_kind)) : archimedean (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87386 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_87387 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : t0_space (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87388 (h0 : functor.add_const (group (comm_group Type)) unsigned) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87389 (h0 : ring (finset (boolean_algebra Type))) : is_domain (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_87390 (h0 : group (with_one empty)) : normalizer_condition (with_one empty) := sorry --non-trivial
lemma new_lemma_87391 (h1 : filter (has_top (has_inv to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_87392 (h0 : not (add_group (has_dist fun_info) -> false)) : @is_add_cyclic.{0} (has_dist.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_dist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_87393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_87394 (h0 : topological_space (uniform_space.core (has_bot (has_Inf (has_Inf real))))) : sequential_space (uniform_space.core (has_bot (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_87395 (h0 : topological_space (semi_normed_ring (has_lt reducibility_hints))) : path_connected_space (semi_normed_ring (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_87396 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87397 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87398 (h0 : complete_lattice (has_top (has_norm (has_top (has_top (has_top empty)))))) : is_compactly_generated (has_top (has_norm (has_top (has_top (has_top empty))))) := sorry --non-trivial
lemma new_lemma_87399 (h0 : functor.add_const (topological_space (finset name)) (finset environment.implicit_infer_kind)) : @sequential_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_87400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_87401 (h0 : group (normed_comm_ring linarith.comp)) : is_cyclic (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_87402 (h0 : list (boolean_algebra.core (measurable_space Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87403 (h1 : filter (fintype (random_gen (random_gen char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_87404 (h0 : uniform_space (comm_group name)) : complete_space (comm_group name) := sorry --non-trivial
lemma new_lemma_87405 (h0 : ring (has_lt (has_nnnorm enat))) : rank_condition (has_lt (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_87406 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : totally_disconnected_space nnreal := sorry --non-trivial
lemma new_lemma_87407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87408 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87409 (h0 : topological_space (comm_group (boolean_algebra.core (has_neg ennreal)))) : locally_compact_space (comm_group (boolean_algebra.core (has_neg ennreal))) := sorry --non-trivial
lemma new_lemma_87410 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @irreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87411 (h0 : cancel_comm_monoid_with_zero (has_bot (option unsigned))) : unique_factorization_monoid (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_87412 (h0 : functor.comp complete_lattice has_neg Type) : @is_atomistic.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_87413 (h0 : ordered_add_comm_monoid (has_to_string (ring unsigned))) : archimedean (has_to_string (ring unsigned)) := sorry --non-trivial
lemma new_lemma_87414 (h0 : topological_space (add_cancel_monoid (normed_comm_ring (finset Type)))) : path_connected_space (add_cancel_monoid (normed_comm_ring (finset Type))) := sorry --non-trivial
lemma new_lemma_87415 (h0 : functor.add_const (finset (free_add_monoid unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87416 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_87417 (h0 : topological_space (ordered_comm_ring pos)) : normal_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_87418 (h0 : complete_lattice (dlist (random_gen (random_gen (random_gen to_additive.value_type))))) : is_compactly_generated (dlist (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_87419 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87420 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_87421 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @path_connected_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_87422 (h0 : topological_space (with_one to_additive.value_type)) : path_connected_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87423 (h0 : fin has_zero.zero) : @preconnected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_87425 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_87427 (h0 : ordered_comm_monoid (ring (has_neg (ring (ring (has_neg name)))))) : has_exists_mul_of_le (ring (has_neg (ring (ring (has_neg name))))) := sorry --non-trivial
lemma new_lemma_87428 (h0 : ordered_comm_monoid (monoid pos)) : has_exists_mul_of_le (monoid pos) := sorry --non-trivial
lemma new_lemma_87429 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87430 (h0 : topological_space (comm_ring string_imp)) : totally_disconnected_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_87431 (h0 : uniform_space (has_bot unsigned)) (h1 : topological_space (uniform_space.separation_quotient (has_bot unsigned))) : totally_separated_space (uniform_space.separation_quotient (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_87432 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_87433 (h0 : add_monoid (has_bot (option empty))) : add_monoid.fg (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_87434 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg Type)) : @path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_87435 (h0 : ring (has_dist num)) : is_principal_ideal_ring (has_dist num) := sorry --non-trivial
lemma new_lemma_87436 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87437 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87438 (h0 : group (id (semiring (semiring linarith.comp)))) : group.fg (id (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_87439 (h0 : functor.add_const (add_monoid (has_add pos)) pos) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_87440 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_Inf.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_87441 (h0 : uniform_space (dlist to_additive.value_type)) : complete_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87442 (h0 : functor.comp topological_space has_neg linarith.comp) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87443 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_87444 (h0 : complete_lattice (with_bot (has_inv (random_gen linarith.comp_source)))) : is_compactly_generated (with_bot (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_87445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_87446 (h0 : topological_space (finset (has_to_string (has_to_string linarith.comp)))) : preirreducible_space (finset (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_87447 (h0 : functor.add_const (ring (as_linear_order empty)) num) : @is_domain.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_87448 (h0 : functor.add_const (topological_space (finset Type)) Type) : @t1_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_87449 (h0 : functor.add_const (list (complete_distrib_lattice Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87450 (h0 : ring (group_with_zero num)) : is_domain (group_with_zero num) := sorry --non-trivial
lemma new_lemma_87451 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : topological_space.separable_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87452 (h0 : ordered_comm_monoid (cancel_monoid (pseudo_metric_space pos))) : has_exists_mul_of_le (cancel_monoid (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_87453 (h0 : function.extfun Type (functor.add_const (topological_space (complete_distrib_lattice name)))) : @path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_87454 (h0 : ring (preorder (option empty))) : is_principal_ideal_ring (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_87455 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87456 (h0 : add_monoid (has_Inf (boolean_algebra (boolean_algebra linarith.comp)))) : add_monoid.fg (has_Inf (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_87457 (h0 : list (semigroup (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87458 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid ennreal)) (option (has_zero (option ennreal)))) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) (option.{0} (has_zero.{0} (option.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_87459 (h0 : function.extfun (((finset Type -> Prop) -> Prop) -> Prop) (function.extfun ((finset Type -> Prop) -> Prop))) : @strong_rank_condition.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) (@function.extfun_app.{2 0} (((finset.{1} Type → Prop) → Prop) → Prop) (function.extfun.{2 0} ((finset.{1} Type → Prop) → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type → Prop))) (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_87460 (h0 : group (canonically_ordered_monoid (sub_neg_monoid (ordered_comm_monoid real)))) : is_cyclic (canonically_ordered_monoid (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_87461 (h0 : list (boolean_algebra (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87462 (h0 : topological_space (has_ssubset ereal)) (h1 : preorder (has_ssubset ereal)) : order_closed_topology (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_87463 (h0 : topological_space (ordered_ring unsigned)) : totally_separated_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_87464 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @regular_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_87465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_87466 (h0 : uniform_space (normed_comm_ring num)) : separated_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_87467 (h0 : topological_space (has_bot (has_Inf Type))) : preirreducible_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_87468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_87469 (h1 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h1) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_87470 (h0 : uniform_space (add_cancel_monoid num)) : complete_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_87471 (h0 : has_lt (has_compl enat)) : no_max_order (has_compl enat) := sorry --non-trivial
lemma new_lemma_87472 (h0 : list (has_ssubset (has_ssubset (has_ssubset (comm_ring linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87473 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87474 (h0 : ring (normed_field ereal)) : rank_condition (normed_field ereal) := sorry --non-trivial
lemma new_lemma_87475 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inter.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_87476 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87477 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_87478 (h0 : ring (with_bot fun_info)) : rank_condition (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_87479 (h0 : ring (nondiscrete_normed_field char)) : strong_rank_condition (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_87480 (h1 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @complete_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_87481 (h0 : functor.add_const (monoid (boolean_algebra real)) real) : @monoid.fg.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_87482 (h0 : functor.add_const (finset (has_add unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87483 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87484 (h0 : filter (has_top (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87485 (h0 : add_group (has_ssubset (multiplicative enat))) : is_add_cyclic (has_ssubset (multiplicative enat)) := sorry --non-trivial
lemma new_lemma_87486 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @t0_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_87487 (h0 : group (normed_group (random_gen (random_gen num)))) : normalizer_condition (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_87488 (h0 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup fun_info))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_87489 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87490 (h0 : topological_space (has_norm (comm_ring fun_info))) : t0_space (has_norm (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_87491 (h0 : uniform_space (add_cancel_monoid (has_neg_part Type))) : separated_space (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_87492 (h0 : set (linear_ordered_comm_group_with_zero fun_info -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_87493 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @locally_compact_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_87494 (h0 : topological_space (has_pos_part (has_add (has_Inf linarith.comp)))) : totally_separated_space (has_pos_part (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_87495 (h0 : functor.add_const (finset (complete_linear_order unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87496 (h0 : list (has_top (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87497 (h0 : ring (has_norm (random_gen linarith.comp))) : strong_rank_condition (has_norm (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_87498 (h0 : uniform_space (measurable_space char)) : complete_space (measurable_space char) := sorry --non-trivial
lemma new_lemma_87499 (h1 : group (has_compl fun_info)) : group.fg (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_87500 (h0 : add_group (has_zero (mul_one_class Type))) : is_add_cyclic (has_zero (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_87501 (h0 : decidable_eq (lex num)) (h1 : equiv.perm (lex num)) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_87502 (h0 : group (denumerable string.iterator_imp)) : is_cyclic (denumerable string.iterator_imp) := sorry --non-trivial
lemma new_lemma_87503 (h0 : topological_space (preorder (option unsigned))) : t1_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_87504 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_87505 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_87506 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87507 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : t0_space (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_87508 (h0 : topological_space (ring (has_neg linarith.comp))) : normal_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_87509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87510 (h0 : add_group real) : is_add_cyclic real := sorry --non-trivial
lemma new_lemma_87511 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_87512 (h1 : topological_space (semi_normed_ring reducibility_hints)) : totally_disconnected_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_87513 (h0 : not (group (fintype char) -> false)) : @is_cyclic.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_87514 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf Type))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_87515 (h0 : topological_space (linear_ordered_semiring (has_norm num))) : locally_compact_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_87516 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_87517 (h0 : not (topological_space (has_top (random_gen linarith.comp_source)) -> false)) : @t0_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_87518 (h0 : add_group (fintype fun_info)) : is_add_cyclic (fintype fun_info) := sorry --non-trivial
lemma new_lemma_87519 (h1 : ring (fintype char)) : strong_rank_condition (fintype char) := sorry --non-trivial
lemma new_lemma_87520 (h0 : not (complete_lattice (preorder empty) -> false)) : @is_compactly_generated.{0} (preorder.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (preorder.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87521 (h0 : set (string.iterator_imp -> mul_one_class (add_comm_semigroup ereal))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_87522 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_Inf name)))) : @t1_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_Inf.{0} name))) h0 Type))  := sorry --non-trivial
lemma new_lemma_87523 (h0 : ring (has_union (semiring (semiring unsigned)))) : strong_rank_condition (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_87524 (h0 : group (distrib fun_info)) : is_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_87525 (h0 : topological_space (finset (finset (finset (finset linarith.comp))))) : discrete_topology (finset (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_87526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87527 (h0 : group (canonically_linear_ordered_monoid pos)) : group.fg (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_87528 (h0 : complete_lattice (add_cancel_comm_monoid char)) : is_compactly_generated (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_87529 (h0 : topological_space (add_group linarith.comp)) : irreducible_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_87530 (h0 : list (has_Inf (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87531 (h0 : topological_space (id (has_norm (has_norm num)))) : totally_disconnected_space (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_87532 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (boolean_algebra.core Type))) : unique_factorization_monoid (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_87533 (h1 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @path_connected_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_87534 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87535 (h0 : fin has_zero.zero) : @discrete_topology.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87536 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : totally_separated_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87537 (h0 : not (complete_lattice (mul_one_class to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_87538 (h0 : complete_lattice (has_div (has_compl char))) : is_compactly_generated (has_div (has_compl char)) := sorry --non-trivial
lemma new_lemma_87539 (h0 : topological_space (boolean_algebra (has_add (has_Inf (finset Type))))) : topological_space.separable_space (boolean_algebra (has_add (has_Inf (finset Type)))) := sorry --non-trivial
lemma new_lemma_87540 (h0 : topological_space (with_one (has_inv (bin_tree (boolean_algebra (boolean_algebra string_imp)))))) : path_connected_space (with_one (has_inv (bin_tree (boolean_algebra (boolean_algebra string_imp))))) := sorry --non-trivial
lemma new_lemma_87541 (h0 : ordered_comm_monoid (finset (generalized_boolean_algebra pos))) : has_exists_mul_of_le (finset (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_87542 (h1 : has_le (nondiscrete_normed_field fun_info)) (h2 : nondiscrete_normed_field fun_info) : is_max h2 := sorry --non-trivial
lemma new_lemma_87543 (h0 : functor.add_const (ring (has_to_string name)) Type) : @rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_87544 (h0 : ordered_comm_monoid (comm_semigroup (sub_neg_monoid real))) : has_exists_mul_of_le (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_87545 (h1 : set (char -> mul_one_class enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_87546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_87547 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @irreducible_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_87548 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_87549 (h0 : group (topological_space (mul_one_class char))) : is_cyclic (topological_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_87550 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87551 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) ennreal) : @strong_rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_87552 (h0 : fin has_zero.zero) : @separated_space.{0} (has_bot.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_87553 (h0 : topological_space (finset (comm_group Type))) : regular_space (finset (comm_group Type)) := sorry --non-trivial
lemma new_lemma_87554 (h0 : not (add_group (has_sub empty) -> false)) : @is_add_cyclic.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_87555 (h0 : not (ring (encodable to_additive.value_type) -> false)) : @is_domain.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_87556 (h0 : fin has_zero.zero) : @separated_space.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87557 (h0 : cancel_comm_monoid_with_zero (add_semigroup congr_arg_kind)) : unique_factorization_monoid (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87558 (h0 : filter (canonically_ordered_comm_semiring (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_87559 (h0 : ring (add_cancel_monoid (ring (has_Inf Type)))) : is_domain (add_cancel_monoid (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_87560 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : normal_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87561 (h0 : functor.add_const (ring (has_to_string Type)) (has_neg (has_to_string environment.implicit_infer_kind))) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (has_neg.{0} (has_to_string.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_87562 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) (has_neg pos)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87563 (h0 : functor.add_const (list (has_neg_part pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87564 (h0 : topological_space (has_neg (comm_group Type))) : path_connected_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_87565 (h0 : ring (ordered_comm_ring real)) : is_domain (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_87566 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87567 (h0 : list (filter empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87568 (h0 : topological_space (ordered_comm_ring pos)) : t1_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_87569 (h0 : add_group (complete_distrib_lattice (finset pos))) : is_add_cyclic (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_87570 (h0 : uniform_space (has_emptyc (has_norm congr_arg_kind))) : separated_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87571 (h0 : functor.comp topological_space finset ennreal) : @regular_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_87572 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87573 (h0 : ring (generalized_boolean_algebra name)) : strong_rank_condition (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_87574 (h0 : group (group_with_zero (semiring (semiring (semiring unsigned))))) : normalizer_condition (group_with_zero (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_87575 (h0 : group (add_group fun_info)) : is_cyclic (add_group fun_info) := sorry --non-trivial
lemma new_lemma_87576 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_87577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87578 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) (has_add (ring pos))) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_87579 (h0 : ring (has_le (has_neg linarith.comp_source))) : rank_condition (has_le (has_neg linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_87580 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) linarith.comp) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87581 (h0 : topological_space (boolean_algebra.core (has_neg_part (has_neg_part (has_neg_part pos))))) : normal_space (boolean_algebra.core (has_neg_part (has_neg_part (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_87582 (h1 : not (topological_space (has_nnnorm string_imp) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_87583 (h0 : ring (ring (comm_group environment.implicit_infer_kind))) : is_domain (ring (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87584 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87585 (h0 : topological_space (mul_one_class enat)) (h1 : has_add (mul_one_class enat)) : has_continuous_add (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_87586 (h0 : functor.add_const (topological_space (semiring empty)) unsigned) : @t1_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87587 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87588 (h2 : topological_space (mul_one_class string.iterator_imp)) : path_connected_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_87589 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : preconnected_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_87590 (h0 : topological_space (ordered_comm_ring (has_add Type))) : locally_compact_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_87591 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_nndist (has_add ennreal)))) : archimedean (canonically_ordered_comm_semiring (has_nndist (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_87592 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (has_Sup empty)))) : @unique_factorization_monoid.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_87593 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_87594 (h0 : functor.add_const (filter (has_add Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87595 (h0 : functor.add_const (uniform_space (plift empty)) empty) : @complete_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_87596 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_87598 (h0 : complete_lattice (comm_group (semigroup Type))) : is_atomistic (comm_group (semigroup Type)) := sorry --non-trivial
lemma new_lemma_87599 (h0 : not (group (has_top num) -> false)) : @group.fg.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_87600 (h0 : add_group (semiring (semiring (semiring (semiring unsigned))))) : is_add_cyclic (semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_87601 (h0 : functor.add_const (ring (has_neg unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87602 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_87603 (h0 : ring (semi_normed_comm_ring (comm_ring char))) : is_domain (semi_normed_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_87604 (h0 : topological_space (monoid (option num))) : t0_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_87605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_87606 (h0 : functor.add_const (group (comm_group name)) pos) : @is_cyclic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_87607 (h0 : topological_space (random_gen (semiring num))) : totally_disconnected_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_87608 (h0 : functor.add_const (group Type) Type) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_87609 (h0 : function.extfun Type group) : @group.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_87610 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @regular_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_87611 (h0 : uniform_space (distrib ereal)) : complete_space (distrib ereal) := sorry --non-trivial
lemma new_lemma_87612 (h1 : not (complete_lattice (random_gen congr_arg_kind) -> false)) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_87613 (h0 : topological_space (option (semiring (semiring (semiring empty))))) : locally_compact_space (option (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_87614 (h0 : ring (normed_group (has_top (has_emptyc congr_arg_kind)))) : is_domain (normed_group (has_top (has_emptyc congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_87615 (h0 : functor.add_const (topological_space (has_Sup empty)) num) : @t0_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_87616 (h0 : group (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) : group.fg (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_87617 (h0 : topological_space (id linarith.comp)) : locally_compact_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_87618 (h0 : functor.add_const (ring (comm_monoid unsigned)) unsigned) : @is_domain.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87619 (h0 : group (has_add unsigned)) : normalizer_condition (has_add unsigned) := sorry --non-trivial
lemma new_lemma_87620 (h1 : topological_space (measurable_space string_imp)) : t0_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_87621 (h0 : metric_space (add_cancel_monoid (has_add linarith.comp))) (h1 : set (add_cancel_monoid (has_add linarith.comp))) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_87622 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : loc_path_connected_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87623 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} (has_ssubset.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} (has_ssubset.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_87624 (h0 : complete_lattice (ordered_comm_monoid (sub_neg_monoid real))) : is_compactly_generated (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_87625 (h0 : ring (normed_group string_imp)) : is_domain (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_87626 (h0 : topological_space (has_lt (mul_one_class (mul_one_class reducibility_hints)))) : totally_disconnected_space (has_lt (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_87627 (h0 : ring (ordered_comm_monoid name)) : is_principal_ideal_ring (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_87628 (h0 : ring (semiring (semiring (semiring (metric_space num))))) : is_domain (semiring (semiring (semiring (metric_space num)))) := sorry --non-trivial
lemma new_lemma_87629 (h0 : add_group (with_zero (with_one char))) : is_add_cyclic (with_zero (with_one char)) := sorry --non-trivial
lemma new_lemma_87630 (h0 : functor.add_const (topological_space bool) unsigned) : path_connected_space bool := sorry --non-trivial
lemma new_lemma_87631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_87632 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring num))) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_87633 (h0 : functor.add_const (group (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @group.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_87634 (h0 : monoid (has_norm (has_top unsigned))) : monoid.fg (has_norm (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_87635 (h0 : list (linear_ordered_field unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87636 (h0 : group (canonically_linear_ordered_monoid (has_add (has_add real)))) : group.fg (canonically_linear_ordered_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_87637 (h0 : function.extfun Type group) : @is_cyclic.{0} name (@function.extfun_app.{2 1} Type group.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_87638 (h0 : topological_space (normed_field enat)) (h1 : add_group (normed_field enat)) : topological_add_group (normed_field enat) := sorry --non-trivial
lemma new_lemma_87639 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_emptyc.{0} (has_norm.{0} (has_inv.{0} (has_norm.{0} linarith.comp_source)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} (has_norm.{0} (has_inv.{0} (has_norm.{0} linarith.comp_source)))))  := sorry --non-trivial
lemma new_lemma_87642 (h0 : functor.add_const (topological_space (has_zero Type)) (has_neg (has_neg (has_zero Type)))) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) (has_neg.{1} (has_neg.{1} (has_zero.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_87643 (h0 : functor.add_const (uniform_space (finset environment.implicit_infer_kind)) Type) : @separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_87644 (h0 : topological_space (has_add (has_neg Type))) : t0_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_87645 (h0 : topological_space (ring (finset (ring (ring Type))))) : preirreducible_space (ring (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_87646 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (has_compl.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_compl.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87647 (h0 : functor.add_const (complete_lattice (has_to_string name)) (normed_comm_ring pos)) : @is_compactly_generated.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87648 (h0 : functor.add_const (group (comm_semigroup name)) real) : @is_simple_group.{0} (comm_semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_semigroup.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_87649 (h1 : topological_space (has_inv (has_nnnorm fun_info))) : totally_disconnected_space (has_inv (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_87650 (h0 : functor.add_const (finset (has_zero Type)) (finset (has_neg linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87651 (h0 : topological_space (has_add (has_to_string (finset linarith.comp)))) : regular_space (has_add (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_87652 (h0 : complete_lattice (has_norm linarith.comp_source)) : is_compactly_generated (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_87653 (h0 : functor.add_const (group (boolean_algebra pos)) Type) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_87654 (h0 : group (has_union (semiring (semiring (with_one empty))))) : normalizer_condition (has_union (semiring (semiring (with_one empty)))) := sorry --non-trivial
lemma new_lemma_87655 (h0 : functor.add_const (group (partial_order name)) unsigned) : @is_cyclic.{0} (partial_order.{0} name) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87656 (h0 : group (fintype (has_top to_additive.value_type))) : group.fg (fintype (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87657 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string pos))) : topological_space.separable_space (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_87658 (h0 : uniform_space (add_group (has_norm (semiring num)))) : separated_space (add_group (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_87659 (h0 : not (complete_lattice (semi_normed_ring (mul_one_class linarith.comp_source)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} (mul_one_class.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} (mul_one_class.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_87660 (h1 h2 : add_comm_semigroup fun_info) : function.is_fixed_pt (fun (h0 : add_comm_semigroup fun_info), h1) h2 := sorry --non-trivial
lemma new_lemma_87661 (h0 : complete_lattice (semiring (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_87662 (h0 : function.extfun Type (functor.add_const (functor.add_const (list (free_add_monoid empty)) empty))) : list.nodup (functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty))) := sorry --non-trivial
lemma new_lemma_87663 (h0 : list (linear_ordered_field num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_87664 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_87665 (h0 : topological_space (normed_group (dlist (has_top (has_top (has_top linarith.ineq)))))) : irreducible_space (normed_group (dlist (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_87666 (h0 : add_monoid (canonically_ordered_comm_semiring pos)) : add_monoid.fg (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_87667 (h0 : uniform_space (has_inter num)) : complete_space (has_inter num) := sorry --non-trivial
lemma new_lemma_87668 (h0 : functor.add_const (finset (complete_distrib_lattice pos)) (has_neg pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87669 (h1 : filter (dlist linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_87670 (h0 : function.extfun Type group) : @group.fg.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_87671 (h0 : group (id (random_gen (random_gen (random_gen fun_info))))) : is_cyclic (id (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_87672 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : t1_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_87673 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_87674 (h0 : ring (distrib (has_ssubset (distrib to_additive.value_type)))) : is_domain (distrib (has_ssubset (distrib to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_87675 (h0 : topological_space (pseudo_emetric_space (has_neg_part unsigned))) : path_connected_space (pseudo_emetric_space (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_87676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87677 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option unsigned))) : unique_factorization_monoid (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_87678 (h0 : uniform_space (id linarith.ineq)) : complete_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_87679 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87680 (h0 : topological_space (simple_graph (option (option unsigned)))) : discrete_topology (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_87681 (h0 : finset (option (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_87682 (h0 : functor.add_const (topological_space (ring pos)) (ring (boolean_algebra Type))) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (ring.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87683 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87684 (h0 : uniform_space (semiring (has_top (has_top (has_top fun_info))))) : separated_space (semiring (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_87685 (h0 : topological_space (ordered_ring (semiring (semiring num)))) : t1_space (ordered_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_87686 (h0 : uniform_space (has_zero (has_to_string linarith.comp))) : separated_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_87687 (h0 : functor.add_const (group (add_comm_monoid pos)) (comm_group name)) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_87688 (h0 : functor.add_const (ring nnreal) empty) : @rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_87689 (h0 : add_group (pseudo_emetric_space fun_info)) : is_add_cyclic (pseudo_emetric_space fun_info) := sorry --non-trivial
lemma new_lemma_87690 (h0 : topological_space (has_norm (has_norm fun_info))) : path_connected_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_87691 (h0 : group (add_cancel_monoid empty)) : normalizer_condition (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_87692 (h0 : functor.add_const (topological_space (plift empty)) num) : @t1_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_87693 (h0 : functor.add_const (group (has_zero linarith.comp)) pos) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_87694 (h0 : topological_space (cancel_comm_monoid_with_zero linarith.ineq)) (h1 : preorder (cancel_comm_monoid_with_zero linarith.ineq)) : order_closed_topology (cancel_comm_monoid_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_87695 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_87696 (h0 h1 : comm_ring (has_inv (random_gen string_imp))) : is_distinct (comm_ring (has_inv (random_gen string_imp))) h0 h1 := sorry --non-trivial
lemma new_lemma_87697 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid Type))) : preirreducible_space (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_87698 (h0 : topological_space (random_gen congr_arg_kind)) : totally_disconnected_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87699 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_Inf (sub_neg_monoid (has_add (has_Inf Type)))))) : unique_factorization_monoid (has_pos_part (has_Inf (sub_neg_monoid (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_87700 (h0 : functor.add_const (topological_space (ring name)) name) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_87701 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_87702 (h0 : functor.add_const (finset (has_to_string linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87703 (h0 : group (with_bot (semiring (semiring (semiring congr_arg_kind))))) : normalizer_condition (with_bot (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_87704 (h0 : ring (non_unital_non_assoc_semiring (option unsigned))) : is_domain (non_unital_non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_87705 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : preirreducible_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_87706 (h0 : topological_space (boolean_algebra.core (has_add Type))) : totally_separated_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_87707 (h0 : topological_space (has_add (sub_neg_monoid real))) : preconnected_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_87708 (h0 : prod (boolean_algebra.core (has_nndist pos)) (boolean_algebra.core (has_nndist pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_87709 (h1 : not (topological_space (normed_field string_imp) -> false)) : @t0_space.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_87710 (h0 : topological_space (metric_space (has_norm (has_norm congr_arg_kind)))) : totally_disconnected_space (metric_space (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_87711 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_87712 (h0 : ordered_comm_monoid (finset (option ennreal))) : has_exists_mul_of_le (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_87713 (h0 : functor.add_const (topological_space (mul_zero_class Type)) unsigned) : @t1_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87714 (h0 : functor.add_const Prop (measure_theory.measure_space (add_right_cancel_monoid empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_87715 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (boolean_algebra.core (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_87716 (h0 : not (uniform_space (has_norm linarith.comp) -> false)) : @separated_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87717 (h0 : functor.add_const (ring (add_comm_monoid (has_to_string name))) pos) : @rank_condition.{0} (add_comm_monoid.{0} (has_to_string.{0} name)) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} (has_to_string.{0} name))) pos h0)  := sorry --non-trivial
lemma new_lemma_87718 (h0 : topological_space (has_norm (has_top congr_arg_kind))) : path_connected_space (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87719 (h2 : not (uniform_space (has_nnnorm char) -> false)) : @complete_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_87720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87721 (h0 : monoid (finset (has_add Type))) : monoid.fg (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_87722 (h0 : topological_space (has_pos_part (has_add (has_add (has_add linarith.comp))))) : preirreducible_space (has_pos_part (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_87723 (h0 h1 : multiset enat) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_87724 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87725 (h1 : ring (has_norm fun_info)) : strong_rank_condition (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_87726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_87727 (h0 : topological_space (has_union linarith.comp)) : irreducible_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_87728 (h0 : uniform_space (complete_semilattice_Sup (semiring (semiring (semiring (semiring unsigned)))))) : separated_space (complete_semilattice_Sup (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_87729 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_87730 (h0 : topological_space (generalized_boolean_algebra (has_to_string linarith.comp))) : t0_space (generalized_boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_87731 (h0 h1 : multiset (nondiscrete_normed_field fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_87732 (h0 : group (normed_comm_ring (has_to_string num))) : group.fg (normed_comm_ring (has_to_string num)) := sorry --non-trivial
lemma new_lemma_87733 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add pos))) : unique_factorization_monoid (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_87734 (h0 : semiring (ordered_comm_ring (has_add (has_add Type)))) : is_noetherian_ring (ordered_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_87735 (h0 : complete_lattice (with_zero char)) : is_compactly_generated (with_zero char) := sorry --non-trivial
lemma new_lemma_87736 (h0 : topological_space (sub_neg_monoid linarith.comp)) : t0_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_87737 (h0 : uniform_space (random_gen (comm_ring (random_gen fun_info)))) : complete_space (random_gen (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_87738 (h0 : ring (has_norm (has_top (random_gen to_additive.value_type)))) : strong_rank_condition (has_norm (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_87739 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_87740 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_87741 (h0 : function.extfun Type (functor.add_const (list (linear_order unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_87742 (h0 : ordered_add_comm_monoid (has_add (has_neg_part name))) : archimedean (has_add (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_87743 (h0 : ring (finset (finset (finset Type)))) : strong_rank_condition (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_87744 (h0 : ring (semigroup (has_neg (has_pos_part linarith.comp)))) : is_domain (semigroup (has_neg (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_87745 (h0 : complete_lattice (ring (option (option (option ennreal))))) : is_atomistic (ring (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_87746 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_neg Type)) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_87747 (h0 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_87748 (h0 : ring (linear_ordered_comm_ring empty)) : rank_condition (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_87749 (h1 : not (ring linarith.comp_source -> false)) : @strong_rank_condition.{0} linarith.comp_source (@classical.by_contradiction'.{1} (ring.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_87750 (h0 : topological_space enat) (h1 : set enat) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_87751 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_domain.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_87752 (h0 : uniform_space (bin_tree congr_arg_kind)) : separated_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87753 (h0 : complete_lattice (has_Sup (option empty))) : is_compactly_generated (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_87754 (h0 : topological_space (free_add_monoid (option (option unsigned)))) : topological_space.separable_space (free_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_87755 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_87756 (h0 : group (non_assoc_semiring (semiring unsigned))) : is_cyclic (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_87757 (h0 : functor.add_const (monoid (simple_graph linarith.comp)) pos) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_87758 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) (has_neg (boolean_algebra (has_neg Type)))) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} (boolean_algebra.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_87759 (h0 : fin has_zero.zero) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87760 (h0 : complete_lattice (partial_order (semiring num))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_87761 (h1 : add_group (has_ssubset std_gen)) : is_add_cyclic (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_87762 (h0 : complete_lattice (add_left_cancel_monoid linarith.ineq)) : is_compactly_generated (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_87763 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_87764 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : totally_separated_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_87765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87766 (h0 : complete_lattice Type) : is_compactly_generated Type := sorry --non-trivial
lemma new_lemma_87767 (h0 : functor.add_const (ring (has_nndist linarith.comp)) Type) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_87768 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_87769 (h1 : ring (normed_group (has_inv string_imp))) : is_domain (normed_group (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_87770 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @is_domain.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_87771 (h0 : list (add_cancel_monoid (has_neg name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_87772 (h0 : group (ordered_add_comm_group to_additive.value_type)) : is_cyclic (ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87773 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) Type) : @is_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_87774 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_87775 (h1 : complete_lattice (has_top (has_norm congr_arg_kind))) : is_atomistic (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87776 (h0 : complete_lattice (has_nndist (option empty))) : complete_lattice.is_Sup_finite_compact (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_87777 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_87778 (h0 : add_monoid (metric_space unsigned)) : add_monoid.fg (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_87779 (h0 : group (boolean_algebra (has_Inf (has_Inf real)))) : normalizer_condition (boolean_algebra (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_87780 (h0 : complete_lattice (ordered_comm_monoid (sub_neg_monoid real))) : is_atomistic (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_87781 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_87782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87783 (h0 : cancel_comm_monoid_with_zero (semigroup (has_to_string pos))) : unique_factorization_monoid (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_87784 (h0 : topological_space (has_nndist (has_neg_part name))) : totally_separated_space (has_nndist (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_87785 (h0 : ring (ordered_comm_group congr_arg_kind)) : rank_condition (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87786 (h0 : list (has_pos_part (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87787 (h0 : add_group (has_append string_imp)) : is_add_cyclic (has_append string_imp) := sorry --non-trivial
lemma new_lemma_87788 (h0 : ring (has_norm (has_top fun_info))) : is_domain (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_87789 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_87790 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : normal_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_87791 (h0 : functor.add_const (list (cancel_monoid Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87792 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_87793 (h0 : has_mem.mem (with_one (has_top congr_arg_kind)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} (has_top.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_87794 (h0 : topological_space (has_nndist (has_pos_part Type))) : preconnected_space (has_nndist (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_87795 (h0 : group (measurable_space.dynkin_system (has_top unsigned))) : normalizer_condition (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_87796 (h0 : not (finset (bin_tree empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_87797 (h0 : functor.add_const (topological_space (semigroup unsigned)) (finset environment.implicit_infer_kind)) : @totally_separated_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_87798 (h0 : functor.comp topological_space ring linarith.comp) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87799 (h0 : functor.add_const (function.extfun (Type 1) list) environment.implicit_infer_kind) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_87800 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87801 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87802 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @separated_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_87803 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_87804 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (ordered_comm_ring (ring pos)))) : archimedean (ordered_comm_monoid (ordered_comm_ring (ring pos))) := sorry --non-trivial
lemma new_lemma_87805 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : preirreducible_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87806 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf linarith.comp))) : normal_space (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_87807 (h0 : uniform_space (semiring (has_top congr_arg_kind))) : separated_space (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87808 (h0 : ring (ordered_cancel_add_comm_monoid ennreal)) : is_domain (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_87809 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_87810 (h0 : fin has_zero.zero) : @normal_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_87811 (h0 : topological_space (ordered_comm_monoid (has_pos_part (boolean_algebra pos)))) : t0_space (ordered_comm_monoid (has_pos_part (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_87812 (h0 : empty -> empty -> empty) : is_right_cancel empty h0 := sorry --non-trivial
lemma new_lemma_87813 (h0 : topological_space (fintype char)) : t0_space (fintype char) := sorry --non-trivial
lemma new_lemma_87814 (h0 : functor.add_const (uniform_space (complete_linear_order num)) num) : @complete_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_87815 (h0 : group (bin_tree (semiring congr_arg_kind))) : is_cyclic (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_87817 (h0 : uniform_space (generalized_boolean_algebra (ring (finset (has_add pos))))) : separated_space (generalized_boolean_algebra (ring (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_87818 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : totally_disconnected_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_87819 (h0 : topological_space (finset (has_nndist (boolean_algebra.core Type)))) : preirreducible_space (finset (has_nndist (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_87820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_87821 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_87822 (h0 : add_group (has_top (has_norm linarith.comp_source))) : is_add_cyclic (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_87823 (h0 : functor.add_const (monoid (has_Inf pos)) Type) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_87824 (h0 : ring (has_add congr_arg_kind)) : is_principal_ideal_ring (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87825 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_87826 (h0 : functor.add_const (uniform_space (mul_one_class linarith.comp)) (mul_one_class pos)) : @separated_space.{0} (mul_one_class.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_one_class.{0} linarith.comp)) (mul_one_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87827 (h0 : topological_space (comm_group (mul_zero_class Type))) : sequential_space (comm_group (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_87828 (h0 : add_monoid (has_add (has_Inf linarith.comp))) : add_monoid.fg (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_87829 (h0 : ring (fintype (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_87830 (h0 : add_group (with_one (semiring num))) : is_add_cyclic (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_87831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_87832 (h0 : topological_space (sub_neg_monoid name)) : locally_compact_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_87833 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_87834 (h0 : add_comm_monoid (add_comm_monoid num) -> add_comm_monoid (add_comm_monoid num) -> Prop) : is_symm (add_comm_monoid (add_comm_monoid num)) h0 := sorry --non-trivial
lemma new_lemma_87835 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87836 (h0 : functor.add_const (functor.add_const (topological_space (has_star empty)) num) congr_arg_kind) : @loc_path_connected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} empty)) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_87837 (h0 : functor.add_const (monoid (has_edist empty)) congr_arg_kind) : @monoid.fg.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_87838 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) num) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_87839 (h0 : function.extfun Type (functor.add_const (complete_lattice ennreal))) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_87840 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_87841 (h0 : topological_space (has_to_string (has_zero name))) : preconnected_space (has_to_string (has_zero name)) := sorry --non-trivial
lemma new_lemma_87842 (h0 : uniform_space (semigroup (ring pos))) : separated_space (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_87843 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @t0_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_87844 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_87845 (h1 : measurable_space (has_compl std_gen)) (h2 : filter (has_compl std_gen)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_87846 (h0 : function.extfun Type (functor.add_const (topological_space (ring linarith.comp)))) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} linarith.comp))) h0 (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_87847 (h0 : functor.add_const (add_monoid (finset pos)) name) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_87848 (h0 : uniform_space (non_assoc_semiring unsigned)) : separated_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_87849 (h1 : multiset (topological_space (with_bot to_additive.value_type))) : @totally_disconnected_space.{0} (with_bot.{0} to_additive.value_type) (@multiset.inf.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (with_bot.{0} to_additive.value_type))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@preorder.to_has_le.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@partial_order.to_preorder.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (with_bot.{0} to_additive.value_type)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (with_bot.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (with_bot.{0} to_additive.value_type)))) h1)  := sorry --non-trivial
lemma new_lemma_87850 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) empty) : @rank_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_87851 (h0 : topological_space (has_neg (has_add Type))) : preconnected_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_87852 (h0 : uniform_space (has_pos_part (has_bot real))) : complete_space (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_87853 (h0 : functor.add_const (ring (has_neg_part name)) unsigned) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_87854 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_87855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_87856 (h3 : ring (semi_normed_ring to_additive.value_type)) : rank_condition (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87857 (h0 : ring (normed_comm_ring (finset (has_nndist (has_pos_part (has_neg (finset linarith.comp))))))) : is_domain (normed_comm_ring (finset (has_nndist (has_pos_part (has_neg (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_87858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87859 (h0 : ordered_add_comm_monoid (plift unsigned)) : archimedean (plift unsigned) := sorry --non-trivial
lemma new_lemma_87860 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_87861 (h0 : functor.add_const (list (comm_group pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87862 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87863 (h0 : topological_space (measurable_space congr_arg_kind)) : locally_compact_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87864 (h0 h1 : multiset (has_compl enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_87865 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_87866 (h0 : functor.comp topological_space add_cancel_monoid pos) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_87867 (h0 : topological_space (has_zero (has_add (has_add (has_add unsigned))))) : preirreducible_space (has_zero (has_add (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_87868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_87869 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_87870 (h0 : topological_space (has_nndist linarith.comp)) : topological_space.separable_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_87871 (h0 : list (has_top (has_nnnorm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87872 (h0 : monoid (with_bot (has_inv linarith.ineq))) : monoid.fg (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_87873 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_domain.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_87874 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_87875 (h0 : functor.add_const Prop (has_to_string pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_87876 (h0 : add_monoid (filter (semiring (semiring (semiring unsigned))))) : add_monoid.fg (filter (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_87877 (h0 : add_monoid (simple_graph (ring (ring Type)))) : add_monoid.fg (simple_graph (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_87878 (h0 : functor.add_const (topological_space Type) (has_add real)) : @irreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_add.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_87879 (h0 : topological_space (left_cancel_monoid empty)) : discrete_topology (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_87880 (h0 : complete_lattice (canonically_ordered_monoid (generalized_boolean_algebra (has_bot real)))) : is_compactly_generated (canonically_ordered_monoid (generalized_boolean_algebra (has_bot real))) := sorry --non-trivial
lemma new_lemma_87881 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_87882 (h0 : not (complete_lattice (with_zero fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_87883 (h0 : topological_space (boolean_algebra (ring pos))) : regular_space (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_87884 (h1 : topological_space (topological_space (has_nnnorm char))) : path_connected_space (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_87885 (h0 : has_mul to_additive.value_type) (h1 : has_le to_additive.value_type) (h2 : to_additive.value_type) : mul_le_cancellable h2 := sorry --non-trivial
lemma new_lemma_87886 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_87887 (h0 : list (add_comm_monoid (has_dist (comm_monoid num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87888 (h0 : semiring (has_nndist (option (option empty)))) : is_noetherian_ring (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_87889 (h0 : topological_space (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : locally_compact_space (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_87890 (h0 : ring (measurable_space (random_gen (dlist (has_inv (has_inv (has_norm linarith.ineq))))))) : is_domain (measurable_space (random_gen (dlist (has_inv (has_inv (has_norm linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_87891 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_87892 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_87893 (h0 : uniform_space (plift (semiring congr_arg_kind))) : complete_space (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87894 (h1 : ring (has_norm to_additive.value_type)) : rank_condition (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87895 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : topological_space.separable_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_87896 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (denumerable (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_87897 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_87898 (h0 : topological_space (add_cancel_comm_monoid empty)) : irreducible_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_87899 (h0 : function.extfun Type ring) : @is_domain.{0} name (@function.extfun_app.{2 1} Type ring.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_87900 (h0 : group (random_gen fun_info)) : normalizer_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_87901 (h0 : functor.add_const (topological_space (has_zero Type)) (ring environment.implicit_infer_kind)) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_87902 (h2 : uniform_space (has_div linarith.ineq)) : complete_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_87903 (h0 : add_group (ring (normed_comm_ring (ring Type)))) : is_add_cyclic (ring (normed_comm_ring (ring Type))) := sorry --non-trivial
lemma new_lemma_87904 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring (semiring (semiring unsigned)))))) : is_atomistic (linear_ordered_semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_87905 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_87906 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_87907 (h0 : topological_space (simple_graph (has_nndist pos))) : sequential_space (simple_graph (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_87908 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_87909 (h0 : topological_space (has_to_string (has_neg (normed_comm_ring Type)))) : irreducible_space (has_to_string (has_neg (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_87910 (h0 : ring (has_sdiff std_gen)) : strong_rank_condition (has_sdiff std_gen) := sorry --non-trivial
lemma new_lemma_87911 (h0 : topological_space (ring (ring linarith.comp))) : t0_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_87912 (h1 : topological_space (has_append fun_info)) : t0_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_87913 (h0 : uniform_space (distrib (has_lt (has_nnnorm linarith.ineq)))) : complete_space (distrib (has_lt (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_87914 (h0 : filter (boolean_algebra.core (option (option (option (option (option unsigned))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_87915 (h0 : complete_lattice (normed_comm_ring (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_87916 (h0 : topological_space (has_zero (finset linarith.comp))) : discrete_topology (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_87917 (h0 : topological_space (boolean_algebra (finset Type))) : path_connected_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_87918 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_87919 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_87920 (h1 : not (add_group (topological_space fun_info) -> false)) : @is_add_cyclic.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_87921 (h0 : topological_space (preorder (semiring num))) : normal_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_87922 (h0 : complete_lattice (with_bot (semiring linarith.comp))) : is_atomistic (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_87923 (h0 : topological_space (has_to_string (has_zero pos))) : topological_space.separable_space (has_to_string (has_zero pos)) := sorry --non-trivial
lemma new_lemma_87924 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add pos)) name) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_87925 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg (has_Inf Type))) : @sequential_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_neg.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87926 (h0 : topological_space (semigroup (has_to_string pos))) : irreducible_space (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_87927 (h0 : filter (generalized_boolean_algebra (has_Inf Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_87928 (h0 : list (comm_semigroup (sub_neg_monoid real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87929 (h0 : functor.add_const (add_monoid (complete_distrib_lattice pos)) linarith.comp) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87930 (h0 : functor.comp list comm_group Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_87931 (h2 : ring (normed_field string.iterator_imp)) : strong_rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_87932 (h0 : ring (has_le string.iterator_imp)) : rank_condition (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_87933 (h0 : ring (finset pos)) : strong_rank_condition (finset pos) := sorry --non-trivial
lemma new_lemma_87934 (h0 : topological_space std_gen) : noncompact_space std_gen := sorry --non-trivial
lemma new_lemma_87935 (h0 : ring (has_union (semiring num))) : rank_condition (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_87936 (h0 : topological_space (with_bot (semiring linarith.comp))) : irreducible_space (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_87937 (h0 : not (topological_space (has_star unsigned) -> false)) : @t1_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_87938 (h0 : topological_space (ring unsigned)) : loc_path_connected_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_87939 (h0 : ring (linear_ordered_add_comm_group (random_gen fun_info))) : strong_rank_condition (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_87940 (h0 : fin has_zero.zero) : @archimedean.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_87941 (h0 : topological_space (has_nndist unsigned)) : preirreducible_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_87942 (h0 : topological_space (has_zero (comm_group name))) : sequential_space (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_87943 (h1 : topological_space (mul_one_class (mul_one_class enat))) : path_connected_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_87944 (h0 : list (with_one (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_87945 (h0 : add_group (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_87946 (h0 : topological_space (has_le char)) (h1 : preorder (has_le char)) : order_closed_topology (has_le char) := sorry --non-trivial
lemma new_lemma_87947 (h0 : functor.add_const (monoid (semigroup linarith.comp)) (ring (ring Type))) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87948 (h0 : fin has_zero.zero) : @is_domain.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_87949 (h0 h1 : multiset (has_div (mul_one_class reducibility_hints))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_87950 (h0 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_87951 (h0 : generalized_boolean_algebra pos -> generalized_boolean_algebra pos -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_87952 (h0 : ring (canonically_ordered_monoid real)) : is_principal_ideal_ring (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_87953 (h0 : not (topological_space (has_top unsigned) -> false)) : @totally_separated_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_87954 (h0 : add_monoid (has_nndist (has_neg (has_add linarith.comp)))) : add_monoid.fg (has_nndist (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_87955 (h0 : functor.add_const (group (generalized_boolean_algebra real)) Type) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (group.{0} (generalized_boolean_algebra.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_87956 (h0 : topological_space (option (semiring empty))) : irreducible_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_87957 (h0 : monoid (measurable_space linarith.comp)) : monoid.fg (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_87958 (h1 : ring (random_gen char)) : is_domain (random_gen char) := sorry --non-trivial
lemma new_lemma_87959 (h0 : topological_space (boolean_algebra.core (finset pos))) : irreducible_space (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_87960 (h0 : finset (has_nndist (has_pos_part Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_87961 (h0 : functor.comp complete_lattice add_comm_monoid name) : @is_atomistic.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_87962 (h0 : ring (linear_ordered_comm_group_with_zero reducibility_hints)) : is_domain (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_87963 (h0 : uniform_space (has_emptyc (has_top congr_arg_kind))) : complete_space (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_87964 (h0 : complete_lattice (group_with_zero (option ennreal))) : complete_lattice.is_Sup_finite_compact (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_87965 (h1 : set (enat -> measure_theory.measure_space (mul_one_class string.iterator_imp))) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_87966 (h0 : functor.add_const (ring (semiring empty)) num) : @is_principal_ideal_ring.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_87967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_87968 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_87969 (h1 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @t0_space.{0} (semigroup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h1 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (semigroup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_87970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_87971 (h0 : set (prod (has_pos_part name) (has_pos_part name))) (h1 : prod (has_pos_part name) (has_pos_part name)) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_87972 (h0 : monoid (comm_group (ring Type))) : monoid.fg (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_87973 (h0 : group (has_add (has_add (has_add Type)))) : is_cyclic (has_add (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_87974 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87975 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_87976 (h0 : not (topological_space (has_nnnorm char) -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_87977 (h0 : topological_space (has_Sup (option empty))) : loc_path_connected_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_87978 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87979 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : discrete_topology (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_87980 (h0 : topological_space (has_pos_part (has_Inf (ring (has_add (has_Inf Type)))))) : locally_compact_space (has_pos_part (has_Inf (ring (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_87981 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_87982 (h1 : uniform_space (normed_field to_additive.value_type)) : complete_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_87983 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen empty)) := sorry --non-trivial
lemma new_lemma_87984 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87985 (h0 : topological_space (boolean_algebra (has_pos_part (finset Type)))) : topological_space.separable_space (boolean_algebra (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_87986 (h0 : set (has_lt ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_87987 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_87988 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_87989 (h0 : topological_space (has_bot (has_pos_part pos))) : regular_space (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_87990 (h0 : not (complete_lattice linarith.comp -> false)) : @is_compactly_generated.{0} linarith.comp (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_87991 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_87992 (h0 : has_neg (normed_group (add_left_cancel_semigroup complex))) (h1 : measurable_space (normed_group (add_left_cancel_semigroup complex))) : has_measurable_neg (normed_group (add_left_cancel_semigroup complex)) := sorry --non-trivial
lemma new_lemma_87993 (h0 : add_group (simple_graph (mul_one_class reducibility_hints))) : is_add_cyclic (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_87994 (h0 : functor.add_const (add_monoid (comm_group environment.implicit_infer_kind)) (normed_comm_ring pos)) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_87995 (h0 : topological_space (linear_ordered_comm_group unsigned)) : path_connected_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_87996 (h0 : ring (sub_neg_monoid (has_add (has_add linarith.comp)))) : is_domain (sub_neg_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_87997 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_sub empty)) := sorry --non-trivial
lemma new_lemma_87998 (h0 : ring (normed_comm_ring (comm_group unsigned))) : is_domain (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_87999 (h0 : add_monoid (cancel_monoid (boolean_algebra (comm_group (has_add name))))) : add_monoid.fg (cancel_monoid (boolean_algebra (comm_group (has_add name)))) := sorry --non-trivial
