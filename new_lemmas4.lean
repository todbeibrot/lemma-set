import imports
lemma new_lemma_32000 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_32001 (h0 : group (boolean_algebra (has_neg_part Type))) : normalizer_condition (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_32002 (h0 : ordered_comm_monoid (add_comm_monoid (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_32003 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_32004 (h0 : functor.add_const Prop (add_cancel_monoid Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_32005 (h0 : list (plift (normed_linear_ordered_group empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32006 (h0 : monoid (measurable_space.dynkin_system (has_top (has_top (has_top empty))))) : monoid.fg (measurable_space.dynkin_system (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_32007 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_32008 (h0 : add_group (add_comm_semigroup (add_comm_semigroup enat))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_32009 (h0 : not (group (add_right_cancel_monoid num) -> false)) : @group.fg.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_32010 (h0 : group (has_to_string num)) : is_cyclic (has_to_string num) := sorry --non-trivial
lemma new_lemma_32011 (h1 : add_group (has_nnnorm char)) : is_add_cyclic (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_32012 (h0 : semiring ereal) (h2 : ideal ereal) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_32013 (h0 : topological_space (sub_neg_monoid (finset pos))) : t1_space (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_32014 (h0 : topological_space (id (semiring (has_norm congr_arg_kind)))) : t0_space (id (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_32015 (h0 : not (topological_space (has_emptyc to_additive.value_type) -> false)) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_32016 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32017 (h1 : group (topological_space (mul_one_class char))) : is_cyclic (topological_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_32018 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_32019 (h0 : add_monoid (has_add (ordered_comm_monoid (ordered_comm_monoid real)))) : add_monoid.fg (has_add (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_32020 (h0 : topological_space (has_Inf (ring (finset pos)))) : loc_path_connected_space (has_Inf (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_32021 (h0 : functor.add_const Prop (has_to_string (finset pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_32022 (h0 : add_group (has_ssubset (random_gen (mul_one_class fun_info)))) : is_add_cyclic (has_ssubset (random_gen (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_32023 (h0 : add_group (canonically_ordered_comm_semiring congr_arg_kind)) : is_add_cyclic (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32025 (h0 : filter (add_left_cancel_monoid (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32026 (h2 : add_group fun_info) : is_add_cyclic fun_info := sorry --non-trivial
lemma new_lemma_32027 (h0 : not (topological_space (measurable_space empty) -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32028 (h0 : add_group (has_neg_part Type)) : is_add_cyclic (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_32029 (h0 : ring (simple_graph (mul_one_class reducibility_hints))) : strong_rank_condition (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_32030 (h0 : uniform_space (boolean_algebra (finset (has_neg environment.implicit_infer_kind)))) : complete_space (boolean_algebra (finset (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_32031 : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@filter.cofinite.{0} Prop)  := sorry --non-trivial
lemma new_lemma_32032 (h0 : uniform_space (has_Sup empty)) : separated_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_32033 (h0 : complete_lattice (sub_neg_monoid pos)) : is_atomistic (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_32034 (h0 : prod (has_union (has_top empty)) (has_union (has_top empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_32035 (h0 : topological_space (boolean_algebra.core Type)) : loc_path_connected_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_32036 (h0 : filter (normed_lattice_add_comm_group (has_Inf real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_32037 (h0 : group (boolean_algebra Type)) : group.fg (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_32038 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_32039 (h0 : topological_space (complete_distrib_lattice (has_add name))) : locally_compact_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_32040 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_32041 (h0 : group (has_top (random_gen (random_gen (has_nnnorm linarith.comp_source))))) : is_cyclic (has_top (random_gen (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_32042 (h0 : set (prod Type Type)) (h1 : functor.add_const (prod Type Type) linarith.comp) : symmetrize_rel h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_32043 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_32044 (h0 : cancel_comm_monoid_with_zero (semigroup (has_neg linarith.comp))) : unique_factorization_monoid (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_32045 (h0 : ring (id (semiring fun_info))) : rank_condition (id (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_32046 (h0 : filter (has_zero (has_zero (has_to_string (has_add linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_32047 (h0 : topological_space (plift (semiring num))) : topological_space.separable_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_32048 (h0 : topological_space (distrib_lattice (random_gen (has_top (has_inv linarith.ineq))))) : locally_compact_space (distrib_lattice (random_gen (has_top (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_32049 (h1 : has_neg fun_info) (h2 : measurable_space fun_info) : has_measurable_neg fun_info := sorry --non-trivial
lemma new_lemma_32050 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_32051 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_32052 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_32053 (h0 : ordered_comm_monoid (has_to_string (has_neg Type))) : has_exists_mul_of_le (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_32054 (h0 : group (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : is_simple_group (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_32055 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_add_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h1 (canonically_ordered_add_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_32056 (h1 : topological_space (mul_one_class (mul_one_class ereal))) : t0_space (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_32057 (h0 : not (list (metric_space empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_32058 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @t0_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32059 (h0 : functor.add_const (topological_space (ring Type)) pos) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_32060 (h0 : function.extfun Type uniform_space) : @separated_space.{0} name (@function.extfun_app.{2 1} Type uniform_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_32061 (h0 : ring (has_add (finset (group_with_zero (option (has_neg ennreal)))))) : rank_condition (has_add (finset (group_with_zero (option (has_neg ennreal))))) := sorry --non-trivial
lemma new_lemma_32062 (h0 : group (boolean_algebra.core (has_neg_part pos))) : normalizer_condition (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_32063 (h0 : monoid (normed_comm_ring (ring (ring (has_neg (ring linarith.comp)))))) : monoid.fg (normed_comm_ring (ring (ring (has_neg (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_32064 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_32065 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32066 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_32067 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32068 (h0 : topological_space (has_bot (has_Inf (has_add pos)))) : discrete_topology (has_bot (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_32069 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_one.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_32070 (h1 : set (add_comm_semigroup enat -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_32071 (h0 : group (boolean_algebra (has_to_string name))) : group.fg (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_32072 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @t1_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32073 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_32074 (h0 : not (complete_lattice (comm_ring char) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32075 (h0 : topological_space (normed_comm_ring (option congr_arg_kind))) : locally_compact_space (normed_comm_ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32076 (h0 : topological_space (finset empty)) : irreducible_space (finset empty) := sorry --non-trivial
lemma new_lemma_32077 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32078 (h0 : topological_space (add_group congr_arg_kind)) : t0_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32079 (h0 : group (free_add_monoid (semiring empty))) : normalizer_condition (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_32080 (h0 : semiring (id (add_group empty))) : is_noetherian_ring (id (add_group empty)) := sorry --non-trivial
lemma new_lemma_32081 (h0 : topological_space (has_bot (has_Inf (has_Inf real)))) : loc_path_connected_space (has_bot (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_32082 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : t0_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32083 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32084 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32085 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_32086 (h0 : set (linarith.ineq -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_32087 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : is_domain (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_32088 (h0 : add_zero_class (with_bot linarith.comp)) (h1 : topological_space (add_submonoid (with_bot linarith.comp))) : discrete_topology (add_submonoid (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_32089 (h0 : functor.add_const (ring (ring name)) name) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_32090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_32091 (h0 : ordered_add_comm_monoid (has_bot (has_pos_part real))) : archimedean (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_32092 (h0 : topological_space (boolean_algebra.core (has_neg name))) : normal_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_32093 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_32094 (h0 : functor.add_const (function.extfun (Type 1) semiring) (finset (boolean_algebra linarith.comp))) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) (finset.{0} (boolean_algebra.{0} linarith.comp)) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_32095 (h0 : not (ring (normed_field to_additive.value_type) -> false)) : @is_domain.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_32096 (h2 : ring (with_zero fun_info)) : strong_rank_condition (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_32097 (h0 : not (uniform_space (mul_zero_class unsigned) -> false)) : @separated_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_32098 (h0 : group (has_Sup num)) : group.fg (has_Sup num) := sorry --non-trivial
lemma new_lemma_32099 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32101 (h2 : uniform_space (div_inv_monoid to_additive.value_type)) : complete_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32102 (h0 : topological_space (topological_space (comm_ring (has_nnnorm linarith.comp_source)))) : t0_space (topological_space (comm_ring (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32103 (h0 : function.extfun Type topological_space) (h1 : function.extfun Type preorder) : @order_closed_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type) (@function.extfun_app.{2 1} Type preorder.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_32104 (h0 : complete_lattice (measurable_space (random_gen num))) : is_atomistic (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_32105 (h0 : complete_lattice (has_to_string (add_cancel_monoid (has_add name)))) : is_atomistic (has_to_string (add_cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_32106 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : preconnected_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_32107 (h0 : topological_space (random_gen num)) : totally_separated_space (random_gen num) := sorry --non-trivial
lemma new_lemma_32108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_32109 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32110 (h0 : not (topological_space (add_group empty) -> false)) : @normal_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32111 (h0 : functor.add_const (ring (cancel_monoid unsigned)) Type) : @strong_rank_condition.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_32112 (h0 : uniform_space (linear_ordered_comm_group (option (option (option unsigned))))) : complete_space (linear_ordered_comm_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_32113 (h1 : complete_lattice (random_gen num)) : is_atomistic (random_gen num) := sorry --non-trivial
lemma new_lemma_32114 (h0 : filter (linear_ordered_field (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_32115 (h0 : complete_lattice (has_bot (has_neg pos))) : is_compactly_generated (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_32116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32117 (h0 : topological_space ennreal) : preconnected_space ennreal := sorry --non-trivial
lemma new_lemma_32118 (h0 : uniform_space (group_with_zero (option (option ennreal)))) : complete_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_32119 (h0 : functor.add_const (function.extfun Type filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_32120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_32121 (h0 : ring (has_nnnorm char)) : rank_condition (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_32122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32123 (h0 : not (group (has_norm fun_info) -> false)) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_32124 (h0 : not (topological_space (normed_group to_additive.value_type) -> false)) : @t0_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_32125 (h0 : not (filter (has_nnnorm linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_32126 (h1 : has_neg (has_compl ereal)) (h2 : measurable_space (has_compl ereal)) : has_measurable_neg (has_compl ereal) := sorry --non-trivial
lemma new_lemma_32127 (h0 : ring (boolean_algebra.core congr_arg_kind)) : is_domain (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32128 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_32129 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_32130 (h0 : functor.add_const (function.extfun (Type 1) semiring) (has_Inf pos)) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) (has_Inf.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_32131 (h0 : ordered_comm_monoid (boolean_algebra.core ennreal)) : has_exists_mul_of_le (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_32132 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_32133 (h0 : add_group (normed_field (mul_one_class ereal))) : is_add_cyclic (normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_32134 (h0 : filter (has_ssubset (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32135 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_32136 (h0 : ring (ordered_comm_group empty)) : is_principal_ideal_ring (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_32137 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32138 (h1 : not (uniform_space (has_compl linarith.comp_source) -> false)) : @complete_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_32139 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @rank_condition.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_32140 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_32141 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_32142 (h0 : not (has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_32143 (h0 : div_inv_monoid string_imp -> div_inv_monoid string_imp -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_32144 (h0 : add_group (random_gen (has_inv to_additive.value_type))) : is_add_cyclic (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32145 (h0 : not (group (normed_group num) -> false)) : @is_cyclic.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_32146 (h0 : topological_space (has_dist ennreal)) : irreducible_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_32147 (h1 : uniform_space (has_neg linarith.comp_source)) : complete_space (has_neg linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32148 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_32149 (h0 : topological_space (has_append reducibility_hints)) : path_connected_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_32150 (h0 : topological_space linarith.comp) : t1_space linarith.comp := sorry --non-trivial
lemma new_lemma_32151 (h0 : set (with_bot linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_32152 (h0 : group (boolean_algebra (has_add (has_Inf real)))) : group.fg (boolean_algebra (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_32153 (h0 : functor.add_const (topological_space (cancel_monoid Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_32154 (h0 h1 : multiset (normed_field fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_32155 (h0 : topological_space unsigned) : t0_space unsigned := sorry --non-trivial
lemma new_lemma_32156 (h0 : functor.add_const Prop (finset name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_32157 (h1 : has_lt (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_32158 (h0 : ring (denumerable (has_nnnorm (random_gen linarith.comp_source)))) : is_domain (denumerable (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32159 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32160 (h0 : ordered_comm_monoid (add_cancel_monoid (option (option pos)))) : has_exists_mul_of_le (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_32161 (h0 : topological_space (filter (semiring empty))) : topological_space.separable_space (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_32162 (h0 : not (topological_space (bin_tree empty) -> false)) : @totally_disconnected_space.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32163 (h1 : set (add_comm_semigroup fun_info -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_32164 (h0 : list (complete_lattice (has_ssubset to_additive.value_type))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} to_additive.value_type) (@list.nth_le.{0} (complete_lattice.{0} (has_ssubset.{0} to_additive.value_type)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_32165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_32166 (h0 : topological_space (semi_normed_comm_ring (comm_ring (has_nnnorm char)))) : path_connected_space (semi_normed_comm_ring (comm_ring (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_32167 (h0 : ring (has_add (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (has_add (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32168 (h0 : topological_space (has_inv char)) : t0_space (has_inv char) := sorry --non-trivial
lemma new_lemma_32169 (h0 : ordered_comm_monoid (boolean_algebra (boolean_algebra.core name))) : has_exists_mul_of_le (boolean_algebra (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_32170 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32171 (h0 : uniform_space (has_neg unsigned)) : separated_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_32172 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_32173 (h0 : functor.add_const (topological_space (ring pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_32174 (h0 : list (comm_ring (with_one (with_one (has_top to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32175 (h0 : topological_space (comm_group (has_neg_part (has_to_string pos)))) : totally_disconnected_space (comm_group (has_neg_part (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_32176 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : totally_separated_space (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_32177 (h0 : functor.add_const (filter (has_add nnreal)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32178 (h0 : finset (has_pos_part (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32179 (h0 : set (set (with_bot linarith.comp_source))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_32180 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) linarith.comp) : @normal_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32181 (h0 : topological_space (has_norm (semiring (semiring unsigned)))) : normal_space (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_32182 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_32183 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen char))) : is_compactly_generated (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_32184 (h0 : ring (generalized_boolean_algebra (has_Inf (has_add pos)))) : rank_condition (generalized_boolean_algebra (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_32185 (h0 : list (ordered_comm_ring (has_add real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32186 (h0 : functor.add_const (group (comm_group linarith.comp)) name) : @is_cyclic.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_32187 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_32188 (h0 : complete_lattice (distrib_lattice (random_gen (has_ssubset linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32189 (h0 : topological_space (boolean_algebra (finset (has_pos_part (normed_comm_ring Type))))) : path_connected_space (boolean_algebra (finset (has_pos_part (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_32190 (h0 : ring (boolean_algebra (has_to_string pos))) : strong_rank_condition (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_32191 (h0 : topological_space (has_nndist (has_neg Type))) : topological_space.separable_space (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_32192 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_32193 (h0 : topological_space (id (with_bot (random_gen (random_gen linarith.ineq))))) : totally_separated_space (id (with_bot (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_32194 (h0 : topological_space (complete_linear_order ennreal)) : preirreducible_space (complete_linear_order ennreal) := sorry --non-trivial
lemma new_lemma_32195 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_32196 (h0 : group (add_group (semiring linarith.comp))) : normalizer_condition (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_32197 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring num)))))) : totally_disconnected_space (add_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_32198 (h0 : not (filter linarith.comp_source -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_32199 (h0 : function.extfun Type ring) : @is_domain.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_32200 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup congr_arg_kind)) unsigned) : @preirreducible_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_Sup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} pos))  := sorry --non-trivial
lemma new_lemma_32202 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group num)) : unique_factorization_monoid (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_32203 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_32204 (h0 : complete_lattice (ring (boolean_algebra (boolean_algebra name)))) : complete_lattice.is_Sup_finite_compact (ring (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_32205 (h0 : not (group (comm_ring linarith.comp_source) -> false)) : @group.fg.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_32206 (h0 : topological_space (has_add name)) : preconnected_space (has_add name) := sorry --non-trivial
lemma new_lemma_32207 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid real)) : archimedean (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_32208 (h0 : ordered_comm_monoid (has_neg (option (boolean_algebra unsigned)))) : has_exists_mul_of_le (has_neg (option (boolean_algebra unsigned))) := sorry --non-trivial
lemma new_lemma_32209 (h0 : functor.comp topological_space boolean_algebra name) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_32210 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32211 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32212 (h0 : uniform_space (has_top (has_top (has_top fun_info)))) : complete_space (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_32213 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) linarith.comp h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_32214 (h0 : group (ordered_cancel_add_comm_monoid (option (option unsigned)))) : group.fg (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_32215 (h0 : ring (semigroup name)) : strong_rank_condition (semigroup name) := sorry --non-trivial
lemma new_lemma_32216 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg unsigned)) linarith.comp) : @archimedean.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32217 (h0 : functor.add_const (group (canonically_ordered_monoid pos)) real) : @is_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_32218 (h0 : set (add_comm_semigroup linarith.ineq -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_32219 (h0 : not (topological_space (has_norm empty) -> false)) : @t0_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32220 (h1 : list (topological_space (has_append char))) (h2 : nat) (h3 : has_lt.lt h2 (list.length h1)) : @path_connected_space.{0} (has_append.{0} char) (@list.nth_le.{0} (topological_space.{0} (has_append.{0} char)) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_32221 (h0 : ring (has_pos_part (has_Inf (has_bot name)))) : rank_condition (has_pos_part (has_Inf (has_bot name))) := sorry --non-trivial
lemma new_lemma_32222 (h0 : functor.comp group mul_zero_class pos) : @is_cyclic.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_32223 (h0 : finset (ordered_comm_ring Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32224 (h0 : ring (ring (semigroup (add_comm_monoid environment.implicit_infer_kind)))) : is_domain (ring (semigroup (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_32225 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_32226 (h0 : ring (has_append (denumerable char))) : rank_condition (has_append (denumerable char)) := sorry --non-trivial
lemma new_lemma_32227 (h0 : ring (add_right_cancel_monoid (semiring congr_arg_kind))) : is_domain (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32228 (h0 : topological_space (encodable linarith.comp_source)) : t0_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32229 (h0 : ring (canonically_linear_ordered_monoid (has_bot (has_bot Type)))) : strong_rank_condition (canonically_linear_ordered_monoid (has_bot (has_bot Type))) := sorry --non-trivial
lemma new_lemma_32230 (h0 : nat) (h1 : topological_space (mv_power_series (linear_ordered_field (fin h0)) unsigned)) : totally_disconnected_space (mv_power_series (linear_ordered_field (fin h0)) unsigned) := sorry --non-trivial
lemma new_lemma_32231 (h0 : functor.comp list add_comm_monoid Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_32232 (h0 : ring (has_add (has_to_string (has_to_string congr_arg_kind)))) : rank_condition (has_add (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_32233 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_32234 (h12 : prod (add_comm_semigroup enat) (add_comm_semigroup enat)) : set.diagonal (add_comm_semigroup enat) h12 := sorry --non-trivial
lemma new_lemma_32235 (h0 : not (group (measurable_space.dynkin_system num) -> false)) : @group.fg.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_32236 (h1 : topological_space (semiring (has_norm linarith.ineq))) : t0_space (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32237 (h0 : list (ring (has_nndist name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32238 (h0 : not (uniform_space (metric_space to_additive.value_type) -> false)) : @complete_space.{0} (metric_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_32239 (h0 : has_neg (simple_graph (mul_one_class linarith.ineq))) (h1 : measurable_space (simple_graph (mul_one_class linarith.ineq))) : has_measurable_neg (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32240 (h0 : not (topological_space (semi_normed_comm_ring (semi_normed_ring char)) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} (semi_normed_ring.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} (semi_normed_ring.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_32241 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @discrete_topology.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32242 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring (semiring (semiring num)))) : unique_factorization_monoid (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_32243 (h0 : topological_space (semiring (semiring (semiring congr_arg_kind)))) : preirreducible_space (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_32244 (h0 : group (metric_space num)) (h1 : option (group (metric_space num))) : normalizer_condition (metric_space num) := sorry --non-trivial
lemma new_lemma_32245 (h0 : complete_lattice (ring (ring (has_add (ring (ring Type)))))) : is_compactly_generated (ring (ring (has_add (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_32246 (h0 : fin has_zero.zero) : @is_domain.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_32247 (h0 : ordered_comm_monoid (has_to_string (semigroup name))) : has_exists_mul_of_le (has_to_string (semigroup name)) := sorry --non-trivial
lemma new_lemma_32248 (h0 : functor.add_const (topological_space (has_neg_part name)) (mul_zero_class unsigned)) : @t1_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_32249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32250 (h0 : list (has_nndist (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32251 (h0 : topological_space (has_neg_part unsigned)) : preirreducible_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_32252 (h0 : topological_space (has_lt (has_mul std_gen))) (h1 : preorder (has_lt (has_mul std_gen))) : order_topology (has_lt (has_mul std_gen)) := sorry --non-trivial
lemma new_lemma_32253 (h0 : functor.add_const (complete_lattice (sub_neg_monoid real)) Type) : @is_compactly_generated.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 1} (complete_lattice.{0} (sub_neg_monoid.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_32254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_32255 (h0 : topological_space (has_zero (option (option unsigned)))) : irreducible_space (has_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_32256 (h0 : topological_space (has_emptyc (has_norm (has_norm linarith.ineq)))) : locally_compact_space (has_emptyc (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32257 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_32258 (h0 : ring (random_gen (has_norm (has_norm linarith.comp)))) : is_domain (random_gen (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_32259 (h0 : ring (has_ssubset (random_gen (has_lt to_additive.value_type)))) : is_domain (has_ssubset (random_gen (has_lt to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_32260 (h1 : ring (encodable linarith.ineq)) : strong_rank_condition (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_32261 (h0 : topological_space (pseudo_metric_space (option empty))) : preirreducible_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_32262 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (boolean_algebra linarith.comp)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_32263 (h1 : topological_space (nondiscrete_normed_field (mul_one_class (normed_field linarith.ineq)))) (h2 : add_group (nondiscrete_normed_field (mul_one_class (normed_field linarith.ineq)))) : topological_add_group (nondiscrete_normed_field (mul_one_class (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32264 (h0 : measurable_space (non_assoc_semiring (option (semiring (option (option (option unsigned))))))) (h1 : has_mul (non_assoc_semiring (option (semiring (option (option (option unsigned))))))) : has_measurable_mul₂ (non_assoc_semiring (option (semiring (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_32265 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32266 (h0 : uniform_space (distrib (random_gen (metric_space (random_gen char))))) : complete_space (distrib (random_gen (metric_space (random_gen char)))) := sorry --non-trivial
lemma new_lemma_32267 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32268 (h0 : functor.add_const (list (semigroup empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32269 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : option (topological_space (bin_tree num))) : @t1_space.{0} (bin_tree.{0} num) (@option.lhoare.{0} (topological_space.{0} (bin_tree.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_32270 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_32271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_32272 (h0 : ring (with_bot (has_norm num))) : is_domain (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_32273 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : discrete_topology (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_32274 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32275 (h1 : uniform_space (has_norm to_additive.value_type)) : separated_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32276 (h0 : functor.add_const (topological_space (option empty)) empty) : @totally_disconnected_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32277 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32278 (h0 : uniform_space (has_norm (has_norm (has_top to_additive.value_type)))) : complete_space (has_norm (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_32279 (h0 : fin has_zero.zero) : @sequential_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_32280 (h1 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_32281 (h0 : topological_space (normed_group (semiring (semiring empty)))) : totally_separated_space (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_32282 (h0 : ordered_comm_monoid (has_pos_part real)) : has_exists_mul_of_le (has_pos_part real) := sorry --non-trivial
lemma new_lemma_32283 (h0 : fin has_zero.zero) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_32284 (h0 : group (normed_group (has_top linarith.ineq))) : is_cyclic (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32285 (h0 : has_to_string (finset congr_arg_kind) -> has_to_string (finset congr_arg_kind) -> Prop) : is_symm (has_to_string (finset congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_32286 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_32287 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset empty)) := sorry --non-trivial
lemma new_lemma_32288 (h2 h3 : multiset ordering) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_32289 (h0 : ring (semigroup (add_comm_monoid (normed_comm_ring (normed_comm_ring Type))))) : is_principal_ideal_ring (semigroup (add_comm_monoid (normed_comm_ring (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_32290 (h1 : add_group (has_norm linarith.comp)) : is_add_cyclic (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_32291 (h0 : topological_space (option (ordered_cancel_comm_monoid congr_arg_kind))) : topological_space.separable_space (option (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32292 (h2 : topological_space fun_info) : totally_disconnected_space fun_info := sorry --non-trivial
lemma new_lemma_32293 (h0 : group (comm_semigroup (sub_neg_monoid (has_pos_part real)))) : is_simple_group (comm_semigroup (sub_neg_monoid (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_32294 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_32295 (h0 : topological_space (finset (has_nndist pos))) : totally_disconnected_space (finset (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_32296 (h0 : topological_space (finset (has_Inf (ordered_comm_ring linarith.comp)))) : t1_space (finset (has_Inf (ordered_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_32297 (h1 : not (ring (semi_normed_ring linarith.comp_source) -> false)) : @is_domain.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_32298 (h0 : group (has_inv (has_inv linarith.comp_source))) : normalizer_condition (has_inv (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32299 (h0 : topological_space (linear_ordered_cancel_comm_monoid num)) : t1_space (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_32300 (h3 : char -> char -> linarith.ineq -> std_gen) (h4 h5 : set char) : set.separates_points (set.image2 h3 h4 h5) := sorry --non-trivial
lemma new_lemma_32301 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : totally_separated_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_32302 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset Type)) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32303 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_32304 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32305 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_to_string Type))) : unique_factorization_monoid (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_32306 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_32307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_32308 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_32309 (h1 : topological_space (distrib (mul_one_class string.iterator_imp))) : totally_disconnected_space (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_32310 (h0 : not (topological_space (linear_ordered_comm_group_with_zero char) -> false)) : @t0_space.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32311 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_32312 (h1 : has_neg (non_unital_non_assoc_semiring linarith.comp_source)) (h2 : measurable_space (non_unital_non_assoc_semiring linarith.comp_source)) : has_measurable_neg (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32313 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32314 (h0 : topological_space (ordered_comm_group (option empty))) : path_connected_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_32315 (h0 : monoid (has_to_string (has_add pos))) : monoid.fg (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_32316 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_32317 (h0 : add_group (random_gen fun_info)) : is_add_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_32318 (h0 : group (has_append (random_gen to_additive.value_type))) : is_cyclic (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32319 (h1 : topological_space (has_lt std_gen)) : path_connected_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_32320 (h0 : functor.add_const (ordered_comm_monoid Type) (has_neg Type)) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} Type) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32321 (h0 : topological_space (has_to_string (has_pos_part linarith.comp))) : loc_path_connected_space (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_32322 (h0 : topological_space (has_div (mul_one_class char))) : path_connected_space (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_32323 (h0 : topological_space (has_add (ring name))) : t1_space (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_32324 (h0 : set (semi_normed_ring (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_32325 (h0 : ring (has_union linarith.comp)) : rank_condition (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_32326 (h0 : functor.add_const (group (has_zero pos)) linarith.comp) : @group.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32327 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32328 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32329 (h0 : uniform_space (with_bot (random_gen linarith.comp_source))) : separated_space (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32330 (h0 : ordered_add_comm_monoid (finset (finset (has_pos_part (has_nndist pos))))) : archimedean (finset (finset (has_pos_part (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_32331 (h0 : ring (has_append (has_ssubset to_additive.value_type))) : strong_rank_condition (has_append (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32332 (h0 : group (id (distrib_lattice linarith.ineq))) : is_cyclic (id (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32333 (h0 : ring (semiring (random_gen (random_gen (pseudo_emetric_space (random_gen fun_info)))))) : is_domain (semiring (random_gen (random_gen (pseudo_emetric_space (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_32334 (h0 : not (topological_space (has_union linarith.comp) -> false)) : @discrete_topology.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_32335 (h0 : topological_space (has_neg (has_neg_part (finset (finset (finset Type)))))) : t0_space (has_neg (has_neg_part (finset (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_32336 (h0 : topological_space (pseudo_metric_space (option (option (option ennreal))))) : normal_space (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_32337 (h0 : group (ring (has_nndist (has_to_string (has_to_string Type))))) : is_cyclic (ring (has_nndist (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_32338 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_32339 (h0 : topological_space (has_one (random_gen empty))) : path_connected_space (has_one (random_gen empty)) := sorry --non-trivial
lemma new_lemma_32340 (h0 : functor.add_const (semiring (comm_group pos)) (has_neg_part (comm_group Type))) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (comm_group.{0} pos)) (has_neg_part.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_32341 (h0 : complete_lattice (complete_distrib_lattice name)) : is_atomistic (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_32342 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_32343 (h0 : topological_space (ring (has_neg_part (has_add (has_neg_part Type))))) : loc_path_connected_space (ring (has_neg_part (has_add (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_32344 (h0 : functor.add_const (group (omega_complete_partial_order empty)) empty) : @normalizer_condition.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32345 (h0 : functor.add_const (functor.add_const (add_group (has_edist unsigned)) empty) num) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_edist.{0} unsigned)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} (has_edist.{0} unsigned)) empty) num h0))  := sorry --non-trivial
lemma new_lemma_32346 (h0 : fin has_zero.zero) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_32347 (h0 : add_monoid (has_to_string (has_neg linarith.comp))) : add_monoid.fg (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_32348 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) (has_add (ring pos))) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) (has_add.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_32349 (h0 : functor.add_const (topological_space auto.case_option) num -> Prop) (h1 : Exists (fun (x : functor.add_const (topological_space auto.case_option) num), h0 x)) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@classical.some.{1} (functor.add_const.{0 0} (topological_space.{0} auto.case_option) num) h0 h1))  := sorry --non-trivial
lemma new_lemma_32350 (h0 : has_lt (normed_field to_additive.value_type)) : no_max_order (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32351 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32352 (h0 : add_monoid (partial_order (semiring empty))) : add_monoid.fg (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_32353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32354 (h0 : ring (with_zero linarith.comp_source)) : rank_condition (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32355 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_32356 (h0 : monoid (comm_semigroup (has_Inf (sub_neg_monoid (has_Inf pos))))) : monoid.fg (comm_semigroup (has_Inf (sub_neg_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_32357 (h0 : topological_space (boolean_algebra.core (has_nndist Type))) : sequential_space (boolean_algebra.core (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_32358 (h0 : ring (semi_normed_ring (has_ssubset enat))) : strong_rank_condition (semi_normed_ring (has_ssubset enat)) := sorry --non-trivial
lemma new_lemma_32359 (h0 : function.extfun Type (functor.add_const (prod (ordered_ring congr_arg_kind) (ordered_ring congr_arg_kind)))) : id_rel (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_32360 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32361 (h0 : functor.add_const (ring (has_zero pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32362 (h0 : uniform_space (id unsigned)) : complete_space (id unsigned) := sorry --non-trivial
lemma new_lemma_32363 (h0 : not (topological_space (measurable_space linarith.comp_source) -> false)) : @discrete_topology.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_32364 (h0 : group (boolean_algebra (has_neg_part (has_add environment.implicit_infer_kind)))) : is_cyclic (boolean_algebra (has_neg_part (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_32365 (h0 : topological_space (plift (semiring (semiring (semiring unsigned))))) : locally_compact_space (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_32366 (h0 : ring (denumerable (has_nnnorm fun_info))) : is_domain (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_32367 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_32368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_32369 (h0 : functor.add_const (monoid (add_cancel_monoid unsigned)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32370 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_32371 (h0 : add_group (pseudo_metric_space (has_top (has_top linarith.comp_source)))) : is_add_cyclic (pseudo_metric_space (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32372 (h0 : char -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_32373 (h0 : ring (has_add environment.implicit_infer_kind)) : rank_condition (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_32374 (h0 : ring (complete_linear_order (semiring (semiring (semiring num))))) : is_principal_ideal_ring (complete_linear_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_32375 (h0 : ring (has_nndist (has_to_string pos))) : strong_rank_condition (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_32376 (h0 : ring (has_star num)) : strong_rank_condition (has_star num) := sorry --non-trivial
lemma new_lemma_32377 (h1 : ring (comm_ring to_additive.value_type)) : rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32378 (h0 : add_group (has_one (semiring (semiring congr_arg_kind)))) : is_add_cyclic (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_32379 (h1 : complete_lattice (denumerable to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32380 (h0 : fin has_zero.zero) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_32381 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add (has_neg name)))) : is_compactly_generated (canonically_linear_ordered_monoid (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_32382 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid num)) num) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_32383 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_32384 (h0 : functor.add_const (ring (partial_order congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32385 (h0 : topological_space (has_zero (has_add (has_add name)))) : regular_space (has_zero (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_32386 (h0 : functor.add_const (filter (has_to_string Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32387 (h0 : add_group (boolean_algebra (ring environment.implicit_infer_kind))) : is_add_cyclic (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_32388 (h0 : topological_space (comm_group (has_neg linarith.comp))) : preconnected_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_32389 (h1 : topological_space (semi_normed_comm_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32390 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_32391 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @t0_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_32392 (h0 : complete_lattice (distrib (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32393 (h0 : not (filter (with_bot empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_32394 (h0 : topological_space (has_add (has_Inf (has_add linarith.comp)))) : normal_space (has_add (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_32395 (h0 : functor.add_const (uniform_space (linear_ordered_field ennreal)) ennreal) : @separated_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_32396 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring congr_arg_kind)))))) : totally_disconnected_space (bin_tree (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_32397 (h0 : group (has_union (random_gen congr_arg_kind))) : group.fg (has_union (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32398 (h0 : nat -> topological_space linarith.comp_source -> std_gen -> topological_space linarith.comp_source) (h1 : nat) (h2 : topological_space linarith.comp_source) (h3 : list std_gen) : t0_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_32399 (h0 : topological_space (linear_ordered_semiring (semiring unsigned))) : totally_disconnected_space (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_32400 (h0 : functor.add_const (topological_space (ring pos)) (has_neg linarith.comp)) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_32401 (h0 : function.extfun nat fin) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_32402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_32403 (h0 : functor.add_const (ordered_comm_monoid (has_neg Type)) name) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_32404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_32405 (h0 : functor.add_const (group (has_top string_imp)) string_imp) : @normalizer_condition.{0} (has_top.{0} string_imp) (@functor.add_const.run.{0 0} (group.{0} (has_top.{0} string_imp)) string_imp h0)  := sorry --non-trivial
lemma new_lemma_32406 (h0 : not (complete_lattice (normed_group linarith.comp) -> false)) : @is_atomistic.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_32407 (h0 : semiring (has_pos_part (has_Inf Type))) : is_noetherian_ring (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_32408 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_inter unsigned)) unsigned) : @unique_factorization_monoid.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_inter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32409 (h0 : not (ring (linear_ordered_comm_ring unsigned) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_32410 (h0 : not (ring (has_emptyc to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_32411 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_32412 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : unique_factorization_monoid nnreal := sorry --non-trivial
lemma new_lemma_32413 (h0 : topological_space (has_zero (has_neg name))) : discrete_topology (has_zero (has_neg name)) := sorry --non-trivial
lemma new_lemma_32414 (h0 : cancel_comm_monoid_with_zero (as_linear_order num)) : unique_factorization_monoid (as_linear_order num) := sorry --non-trivial
lemma new_lemma_32415 (h0 : group (has_star congr_arg_kind) -> Prop) (h1 : Exists (fun (x : group (has_star congr_arg_kind)), h0 x)) : @group.fg.{0} (has_star.{0} congr_arg_kind) (@classical.some.{1} (group.{0} (has_star.{0} congr_arg_kind)) h0 h1)  := sorry --non-trivial
lemma new_lemma_32416 (h0 : filter (add_comm_monoid (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32417 (h0 : functor.add_const (topological_space (add_group num)) empty) : @topological_space.separable_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_32418 (h0 : topological_space string_imp) (h1 : set string_imp) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_32419 (h0 : monoid (distrib_lattice (random_gen (has_top (has_top fun_info))))) : monoid.fg (distrib_lattice (random_gen (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_32420 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (comm_group (comm_group Type))) : @normal_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (comm_group.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_32421 (h0 : ring (boolean_algebra (semigroup name))) : strong_rank_condition (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_32422 (h1 : filter (add_left_cancel_monoid (add_monoid (comm_ring char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_32423 (h1 : topological_space string.iterator_imp) (h2 : preorder string.iterator_imp) : order_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_32424 (h0 : topological_space (simple_graph Type)) : discrete_topology (simple_graph Type) := sorry --non-trivial
lemma new_lemma_32425 (h0 : list (complete_linear_order empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32426 (h0 : complete_lattice (boolean_algebra (comm_group unsigned))) : is_compactly_generated (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_32427 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_32428 (h0 : uniform_space (comm_group (semigroup (semigroup pos)))) : complete_space (comm_group (semigroup (semigroup pos))) := sorry --non-trivial
lemma new_lemma_32429 (h0 : topological_space (has_neg_part (canonically_linear_ordered_monoid pos))) : locally_compact_space (has_neg_part (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_32430 (h0 : topological_space (has_add (finset (finset (finset environment.implicit_infer_kind))))) : t0_space (has_add (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_32431 (h0 : topological_space (ring (finset (uniform_space (has_neg pos))))) : loc_path_connected_space (ring (finset (uniform_space (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_32432 (h0 : topological_space (comm_group (option pos))) : t0_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_32433 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_32434 (h0 : prod (canonically_ordered_comm_semiring ennreal) (canonically_ordered_comm_semiring ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_32435 (h4 : ring (topological_space char)) : rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_32436 (h0 : functor.add_const (function.extfun Type topological_space) (finset linarith.comp)) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} linarith.comp) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32437 (h0 : ring (ring (has_add (boolean_algebra Type)))) : is_principal_ideal_ring (ring (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_32438 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_32439 (h0 : group (cancel_monoid (has_add Type))) : group.fg (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_32440 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32441 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_32442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32443 (h0 : functor.add_const (add_group (has_neg Type)) linarith.comp) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32445 (h0 : ring (metric_space (denumerable (metric_space (denumerable to_additive.value_type))))) : is_domain (metric_space (denumerable (metric_space (denumerable to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_32446 (h0 : set (non_unital_non_assoc_semiring name)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_32447 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_32448 (h0 : pseudo_metric_space (has_add Type)) (h1 : add_monoid (has_add Type)) : has_lipschitz_add (has_add Type) := sorry --non-trivial
lemma new_lemma_32449 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (boolean_algebra name)) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_32450 (h0 : linarith.comp -> boolean_algebra name -> boolean_algebra name) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_32451 (h0 : monoid (has_inter (option num))) : monoid.fg (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_32452 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_32453 (h0 : functor.add_const Prop (has_nndist (option (finset name)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_32454 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_32455 (h0 : functor.add_const (group (has_pos_part pos)) linarith.comp) : @is_simple_group.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32456 (h0 : topological_space (semiring (ordered_ring empty))) : topological_space.separable_space (semiring (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_32457 (h0 : topological_space (has_add (ring linarith.comp))) : preconnected_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_32458 (h0 : ring (has_pos_part (has_Inf (finset pos)))) : is_domain (has_pos_part (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_32459 (h0 : list (linear_ordered_add_comm_group (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32460 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_32461 (h0 : not (uniform_space (plift unsigned) -> false)) : @separated_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_32462 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add Type)) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{1} Type) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32463 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) Type) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_32464 (h0 : group (bin_tree unsigned)) : is_cyclic (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_32465 (h0 : add_comm_semigroup char -> add_comm_semigroup char -> Prop) (h1 : set (add_comm_semigroup char)) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_32466 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) empty) : @archimedean.{1} (plift.{1} (semiring.{0} unsigned)) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) empty h0) (plift.{1} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_32467 (h0 : functor.add_const (topological_space (semiring empty)) empty) : @discrete_topology.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32468 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) name) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_32469 (h0 : topological_space (comm_semigroup (has_add linarith.comp))) : preconnected_space (comm_semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_32470 (h0 : functor.add_const (functor.add_const (functor.add_const Prop (add_cancel_monoid pos)) pos) name) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_32471 (h0 : ring (comm_group (comm_group (has_nndist pos)))) : rank_condition (comm_group (comm_group (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_32472 (h0 : ring (linear_ordered_semiring (semiring num))) : is_domain (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_32473 (h0 : functor.add_const (add_group (ordered_comm_monoid linarith.comp)) Type) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_32474 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_32475 (h0 : non_assoc_semiring name -> non_assoc_semiring name -> Prop) : is_strict_order (non_assoc_semiring name) h0 := sorry --non-trivial
lemma new_lemma_32476 (h0 : functor.add_const (add_group (add_cancel_monoid name)) linarith.comp) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32477 (h1 : topological_space (has_emptyc (random_gen linarith.comp_source))) : t0_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32478 (h0 : topological_space (ordered_comm_ring Type)) : t1_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_32479 (h0 : functor.add_const (ring (semigroup unsigned)) linarith.comp) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32480 (h0 : topological_space (has_emptyc linarith.comp)) : t0_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_32481 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32482 (h0 : list (has_inv (has_ssubset char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32483 (h0 : preorder (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) (h1 : set (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_32484 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_32485 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_32486 (h0 : functor.add_const (list (cancel_monoid pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32487 (h0 : topological_space (generalized_boolean_algebra name)) : regular_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_32488 (h0 : monoid (complete_semilattice_Sup (semiring (has_top (semiring empty))))) : monoid.fg (complete_semilattice_Sup (semiring (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_32489 (h0 : functor.add_const (functor.add_const Prop Type) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32490 (h0 : topological_space (ring (has_neg (finset pos)))) : path_connected_space (ring (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_32491 (h0 : topological_space (ring pos)) : t0_space (ring pos) := sorry --non-trivial
lemma new_lemma_32492 (h0 : add_group (canonically_linear_ordered_monoid (option (option (option congr_arg_kind))))) : is_add_cyclic (canonically_linear_ordered_monoid (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_32493 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) unsigned) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32494 (h0 : ring (ordered_comm_group (option unsigned))) : rank_condition (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_32495 (h0 : monoid (has_one (has_top linarith.comp))) : monoid.fg (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_32496 (h0 : ring (encodable (random_gen linarith.comp_source))) : is_domain (encodable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32497 (h0 : topological_space (has_add (has_neg linarith.comp))) : discrete_topology (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_32498 (h0 : add_monoid (option unsigned)) : add_monoid.fg (option unsigned) := sorry --non-trivial
lemma new_lemma_32499 (h0 : functor.add_const (filter (normed_comm_ring pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32500 (h0 : ring (nondiscrete_normed_field (normed_field reducibility_hints))) : strong_rank_condition (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_32501 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) unsigned) : @preirreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32502 (h0 : ring (add_comm_semigroup (add_comm_semigroup char))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_32503 (h0 : list (semigroup (has_zero environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32504 (h0 : set (mul_one_class enat -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_32505 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup empty)) (option (option (option (option empty))))) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) (option.{0} (option.{0} (option.{0} (option.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_32506 (h0 : list (has_nndist (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32507 (h0 : filter (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32508 (h0 : complete_lattice (add_cancel_monoid (has_neg (has_add (has_neg linarith.comp))))) : is_compactly_generated (add_cancel_monoid (has_neg (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_32509 (h0 : group (with_one (has_top (has_norm fun_info)))) : group.fg (with_one (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_32510 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_Inf (has_Inf pos))) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_32511 (h0 : functor.add_const (group (sub_neg_monoid pos)) linarith.comp) : @is_simple_group.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_32513 (h0 : topological_space (mul_one_class (mul_one_class enat))) : path_connected_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_32514 (h0 : group (plift (semiring (semiring (semiring (semiring empty)))))) : normalizer_condition (plift (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_32515 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_32516 (h0 : complete_lattice (has_neg_part (option pos))) : is_compactly_generated (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_32517 (h1 : ring (mul_one_class (add_comm_semigroup enat))) : strong_rank_condition (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_32518 (h0 : topological_space (normed_comm_ring empty)) : path_connected_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_32519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32520 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_32521 (h0 : topological_space (ring (mul_one_class linarith.comp))) : preconnected_space (ring (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_32522 (h1 : ring (complete_semilattice_Sup linarith.comp_source)) : strong_rank_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32523 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32524 (h0 : finset (add_cancel_monoid name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32525 (h0 : ring (with_zero (has_ssubset (random_gen linarith.ineq)))) : rank_condition (with_zero (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32526 (h0 : group znum) : group.fg znum := sorry --non-trivial
lemma new_lemma_32527 (h0 : group (finset (finset ennreal))) : is_simple_group (finset (finset ennreal)) := sorry --non-trivial
lemma new_lemma_32528 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_32529 (h0 : functor.add_const (complete_lattice (boolean_algebra environment.implicit_infer_kind)) name) : @is_atomistic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_32530 (h0 : group (random_gen linarith.comp)) : normalizer_condition (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_32531 (h0 : topological_space (normed_comm_ring (has_add pos))) : t1_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_32532 (h8 : reducibility_hints) (h9 : Type) (h10 : h9) : heq h8 h10 := sorry --non-trivial
lemma new_lemma_32533 (h0 : functor.add_const (topological_space (has_Sup unsigned)) (option (option empty))) : @locally_compact_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32534 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_32535 (h0 : list (linear_ordered_comm_group num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32536 (h0 : functor.add_const (ring (normed_comm_ring pos)) Type) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_32537 (h0 : monoid (measurable_space (has_inv (random_gen linarith.comp_source)))) : monoid.fg (measurable_space (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32538 (h0 : ring (has_inv linarith.ineq)) : is_domain (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_32539 (h0 : ring (bin_tree empty)) : is_domain (bin_tree empty) := sorry --non-trivial
lemma new_lemma_32540 (h0 : topological_space (has_bot (has_add Type))) : topological_space.separable_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_32541 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32542 (h0 : complete_lattice (has_top (has_norm linarith.ineq))) : is_compactly_generated (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32543 (h0 : uniform_space (normed_comm_ring (has_nndist (has_add (has_add linarith.comp))))) : separated_space (normed_comm_ring (has_nndist (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_32544 (h0 : functor.add_const (topological_space (ring Type)) pos) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_32545 (h0 : not (uniform_space (with_zero char) -> false)) : @complete_space.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32546 (h0 : functor.add_const (list (has_nndist pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32547 (h0 : list (cancel_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32548 (h0 : not (add_group (semi_normed_ring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_32549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_32550 (h0 : not (group (semi_normed_comm_ring linarith.comp_source) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_32551 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_32552 (h0 : complete_lattice (add_left_cancel_semigroup empty)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_32553 (h7 : topological_space linarith.ineq) : t0_space linarith.ineq := sorry --non-trivial
lemma new_lemma_32554 (h0 : functor.add_const (function.extfun (Type 1) ring) (ordered_ring Type)) : @rank_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ordered_ring.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_32555 (h0 : finset (canonically_ordered_comm_semiring linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32556 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_32557 (h0 : filter (has_bot (finset (has_add (has_Inf pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32558 (h0 : ring (boolean_algebra (has_add (has_add (has_add pos))))) : is_domain (boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_32559 (h0 : filter (left_cancel_semigroup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32560 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @unique_factorization_monoid.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type cancel_comm_monoid_with_zero.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_32561 (h1 : topological_space (random_gen (has_top to_additive.value_type))) : totally_separated_space (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32562 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) ennreal) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_32563 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))))) : t0_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_32564 (h0 : functor.comp topological_space has_to_string (has_nndist name)) : @topological_space.separable_space.{0} (has_to_string.{0} (has_nndist.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_32565 (h0 : functor.add_const (uniform_space (ordered_ring congr_arg_kind)) empty) : @complete_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_32566 (h0 : functor.add_const (complete_lattice (has_inter ennreal)) num) : @is_compactly_generated.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_32567 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_32568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_32569 (h0 : functor.add_const (semiring (add_cancel_monoid name)) (option (option pos))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} name)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_32570 (h0 : filter (ring (finset (has_nndist pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32571 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32572 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_32573 (h0 : filter (measurable_space.dynkin_system unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32574 (h0 : functor.add_const (complete_lattice (ring Type)) pos) : @is_atomistic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_32575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) znum) := sorry --non-trivial
lemma new_lemma_32576 (h0 : ordered_comm_monoid (has_neg_part (semigroup pos))) : has_exists_mul_of_le (has_neg_part (semigroup pos)) := sorry --non-trivial
lemma new_lemma_32577 (h1 : ring (comm_ring (has_ssubset to_additive.value_type))) : strong_rank_condition (comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32578 (h0 : complete_lattice (add_comm_monoid name)) : is_atomistic (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_32579 (h1 : complete_lattice (has_ssubset std_gen)) : is_compactly_generated (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_32580 (h0 : ring (semi_normed_ring (has_nnnorm linarith.comp_source))) : rank_condition (semi_normed_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32581 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32582 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) linarith.comp) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32583 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_32584 (h0 : not (topological_space (metric_space linarith.comp_source) -> false)) : @path_connected_space.{0} (metric_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_32585 (h1 : list (normed_group to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_32586 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_32587 (h1 : topological_space (has_nnnorm (mul_one_class ereal))) (h2 : preorder (has_nnnorm (mul_one_class ereal))) : order_closed_topology (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_32588 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_32589 (h0 : functor.add_const (ring (plift num)) num) : @is_domain.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_32590 (h0 : ring (has_union unsigned)) : strong_rank_condition (has_union unsigned) := sorry --non-trivial
lemma new_lemma_32591 (h0 : topological_space (with_bot (comm_ring to_additive.value_type))) : irreducible_space (with_bot (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32592 (h0 : topological_space (measurable_space (has_top (has_top (has_emptyc fun_info))))) : totally_separated_space (measurable_space (has_top (has_top (has_emptyc fun_info)))) := sorry --non-trivial
lemma new_lemma_32593 (h0 : not (topological_space (plift empty) -> false)) : @t1_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32594 (h0 : topological_space (has_to_string (ring (has_zero linarith.comp)))) : totally_disconnected_space (has_to_string (ring (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_32595 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_32596 (h0 : ring (linear_ordered_comm_monoid_with_zero (option unsigned))) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_32597 (h0 : functor.add_const (function.extfun Type add_group) (has_pos_part (has_Inf Type))) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) (has_pos_part.{1} (has_Inf.{1} Type)) h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32598 (h0 : topological_space (cancel_monoid (has_add (has_add (boolean_algebra.core (has_neg_part Type)))))) : preirreducible_space (cancel_monoid (has_add (has_add (boolean_algebra.core (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_32599 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_32600 (h0 : topological_space (has_neg_part pos)) : path_connected_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_32601 (h0 : functor.add_const (complete_lattice (has_inter unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_32602 (h1 : uniform_space (semi_normed_comm_ring char)) : complete_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_32603 (h0 : list (monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32604 (h0 : filter Prop) (h1 : sym2 (filter Prop)) (h2 : has_mem.mem h0 h1) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@sym2.mem.other.{0} (filter.{0} Prop) h0 h1 (@id.{0} (@has_mem.mem.{0 0} (filter.{0} Prop) (sym2.{0} (filter.{0} Prop)) (@sym2.has_mem.{0} (filter.{0} Prop)) h0 h1) h2))  := sorry --non-trivial
lemma new_lemma_32605 (h1 : add_group (normed_field linarith.comp_source)) : is_add_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32606 (h0 : uniform_space (has_to_string (has_well_founded (add_cancel_monoid (has_sdiff pos))))) : separated_space (has_to_string (has_well_founded (add_cancel_monoid (has_sdiff pos)))) := sorry --non-trivial
lemma new_lemma_32607 (h0 : add_group (random_gen (random_gen reducibility_hints))) : is_add_cyclic (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_32608 (h0 : uniform_space (normed_comm_ring linarith.comp)) : complete_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_32609 (h0 : ring (fintype (random_gen (random_gen linarith.ineq)))) : is_domain (fintype (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32610 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32611 (h0 : monoid (add_cancel_monoid (ring linarith.comp))) : monoid.fg (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_32612 (h0 : not (topological_space (id empty) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_32613 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32614 (h0 : functor.add_const (group (has_nndist pos)) linarith.comp) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32615 (h0 : filter (has_sub (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32616 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : path_connected_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32617 (h0 : uniform_space (canonically_ordered_monoid linarith.comp)) : complete_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_32618 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_32619 (h0 : not (ring (left_cancel_semigroup congr_arg_kind) -> false)) : @is_domain.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32620 (h0 : topological_space (semigroup (ring (has_neg Type)))) : locally_compact_space (semigroup (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_32621 (h0 : group (semigroup (has_Inf (has_pos_part pos)))) : normalizer_condition (semigroup (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_32622 (h0 : functor.add_const (topological_space (has_neg name)) name) : @totally_disconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_32623 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_32624 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32625 (h0 : monoid (boolean_algebra (comm_group Type))) : monoid.fg (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_32626 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_32627 (h0 : ring (has_top (has_norm linarith.ineq))) : is_domain (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32628 (h0 : complete_lattice (simple_graph (finset name))) : is_compactly_generated (simple_graph (finset name)) := sorry --non-trivial
lemma new_lemma_32629 (h0 : topological_space (has_neg (has_add (has_add pos)))) : t0_space (has_neg (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_32630 (h1 : complete_lattice (semiring linarith.comp)) : is_atomistic (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_32631 (h0 : ring (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind)))) : strong_rank_condition (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_32632 (h0 : ring (finset (has_zero (finset Type)))) : rank_condition (finset (has_zero (finset Type))) := sorry --non-trivial
lemma new_lemma_32633 (h0 : filter (has_neg (has_add (finset (finset environment.implicit_infer_kind))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_32634 (h0 : functor.add_const (topological_space (has_neg name)) (has_to_string linarith.comp)) : @normal_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_32635 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add (canonically_linear_ordered_monoid pos)))) : archimedean (add_cancel_monoid (has_add (canonically_linear_ordered_monoid pos))) := sorry --non-trivial
lemma new_lemma_32636 (h0 : ring (dlist (has_nnnorm (boolean_algebra.core (random_gen string_imp))))) : strong_rank_condition (dlist (has_nnnorm (boolean_algebra.core (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_32637 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : discrete_topology (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32638 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) empty) : @group.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32639 (h0 : topological_space (boolean_algebra.core ennreal)) : normal_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_32640 (h0 : list (has_neg_part (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32641 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) (ring pos)) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (ring.{0} pos) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32642 (h0 : ring (random_gen (has_norm (semiring linarith.comp)))) : strong_rank_condition (random_gen (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_32643 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32644 (h0 : functor.add_const (ring (ordered_cancel_add_comm_monoid empty)) num) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_cancel_add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_32645 (h2 : ring (nondiscrete_normed_field string.iterator_imp)) : is_domain (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_32646 (h0 : functor.add_const (topological_space (semigroup name)) name) : @irreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_32647 (h0 : list (option (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32648 (h0 : ring (generalized_boolean_algebra (has_add Type))) : strong_rank_condition (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_32649 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : irreducible_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_32650 (h0 : topological_space (has_Sup (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (has_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_32651 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_32652 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_32653 (h0 : complete_lattice (with_one string_imp)) : complete_lattice.is_Sup_finite_compact (with_one string_imp) := sorry --non-trivial
lemma new_lemma_32654 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_32655 (h3 : uniform_space (non_unital_non_assoc_semiring (has_append to_additive.value_type))) : complete_space (non_unital_non_assoc_semiring (has_append to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32656 (h0 : ring (is_R_or_C (option empty))) : strong_rank_condition (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_32657 (h2 : set (char -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_32658 (h2 : ring (encodable to_additive.value_type)) : rank_condition (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32659 (h0 : complete_lattice (finset (finset (option name)))) : is_atomistic (finset (finset (option name))) := sorry --non-trivial
lemma new_lemma_32660 (h0 : topological_space (has_emptyc (has_top (has_norm (measurable_space (has_norm fun_info)))))) : irreducible_space (has_emptyc (has_top (has_norm (measurable_space (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_32661 (h0 : complete_lattice (random_gen (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32662 (h0 : topological_space (semiring empty)) : discrete_topology (semiring empty) := sorry --non-trivial
lemma new_lemma_32663 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32664 (h0 : set (simple_graph (mul_one_class ereal))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_32665 (h0 : topological_space (add_left_cancel_semigroup (option (option unsigned)))) : normal_space (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_32666 (h0 : ring (normed_lattice_add_comm_group name)) : is_principal_ideal_ring (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_32667 (h0 : topological_space (complete_distrib_lattice pos)) : sequential_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_32668 (h0 : group (left_cancel_semigroup empty)) : group.fg (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_32669 (h0 : functor.add_const (complete_lattice (comm_group Type)) (comm_group Type)) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (comm_group.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32670 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) (h1 : has_inf (add_comm_semigroup string.iterator_imp)) : has_continuous_inf (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_32671 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp)))) : path_connected_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_32672 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (finset znum))) : unique_factorization_monoid (normed_comm_ring (finset znum)) := sorry --non-trivial
lemma new_lemma_32673 (h0 : group (denumerable (has_nnnorm (has_top to_additive.value_type)))) : group.fg (denumerable (has_nnnorm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_32674 (h0 : topological_space (div_inv_monoid linarith.ineq)) : totally_disconnected_space (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_32675 (h0 : ring (has_top (semiring (semiring unsigned)))) : strong_rank_condition (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_32676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_32677 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero mul_zero_class)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_32678 (h0 : group (with_one (semilattice_inf linarith.ineq))) : group.fg (with_one (semilattice_inf linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32679 (h1 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_32680 (h0 : prod (add_comm_semigroup fun_info) (add_comm_semigroup fun_info)) : set.diagonal (add_comm_semigroup fun_info) h0 := sorry --non-trivial
lemma new_lemma_32681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg name)) := sorry --non-trivial
lemma new_lemma_32682 (h0 : topological_space (has_nndist (add_comm_monoid unsigned))) : locally_compact_space (has_nndist (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_32683 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) pos) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_32684 (h0 : functor.add_const (add_group (add_comm_monoid name)) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_32685 (h0 : complete_lattice (add_comm_monoid (has_add (has_add (has_add name))))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_32686 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_32687 (h1 : topological_space (add_comm_semigroup char)) (h3 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_32688 (h0 : functor.add_const (uniform_space (semigroup unsigned)) unsigned) : @complete_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32689 (h0 : not (ring (comm_ring char) -> false)) : @is_domain.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32690 (h0 : functor.add_const (finset (boolean_algebra pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32691 (h0 : functor.add_const (function.extfun Type add_group) (has_add Type)) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) (has_add.{1} Type) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32692 (h0 : function.extfun nat fin) : @irreducible_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_32693 (h2 : add_group (topological_space char)) : is_add_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_32694 (h0 : function.extfun Type (functor.comp topological_space pseudo_metric_space)) : @totally_separated_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} pseudo_metric_space.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_32695 (h0 : topological_space (comm_group (has_add (has_add (has_add name))))) : irreducible_space (comm_group (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_32696 (h0 : complete_lattice (mul_one_class (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_32697 (h0 : semiring (complete_semilattice_Sup congr_arg_kind)) : is_noetherian_ring (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32698 (h0 : topological_space (has_pos_part (has_add real))) : t0_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_32699 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32700 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_32701 (h0 : complete_lattice (normed_comm_ring congr_arg_kind)) : is_compactly_generated (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32702 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32703 (h1 : not (complete_lattice (has_norm to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_32704 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_32705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_32707 (h0 : topological_space (has_nndist (boolean_algebra name))) : totally_disconnected_space (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_32708 (h4 : topological_space (has_nnnorm to_additive.value_type)) : t0_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32709 (h0 : add_monoid (has_top (semiring unsigned))) : add_monoid.fg (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_32710 (h5 : ring (add_cancel_comm_monoid reducibility_hints)) : is_domain (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_32711 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_32712 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (ring linarith.comp)) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_32713 (h0 : functor.add_const (group (has_Inf name)) pos) : @normalizer_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_32714 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) unsigned) : @totally_disconnected_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32715 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32716 (h0 : functor.add_const (complete_lattice (mul_zero_class unsigned)) Type) : @is_compactly_generated.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_32717 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : path_connected_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_32718 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order empty)) num) : @archimedean.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_32719 (h0 : finset (semigroup (mul_one_class (mul_one_class linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32720 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_32721 (h0 : topological_space (finset (has_add name))) : discrete_topology (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_32722 (h0 : functor.add_const (add_monoid (ordered_comm_monoid linarith.comp)) pos) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_32723 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_32724 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_32725 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : regular_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_32726 (h0 : topological_space (has_norm (has_inv to_additive.value_type))) : irreducible_space (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32727 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) linarith.comp) : @complete_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32729 (h0 : functor.add_const (topological_space (has_neg ennreal)) Type) : @totally_separated_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_32730 (h0 : topological_space (is_R_or_C (semiring (semiring empty)))) : locally_compact_space (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_32731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32732 (h0 : ring (has_nnnorm (measure_theory.measure_space linarith.ineq))) : is_domain (has_nnnorm (measure_theory.measure_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32733 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg Type)) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32734 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) pos) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_32735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32736 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring linarith.comp))))) : t0_space (linear_ordered_semiring (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_32737 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_32738 (h0 : add_monoid (has_one (has_top unsigned))) : add_monoid.fg (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_32739 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32740 (h0 : semiring (ordered_comm_ring (has_add (has_add (has_add (has_add real)))))) : is_noetherian_ring (ordered_comm_ring (has_add (has_add (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_32741 (h1 : complete_lattice (fintype char)) : complete_lattice.is_Sup_finite_compact (fintype char) := sorry --non-trivial
lemma new_lemma_32742 (h0 : not (uniform_space Type -> false)) : @complete_space.{1} Type (@classical.by_contradiction'.{2} (uniform_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} (ring.{0} pos)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (complete_distrib_lattice.{0} (ring.{0} pos)))  := sorry --non-trivial
lemma new_lemma_32744 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring name)) linarith.comp) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32745 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : irreducible_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_32746 (h0 : complete_lattice (normed_comm_ring (ring (has_neg_part Type)))) : is_atomistic (normed_comm_ring (ring (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_32747 (h0 : list (mul_zero_class (mul_zero_class (option name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32748 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @totally_disconnected_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_32749 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_32750 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) linarith.comp) : @t0_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_32751 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core Type)) (cancel_monoid pos)) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) (cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_32752 (h0 : group (linear_ordered_comm_group (option unsigned))) : normalizer_condition (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_32753 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32754 (h0 : topological_space (mul_zero_class (semiring (semiring (semiring (semiring num)))))) : topological_space.separable_space (mul_zero_class (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_32755 (h0 : add_monoid (has_neg Type)) : add_monoid.fg (has_neg Type) := sorry --non-trivial
lemma new_lemma_32756 (h0 : monoid (normed_comm_ring (comm_group unsigned))) : monoid.fg (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_32757 (h0 : add_group (has_top (semiring (has_union num)))) : is_add_cyclic (has_top (semiring (has_union num))) := sorry --non-trivial
lemma new_lemma_32758 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : locally_compact_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_32759 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @t1_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_32760 (h0 : topological_space (measurable_space (has_top (has_top linarith.comp_source)))) : t0_space (measurable_space (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_32761 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : t0_space ennreal := sorry --non-trivial
lemma new_lemma_32762 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32763 (h0 : not (ring (random_gen char) -> false)) : @rank_condition.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32764 (h0 : set (ereal -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_32765 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_32766 (h0 : complete_lattice (has_to_string (finset pos))) : complete_lattice.is_Sup_finite_compact (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_32767 (h0 : topological_space (has_emptyc (has_top fun_info))) : locally_compact_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_32768 (h0 : uniform_space (monoid unsigned)) : separated_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_32769 (h0 : topological_space (has_neg_part name)) : t1_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_32770 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32771 (h0 : complete_lattice (boolean_algebra.core (finset (finset name)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (finset (finset name))) := sorry --non-trivial
lemma new_lemma_32772 (h1 : function.extfun Type group) : @group.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32773 (h0 : functor.add_const (complete_lattice (has_Inf pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_32774 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_32775 (h0 : has_mul linarith.comp) (h1 : group (has_one (con linarith.comp))) : group.fg (has_one (con linarith.comp)) := sorry --non-trivial
lemma new_lemma_32776 (h0 : topological_space (free_add_monoid empty)) : discrete_topology (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_32777 (h0 : group (finset (has_pos_part linarith.comp))) : normalizer_condition (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_32778 (h0 : topological_space (ring (option (option (option unsigned))))) : topological_space.separable_space (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_32779 (h0 : not (function.extfun (Type 1) uniform_space -> false)) : @separated_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) uniform_space.{1}) h0) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32780 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (id (matrix.vec_empty (matrix.vec_empty h1))) := sorry --non-trivial
lemma new_lemma_32781 (h0 : complete_lattice (semigroup (finset pos))) : is_atomistic (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_32782 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_32783 (h0 : ring (simple_graph (has_add Type))) : strong_rank_condition (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_32784 (h0 : list (ring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32785 (h0 : filter (has_top (distrib_lattice (has_inv (has_norm (has_norm to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32786 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_add_comm_monoid_with_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_32787 (h0 : topological_space (has_lt linarith.ineq)) : path_connected_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_32788 (h0 : topological_space (id (semiring empty))) : irreducible_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_32789 (h0 : topological_space (has_inv (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (has_inv (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32790 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_32791 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_32792 (h0 : complete_lattice (is_R_or_C congr_arg_kind)) : is_compactly_generated (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32793 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32794 (h0 : ring (has_add (finset (finset linarith.comp)))) : rank_condition (has_add (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_32795 (h0 : set (mul_one_class enat -> environment.projection_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_32796 (h0 : topological_space (has_nnnorm (has_top (has_top (has_top (has_top to_additive.value_type)))))) : locally_compact_space (has_nnnorm (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_32797 (h0 : uniform_space (with_one (has_norm (linear_ordered_add_comm_group_with_top num)))) : complete_space (with_one (has_norm (linear_ordered_add_comm_group_with_top num))) := sorry --non-trivial
lemma new_lemma_32798 (h0 : topological_space (with_one (random_gen linarith.ineq))) : totally_separated_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32799 (h0 : ordered_comm_monoid (semigroup (ring (finset Type)))) : has_exists_mul_of_le (semigroup (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_32800 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_32801 (h0 : functor.add_const (functor.comp topological_space semigroup environment.implicit_infer_kind) Type) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_32802 (h0 : complete_lattice (has_compl std_gen)) : complete_lattice.is_Sup_finite_compact (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_32803 (h0 : group (linear_ordered_add_comm_group (denumerable (has_top linarith.ineq)))) : is_cyclic (linear_ordered_add_comm_group (denumerable (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32804 (h0 : list (ring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_32805 (h0 : ring (canonically_ordered_monoid pos)) : strong_rank_condition (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_32806 (h0 : topological_space (linear_ordered_comm_group ennreal)) : path_connected_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_32807 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_32808 (h0 : ordered_add_comm_monoid (cancel_monoid (has_add (has_add (has_add (add_comm_monoid name)))))) : archimedean (cancel_monoid (has_add (has_add (has_add (add_comm_monoid name))))) := sorry --non-trivial
lemma new_lemma_32809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_32810 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_32811 (h0 : ring (linear_ordered_comm_monoid_with_zero (option (option (option unsigned))))) : strong_rank_condition (linear_ordered_comm_monoid_with_zero (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_32812 (h0 : group (left_cancel_semigroup unsigned)) : group.fg (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_32813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32814 (h0 : not (group (simple_graph char) -> false)) : @is_cyclic.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (group.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_32815 (h0 : group (linear_ordered_add_comm_group (complete_semilattice_Sup to_additive.value_type))) : is_cyclic (linear_ordered_add_comm_group (complete_semilattice_Sup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32816 (h0 : topological_space (has_to_string (has_add linarith.comp))) : irreducible_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_32817 (h0 : filter (has_star (has_top (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32818 (h0 : not (uniform_space (non_assoc_semiring congr_arg_kind) -> false)) : @separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32820 (h0 : functor.add_const (group (has_add pos)) pos) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_32821 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32822 (h0 : topological_space (has_lt (mul_one_class to_additive.value_type))) : t0_space (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32823 (h0 : semiring (simple_graph (ring environment.implicit_infer_kind))) : is_noetherian_ring (simple_graph (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_32824 (h0 : group (sub_neg_monoid (finset pos))) : is_cyclic (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_32825 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_32826 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @preirreducible_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32827 (h0 : topological_space (has_zero (finset linarith.comp))) : loc_path_connected_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_32828 (h0 : functor.add_const (uniform_space (has_add ennreal)) name) : @complete_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_32829 (h0 : complete_lattice (div_inv_monoid linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_32830 (h0 : topological_space (has_to_string (cancel_monoid pos))) : discrete_topology (has_to_string (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_32831 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @totally_disconnected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_32832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_32833 (h0 : functor.add_const (add_group (add_comm_monoid name)) (has_neg_part Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (add_comm_monoid.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32834 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32835 (h0 : add_monoid (random_gen (semiring (has_norm empty)))) : add_monoid.fg (random_gen (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_32836 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_32837 (h0 : topological_space (mul_one_class fun_info)) (h1 : preorder (mul_one_class fun_info)) : order_topology (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_32838 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (option name)) := sorry --non-trivial
lemma new_lemma_32839 (h0 : uniform_space (comm_semigroup (has_bot (has_bot (has_bot Type))))) : complete_space (comm_semigroup (has_bot (has_bot (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_32840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_32841 (h0 : topological_space (has_neg_part (semigroup ennreal))) : normal_space (has_neg_part (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_32842 (h0 : topological_space (normed_group (random_gen congr_arg_kind))) : irreducible_space (normed_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_32843 (h0 : functor.add_const (topological_space (has_neg name)) name) : @sequential_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_32844 (h0 : topological_space (has_pos_part (has_add (boolean_algebra linarith.comp)))) : path_connected_space (has_pos_part (has_add (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_32845 (h0 : filter (has_inv (random_gen (has_nnnorm (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_32846 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_32847 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @t0_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_32848 (h0 : functor.add_const (monoid (comm_group unsigned)) (has_zero (has_zero environment.implicit_infer_kind))) : @monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} unsigned)) (has_zero.{0} (has_zero.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32849 (h0 : functor.add_const (uniform_space (has_Inf name)) pos) : @complete_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_32850 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_32851 (h0 : functor.comp group ring Type) : @group.fg.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_32852 (h0 : topological_space (mul_zero_class (option (option empty)))) : topological_space.separable_space (mul_zero_class (option (option empty))) := sorry --non-trivial
lemma new_lemma_32853 (h0 : ring (simple_graph (mul_one_class (mul_one_class char)))) : strong_rank_condition (simple_graph (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_32854 (h0 : complete_lattice (measurable_space (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_32855 (h1 : function.extfun Type monoid) : @monoid.fg.{0} num (@function.extfun_app.{2 1} Type monoid.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_32856 (h0 : topological_space (cancel_monoid unsigned)) : path_connected_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_32857 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_32858 (h0 : monoid (normed_lattice_add_comm_group (has_bot (has_bot (has_bot (has_Inf real)))))) : monoid.fg (normed_lattice_add_comm_group (has_bot (has_bot (has_bot (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_32859 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_32860 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset (normed_comm_ring (boolean_algebra linarith.comp)))) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{0} (normed_comm_ring.{0} (boolean_algebra.{0} linarith.comp))) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_32861 (h0 : complete_lattice (random_gen congr_arg_kind)) : is_compactly_generated (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32862 (h0 : not (cancel_comm_monoid_with_zero (left_cancel_semigroup congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32863 (h0 : filter (complete_distrib_lattice (option (option (option empty))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_32864 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.ineq))) : irreducible_space (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32865 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_32866 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_32867 (h0 : ring (has_edist (semiring (semiring unsigned)))) : rank_condition (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_32868 (h0 : topological_space (finset (option (option unsigned)))) : path_connected_space (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_32869 (h0 : ordered_comm_monoid (has_to_string unsigned)) : has_exists_mul_of_le (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_32870 (h0 : function.extfun Type ring) : @is_domain.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32871 (h0 : functor.add_const (topological_space (ring pos)) pos) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_32872 (h0 : topological_space (has_inter (option unsigned))) : irreducible_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_32873 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg (has_neg (has_neg Type)))))) : normal_space (normed_lattice_add_comm_group (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_32874 (h1 : complete_lattice (with_bot to_additive.value_type)) : is_compactly_generated (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_32875 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_32876 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) (boolean_algebra name)) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_32877 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_32878 (h0 : ordered_comm_monoid (ordered_comm_ring (finset (finset (finset pos))))) : has_exists_mul_of_le (ordered_comm_ring (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_32879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_32880 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : discrete_topology (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_32881 (h0 : finset (has_Sup unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32882 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : has_div (has_ssubset string.iterator_imp)) : has_continuous_div (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_32883 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_32884 (h0 : functor.add_const (group (comm_group Type)) Type) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_32885 (h0 : topological_space (ordered_comm_monoid (ring Type))) : irreducible_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_32886 (h0 : ring (has_nndist empty)) : is_principal_ideal_ring (has_nndist empty) := sorry --non-trivial
lemma new_lemma_32887 (h0 : topological_space (add_cancel_monoid (comm_group pos))) : preconnected_space (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_32888 (h0 : topological_space (cancel_monoid (has_add Type))) : normal_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_32889 (h0 : functor.add_const (finset (has_to_string unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32890 (h0 : function.extfun Type group) : @normalizer_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_32891 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_32892 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_32893 (h0 : add_monoid (add_left_cancel_semigroup unsigned)) : add_monoid.fg (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_32894 (h0 : ring (add_left_cancel_monoid (random_gen char))) : strong_rank_condition (add_left_cancel_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_32895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_32896 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : irreducible_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_32897 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_32898 (h0 : ring (has_ssubset (random_gen (random_gen linarith.ineq)))) : is_domain (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_32899 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32900 (h0 : ordered_comm_monoid (add_comm_monoid (ring pos))) : has_exists_mul_of_le (add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_32901 (h0 : functor.add_const (uniform_space (cancel_monoid environment.implicit_infer_kind)) name) : @separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_32902 (h0 : topological_space (finset (has_nndist Type))) : discrete_topology (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_32903 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_32904 (h0 : ring (uniform_space (has_nnnorm linarith.comp_source))) : strong_rank_condition (uniform_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_32905 (h1 : topological_space (sub_neg_monoid (has_inv char))) : totally_disconnected_space (sub_neg_monoid (has_inv char)) := sorry --non-trivial
lemma new_lemma_32906 (h0 : ring (has_top (semiring (has_norm (random_gen congr_arg_kind))))) : is_domain (has_top (semiring (has_norm (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_32907 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_32908 (h0 : topological_space (normed_comm_ring (has_pos_part (finset Type)))) : locally_compact_space (normed_comm_ring (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_32909 (h0 : ring (has_ssubset (has_inv linarith.ineq))) : rank_condition (has_ssubset (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32910 (h0 : ring (has_add Type)) : is_principal_ideal_ring (has_add Type) := sorry --non-trivial
lemma new_lemma_32911 (h0 : topological_space (ring Type)) : topological_space.separable_space (ring Type) := sorry --non-trivial
lemma new_lemma_32912 (h0 : ring (has_edist congr_arg_kind)) : is_domain (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32913 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @path_connected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_32914 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @totally_separated_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32915 (h0 : uniform_space (linear_order (ordered_comm_group (option empty)))) : separated_space (linear_order (ordered_comm_group (option empty))) := sorry --non-trivial
lemma new_lemma_32916 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option num))) : complete_space (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_32917 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_32918 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_32919 (h0 : ring (normed_group (random_gen fun_info))) : rank_condition (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_32920 (h0 : topological_space (has_add (has_add unsigned))) : topological_space.separable_space (has_add (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_32921 (h2 : topological_space (normed_field string.iterator_imp)) : totally_disconnected_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_32922 (h0 : semiring (ordered_comm_monoid (has_add name))) : is_noetherian_ring (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_32923 (h0 : ring (add_cancel_monoid (has_add Type))) : is_domain (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_32924 (h0 : topological_space (normed_comm_ring (boolean_algebra.core name))) : totally_separated_space (normed_comm_ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_32925 (h0 : not (topological_space (normed_group num) -> false)) : @locally_compact_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_32926 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_32927 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32928 (h0 : topological_space (measure_theory.measure_space (semiring num))) : irreducible_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_32929 (h1 : complete_lattice (dlist (random_gen char))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_32930 (h0 : add_monoid (has_norm (has_norm linarith.comp))) : add_monoid.fg (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_32931 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (has_nnnorm (mul_one_class enat)))))) : rank_condition (has_nnnorm (mul_one_class (mul_one_class (has_nnnorm (mul_one_class enat))))) := sorry --non-trivial
lemma new_lemma_32932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_32933 (h0 : topological_space (boolean_algebra (has_add name))) : preconnected_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_32934 (h0 : fin has_zero.zero) : @monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type (@matrix.vec_empty.{0} (functor.add_const.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type) h0))))) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_32935 (h1 : ring (has_emptyc (random_gen linarith.comp))) : is_domain (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_32936 (h0 : add_group (simple_graph (mul_one_class std_gen))) : is_add_cyclic (simple_graph (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_32937 (h0 : functor.add_const (functor.add_const (group pos) linarith.comp) linarith.comp) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_32938 (h0 : functor.add_const (ring (semiring unsigned)) congr_arg_kind) : @rank_condition.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_32939 (h0 : topological_space (semiring congr_arg_kind)) : locally_compact_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_32941 (h0 : topological_space (generalized_boolean_algebra (generalized_boolean_algebra (comm_group Type)))) : path_connected_space (generalized_boolean_algebra (generalized_boolean_algebra (comm_group Type))) := sorry --non-trivial
lemma new_lemma_32942 (h0 : uniform_space (semiring congr_arg_kind)) : separated_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32943 (h0 : functor.add_const (topological_space (cancel_monoid num)) num) : @discrete_topology.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_32944 (h0 : ring (comm_ring (comm_ring char))) : is_domain (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_32945 (h0 : topological_space (boolean_algebra.core (option (option unsigned)))) : irreducible_space (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_32946 (h0 : topological_space (has_compl (mul_one_class char))) (h1 : preorder (has_compl (mul_one_class char))) : order_closed_topology (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_32947 (h1 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : Exists (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_32948 (h0 : finset (bin_tree (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_32949 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_32950 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_32951 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_32952 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_32953 (h0 : functor.add_const (uniform_space (ordered_ring congr_arg_kind)) unsigned) : @separated_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32954 (h0 : semiring (ring (normed_comm_ring (has_Inf (has_Inf (has_Inf Type)))))) : is_noetherian_ring (ring (normed_comm_ring (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_32955 (h0 : topological_space (linear_ordered_comm_group_with_zero environment.projection_info)) : totally_disconnected_space (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_32956 (h0 : topological_space (has_bot empty) -> Prop) (h1 : Exists (fun (x : topological_space (has_bot empty)), h0 x)) : @loc_path_connected_space.{0} (has_bot.{0} empty) (@classical.some.{1} (topological_space.{0} (has_bot.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_32957 (h0 : ring (has_zero (ring linarith.comp))) : is_principal_ideal_ring (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_32958 (h0 : semiring (has_to_string (ordered_ring linarith.comp))) : is_noetherian_ring (has_to_string (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_32959 (h0 : functor.add_const (add_monoid (has_add name)) (normed_comm_ring Type)) : @add_monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} name)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_32960 (h0 : set (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_32961 (h0 : complete_lattice (cancel_monoid (finset Type))) : is_compactly_generated (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_32962 (h0 : topological_space (ordered_ring (semiring (semiring (semiring (semiring num)))))) : irreducible_space (ordered_ring (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_32963 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_32964 (h0 : topological_space (simple_graph (boolean_algebra.core (boolean_algebra.core (has_Inf Type))))) : loc_path_connected_space (simple_graph (boolean_algebra.core (boolean_algebra.core (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_32965 (h0 : uniform_space (has_zero (has_neg_part linarith.comp))) : complete_space (has_zero (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_32966 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_32967 (h0 : not (complete_lattice (random_gen (has_nnnorm linarith.ineq)) -> false)) : @is_compactly_generated.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_32968 (h0 : ring (uniform_space string.iterator_imp)) : is_domain (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_32969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_32970 (h0 : topological_space (generalized_boolean_algebra real)) : irreducible_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_32971 (h0 : add_group (has_le (normed_field (mul_one_class fun_info)))) : is_add_cyclic (has_le (normed_field (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_32972 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : t1_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_32973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_32974 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid ennreal)) (option num)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} ennreal)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_32975 (h0 : topological_space (random_gen (random_gen fun_info))) : t0_space (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_32976 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : loc_path_connected_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_32977 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_32978 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_32979 (h0 : ring (canonically_ordered_comm_semiring Type)) : is_domain (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_32980 (h0 : topological_space (semigroup (has_to_string unsigned))) : totally_separated_space (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_32981 (h0 : ring (ordered_comm_group unsigned)) : rank_condition (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_32982 (h0 : functor.add_const (uniform_space (has_to_string name)) linarith.comp) : @complete_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_32983 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (add_cancel_monoid.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_32984 (h0 : ring (canonically_ordered_monoid (has_add pos))) : is_principal_ideal_ring (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_32985 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_32986 (h0 : group (measurable_space (has_norm string_imp))) : group.fg (measurable_space (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_32987 (h0 : functor.add_const (ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) unsigned) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_32988 (h0 : add_group (semiring linarith.comp)) : is_add_cyclic (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_32989 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_32990 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_32991 (h0 : ring (linear_ordered_add_comm_group (linear_ordered_add_comm_group to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_32992 (h0 : topological_space (has_pos_part (ordered_ring (ring Type)))) : preirreducible_space (has_pos_part (ordered_ring (ring Type))) := sorry --non-trivial
lemma new_lemma_32993 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) (has_neg name)) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_32994 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring empty))))) : irreducible_space (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_32995 (h0 : function.extfun Type (functor.add_const (complete_lattice (free_add_monoid empty)))) : @is_compactly_generated.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_32996 (h0 : list (topological_space string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_32997 (h0 : complete_lattice (semigroup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_32998 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_32999 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_33000 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid Type)) Type) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_33001 (h0 : complete_lattice (has_compl (mul_one_class std_gen))) : is_compactly_generated (has_compl (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_33002 (h1 : add_group (distrib char)) : is_add_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_33003 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : t0_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_33004 (h0 : topological_space (boolean_algebra.core (has_to_string name))) : sequential_space (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_33005 (h0 : add_group (with_one num)) : is_add_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_33006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33007 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_33008 (h0 : topological_space (metric_space congr_arg_kind)) : totally_separated_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33009 (h0 : add_monoid (semigroup (cancel_monoid name))) : add_monoid.fg (semigroup (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_33010 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_33011 (h0 : finset (complete_distrib_lattice (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33012 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} complex) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} complex))  := sorry --non-trivial
lemma new_lemma_33013 (h0 : add_group (id (has_inv (has_inv fun_info)))) : is_add_cyclic (id (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_33014 (h0 : list (comm_group (semigroup name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33015 (h0 : monoid (sub_neg_monoid (has_add (has_add pos)))) : monoid.fg (sub_neg_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_33016 (h0 : function.extfun Type topological_space) : @t1_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33017 (h0 : uniform_space (generalized_boolean_algebra Type)) : separated_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_33018 (h0 : functor.add_const (ring (add_cancel_monoid ennreal)) ennreal) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_33019 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name))))))  := sorry --non-trivial
lemma new_lemma_33020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_33021 (h0 : topological_space (finset (has_neg Type))) : path_connected_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_33022 (h0 : functor.add_const (topological_space Type) (finset linarith.comp)) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_33023 (h0 : complete_lattice (canonically_ordered_add_monoid empty)) : is_compactly_generated (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_33024 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup (has_to_string unsigned))) linarith.comp) : @unique_factorization_monoid.{0} (semigroup.{0} (has_to_string.{0} unsigned)) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} (has_to_string.{0} unsigned))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33025 (h0 : ordered_comm_monoid (has_neg_part (has_neg_part pos))) : has_exists_mul_of_le (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_33026 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33027 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_33028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_33029 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33030 (h0 : uniform_space (has_nnnorm (has_nnnorm (has_nnnorm char)))) : complete_space (has_nnnorm (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_33031 (h0 : uniform_space (mul_one_class environment.projection_info)) : complete_space (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_33032 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : preconnected_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33033 (h0 : ordered_add_comm_monoid (has_zero (has_pos_part Type))) : archimedean (has_zero (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_33034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_33035 (h0 : function.extfun Type ring) : @rank_condition.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33036 (h1 : topological_space (filter ereal)) (h2 : set (filter ereal)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_33037 (h0 : ring (with_zero to_additive.value_type)) : rank_condition (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33038 (h0 : uniform_space (boolean_algebra.core (has_neg name))) : separated_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_33039 (h0 : topological_space (add_cancel_monoid linarith.comp)) : irreducible_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_33040 (h0 : topological_space (id congr_arg_kind)) : t0_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33042 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @sequential_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_33043 (h0 : functor.comp topological_space comm_group Type) : @preconnected_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_33044 (h0 : ordered_comm_monoid environment.implicit_infer_kind) : has_exists_mul_of_le environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_33045 (h0 : group (complete_distrib_lattice (ring (ring (ring (ring Type)))))) : normalizer_condition (complete_distrib_lattice (ring (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_33046 (h0 : functor.add_const (complete_lattice (simple_graph pos)) pos) : @is_compactly_generated.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_33047 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg linarith.comp)) : @normal_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} linarith.comp) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_33048 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : discrete_topology (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_33049 (h0 : functor.add_const (ring (has_neg_part ennreal)) unsigned) : @is_domain.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33050 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33051 (h0 : measurable_space (has_compl enat)) (h1 : has_div (has_compl enat)) : has_measurable_div (has_compl enat) := sorry --non-trivial
lemma new_lemma_33052 (h0 : topological_space (lex (has_to_string congr_arg_kind))) : t0_space (lex (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33053 (h0 : finset (has_neg_part (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33054 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33055 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_33056 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} (has_neg_part.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} (has_neg_part.{0} pos)))  := sorry --non-trivial
lemma new_lemma_33057 (h0 : ordered_comm_monoid (comm_group linarith.comp)) : has_exists_mul_of_le (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_33058 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_33059 (h0 : functor.add_const (semiring (generalized_boolean_algebra Type)) Type) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_33060 (h0 : list (linear_ordered_add_comm_group (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33061 (h0 : topological_space (has_top (has_top (has_top congr_arg_kind)))) : t0_space (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_33062 (h0 : complete_lattice (ring (has_add Type))) : complete_lattice.is_Sup_finite_compact (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_33063 (h0 : ring (ring (has_neg_part (has_neg Type)))) : is_domain (ring (has_neg_part (has_neg Type))) := sorry --non-trivial
lemma new_lemma_33064 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) linarith.comp) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33065 (h1 : complete_lattice (div_inv_monoid (comm_ring (fintype linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (comm_ring (fintype linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_33066 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33067 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_33068 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33069 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) name) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_33070 (h0 : topological_space (dlist (random_gen (random_gen fun_info)))) : totally_disconnected_space (dlist (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_33071 (h0 : complete_lattice char) : is_compactly_generated char := sorry --non-trivial
lemma new_lemma_33072 (h0 : topological_space (has_neg (ring Type))) : preirreducible_space (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_33073 (h0 : group (has_inner empty congr_arg_kind)) : group.fg (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33074 (h0 : functor.add_const (topological_space (plift empty)) num) : @totally_disconnected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_33075 (h0 : group (ring (boolean_algebra environment.implicit_infer_kind))) : is_cyclic (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33076 (h0 : not (ring (has_norm num) -> false)) : @is_domain.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_33077 (h0 : list (has_Inf (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_33078 (h0 : fin has_zero.zero) : @is_simple_group.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_33079 (h0 : topological_space (with_bot (has_top to_additive.value_type))) : totally_disconnected_space (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33080 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : topological_space.separable_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_33081 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_33082 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_33083 (h3 : topological_space (topological_space char)) : path_connected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_33084 (h0 : uniform_space (has_bot (has_add pos))) : complete_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_33085 (h0 : topological_space (bin_tree unsigned)) : totally_separated_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_33086 (h0 : topological_space (ordered_comm_ring (finset (has_pos_part linarith.comp)))) : irreducible_space (ordered_comm_ring (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_33087 (h0 : list (semiring (option (option (option empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33088 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_semigroup empty)) := sorry --non-trivial
lemma new_lemma_33089 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_33090 (h0 : fin has_zero.zero) : @irreducible_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_33091 (h0 : topological_space (add_cancel_monoid (comm_group unsigned))) : irreducible_space (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_33092 (h0 : functor.add_const (topological_space (complete_linear_order empty)) (semiring (semiring empty))) : @normal_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_33093 (h0 : group (ordered_comm_monoid (has_add pos))) : is_cyclic (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_33094 (h0 : group (has_top (has_top fun_info))) : is_cyclic (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_33095 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33096 (h0 : filter (boolean_algebra.core (option (has_add name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33097 (h0 : topological_space (dlist (has_ssubset (random_gen string_imp)))) : t0_space (dlist (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_33098 (h0 : ring (semigroup linarith.comp)) : strong_rank_condition (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_33099 (h0 : ring (has_neg (option congr_arg_kind))) : is_principal_ideal_ring (has_neg (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33100 (h0 : cancel_comm_monoid_with_zero (semiring empty)) : unique_factorization_monoid (semiring empty) := sorry --non-trivial
lemma new_lemma_33101 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33102 (h0 : monoid (mul_zero_class (semiring (semiring num)))) : monoid.fg (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_33103 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (has_neg Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_33104 (h0 : not (group (with_one linarith.comp_source) -> false)) : @group.fg.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_33105 (h0 : topological_space (has_neg (ring pos))) : irreducible_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_33106 (h0 : functor.add_const (semiring (has_nndist environment.implicit_infer_kind)) (semigroup linarith.comp)) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} environment.implicit_infer_kind)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_33107 (h0 : ring (measurable_space.dynkin_system (has_top num))) : rank_condition (measurable_space.dynkin_system (has_top num)) := sorry --non-trivial
lemma new_lemma_33108 (h0 : add_group (simple_graph (has_nnnorm (nondiscrete_normed_field linarith.comp_source)))) : is_add_cyclic (simple_graph (has_nnnorm (nondiscrete_normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_33109 (h0 : ring (distrib (comm_ring (normed_field (has_nnnorm linarith.comp_source))))) : is_domain (distrib (comm_ring (normed_field (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_33110 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : locally_compact_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_33111 (h0 : topological_space (has_pos_part (has_pos_part pos))) : topological_space.separable_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_33112 (h0 : topological_space (has_scalar (boolean_algebra string_imp) string_imp)) (h1 : set (has_scalar (boolean_algebra string_imp) string_imp)) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_33113 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_33114 (h0 : ordered_add_comm_monoid (has_to_string (boolean_algebra.core linarith.comp))) : archimedean (has_to_string (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_33115 (h0 : function.extfun Type (functor.add_const (ring (plift empty)))) : @is_principal_ideal_ring.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} (plift.{1} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_33116 (h0 : ring (has_dist empty)) : rank_condition (has_dist empty) := sorry --non-trivial
lemma new_lemma_33117 (h0 : topological_space (finset (normed_comm_ring pos))) : totally_disconnected_space (finset (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_33118 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_33120 (h0 : group (topological_space (has_nnnorm string.iterator_imp))) : is_cyclic (topological_space (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_33121 (h0 : group (normed_comm_ring (add_cancel_monoid pos))) : is_simple_group (normed_comm_ring (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_33122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_33123 (h0 : functor.add_const (ring (plift num)) empty) : @strong_rank_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_33124 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid pos)) Type) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_33125 (h0 : not (filter (has_compl fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_33126 (h0 : not (complete_lattice (linear_ordered_comm_ring num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_33127 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33128 (h0 : group (normed_group (semiring empty))) : is_cyclic (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_33129 (h0 : ring (has_pos_part real)) : strong_rank_condition (has_pos_part real) := sorry --non-trivial
lemma new_lemma_33130 (h0 : list (distrib_lattice (has_nnnorm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33131 (h0 : functor.add_const (uniform_space (has_neg_part linarith.comp)) linarith.comp) : @separated_space.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33132 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_33133 (h0 : mul_one_class (has_lt linarith.comp_source) -> mul_one_class (has_lt linarith.comp_source) -> Prop) : is_antisymm (mul_one_class (has_lt linarith.comp_source)) h0 := sorry --non-trivial
lemma new_lemma_33134 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_33135 (h0 : group (complete_distrib_lattice congr_arg_kind)) : group.fg (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33136 (h0 : monoid (has_to_string (comm_group Type))) : monoid.fg (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_33137 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33138 (h0 : ring (semigroup (boolean_algebra Type))) : strong_rank_condition (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_33139 (h0 : functor.add_const Prop (complete_distrib_lattice unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33140 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_33141 (h0 : functor.add_const nat (add_comm_monoid name)) (h1 : list (mul_zero_class (composition_as_set (functor.add_const.run h0)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_33142 (h0 : topological_space (pseudo_metric_space empty)) : preirreducible_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_33143 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33144 (h0 : functor.add_const (complete_lattice (add_comm_monoid linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33145 (h0 : monoid (mul_zero_class (option name))) : monoid.fg (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_33146 (h0 : topological_space (has_zero (has_neg_part (comm_group unsigned)))) : sequential_space (has_zero (has_neg_part (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_33147 (h0 : std_gen -> std_gen -> Prop) (h1 : set std_gen) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_33148 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : preirreducible_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_33149 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_33150 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_33151 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_33152 (h0 : fin has_zero.zero) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_33153 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : totally_separated_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_33154 (h0 : list (distrib_lattice linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33155 (h0 : not (topological_space (with_one fun_info) -> false)) : @totally_disconnected_space.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_33156 (h0 : functor.add_const (list (complete_distrib_lattice Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33158 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_33159 (h0 : group (has_pos_part (has_neg Type))) : is_cyclic (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_33160 (h0 : filter (has_norm (has_emptyc num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33161 (h0 : add_monoid (has_edist (option (option (option empty))))) : add_monoid.fg (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_33162 (h0 : functor.add_const (group (has_add name)) pos) : @normalizer_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_33163 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_33164 (h0 : filter (pseudo_metric_space (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33165 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33166 (h0 : topological_space (finset ennreal)) : regular_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_33167 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_33168 (h0 : complete_lattice (add_cancel_monoid (has_neg_part pos))) : is_compactly_generated (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_33169 (h0 h1 : multiset (mul_one_class (normed_field (normed_field (normed_field char))))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_33170 (h0 : topological_space (with_one (random_gen char))) : totally_disconnected_space (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_33171 (h0 : add_monoid (has_neg pos)) : add_monoid.fg (has_neg pos) := sorry --non-trivial
lemma new_lemma_33172 (h0 : group (has_one unsigned)) : group.fg (has_one unsigned) := sorry --non-trivial
lemma new_lemma_33173 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) congr_arg_kind) : @path_connected_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33174 (h0 : functor.add_const (semiring (has_Inf pos)) linarith.comp) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33175 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_33176 (h0 : not (filter (add_group congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_33177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_33178 (h0 : add_monoid (canonically_ordered_monoid (has_Inf real))) : add_monoid.fg (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_33179 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_33180 (h0 : group (id (has_norm empty))) : normalizer_condition (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_33181 (h0 : functor.add_const (monoid (semigroup name)) (finset (ring Type))) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} name)) (finset.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_33182 (h1 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_33183 (h1 : filter (has_emptyc congr_arg_kind)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_33184 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_33185 (h0 : functor.comp topological_space add_comm_monoid pos) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_33186 (h3 : ring (add_monoid fun_info)) : rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_33187 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_33188 (h0 : functor.add_const (complete_lattice (boolean_algebra.core congr_arg_kind)) (has_to_string (has_to_string num))) : @is_atomistic.{0} (boolean_algebra.core.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} congr_arg_kind)) (has_to_string.{0} (has_to_string.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_33189 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @is_compactly_generated.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_33190 (h0 : functor.add_const (complete_lattice (mul_zero_class name)) name) : @is_atomistic.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_33191 (h0 : ring (has_emptyc to_additive.value_type)) : rank_condition (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33192 (h0 : topological_space (has_nndist ereal)) : t2_5_space (has_nndist ereal) := sorry --non-trivial
lemma new_lemma_33193 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_33194 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : normal_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_33195 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : preconnected_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_33196 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normal_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_33197 (h1 : group (id to_additive.value_type)) : is_cyclic (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33198 (h0 : functor.add_const (topological_space (finset pos)) (add_left_cancel_monoid environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (add_left_cancel_monoid.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_33199 (h0 : topological_space (distrib to_additive.value_type)) : totally_disconnected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33200 (h0 : not (ring (topological_space to_additive.value_type) -> false)) : @rank_condition.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_33201 (h2 : topological_space (has_add linarith.comp_source)) : t0_space (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33202 (h0 : fin has_zero.zero) : @regular_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_33203 (h0 : uniform_space (topological_space char)) : complete_space (topological_space char) := sorry --non-trivial
lemma new_lemma_33204 (h0 : functor.add_const (group (non_assoc_semiring empty)) empty) : @group.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_33205 (h0 : function.extfun Type (functor.add_const (functor.add_const (list (semigroup empty)) empty))) : list.nodup (functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty))) := sorry --non-trivial
lemma new_lemma_33206 (h0 : ring (semi_normed_comm_ring linarith.comp_source)) : is_domain (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33207 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33208 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_33209 (h0 : uniform_space (ring (option (finset ennreal)))) : complete_space (ring (option (finset ennreal))) := sorry --non-trivial
lemma new_lemma_33210 (h0 : topological_space (add_monoid (has_nnnorm fun_info))) : t0_space (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_33211 (h0 : functor.add_const (ring (semigroup pos)) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33212 (h0 : topological_space (complete_distrib_lattice (semigroup pos))) : discrete_topology (complete_distrib_lattice (semigroup pos)) := sorry --non-trivial
lemma new_lemma_33213 (h0 : group (id (with_bot string_imp))) : normalizer_condition (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_33214 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_33215 (h1 : not (group (semi_normed_ring char) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_33216 (h0 : topological_space (has_to_string (semigroup Type))) : preconnected_space (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_33217 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @preconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_33218 (h0 : semiring (has_Inf (ring (ring (has_to_string (has_pos_part pos)))))) : is_noetherian_ring (has_Inf (ring (ring (has_to_string (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_33219 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33220 (h0 : topological_space (has_nndist (finset pos))) : totally_disconnected_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_33221 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33222 (h0 : functor.add_const (add_group (cancel_monoid name)) (boolean_algebra environment.implicit_infer_kind)) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} name)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_33223 (h0 : topological_space (add_cancel_monoid unsigned)) : irreducible_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_33224 (h0 : group (semigroup (mul_one_class linarith.comp))) : is_simple_group (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_33225 (h1 : add_group (mul_one_class linarith.ineq)) : is_add_cyclic (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_33226 (h0 : topological_space (boolean_algebra real)) : irreducible_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_33227 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_33228 (h0 : std_gen -> std_gen) : function.injective h0 := sorry --non-trivial
lemma new_lemma_33229 (h1 : not (ring (semi_normed_ring string_imp) -> false)) : @is_domain.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_33230 (h0 : topological_space (is_R_or_C empty)) : topological_space.separable_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_33231 (h0 : group (has_add (mul_one_class (has_neg linarith.comp)))) : normalizer_condition (has_add (mul_one_class (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_33232 (h0 : add_group (has_to_string (has_neg_part (has_neg_part Type)))) : is_add_cyclic (has_to_string (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_33233 (h0 : topological_space (has_neg_part (has_add (has_neg_part Type)))) : locally_compact_space (has_neg_part (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_33234 (h0 : functor.comp topological_space canonically_ordered_comm_semiring (has_nndist pos)) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} (has_nndist.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_33235 (h0 : add_comm_semigroup enat -> add_comm_semigroup enat -> Prop) : is_irrefl (add_comm_semigroup enat) h0 := sorry --non-trivial
lemma new_lemma_33236 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_33237 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_33238 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33239 (h0 : topological_space (uniform_space (mul_one_class fun_info))) : t0_space (uniform_space (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_33240 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg name)) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} name) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_33241 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33242 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring ennreal)) : has_exists_mul_of_le (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_33243 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_33244 (h0 : ring (canonically_linear_ordered_monoid name)) : is_domain (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_33245 (h0 : ring (ordered_comm_ring (has_add name))) : is_principal_ideal_ring (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_33246 (h1 : complete_lattice (id (with_bot string_imp))) : is_atomistic (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_33247 (h1 : complete_lattice (mul_one_class (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_33248 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33249 (h0 : topological_space (left_cancel_monoid empty)) : topological_space.separable_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_33250 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_33251 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33252 (h0 : prod (free_add_monoid empty) (free_add_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_33253 (h0 : topological_space (comm_group (has_to_string (cancel_monoid pos)))) : irreducible_space (comm_group (has_to_string (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_33254 (h0 : ring (has_nndist (option (option (option unsigned))))) : rank_condition (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_33255 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_33256 (h0 : functor.add_const (monoid (boolean_algebra pos)) linarith.comp) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33257 (h0 : ring (has_ssubset (random_gen (random_gen char)))) : strong_rank_condition (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_33258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_33259 (h0 : filter (option num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33260 (h0 : topological_space (add_comm_monoid (has_add (normed_comm_ring Type)))) : loc_path_connected_space (add_comm_monoid (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_33261 (h0 : add_group (linear_ordered_add_comm_group (denumerable linarith.ineq))) : is_add_cyclic (linear_ordered_add_comm_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_33262 (h0 : ring (has_compl reducibility_hints)) : is_domain (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_33263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33264 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33265 (h0 : group (random_gen (random_gen (random_gen empty)))) : is_cyclic (random_gen (random_gen (random_gen empty))) := sorry --non-trivial
lemma new_lemma_33266 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @preirreducible_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_33267 (h0 : topological_space (measurable_space.dynkin_system (has_sub unsigned))) : topological_space.separable_space (measurable_space.dynkin_system (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_33268 (h0 : ring (sub_neg_monoid (has_neg (has_neg name)))) : strong_rank_condition (sub_neg_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_33269 (h0 : ring (has_pos_part (sub_neg_monoid (sub_neg_monoid real)))) : strong_rank_condition (has_pos_part (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_33270 (h0 : list (random_gen (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33271 (h0 : add_comm_semigroup (add_comm_semigroup char) -> add_comm_semigroup (add_comm_semigroup char)) (h2 : add_comm_semigroup (add_comm_semigroup char)) : function.is_fixed_pt h0 h2 := sorry --non-trivial
lemma new_lemma_33272 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_33273 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : path_connected_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33274 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_33275 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_33276 (h0 : not (ring (has_div (mul_one_class linarith.ineq)) -> false)) : @strong_rank_condition.{0} (has_div.{0} (mul_one_class.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} (mul_one_class.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_33277 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_33278 (h0 : functor.add_const (uniform_space (semiring empty)) empty) : @separated_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_33279 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33280 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_33281 (h0 : uniform_space (left_cancel_monoid unsigned)) : separated_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_33282 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (finset.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (finset.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_33283 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_Inf real))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_33284 (h0 : uniform_space (comm_semigroup (sub_neg_monoid Type))) : complete_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_33285 (h0 : add_group (simple_graph (mul_one_class (mul_one_class ereal)))) : is_add_cyclic (simple_graph (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_33286 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33287 (h0 : topological_space (ring (option unsigned))) : irreducible_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_33288 (h0 : ring (is_R_or_C congr_arg_kind)) : is_principal_ideal_ring (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33289 (h0 : topological_space (has_compl (has_nnnorm string.iterator_imp))) : path_connected_space (has_compl (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_33290 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : loc_path_connected_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_33291 (h0 : has_mem.mem empty has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} empty (@finset.pi.empty.{1 0} Type complete_lattice.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_33292 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_33293 (h0 : filter (canonically_ordered_comm_semiring num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33294 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_33295 (h0 : monoid (semiring (linear_ordered_semiring (linear_ordered_semiring congr_arg_kind)))) : monoid.fg (semiring (linear_ordered_semiring (linear_ordered_semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_33296 (h0 : group (semigroup (has_pos_part Type))) : normalizer_condition (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_33297 (h0 : set enat) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_33298 (h0 : group (has_nndist name)) : is_cyclic (has_nndist name) := sorry --non-trivial
lemma new_lemma_33299 (h0 : ordered_add_comm_monoid (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) : archimedean (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_33300 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_33301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_33302 (h0 : complete_lattice (has_top (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_33303 (h0 : ring (has_one (has_union empty))) : rank_condition (has_one (has_union empty)) := sorry --non-trivial
lemma new_lemma_33304 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_33305 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (has_neg name)) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_33306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : id_rel (function.extfun_app (function.extfun_app h0 (prod (semigroup empty))) (semigroup empty)) := sorry --non-trivial
lemma new_lemma_33307 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_33308 (h0 : ring (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp)))) : is_principal_ideal_ring (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_33309 (h0 : uniform_space (canonically_ordered_comm_semiring (option congr_arg_kind))) : complete_space (canonically_ordered_comm_semiring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33310 (h0 : ring (has_pos_part (has_nndist pos))) : strong_rank_condition (has_pos_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_33311 (h0 : filter (mul_zero_class ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33312 (h0 : uniform_space (ring (boolean_algebra.core pos))) : separated_space (ring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_33313 (h0 : topological_space (has_pos_part (has_neg linarith.comp))) : path_connected_space (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_33314 (h0 : set (set ereal)) (h1 : set ereal) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_33315 (h0 : topological_space std_gen) (h1 : has_sup std_gen) : has_continuous_sup std_gen := sorry --non-trivial
lemma new_lemma_33316 (h0 : group (ordered_comm_monoid (has_add pos))) : normalizer_condition (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_33317 (h0 : topological_space (has_neg (has_to_string linarith.comp))) : regular_space (has_neg (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_33318 (h0 : uniform_space (add_left_cancel_semigroup empty)) : separated_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_33319 (h0 : not (uniform_space (metric_space congr_arg_kind) -> false)) : @separated_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33320 (h0 : ring (simple_graph pos)) : is_principal_ideal_ring (simple_graph pos) := sorry --non-trivial
lemma new_lemma_33321 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @irreducible_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_33322 (h0 : monoid (boolean_algebra.core (finset pos))) : monoid.fg (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_33323 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_33324 (h0 : list (metric_space empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33325 (h0 : topological_space (has_nnnorm (dlist fun_info))) : path_connected_space (has_nnnorm (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_33326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_33327 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice name)) Type) : @is_atomistic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_33328 (h1 : topological_space (has_div ereal)) : path_connected_space (has_div ereal) := sorry --non-trivial
lemma new_lemma_33329 (h0 : filter (has_nnnorm (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33330 (h0 : complete_lattice (measurable_space (has_norm (has_norm (has_norm num))))) : is_compactly_generated (measurable_space (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_33331 (h0 : functor.add_const (semiring (normed_comm_ring pos)) linarith.comp) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33332 (h0 : functor.add_const (list (as_linear_order empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33333 (h0 : functor.add_const (group (has_neg ennreal)) unsigned) : @is_cyclic.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33334 (h0 : not (complete_lattice (has_nnnorm char) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_33335 (h0 : add_monoid (canonically_ordered_comm_semiring (option unsigned))) : add_monoid.fg (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_33336 (h0 : uniform_space (semiring (has_top empty))) : separated_space (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_33337 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_33338 (h0 : add_monoid (partial_order (measure_theory.measure_space empty))) : add_monoid.fg (partial_order (measure_theory.measure_space empty)) := sorry --non-trivial
lemma new_lemma_33339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33340 (h1 : ring (has_nnnorm (random_gen reducibility_hints))) : strong_rank_condition (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_33341 (h0 : function.extfun Type topological_space) : @normal_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_33342 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (boolean_algebra.core name)))) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) (has_add.{1} Type) (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name))) h0 (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_33343 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_33344 (h0 : functor.add_const (topological_space (id empty)) num) : @irreducible_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) num h0)  := sorry --non-trivial
lemma new_lemma_33345 (h0 : measurable_space (has_nnnorm string.iterator_imp)) (h1 : filter (has_nnnorm string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_33346 (h0 : functor.add_const (add_monoid (canonically_ordered_monoid pos)) (has_Inf pos)) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_monoid.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_33347 (h0 : function.extfun Type group) : @is_simple_group.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_33348 (h0 : add_group (has_norm congr_arg_kind)) : is_add_cyclic (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33349 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_33350 (h0 : semiring (has_zero (has_pos_part (normed_comm_ring pos)))) : is_noetherian_ring (has_zero (has_pos_part (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_33351 (h0 : has_mem.mem (lex num) has_emptyc.emptyc) : @totally_separated_space.{0} (lex.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (lex.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_33352 (h0 : functor.add_const (ring (add_cancel_monoid Type)) Type) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_33353 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) pos) : @preirreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_33354 (h0 : topological_space (normed_comm_ring (normed_comm_ring (has_add unsigned)))) : preirreducible_space (normed_comm_ring (normed_comm_ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_33355 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33356 (h0 : topological_space (boolean_algebra.core (ring (has_add Type)))) : topological_space.separable_space (boolean_algebra.core (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_33357 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) linarith.comp) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33358 (h0 : functor.add_const (ring (id pos)) Type) : @is_principal_ideal_ring.{0} (@id.{2} Type pos) (@functor.add_const.run.{0 1} (ring.{0} (@id.{2} Type pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_33359 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_33360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_33361 (h0 : group (boolean_algebra unsigned)) : group.fg (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_33362 (h0 : group (has_top (semiring (semiring (has_top (semiring (semiring empty))))))) : is_cyclic (has_top (semiring (semiring (has_top (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_33363 (h0 : set (semi_normed_comm_ring linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_33364 (h0 : group (linear_ordered_field (option (option (option ennreal))))) : normalizer_condition (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_33365 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_33366 (h0 : functor.add_const (functor.add_const (monoid pos) pos) (has_neg pos)) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} pos) pos) (has_neg.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_33367 (h0 : complete_lattice (linear_ordered_semiring (random_gen (random_gen (has_norm num))))) : is_atomistic (linear_ordered_semiring (random_gen (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_33368 (h0 : complete_lattice (add_monoid (has_nnnorm (fintype (fintype linarith.ineq))))) : is_compactly_generated (add_monoid (has_nnnorm (fintype (fintype linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_33369 (h0 : topological_space (has_inter (option num))) : totally_disconnected_space (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_33370 (h0 : topological_space (mul_zero_class (mul_zero_class name))) : regular_space (mul_zero_class (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_33371 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class fun_info)))) : rank_condition (semi_normed_ring (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_33372 (h0 : topological_space (cancel_monoid (option ennreal))) : t0_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_33373 (h0 : topological_space (add_group (has_top linarith.comp))) : normal_space (add_group (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_33374 (h0 : topological_space (add_right_cancel_monoid unsigned)) : topological_space.separable_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_33375 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_33376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_33377 (h0 : complete_lattice (left_cancel_semigroup (semiring num))) : is_compactly_generated (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_33378 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add unsigned))) : is_atomistic (canonically_ordered_comm_semiring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_33379 (h0 : topological_space (ring (has_add Type))) : t0_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_33380 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_33381 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_add name))))) : t0_space (add_cancel_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_33382 (h0 : finset (has_neg_part (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33383 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @is_cyclic.{0} unsigned (@finset.pi.empty.{1 0} Type group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_33384 (h1 : ring (random_gen string_imp)) : is_domain (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_33385 (h0 : nat) (h1 : measurable_space (semi_normed_comm_ring (mul_one_class (has_ssubset (zmod h0))))) (h2 : filter (semi_normed_comm_ring (mul_one_class (has_ssubset (zmod h0))))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_33386 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part name)) (has_add Type)) : @archimedean.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_pos_part.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_33387 (h0 : group (semiring (semiring (semiring (semiring unsigned))))) : is_cyclic (semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_33388 (h0 : add_comm_monoid (has_to_string pos) -> add_comm_monoid (has_to_string pos) -> Prop) : is_symm (add_comm_monoid (has_to_string pos)) h0 := sorry --non-trivial
lemma new_lemma_33389 (h0 : topological_space (option pos)) : totally_separated_space (option pos) := sorry --non-trivial
lemma new_lemma_33390 (h0 : filter (has_inv (dlist (with_bot to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33391 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) name) : @t1_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_33392 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33393 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33394 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_33395 (h0 : topological_space (add_comm_monoid unsigned)) : preconnected_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_33396 (h1 : complete_lattice (distrib (comm_ring to_additive.value_type))) : is_compactly_generated (distrib (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33397 (h0 : topological_space (with_one (semiring (semiring (semiring num))))) : t0_space (with_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_33398 (h0 : add_group (has_ssubset (has_nnnorm to_additive.value_type))) : is_add_cyclic (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33399 (h0 : not (topological_space (has_nnnorm (has_nnnorm (has_nnnorm (has_append linarith.comp_source)))) -> false)) : @t0_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_append.{0} linarith.comp_source)))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_append.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_33400 (h0 : functor.add_const (filter (has_nndist unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33401 (h0 : complete_lattice (has_nndist (finset pos))) : is_compactly_generated (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_33402 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @totally_disconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_33403 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : irreducible_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33404 (h0 : topological_space (has_inter congr_arg_kind)) : irreducible_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33405 (h0 : list (with_bot (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33406 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : totally_disconnected_space (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_33407 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33408 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : totally_disconnected_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33409 (h0 : uniform_space (has_top (has_norm congr_arg_kind))) : separated_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33410 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp)  := sorry --non-trivial
lemma new_lemma_33411 (h0 : topological_space (has_nndist empty)) : path_connected_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_33412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33413 (h0 : topological_space (random_gen (has_inv to_additive.value_type))) : t0_space (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33414 (h0 : ring (fintype linarith.comp_source)) : strong_rank_condition (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_33416 (h0 : ordered_comm_monoid (canonically_ordered_monoid (finset pos))) : has_exists_mul_of_le (canonically_ordered_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_33417 (h0 : group (measurable_space (semiring unsigned))) : group.fg (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33418 (h0 : not (ring (measurable_space (random_gen linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_33419 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_33420 (h0 : functor.add_const (group (has_neg_part name)) name) : @group.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_33421 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33422 (h0 : measurable_space (comm_ring linarith.comp_source)) (h1 : has_mul (comm_ring linarith.comp_source)) : has_measurable_mul₂ (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33423 (h0 : not (topological_space (with_zero linarith.comp_source) -> false)) : @t0_space.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_33424 (h0 : functor.add_const (monoid (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_33425 (h0 : functor.add_const (ring environment.implicit_infer_kind) Type) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (ring.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_33426 (h0 : functor.add_const Prop (complete_distrib_lattice (option (option (option (option unsigned)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33427 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring empty)) unsigned) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33428 (h0 : char -> char -> Prop) : is_total char h0 := sorry --non-trivial
lemma new_lemma_33429 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33430 (h0 : complete_lattice (finset (option (option (option empty))))) : is_compactly_generated (finset (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_33431 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33432 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add (has_add (has_add linarith.comp))))) : archimedean (generalized_boolean_algebra (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33433 (h0 : ring (with_bot (random_gen (has_top (has_top num))))) : strong_rank_condition (with_bot (random_gen (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_33434 (h0 : monoid (with_bot (semiring (semiring (semiring (semiring (semiring unsigned))))))) : monoid.fg (with_bot (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_33435 (h0 : filter (has_add (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33436 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_33437 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33438 (h0 : not (complete_lattice num -> false)) : @is_atomistic.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_33439 (h0 : topological_space (normed_field (has_append (semi_normed_ring (denumerable reducibility_hints))))) : path_connected_space (normed_field (has_append (semi_normed_ring (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_33440 (h0 : topological_space (ring unsigned)) : totally_disconnected_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_33441 (h0 : ring (normed_linear_ordered_group (option unsigned))) : rank_condition (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_33442 (h0 : ring (mul_zero_class (add_comm_monoid name))) : rank_condition (mul_zero_class (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_33443 (h0 : add_group (normed_lattice_add_comm_group Type)) : is_add_cyclic (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_33444 (h0 : topological_space (random_gen (metric_space string_imp))) : t0_space (random_gen (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_33445 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : locally_compact_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33446 (h0 : topological_space (ring (finset linarith.comp))) : topological_space.separable_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_33447 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33448 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_33449 (h0 : topological_space (complete_semilattice_Sup (random_gen fun_info))) : totally_disconnected_space (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_33450 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class linarith.ineq)))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_33451 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_33452 (h0 : ring (pseudo_metric_space ennreal) -> ring (pseudo_metric_space ennreal) -> Prop) : is_symm (ring (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_33453 (h0 : prod (comm_group Type) (comm_group Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_33454 (h0 : measurable_space environment.implicit_infer_kind) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @has_measurable_div₂.{0} environment.implicit_infer_kind h0 (@function.extfun_app.{2 1} Type has_div.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_div.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_33455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_33456 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_33457 (h0 : not (group (linear_ordered_comm_ring congr_arg_kind) -> false)) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33458 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33459 (h0 : group (generalized_boolean_algebra (has_Inf (has_pos_part (has_Inf linarith.comp))))) : is_simple_group (generalized_boolean_algebra (has_Inf (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33460 (h0 : group (has_Inf Type)) : is_simple_group (has_Inf Type) := sorry --non-trivial
lemma new_lemma_33461 (h0 : functor.add_const (ring (partial_order empty)) num) : @is_principal_ideal_ring.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_33462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33463 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @totally_disconnected_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_33464 (h0 : ring (add_monoid fun_info)) : rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_33465 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33466 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33467 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_linear_order linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_33468 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_33469 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) (ring name)) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_33470 (h0 : functor.add_const (ring (plift num)) unsigned) : @is_principal_ideal_ring.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33471 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) : path_connected_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33472 (h0 : complete_lattice (comm_group (option (option (cancel_monoid unsigned))))) : complete_lattice.is_Sup_finite_compact (comm_group (option (option (cancel_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_33473 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice empty)) empty) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_33474 (h0 : functor.add_const (uniform_space (ring pos)) linarith.comp) : @separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33475 (h0 : functor.add_const (semiring (has_add pos)) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33476 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33477 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_33478 (h1 : Prop) : set.separates_points (id (fun (h0 : string.iterator_imp -> enat), h1)) := sorry --non-trivial
lemma new_lemma_33479 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_33480 (h0 : functor.add_const (group (semiring empty)) empty) : @group.fg.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_33481 (h0 : uniform_space (uniform_space (has_lt (has_lt linarith.ineq)))) : complete_space (uniform_space (has_lt (has_lt linarith.ineq))) := sorry --non-trivial
lemma new_lemma_33482 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33483 (h0 : uniform_space (measure_theory.measure_space congr_arg_kind)) : separated_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33484 (h0 : uniform_space (boolean_algebra environment.implicit_infer_kind)) : complete_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_33485 (h0 : ring (has_bot (has_neg pos))) : is_domain (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_33486 (h0 : ring (has_neg ennreal)) : strong_rank_condition (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_33487 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_33488 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33489 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (ring pos)) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_33490 (h0 : monoid (finset (complete_lattice Type))) : monoid.fg (finset (complete_lattice Type)) := sorry --non-trivial
lemma new_lemma_33491 (h0 : topological_space (comm_group (has_add name))) : topological_space.separable_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_33492 (h0 : topological_space (add_comm_monoid (comm_semigroup (has_bot (comm_semigroup real))))) : t1_space (add_comm_monoid (comm_semigroup (has_bot (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_33493 (h0 : ordered_add_comm_monoid (ring (ring (has_add (has_add (has_neg Type)))))) : archimedean (ring (ring (has_add (has_add (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_33494 (h0 : topological_space (has_le linarith.comp_source)) : totally_disconnected_space (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33495 (h0 : not (topological_space (has_append linarith.ineq) -> false)) : @path_connected_space.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_33496 (h0 : topological_space (metric_space to_additive.value_type)) : path_connected_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33497 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_33498 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_33499 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_nndist Type))) : archimedean (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_33500 (h0 : uniform_space (has_add (has_add Type))) : complete_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_33501 (h0 : ring (boolean_algebra.core (option (option unsigned)))) : rank_condition (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_33502 (h0 : topological_space (has_to_string (ring (has_neg (has_add Type))))) : sequential_space (has_to_string (ring (has_neg (has_add Type)))) := sorry --non-trivial
lemma new_lemma_33503 (h0 : add_group (has_emptyc (random_gen linarith.ineq))) : is_add_cyclic (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_33504 (h0 : complete_lattice (measurable_space (has_top (has_top fun_info)))) : is_compactly_generated (measurable_space (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_33505 (h0 : not (topological_space (add_right_cancel_monoid fun_info) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_33506 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : unique_factorization_monoid (normed_linear_ordered_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_33507 (h0 : group (ordered_comm_ring (has_pos_part linarith.comp))) : is_cyclic (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_33508 (h1 : ring (with_one char)) : rank_condition (with_one char) := sorry --non-trivial
lemma new_lemma_33509 (h0 : functor.add_const (topological_space (add_comm_monoid name)) unsigned) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33510 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) Type) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_33511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33512 (h0 : ring (linear_ordered_semiring (semiring (semiring (semiring linarith.comp))))) : strong_rank_condition (linear_ordered_semiring (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33513 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_33514 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (has_Sup empty)))) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_33515 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_33516 (h0 : functor.add_const Prop (has_neg (has_to_string (has_add (has_add (semigroup linarith.comp)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33517 (h0 : functor.comp topological_space has_neg_part Type) : @preirreducible_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_33518 (h1 : set (add_comm_semigroup environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_33519 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring Type)) (semigroup pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33520 (h0 : complete_lattice (non_unital_non_assoc_semiring string.iterator_imp)) : is_compactly_generated (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_33521 (h0 : list (add_comm_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33522 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_33523 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33524 (h0 : semiring (has_pos_part (has_pos_part (has_pos_part (has_Inf linarith.comp))))) : is_noetherian_ring (has_pos_part (has_pos_part (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33525 (h0 : not (ring (non_unital_non_assoc_semiring char) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_33526 (h0 : list (left_cancel_semigroup (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33527 (h0 : topological_space (semiring (has_union unsigned))) : locally_compact_space (semiring (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_33528 (h0 h1 : multiset (has_compl string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_33529 (h0 : functor.add_const (list (has_nndist Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33530 (h1 : nat -> topological_space (normed_field string_imp) -> topological_space (normed_field string_imp)) (h2 : nat) (h3 : topological_space (normed_field string_imp)) : t0_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_33531 (h0 : topological_space (semigroup (has_neg Type))) : loc_path_connected_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_33532 (h1 : group (linear_ordered_add_comm_group char)) : is_cyclic (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_33533 (h0 : functor.add_const (topological_space (finset pos)) pos) : @sequential_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_33534 (h0 : topological_space (has_zero pos)) : discrete_topology (has_zero pos) := sorry --non-trivial
lemma new_lemma_33535 (h1 : topological_space (normed_field char)) : t0_space (normed_field char) := sorry --non-trivial
lemma new_lemma_33536 (h0 : functor.add_const (complete_lattice (boolean_algebra.core ennreal)) (has_to_string num)) : @is_compactly_generated.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} ennreal)) (has_to_string.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_33537 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_33538 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (has_neg Type)) := sorry --non-trivial
lemma new_lemma_33539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33540 (h0 : topological_space (has_one (has_top (semiring (has_top empty))))) : preirreducible_space (has_one (has_top (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_33541 (h0 : monoid (has_add (has_Inf linarith.comp))) : monoid.fg (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_33542 (h0 : group (has_norm string_imp)) : group.fg (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_33543 (h0 : uniform_space (add_group (has_norm linarith.comp))) : separated_space (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_33544 (h0 : group (add_comm_monoid (has_add pos))) : group.fg (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_33545 (h0 : complete_lattice (semigroup (semiring unsigned))) : is_compactly_generated (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33546 (h0 : topological_space (ring (has_add Type))) : totally_disconnected_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_33547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_33548 (h0 : ring (measurable_space (semiring (semiring congr_arg_kind)))) : strong_rank_condition (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_33549 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33550 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_33551 (h0 : functor.comp topological_space finset name) : @t1_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_33552 (h0 : prod (has_dist fun_info) (has_dist fun_info)) : set.diagonal (has_dist fun_info) h0 := sorry --non-trivial
lemma new_lemma_33553 (h0 : filter (normed_comm_ring (comm_group (comm_group unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33554 (h0 : topological_space (has_ssubset reducibility_hints)) : t0_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_33555 (h0 : ring (has_inv (has_norm (measurable_space fun_info)))) : is_domain (has_inv (has_norm (measurable_space fun_info))) := sorry --non-trivial
lemma new_lemma_33556 (h0 : add_group (canonically_ordered_monoid (boolean_algebra.core (has_add pos)))) : is_add_cyclic (canonically_ordered_monoid (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_33557 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_33558 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33559 (h0 : topological_space (has_zero (finset pos))) : discrete_topology (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_33560 (h0 : add_group (has_inv (random_gen (random_gen fun_info)))) : is_add_cyclic (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_33561 (h0 : functor.add_const (monoid (has_neg_part pos)) (has_add pos)) : @monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_33562 (h2 : ring (fintype linarith.comp_source)) : rank_condition (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33563 (h0 : topological_space (semiring (random_gen fun_info))) : locally_compact_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_33564 (h0 : functor.add_const (add_monoid (has_neg_part unsigned)) (option (option unsigned))) : @add_monoid.fg.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_33565 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : t1_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_33566 (h0 : monoid (has_add (finset (ring pos)))) : monoid.fg (has_add (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_33567 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) (ring (has_to_string (has_to_string pos)))) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} linarith.comp)) (ring.{0} (has_to_string.{0} (has_to_string.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_33568 (h0 : ring (random_gen (has_inv fun_info))) : rank_condition (random_gen (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_33569 (h0 : ordered_comm_monoid (semigroup Type)) : has_exists_mul_of_le (semigroup Type) := sorry --non-trivial
lemma new_lemma_33570 (h0 : not (group (normed_field string.iterator_imp) -> false)) : @is_cyclic.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_33571 (h0 : complete_lattice (has_nndist (has_to_string pos))) : is_compactly_generated (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_33572 (h2 : ring (fintype fun_info)) : rank_condition (fintype fun_info) := sorry --non-trivial
lemma new_lemma_33573 (h0 : not (complete_lattice (has_inv linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_33574 (h0 : functor.add_const Prop (mul_one_class (has_neg environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33575 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part Type)) linarith.comp) : @unique_factorization_monoid.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33576 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33577 (h1 : ring (normed_field environment.projection_info)) : rank_condition (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_33578 (h0 : topological_space (ordered_comm_ring (ring Type))) : normal_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_33579 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_33580 (h1 : not (topological_space (add_cancel_comm_monoid reducibility_hints) -> false)) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_33581 (h0 : functor.add_const (filter (finset linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33582 (h0 : uniform_space (has_union (semiring (has_norm (has_norm linarith.comp))))) : separated_space (has_union (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33583 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_33584 (h0 : functor.add_const (filter (has_neg Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33585 (h0 : complete_lattice (boolean_algebra.core (has_neg_part pos))) : is_atomistic (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_33586 (h0 : topological_space empty) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_33587 (h0 : group (normed_comm_ring (has_to_string Type))) : group.fg (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_33588 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 znum) := sorry --non-trivial
lemma new_lemma_33589 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @add_monoid.fg.{0} unsigned (@finset.pi.empty.{1 0} Type add_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_33590 (h0 : add_group (semi_normed_ring fun_info)) : is_add_cyclic (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_33591 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_33592 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_33593 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @sequential_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33594 (h0 : uniform_space (boolean_algebra (boolean_algebra pos))) : separated_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_33595 (h0 : topological_space (has_add (option (has_add pos)))) : preirreducible_space (has_add (option (has_add pos))) := sorry --non-trivial
lemma new_lemma_33596 (h0 : functor.add_const (uniform_space (has_add Type)) (has_Inf (has_pos_part linarith.comp))) : @complete_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) (has_Inf.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_33597 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_33598 (h0 : topological_space real) : totally_separated_space real := sorry --non-trivial
lemma new_lemma_33599 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_33600 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_33601 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_33602 (h0 : add_monoid (mul_zero_class (has_nndist (finset pos)))) : add_monoid.fg (mul_zero_class (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_33603 (h0 : group (partial_order congr_arg_kind)) : group.fg (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33604 (h0 : complete_lattice (complete_distrib_lattice (has_neg linarith.comp))) : is_compactly_generated (complete_distrib_lattice (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_33605 (h0 : ring (has_edist num)) : strong_rank_condition (has_edist num) := sorry --non-trivial
lemma new_lemma_33606 (h0 : topological_space (add_group congr_arg_kind)) : irreducible_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33607 (h0 : ring (simple_graph (mul_one_class char))) : strong_rank_condition (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_33608 (h0 : ordered_comm_monoid (ring (has_neg (has_neg pos)))) : has_exists_mul_of_le (ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_33609 (h0 : add_monoid (has_nndist (finset name))) : add_monoid.fg (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_33610 (h0 : topological_space (ring (has_add (has_pos_part (finset Type))))) : sequential_space (ring (has_add (has_pos_part (finset Type)))) := sorry --non-trivial
lemma new_lemma_33611 (h0 : complete_lattice (topological_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33612 (h1 : not (topological_space (denumerable to_additive.value_type) -> false)) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_33613 (h0 : not (ring (has_top linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_33614 (h0 : filter (ordered_comm_monoid (finset (has_to_string Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33615 (h0 : ring (normed_field (normed_field (normed_field (normed_field char))))) : is_domain (normed_field (normed_field (normed_field (normed_field char)))) := sorry --non-trivial
lemma new_lemma_33616 (h0 : ring (ring (has_nndist linarith.comp))) : strong_rank_condition (ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_33617 (h0 : ring (mul_zero_class environment.implicit_infer_kind)) : rank_condition (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_33618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_33619 (h2 : group (with_one congr_arg_kind)) : group.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33620 (h0 : list (has_to_string (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33621 (h0 : topological_space (add_comm_monoid (comm_group (comm_group linarith.comp)))) : preconnected_space (add_comm_monoid (comm_group (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_33622 (h0 : not (uniform_space (complete_linear_order congr_arg_kind) -> false)) : @separated_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33623 (h0 : complete_lattice (plift num)) : complete_lattice.is_Sup_finite_compact (plift num) := sorry --non-trivial
lemma new_lemma_33624 (h0 : topological_space (semi_normed_ring (mul_one_class (mul_one_class fun_info)))) : path_connected_space (semi_normed_ring (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_33625 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : preirreducible_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_33626 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : irreducible_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_33627 (h0 : topological_space (finset (has_pos_part pos))) : locally_compact_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_33628 (h0 : finset (add_semigroup empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33629 (h0 : group (boolean_algebra pos)) : is_cyclic (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_33630 (h0 : functor.add_const (ring (ordered_comm_ring pos)) name) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_33631 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33632 (h0 : functor.add_const (group (boolean_algebra.core pos)) name) : @normalizer_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_33633 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_33634 (h0 : functor.comp group mul_zero_class pos) : @group.fg.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_33635 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : t1_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_33636 (h0 : complete_lattice (linear_ordered_semiring to_additive.value_type)) : is_atomistic (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33637 (h0 : topological_space (has_add (has_Inf (has_Inf name)))) : preconnected_space (has_add (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_33638 (h0 : functor.add_const (add_monoid (has_Inf pos)) Type) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_33639 (h0 : char -> char -> Prop) (h1 : filter char) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_33640 (h0 : topological_space (linear_ordered_semiring (semiring (semiring unsigned)))) : discrete_topology (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_33641 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup num)) : unique_factorization_monoid (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_33642 (h0 : topological_space (semigroup (boolean_algebra linarith.comp))) : totally_disconnected_space (semigroup (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_33643 (h0 : group (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : group.fg (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_33644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_33645 (h0 : complete_lattice (metric_space congr_arg_kind)) : is_atomistic (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33646 (h0 : ordered_comm_monoid (finset (boolean_algebra.core name))) : has_exists_mul_of_le (finset (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_33647 (h0 : not (complete_lattice (partial_order empty) -> false)) : @is_compactly_generated.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_33648 (h0 : ordered_add_comm_monoid (has_add (has_neg (has_neg (has_neg linarith.comp))))) : archimedean (has_add (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_33649 (h0 : functor.comp ring has_neg_part pos) : @is_domain.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_33650 (h0 : ring (ordered_comm_ring (has_neg (has_neg Type)))) : rank_condition (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_33651 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_33652 (h0 : functor.add_const (add_group (boolean_algebra pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_33653 (h0 : uniform_space (random_gen (has_lt char))) : complete_space (random_gen (has_lt char)) := sorry --non-trivial
lemma new_lemma_33654 (h0 : filter (add_left_cancel_monoid (comm_ring fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33655 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33656 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_33657 (h0 : monoid (normed_comm_ring (add_cancel_monoid pos))) : monoid.fg (normed_comm_ring (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_33658 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_33660 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33661 (h0 : topological_space (left_cancel_monoid (semiring unsigned))) : totally_disconnected_space (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33662 (h0 : uniform_space (simple_graph (option empty))) : separated_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_33663 (h0 : topological_space (has_neg_part (option pos))) : loc_path_connected_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_33664 (h0 : monoid (complete_distrib_lattice (has_add (semigroup pos)))) : monoid.fg (complete_distrib_lattice (has_add (semigroup pos))) := sorry --non-trivial
lemma new_lemma_33665 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_33666 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (finset (finset pos))) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_33667 (h0 : not (topological_space (has_lt fun_info) -> false)) : @path_connected_space.{0} (has_lt.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_33668 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_33669 (h0 : add_group (add_semigroup empty)) : is_add_cyclic (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_33670 (h0 : ring (with_one (has_nnnorm linarith.comp_source))) : strong_rank_condition (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_33671 (h0 : group (generalized_boolean_algebra (finset Type))) : is_simple_group (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_33672 (h0 : ring (omega_complete_partial_order congr_arg_kind)) : is_domain (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33673 (h0 : fin has_zero.zero) : @discrete_topology.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_33674 (h0 : topological_space (non_assoc_semiring empty)) : locally_compact_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_33675 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : normal_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_33676 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : discrete_topology (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_33677 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33678 (h0 : uniform_space (boolean_algebra (normed_comm_ring pos))) : complete_space (boolean_algebra (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_33679 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_33680 (h0 : fin has_zero.zero) : @archimedean.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_33681 (h0 : has_lt (has_ssubset std_gen)) : no_max_order (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_33682 (h1 : complete_lattice (distrib (random_gen linarith.comp_source))) : is_compactly_generated (distrib (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_33683 (h0 : ring (has_Inf (has_Inf (has_Inf (has_neg name))))) : is_domain (has_Inf (has_Inf (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_33684 (h1 : uniform_space (add_comm_semigroup linarith.ineq)) : complete_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_33685 (h0 : uniform_space (canonically_linear_ordered_monoid (ring pos))) : complete_space (canonically_linear_ordered_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_33686 (h0 : ring (has_one (has_norm (has_norm empty)))) : strong_rank_condition (has_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_33687 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_33688 (h0 : finset (has_bot (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33689 (h0 : filter (add_cancel_monoid name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33690 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33691 (h0 : measurable_space (add_group empty)) (h1 : topological_space (measure_theory.measure (add_group empty))) : t0_space (measure_theory.measure (add_group empty)) := sorry --non-trivial
lemma new_lemma_33692 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_33693 (h0 : functor.add_const (functor.add_const (finset Type) pos) (has_to_string Type)) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_33694 (h0 : topological_space (has_div char)) (h1 : preorder (has_div char)) : order_closed_topology (has_div char) := sorry --non-trivial
lemma new_lemma_33695 (h0 : ring (dlist reducibility_hints)) : strong_rank_condition (dlist reducibility_hints) := sorry --non-trivial
lemma new_lemma_33696 (h0 : complete_lattice (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) : is_compactly_generated (random_gen (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_33697 (h0 : functor.add_const Prop (cancel_monoid linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33698 (h0 : topological_space (normed_linear_ordered_group (semiring empty))) : irreducible_space (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_33699 (h0 h1 : multiset (nondiscrete_normed_field char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_33700 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : t1_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33701 (h0 : group (mul_one_class string_imp)) : is_cyclic (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_33702 (h0 : functor.add_const (group (comm_group pos)) linarith.comp) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33703 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_33704 (h0 : functor.add_const (add_group (normed_comm_ring pos)) Type) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_33705 (h0 : semiring (free_add_monoid empty)) : is_noetherian_ring (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_33706 (h0 : uniform_space (boolean_algebra (sub_neg_monoid real))) : separated_space (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_33707 (h0 : functor.add_const (topological_space (cancel_monoid Type)) pos) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_33708 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_to_string pos))) : archimedean (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_33709 (h0 : complete_lattice (has_neg environment.implicit_infer_kind)) : is_compactly_generated (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_33710 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33711 (h0 : has_nnnorm reducibility_hints -> has_nnnorm reducibility_hints -> Prop) : is_total_preorder (has_nnnorm reducibility_hints) h0 := sorry --non-trivial
lemma new_lemma_33712 (h0 : prod (left_cancel_semigroup num) (left_cancel_semigroup num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_33713 (h0 : group (has_zero (comm_group Type))) : group.fg (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_33714 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_33715 (h0 : group (id (has_norm (random_gen unsigned)))) : group.fg (id (has_norm (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_33716 (h0 : ring (with_one (random_gen num))) : rank_condition (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_33717 (h2 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @is_domain.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h2)  := sorry --non-trivial
lemma new_lemma_33718 (h9 : ring (random_gen string.iterator_imp)) : strong_rank_condition (random_gen string.iterator_imp) := sorry --non-trivial
lemma new_lemma_33719 (h0 : functor.add_const (filter (add_cancel_monoid Type)) (has_add name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33720 (h0 : ring (add_cancel_monoid name)) : rank_condition (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_33721 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_add name)) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_33722 (h0 : add_group (add_left_cancel_semigroup num)) : is_add_cyclic (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_33723 (h5 : uniform_space (has_compl linarith.comp_source)) : complete_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33724 (h0 : topological_space (complete_distrib_lattice (has_pos_part Type))) : totally_disconnected_space (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_33725 (h0 : add_group (generalized_boolean_algebra (has_neg name))) : is_add_cyclic (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_33726 (h1 : set (semi_normed_ring string.iterator_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_33727 (h0 : uniform_space (has_emptyc linarith.comp)) : complete_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_33728 (h0 : ring (has_top (has_nnnorm linarith.comp_source))) : is_domain (has_top (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_33729 (h0 : not (monoid (with_bot congr_arg_kind) -> false)) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33730 (h0 : filter (with_bot (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33731 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_33732 (h0 : functor.add_const (topological_space (option pos)) pos) : @loc_path_connected_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_33733 (h0 : add_monoid (id (has_norm (has_norm empty)))) : add_monoid.fg (id (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_33734 (h2 : preorder (mul_one_class enat)) (h3 : set (mul_one_class enat)) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_33735 (h0 : topological_space (has_to_string (has_add name))) : topological_space.separable_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_33736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : irreducible_space real := sorry --non-trivial
lemma new_lemma_33737 (h0 : filter (has_neg (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33738 (h0 : functor.add_const (finset (pseudo_emetric_space linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33739 (h0 : topological_space (add_comm_monoid (ring environment.implicit_infer_kind))) : normal_space (add_comm_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33742 (h0 : list (comm_group (has_neg_part (has_neg_part Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_33743 (h0 : functor.add_const (filter (boolean_algebra pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33744 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_33745 (h0 : order_hom nat Prop -> Prop) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@classical.epsilon.{1} (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) (@has_bot_nonempty.{0} (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) (@order_hom.has_bot.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)))) h0)  := sorry --non-trivial
lemma new_lemma_33746 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_nndist Type))) : unique_factorization_monoid (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_33747 (h0 : functor.add_const (add_monoid (ordered_comm_monoid Type)) name) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_33748 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_33749 (h2 : uniform_space (random_gen reducibility_hints)) : complete_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_33750 (h0 : functor.add_const (complete_lattice (has_neg Type)) unsigned) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33751 (h0 : list (complete_semilattice_Sup (random_gen (has_nnnorm char)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33752 (h0 : complete_lattice (semigroup (ring (has_add name)))) : is_compactly_generated (semigroup (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_33753 (h0 : functor.comp list ring name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_33754 (h0 : semiring (has_sub (semiring (semiring (semiring (semiring num)))))) : is_noetherian_ring (has_sub (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_33755 (h0 : not (functor.comp complete_lattice random_gen fun_info -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@functor.comp.run.{0 0 0} complete_lattice.{0} random_gen.{0} fun_info (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} complete_lattice.{0} random_gen.{0} fun_info) h0))  := sorry --non-trivial
lemma new_lemma_33756 (h0 : uniform_space (with_zero (has_top (has_inv to_additive.value_type)))) : complete_space (with_zero (has_top (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_33757 (h0 : add_monoid (ordered_comm_ring real)) : add_monoid.fg (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_33758 (h2 : ring (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (has_ssubset (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_33759 (h0 : topological_space (finset (has_neg (has_add Type)))) : t1_space (finset (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_33760 (h0 : list (complete_semilattice_Sup (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33761 (h0 : functor.add_const (ring (has_Inf pos)) (has_neg name)) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_33762 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_33763 (h0 : functor.add_const (semiring (boolean_algebra Type)) (has_zero linarith.comp)) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_33764 (h0 : topological_space (comm_group ennreal)) : totally_separated_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_33765 (h0 : add_group (plift num)) : is_add_cyclic (plift num) := sorry --non-trivial
lemma new_lemma_33766 (h0 : ring (partial_order (semiring unsigned))) : strong_rank_condition (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33767 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) name) : @normal_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_33768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_33769 (h0 : topological_space (has_neg (option unsigned))) : normal_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_33770 (h0 : cancel_comm_monoid_with_zero (has_add (ring Type))) : unique_factorization_monoid (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_33771 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33772 (h0 : functor.add_const (functor.add_const (list Prop) linarith.comp) (has_neg_part pos)) : list.head (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_33773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (emetric_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (emetric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_33774 (h0 : add_monoid (bin_tree (semiring congr_arg_kind))) : add_monoid.fg (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33775 (h0 : group (non_assoc_semiring (option empty))) : is_cyclic (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_33776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33777 (h0 : topological_space (div_inv_monoid (random_gen (random_gen (random_gen string_imp))))) : path_connected_space (div_inv_monoid (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_33778 (h0 : topological_space (cancel_monoid (semigroup name))) : loc_path_connected_space (cancel_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_33779 (h0 : filter (boolean_algebra (comm_group (comm_group (comm_group (comm_group name)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33780 (h0 : ordered_add_comm_monoid (has_bot congr_arg_kind)) : archimedean (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33781 (h0 : not (add_group (comm_ring to_additive.value_type) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_33782 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_33783 (h0 : filter (with_bot (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33784 (h0 : topological_space (has_Inf (has_neg (has_neg linarith.comp)))) : locally_compact_space (has_Inf (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_33785 (h0 : list (boolean_algebra (normed_comm_ring (has_pos_part linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_33786 (h0 : uniform_space (sub_neg_monoid (has_Inf pos))) : separated_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_33787 (h0 : filter (has_star (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33788 (h0 : not (topological_space (has_top fun_info) -> false)) : @preirreducible_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_33789 (h0 : function.extfun Type ring) : @is_domain.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33790 (h0 : topological_space (with_bot (has_norm fun_info))) : discrete_topology (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_33791 (h0 : ulower (fin has_zero.zero)) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_33792 (h0 : group (add_group unsigned)) : is_cyclic (add_group unsigned) := sorry --non-trivial
lemma new_lemma_33793 (h0 : functor.add_const (topological_space (has_add Type)) (ring environment.implicit_infer_kind)) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_33794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33795 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) congr_arg_kind) : @loc_path_connected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33796 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_33797 (h0 : topological_space (has_neg_part (has_add (has_add Type)))) : discrete_topology (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_33798 (h0 : group (ordered_cancel_add_comm_monoid (has_neg pos))) : normalizer_condition (ordered_cancel_add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_33799 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_33800 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : totally_disconnected_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_33801 (h0 : filter (has_to_string (option (has_to_string (option ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33802 (h0 : fin has_zero.zero) : @preconnected_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_33803 (h0 : functor.add_const (topological_space (ordered_ring empty)) unsigned) : @discrete_topology.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33804 (h1 : semiring (nondiscrete_normed_field enat)) (h2 : ideal (nondiscrete_normed_field enat)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_33805 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : preirreducible_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_33806 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_33807 (h0 : functor.add_const (topological_space (option empty)) congr_arg_kind) : @t1_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33808 (h0 : not (ring (fintype linarith.ineq) -> false)) : @strong_rank_condition.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_33809 (h0 : topological_space (pseudo_metric_space (option pos))) : t1_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_33810 (h0 : topological_space (linear_ordered_semiring (linear_ordered_semiring congr_arg_kind))) : irreducible_space (linear_ordered_semiring (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33811 (h0 : not (uniform_space (topological_space reducibility_hints) -> false)) : @complete_space.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_33812 (h0 : functor.add_const (topological_space (has_star num)) (semiring congr_arg_kind)) : @normal_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_33813 (h0 : filter (complete_distrib_lattice (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33814 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33815 (h0 : function.extfun Type (functor.add_const (ring (normed_linear_ordered_group num)))) : @rank_condition.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_33816 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @is_domain.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type ring.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_33818 (h0 h1 : multiset (non_unital_non_assoc_semiring (mul_one_class fun_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_33819 (h0 : topological_space (has_neg (finset name))) : loc_path_connected_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_33820 (h0 : set (semi_normed_comm_ring linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_33821 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_33822 (h0 : semiring (semigroup (option (option pos)))) : is_noetherian_ring (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_33823 (h0 : semiring (boolean_algebra.core pos)) : is_noetherian_ring (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_33824 (h0 : add_group (comm_semigroup (has_add real))) : is_add_cyclic (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_33825 (h0 : topological_space (sub_neg_monoid Type)) : irreducible_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_33826 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_33827 (h0 : topological_space (ring empty)) : totally_separated_space (ring empty) := sorry --non-trivial
lemma new_lemma_33828 (h0 : finset (linear_ordered_comm_monoid_with_zero (semiring (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_33829 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33830 (h0 : add_group (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal)))))) : is_add_cyclic (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal))))) := sorry --non-trivial
lemma new_lemma_33831 (h0 : ring (semi_normed_ring to_additive.value_type)) : is_domain (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33832 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_33833 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_33834 (h0 : not (ring (has_lt linarith.comp_source) -> false)) : @is_domain.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_33835 (h0 : topological_space (has_pos_part (ring pos))) : totally_disconnected_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_33836 (h0 : group (comm_ring (random_gen (has_norm string_imp)))) : is_cyclic (comm_ring (random_gen (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_33837 (h0 : not (topological_space (has_norm unsigned) -> false)) : @normal_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_33838 (h0 : not (filter (metric_space empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_33839 (h1 : filter (add_monoid to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_33840 (h0 : group (has_emptyc (random_gen (random_gen to_additive.value_type)))) : is_cyclic (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_33841 (h0 : uniform_space (has_union (has_top linarith.comp))) : separated_space (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_33842 (h0 : group (has_zero (ring (mul_one_class (has_neg Type))))) : group.fg (has_zero (ring (mul_one_class (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_33843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33844 (h0 : complete_lattice (non_assoc_semiring empty)) : is_atomistic (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_33845 (h0 : ring (has_edist (option (option empty)))) : strong_rank_condition (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_33846 (h0 : topological_space (canonically_linear_ordered_monoid (has_to_string congr_arg_kind))) : path_connected_space (canonically_linear_ordered_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_33847 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33848 (h0 : topological_space (topological_space string.iterator_imp)) : totally_disconnected_space (topological_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_33849 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33850 (h0 : not (finset Prop -> false)) (h1 : not (finset.nonempty (classical.by_contradiction' h0) -> false)) : @finset.max'.{0} Prop Prop.linear_order (@classical.by_contradiction'.{1} (finset.{0} Prop) h0) (@classical.by_contradiction'.{0} (@finset.nonempty.{0} Prop (@classical.by_contradiction'.{1} (finset.{0} Prop) h0)) h1)  := sorry --non-trivial
lemma new_lemma_33851 (h0 : monoid (comm_group (comm_group Type))) : monoid.fg (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_33852 (h0 : semiring (has_inner (option empty) unsigned)) : is_noetherian_ring (has_inner (option empty) unsigned) := sorry --non-trivial
lemma new_lemma_33853 (h0 : functor.add_const (add_monoid (has_Inf pos)) (has_nndist pos)) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} pos)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_33854 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (finset Type)) := sorry --non-trivial
lemma new_lemma_33855 (h0 : topological_space (non_unital_non_assoc_semiring (has_nnnorm string.iterator_imp))) : t0_space (non_unital_non_assoc_semiring (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_33856 (h0 : monoid (has_inv (has_inv (has_inv linarith.comp_source)))) : monoid.fg (has_inv (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_33857 (h0 : topological_space (complete_distrib_lattice (has_add (has_add pos)))) : locally_compact_space (complete_distrib_lattice (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_33858 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33859 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_33860 (h0 : functor.add_const (topological_space (finset ennreal)) ennreal) : @totally_separated_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_33861 (h0 : list (semigroup (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_33862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_33863 (h0 : topological_space (normed_field (has_nnnorm (random_gen to_additive.value_type)))) : totally_disconnected_space (normed_field (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_33864 (h0 : topological_space (normed_group num)) : path_connected_space (normed_group num) := sorry --non-trivial
lemma new_lemma_33865 (h0 : filter (normed_comm_ring (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33866 (h0 : complete_lattice (plift congr_arg_kind)) : is_compactly_generated (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33867 (h0 : prod (linear_ordered_semiring (semiring unsigned)) (linear_ordered_semiring (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_33868 (h0 : filter (comm_group (cancel_monoid name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33869 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf Type)))) : t0_space (canonically_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_33870 (h0 : topological_space (add_comm_monoid (sub_neg_monoid real))) : t1_space (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_33871 (h0 : ring (has_neg_part (has_add (boolean_algebra.core (comm_group Type))))) : rank_condition (has_neg_part (has_add (boolean_algebra.core (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_33872 (h0 : topological_space (has_compl (has_nnnorm reducibility_hints))) : t0_space (has_compl (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_33873 (h0 : functor.add_const (list (semigroup pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33874 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (mul_zero_class empty)) := sorry --non-trivial
lemma new_lemma_33875 (h0 : functor.add_const (topological_space (has_Sup unsigned)) num) : @irreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_33876 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_nndist (ring name)))) : unique_factorization_monoid (generalized_boolean_algebra (has_nndist (ring name))) := sorry --non-trivial
lemma new_lemma_33877 (h0 : functor.add_const (topological_space (boolean_algebra name)) (boolean_algebra Type)) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_33878 (h0 : functor.add_const (topological_space (ring empty)) unsigned) : @t0_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33879 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add real)) : @normalizer_condition.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} real) h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_33880 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option empty)) -> Prop) (h1 : Exists (fun (x : cancel_comm_monoid_with_zero (add_comm_monoid (option empty))), h0 x)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} (option.{0} empty)) (@classical.some.{1} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} (option.{0} empty))) h0 h1)  := sorry --non-trivial
lemma new_lemma_33881 (h0 : not (topological_space (has_star congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33882 (h0 : set (has_compl std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_33883 (h0 : group (has_Inf (has_Inf (boolean_algebra.core pos)))) : normalizer_condition (has_Inf (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_33884 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_33885 (h0 : group (has_neg (finset (semigroup pos)))) : is_simple_group (has_neg (finset (semigroup pos))) := sorry --non-trivial
lemma new_lemma_33886 (h0 : semiring (ordered_cancel_add_comm_monoid (option ennreal))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_33887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33888 (h0 : set (has_lt (mul_one_class (mul_one_class linarith.ineq)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_33889 (h0 : ring (has_zero (finset (finset Type)))) : is_domain (has_zero (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_33890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : t0_space ennreal := sorry --non-trivial
lemma new_lemma_33891 (h0 : functor.comp add_group canonically_ordered_comm_semiring Type) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_33892 (h0 : not (ring (normed_field real) -> false)) : @rank_condition.{0} (normed_field.{0} real) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_33893 (h0 : topological_space (has_nndist (option (option (option (option (option unsigned))))))) : normal_space (has_nndist (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_33894 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} name (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) name)  := sorry --non-trivial
lemma new_lemma_33895 (h0 : monoid (ring unsigned) -> monoid (ring unsigned) -> Prop) : is_symm (monoid (ring unsigned)) h0 := sorry --non-trivial
lemma new_lemma_33896 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_33897 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_33898 (h0 : group (with_one (random_gen (complete_semilattice_Sup empty)))) : is_cyclic (with_one (random_gen (complete_semilattice_Sup empty))) := sorry --non-trivial
lemma new_lemma_33899 (h0 : functor.add_const (filter (has_to_string unsigned)) (has_neg_part pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33900 (h1 : function.extfun Type monoid) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_33901 (h1 : not (uniform_space (uniform_space linarith.ineq) -> false)) : @complete_space.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_33902 (h1 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_33903 (h0 : ordered_add_comm_monoid (has_neg (has_add Type))) : archimedean (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_33904 (h0 : not (function.extfun (finset Type) (has_mem.mem empty) -> false)) : @rank_condition.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_33905 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : totally_separated_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_33906 (h0 : topological_space (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : path_connected_space (semi_normed_comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_33907 (h0 : group (add_cancel_monoid (has_add linarith.comp))) : group.fg (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_33908 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_33909 (h0 : functor.add_const (finset (has_pos_part name)) (ring linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33910 (h0 : ordered_comm_monoid (generalized_boolean_algebra real)) : has_exists_mul_of_le (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_33911 (h1 : topological_space (has_ssubset (random_gen string_imp))) : t0_space (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_33912 (h0 : filter (topological_space (with_zero char))) : @path_connected_space.{0} (with_zero.{0} char) (@filter.Limsup.{0} (topological_space.{0} (with_zero.{0} char)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (with_zero.{0} char)) (@topological_space.complete_lattice.{0} (with_zero.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_33913 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_33914 (h0 : add_group (semigroup (option (option (option unsigned))))) : is_add_cyclic (semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_33915 (h0 : group (has_norm (has_norm linarith.comp))) : normalizer_condition (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_33916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_semilattice_Sup fun_info)) := sorry --non-trivial
lemma new_lemma_33917 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_33918 (h1 h2 : multiset (has_ssubset environment.projection_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_33919 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (has_pos_part (has_pos_part linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33920 (h0 : functor.comp ring add_cancel_monoid name) : @strong_rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_33921 (h0 : complete_lattice (mul_one_class (metric_space (metric_space to_additive.value_type)))) : is_compactly_generated (mul_one_class (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_33922 (h0 : topological_space (comm_monoid num)) : totally_separated_space (comm_monoid num) := sorry --non-trivial
lemma new_lemma_33923 (h0 : not (add_group (linear_ordered_semiring congr_arg_kind) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_33924 (h0 : add_group (encodable linarith.comp_source)) : is_add_cyclic (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_33925 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_33926 (h1 : filter (measurable_space empty)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_33927 (h1 : group (has_top string_imp)) : normalizer_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_33928 (h0 : filter (with_one (has_nnnorm (has_nnnorm linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33929 (h0 : topological_space (complete_distrib_lattice (has_add (sub_neg_monoid (sub_neg_monoid Type))))) : t0_space (complete_distrib_lattice (has_add (sub_neg_monoid (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_33930 (h0 : functor.add_const (uniform_space (has_star num)) congr_arg_kind) : @complete_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33931 (h0 : functor.add_const (group (semigroup Type)) (has_neg environment.implicit_infer_kind)) : @is_simple_group.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_33932 (h0 : filter (measurable_space.dynkin_system (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_33933 (h0 : semiring (boolean_algebra unsigned)) : is_noetherian_ring (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_33934 (h0 : topological_space (has_pos_part (has_Inf (has_Inf real)))) : loc_path_connected_space (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_33935 (h0 : complete_lattice (semi_normed_comm_ring (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_33936 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra linarith.comp)) pos) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_33937 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @t1_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_33938 (h0 : semiring (boolean_algebra.core unsigned)) : is_noetherian_ring (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_33939 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_33940 (h0 : topological_space (has_norm (semiring (semiring empty)))) : path_connected_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_33941 (h0 : topological_space (ordered_ring (has_dist unsigned))) : t0_space (ordered_ring (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_33942 (h0 : not (group (has_nnnorm linarith.ineq) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_33943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_33944 (h0 : functor.add_const (topological_space (has_star num)) num) : @normal_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_33945 (h1 : ring (nondiscrete_normed_field reducibility_hints)) : is_domain (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_33946 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_33947 (h0 : functor.add_const (finset (finset linarith.comp)) (complete_distrib_lattice (ring (has_neg Type)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_33948 (h0 : ring (dlist (has_ssubset fun_info))) : is_domain (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_33949 (h0 : topological_space (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : sequential_space (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33950 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33951 (h0 : functor.comp topological_space measurable_space.dynkin_system empty) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} empty) (@functor.comp.run.{0 0 0} topological_space.{0} measurable_space.dynkin_system.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_33952 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_33953 (h0 : topological_space (with_bot (random_gen fun_info))) : t0_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_33954 (h0 : functor.add_const (group (has_nndist (semiring num))) congr_arg_kind) : @group.fg.{0} (has_nndist.{0} (semiring.{0} num)) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} (semiring.{0} num))) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_33955 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_33956 (h1 : group (has_top to_additive.value_type)) : is_cyclic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_33957 (h0 : functor.add_const (ring (has_add linarith.comp)) Type) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_33958 (h0 : not (semiring (with_one linarith.comp) -> false)) : @is_noetherian_ring.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_33959 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_33960 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_33961 (h0 : not (topological_space (has_one unsigned) -> false)) : @discrete_topology.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_33962 (h0 : filter (boolean_algebra (has_to_string name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_33963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_33964 (h0 : complete_lattice (uniform_space (distrib (distrib linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (uniform_space (distrib (distrib linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_33965 (h3 h4 : multiset (add_comm_semigroup (add_comm_semigroup ereal))) : multiset.disjoint h3 h4 := sorry --non-trivial
lemma new_lemma_33966 (h0 : topological_space (normed_comm_ring (cancel_monoid unsigned))) : preconnected_space (normed_comm_ring (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_33967 (h0 : set (add_comm_semigroup (mul_one_class ereal))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_33968 (h0 : group (free_add_monoid congr_arg_kind)) : group.fg (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_33969 (h0 : topological_space (complete_distrib_lattice (semigroup (has_add (cancel_monoid pos))))) : totally_disconnected_space (complete_distrib_lattice (semigroup (has_add (cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_33970 (h0 : ring (ring pos)) : is_domain (ring pos) := sorry --non-trivial
lemma new_lemma_33971 (h0 : topological_space (linear_ordered_comm_group unsigned)) : totally_separated_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_33972 (h0 : list (with_one (random_gen (random_gen (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_33973 (h0 : add_group (ordered_cancel_add_comm_monoid (option ennreal))) : is_add_cyclic (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_33974 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_33975 (h0 : monoid (random_gen (random_gen to_additive.value_type))) : monoid.fg (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_33976 (h0 : add_group (semigroup (add_comm_monoid environment.implicit_infer_kind))) : is_add_cyclic (semigroup (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_33977 (h0 : option (functor.add_const (topological_space (has_to_string pos)) unsigned)) (h1 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned (@option.get_or_else.{0} (functor.add_const.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned) h0 h1))  := sorry --non-trivial
lemma new_lemma_33978 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @t1_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33979 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add linarith.comp)))) : totally_separated_space (normed_lattice_add_comm_group (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_33980 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_33981 (h0 : complete_lattice (has_zero (canonically_linear_ordered_add_monoid Type))) : complete_lattice.is_Sup_finite_compact (has_zero (canonically_linear_ordered_add_monoid Type)) := sorry --non-trivial
lemma new_lemma_33982 (h0 : complete_lattice (linear_ordered_semiring (semiring unsigned))) : is_atomistic (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_33983 (h1 : set (mul_one_class (has_nnnorm std_gen) -> mul_one_class (add_comm_semigroup enat))) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_33984 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (plift unsigned)) := sorry --non-trivial
lemma new_lemma_33985 (h0 : functor.comp topological_space mul_zero_class Type) : @totally_separated_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_33986 (h0 : semiring (linear_ordered_field (option ennreal))) : is_noetherian_ring (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_33987 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_33988 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @topological_space.separable_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_33989 (h0 : not (topological_space (distrib fun_info) -> false)) : @path_connected_space.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_33990 (h0 : ring (has_add (has_add linarith.comp))) : rank_condition (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_33991 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_33992 (h0 : topological_space (linear_ordered_field empty)) : path_connected_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_33993 (h0 : topological_space (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) : discrete_topology (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_33994 (h0 : functor.add_const Prop (add_group (semiring (semiring (semiring (option (semiring unsigned))))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_33995 (h0 : not (ring (has_lt reducibility_hints) -> false)) : @rank_condition.{0} (has_lt.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_33996 (h0 : set (prod real real)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_33997 (h0 : cancel_comm_monoid_with_zero (has_add (sub_neg_monoid Type))) : unique_factorization_monoid (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_33998 (h0 : ring fun_info) : rank_condition fun_info := sorry --non-trivial
lemma new_lemma_33999 (h0 : monoid (linear_ordered_field (option (option (option unsigned))))) : monoid.fg (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_34000 (h0 : complete_lattice (with_one (with_bot string_imp))) : is_atomistic (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_34001 (h0 : complete_lattice (has_norm (random_gen (random_gen fun_info)))) : is_atomistic (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_34002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34003 (h1 : measurable_space (mul_one_class (normed_field std_gen))) (h2 : measure_theory.measure (mul_one_class (normed_field std_gen))) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_34004 (h0 : ordered_comm_monoid (has_Inf (has_neg (has_add pos)))) : has_exists_mul_of_le (has_Inf (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_34005 (h0 : group (has_to_string name)) : normalizer_condition (has_to_string name) := sorry --non-trivial
lemma new_lemma_34006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_34007 (h0 : not (add_group (normed_group (random_gen fun_info)) -> false)) : @is_add_cyclic.{0} (normed_group.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_34008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_34009 (h0 : functor.add_const (ring znum) (option num)) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_34010 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34011 (h0 : functor.add_const (functor.add_const (add_monoid linarith.comp) pos) linarith.comp) : @add_monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (add_monoid.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_monoid.{0} linarith.comp) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_34012 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34013 (h1 : uniform_space (normed_field std_gen)) : complete_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_34014 (h0 : ring (finset (boolean_algebra name))) : rank_condition (finset (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_34015 (h0 : not (topological_space (linear_ordered_add_comm_group string_imp) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_34016 (h0 : uniform_space (add_cancel_monoid environment.implicit_infer_kind)) : complete_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_34017 (h2 : topological_space (add_comm_semigroup char)) : topological_space.first_countable_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_34018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_34019 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_34020 (h0 : function.extfun Type topological_space) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34021 (h0 : topological_space (as_linear_order (option (option empty)))) : loc_path_connected_space (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_34022 (h0 : add_monoid (has_zero (has_add (has_add pos)))) : add_monoid.fg (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_34023 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core Type)) : unique_factorization_monoid (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_34024 (h0 : topological_space (has_nndist (mul_zero_class (has_neg environment.implicit_infer_kind)))) : t1_space (has_nndist (mul_zero_class (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_34025 (h0 : topological_space (has_nndist (has_add (finset (finset pos))))) : normal_space (has_nndist (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_34026 (h0 : functor.add_const (function.extfun Type filter) (has_Inf pos)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_34027 (h0 : group (topological_space (has_top fun_info))) : group.fg (topological_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_34028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_34029 (h0 : uniform_space (add_group (has_norm (semiring linarith.comp)))) : separated_space (add_group (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_34030 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_34031 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)))) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_34032 (h0 : topological_space (has_star congr_arg_kind)) : path_connected_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34033 (h0 : function.extfun Type group) : @normalizer_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_34034 (h0 : complete_lattice (has_to_string (finset (has_nndist (finset pos))))) : complete_lattice.is_Sup_finite_compact (has_to_string (finset (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_34035 (h0 : complete_lattice (non_assoc_semiring (option empty))) : is_atomistic (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_34036 (h0 : ordered_add_comm_monoid (semiring (semiring unsigned))) (h1 : uniform_space (plift (archimedean (semiring (semiring unsigned))))) : complete_space (plift (archimedean (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_34037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34038 (h0 : ring (has_neg_part (option empty))) : strong_rank_condition (has_neg_part (option empty)) := sorry --non-trivial
lemma new_lemma_34039 (h0 : topological_space (has_div (mul_one_class reducibility_hints))) : totally_disconnected_space (has_div (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_34040 (h1 : topological_space (comm_ring (random_gen (random_gen to_additive.value_type)))) : t0_space (comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_34041 (h0 : functor.comp topological_space has_zero (option pos)) : @path_connected_space.{0} (has_zero.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_34042 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) num) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_34043 (h0 : functor.comp group mul_zero_class Type) : @normalizer_condition.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} group.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_34044 (h0 : ring (linear_ordered_comm_group_with_zero ereal)) : rank_condition (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_34045 (h0 : functor.add_const (topological_space (ring Type)) (has_neg (has_neg Type))) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34046 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34047 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice empty)) empty) : @archimedean.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_34048 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34049 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_34050 (h0 : not (ring (bin_tree empty) -> false)) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_34051 (h0 : group (add_comm_monoid (option ennreal))) : group.fg (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_34052 (h0 : ring (has_zero (has_add (comm_group (has_add (comm_group pos)))))) : is_principal_ideal_ring (has_zero (has_add (comm_group (has_add (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_34053 (h1 : not (topological_space (random_gen linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_34054 (h0 : complete_lattice (linear_ordered_comm_group (option (option ennreal)))) : is_compactly_generated (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_34055 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : t0_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_34056 (h0 : functor.add_const (monoid (has_Inf Type)) (ring (finset linarith.comp))) : @monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_Inf.{1} Type)) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34057 (h0 : complete_lattice (normed_group (semiring empty))) : is_compactly_generated (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_34058 (h0 : function.extfun Type ring) : @rank_condition.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34059 (h0 : functor.add_const (add_monoid (has_zero Type)) (ring (ring linarith.comp))) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34060 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) pos) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_34061 (h0 : functor.add_const (group (has_nndist pos)) name) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_34062 (h0 : complete_lattice (measurable_space (semiring linarith.comp_source))) : is_compactly_generated (measurable_space (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34063 (h0 : not (complete_lattice (random_gen congr_arg_kind) -> false)) : @is_atomistic.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_34064 (h0 : monoid (ordered_comm_ring (ring Type))) : monoid.fg (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_34065 (h1 : not (topological_space (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_34066 (h0 : ordered_add_comm_monoid (as_linear_order num)) : archimedean (as_linear_order num) := sorry --non-trivial
lemma new_lemma_34067 (h0 : topological_space (has_norm linarith.comp)) : discrete_topology (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_34068 (h0 : group (has_to_string (has_add (has_add name)))) : group.fg (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_34069 (h0 : ring (has_nnnorm (has_ssubset string_imp))) : is_domain (has_nnnorm (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_34070 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra Type)) name) : @separated_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_34071 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_34072 (h0 : complete_lattice (measurable_space (has_norm to_additive.value_type))) : is_atomistic (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34073 (h0 : topological_space (free_add_monoid (semiring congr_arg_kind))) : totally_disconnected_space (free_add_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34074 (h0 : not (uniform_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class string_imp))) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} (mul_one_class.{0} string_imp))) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} (mul_one_class.{0} string_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_34075 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34076 (h0 : group (random_gen (has_inv linarith.comp_source))) : is_cyclic (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34077 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34078 (h0 : list (monoid (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34079 (h0 : ring (nondiscrete_normed_field (nondiscrete_normed_field char))) : strong_rank_condition (nondiscrete_normed_field (nondiscrete_normed_field char)) := sorry --non-trivial
lemma new_lemma_34080 (h0 : function.extfun Type (functor.add_const (functor.add_const (prod nnreal nnreal) empty))) : id_rel (functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty))) := sorry --non-trivial
lemma new_lemma_34081 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34082 (h0 : ring (add_comm_monoid (ring (has_add linarith.comp)))) : is_principal_ideal_ring (add_comm_monoid (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_34083 (h0 : complete_lattice (distrib_lattice (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_34084 (h0 : add_monoid (comm_group pos)) : add_monoid.fg (comm_group pos) := sorry --non-trivial
lemma new_lemma_34085 (h0 : monoid linarith.comp_source) : monoid.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_34086 (h0 : not (complete_lattice (has_norm to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_34087 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_34088 (h0 : add_group (random_gen (random_gen (random_gen (has_nnnorm fun_info))))) : is_add_cyclic (random_gen (random_gen (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_34089 (h0 : topological_space (boolean_algebra.core (has_add (has_nndist pos)))) : t0_space (boolean_algebra.core (has_add (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_34090 (h0 : topological_space (has_neg (has_add (finset name)))) : normal_space (has_neg (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_34091 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @sequential_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_34092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34093 (h0 : functor.add_const (group (has_neg_part name)) pos) : @group.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_34094 (h0 : group (linear_ordered_add_comm_group (has_top congr_arg_kind))) : is_cyclic (linear_ordered_add_comm_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34095 (h0 : list (cancel_monoid (cancel_monoid pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34096 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_34097 (h0 : topological_space char) (h1 : ring (connected_components char)) : rank_condition (connected_components char) := sorry --non-trivial
lemma new_lemma_34098 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34099 (h0 : add_group (has_nnnorm (mul_one_class to_additive.value_type))) : is_add_cyclic (has_nnnorm (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34100 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_34101 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : preirreducible_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_34102 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_34103 (h0 : complete_lattice (ordered_ring empty)) : is_atomistic (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_34104 (h0 : not (group (linear_ordered_add_comm_group string_imp) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_34105 (h0 : topological_space (comm_semigroup (has_add linarith.comp))) : path_connected_space (comm_semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_34106 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_34107 (h0 : topological_space (has_to_string (option num))) : totally_disconnected_space (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_34108 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34109 (h0 : ring (preorder num)) : rank_condition (preorder num) := sorry --non-trivial
lemma new_lemma_34110 (h0 : semiring (semiring (semiring congr_arg_kind))) : is_noetherian_ring (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34111 (h0 : topological_space (add_left_cancel_monoid complex)) : path_connected_space (add_left_cancel_monoid complex) := sorry --non-trivial
lemma new_lemma_34112 (h0 : list (complete_distrib_lattice (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34113 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_34114 (h0 h1 : multiset (has_ssubset environment.projection_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_34115 (h0 : complete_lattice (semi_normed_ring fun_info)) : is_compactly_generated (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_34116 (h0 : functor.add_const (list (finset linarith.comp)) (finset pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34117 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : totally_separated_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34118 (h0 : functor.add_const (function.extfun (Type 1) filter) (has_pos_part pos)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_34119 (h0 : functor.add_const (list (semigroup pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34120 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_34121 (h0 : topological_space (has_nndist (comm_group (comm_group unsigned)))) : normal_space (has_nndist (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_34122 (h0 : group (measurable_space Type)) : group.fg (measurable_space Type) := sorry --non-trivial
lemma new_lemma_34123 (h0 : functor.add_const (filter (ordered_comm_monoid linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34125 (h0 : uniform_space (has_le std_gen)) : complete_space (has_le std_gen) := sorry --non-trivial
lemma new_lemma_34126 (h0 : topological_space (add_comm_monoid (semigroup environment.implicit_infer_kind))) : regular_space (add_comm_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34127 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_34128 (h0 : semiring ereal) (h1 : ideal ereal) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_34129 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist name))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_34130 (h0 : topological_space (metric_space (has_norm empty))) : irreducible_space (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_34131 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : t1_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_34132 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_Inf real))) : unique_factorization_monoid (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_34133 (h0 : group (semiring (option empty))) : normalizer_condition (semiring (option empty)) := sorry --non-trivial
lemma new_lemma_34134 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_34135 (h0 : uniform_space (generalized_boolean_algebra name)) : complete_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_34136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_34137 (h0 : complete_lattice (comm_group (finset Type))) : is_atomistic (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_34138 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_emptyc num)) := sorry --non-trivial
lemma new_lemma_34139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_34140 (h0 : function.extfun Type group) : @is_cyclic.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_34141 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_34142 (h0 : topological_space (has_add (generalized_boolean_algebra real))) : sequential_space (has_add (generalized_boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_34143 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) : totally_disconnected_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_34144 (h0 : complete_lattice (mul_one_class (mul_one_class (add_comm_semigroup enat)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_34145 (h0 : function.extfun Type group) : @group.fg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type group.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_34146 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_34147 (h0 : topological_space (has_Inf (has_Inf Type))) : sequential_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_34148 (h0 : ring (has_star (option (option (option empty))))) : rank_condition (has_star (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_34149 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_34150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34151 (h0 : complete_lattice (pseudo_metric_space pos)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_34152 (h0 : functor.add_const (list (order_dual unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34153 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_34154 (h0 : ordered_add_comm_monoid (has_pos_part (ordered_comm_monoid (sub_neg_monoid (has_Inf Type))))) : archimedean (has_pos_part (ordered_comm_monoid (sub_neg_monoid (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_34155 (h0 : add_monoid (complete_distrib_lattice (option (option (option empty))))) : add_monoid.fg (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_34156 (h0 : ring (distrib (has_ssubset reducibility_hints))) : is_domain (distrib (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_34157 (h0 : function.extfun Type (functor.add_const (ring (bin_tree real)))) : @is_domain.{0} (bin_tree.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} real)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (bin_tree.{0} real))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_34158 (h0 : group (id (has_top (has_top (has_top (has_top (has_top linarith.comp_source))))))) : normalizer_condition (id (has_top (has_top (has_top (has_top (has_top linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_34159 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_neg (has_neg (has_neg pos)))) : @t0_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_neg.{0} (has_neg.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_34160 (h0 : topological_space (has_to_string (finset pos))) : discrete_topology (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_34161 (h0 : group (encodable to_additive.value_type)) : is_cyclic (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_34162 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) empty) : @separated_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_34163 (h0 : topological_space (has_zero (has_add unsigned))) : t0_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_34164 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_34165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34166 (h0 : topological_space (boolean_algebra (has_Inf real))) : loc_path_connected_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_34167 (h0 : complete_lattice (normed_linear_ordered_group (semiring congr_arg_kind))) : is_compactly_generated (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34168 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_34169 (h0 : monoid (ring empty)) : monoid.fg (ring empty) := sorry --non-trivial
lemma new_lemma_34170 (h0 : functor.add_const (topological_space (has_add pos)) name) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_34171 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34172 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_34173 (h0 : ring (add_comm_monoid (ring (ring (add_comm_monoid Type))))) : is_domain (add_comm_monoid (ring (ring (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_34174 (h0 : functor.add_const (topological_space (has_nndist empty)) congr_arg_kind) : @locally_compact_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34175 (h0 : ring (semigroup (has_to_string (boolean_algebra pos)))) : is_domain (semigroup (has_to_string (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_34176 (h0 : group (complete_linear_order unsigned)) : is_simple_group (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_34177 (h0 : topological_space (semiring linarith.comp_source)) : totally_disconnected_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34178 (h0 : functor.add_const (uniform_space (mul_one_class Type)) pos) : @separated_space.{1} (mul_one_class.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (mul_one_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_34179 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_34180 (h0 : function.extfun Type (functor.add_const (uniform_space (non_assoc_semiring num)))) : @complete_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_34181 (h0 : ring (has_Inf (has_Inf pos))) : is_principal_ideal_ring (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_34182 (h1 : ring (semi_normed_ring (has_append (semi_normed_ring (denumerable (denumerable char)))))) : is_domain (semi_normed_ring (has_append (semi_normed_ring (denumerable (denumerable char))))) := sorry --non-trivial
lemma new_lemma_34183 (h0 : topological_space (has_add (has_pos_part (has_pos_part name)))) : discrete_topology (has_add (has_pos_part (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_34184 (h0 : functor.add_const (topological_space (semiring unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34185 (h0 : fin has_zero.zero) : @path_connected_space.{1} (semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34186 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_34187 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_34188 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_34189 (h0 : set (std_gen -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_34190 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_34191 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_34192 (h0 : functor.add_const (group (measurable_space.dynkin_system num)) num) : @group.fg.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_34193 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_34194 (h0 : topological_space (ring (option (option (option empty))))) : preirreducible_space (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_34195 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_34196 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34197 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34198 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34199 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_34200 (h2 : topological_space (has_ssubset char)) : totally_disconnected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_34201 (h0 : topological_space (finset (finset linarith.comp))) : preconnected_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_34202 (h0 : functor.add_const (group (simple_graph linarith.comp)) linarith.comp) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34203 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34204 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @group.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_34205 (h0 : has_lt (normed_field ereal)) : no_max_order (normed_field ereal) := sorry --non-trivial
lemma new_lemma_34206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34207 (h0 : function.extfun nat fin) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_34208 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34209 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_34210 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_34211 (h0 : add_group (has_nndist (boolean_algebra.core (has_add linarith.comp)))) : is_add_cyclic (has_nndist (boolean_algebra.core (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_34212 (h0 : complete_lattice (has_to_string (option (option (option (option num)))))) : is_compactly_generated (has_to_string (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_34213 (h0 : topological_space (add_cancel_comm_monoid (option empty))) : path_connected_space (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_34214 (h1 : add_group (mul_one_class (mul_one_class reducibility_hints))) : is_add_cyclic (mul_one_class (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_34215 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34216 (h0 : complete_lattice (has_emptyc (has_norm (has_norm linarith.comp)))) : is_atomistic (has_emptyc (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_34217 (h0 : group (with_bot (random_gen (random_gen string_imp)))) : group.fg (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_34218 (h0 : topological_space (metric_space congr_arg_kind)) : preirreducible_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34219 (h0 : filter (has_pos_part (has_pos_part pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34220 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_34221 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring num)) : @totally_separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_34222 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_34223 (h0 : group (ring (option pos))) : group.fg (ring (option pos)) := sorry --non-trivial
lemma new_lemma_34224 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_34225 (h0 : group (normed_group (has_norm (semiring (has_norm (semiring (has_norm unsigned))))))) : group.fg (normed_group (has_norm (semiring (has_norm (semiring (has_norm unsigned)))))) := sorry --non-trivial
lemma new_lemma_34226 (h0 : topological_space (has_zero (has_add (option ennreal)))) : normal_space (has_zero (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_34227 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @totally_disconnected_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34228 (h1 : complete_lattice (with_one char)) : complete_lattice.is_Sup_finite_compact (with_one char) := sorry --non-trivial
lemma new_lemma_34229 (h1 : ring (linear_ordered_semiring (random_gen empty))) : rank_condition (linear_ordered_semiring (random_gen empty)) := sorry --non-trivial
lemma new_lemma_34230 (h1 : ring (fintype (random_gen (random_gen (random_gen char))))) : rank_condition (fintype (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_34231 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_34232 (h0 : functor.add_const (group (generalized_boolean_algebra real)) real) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_34233 (h0 : topological_space (comm_semigroup (sub_neg_monoid (ordered_comm_monoid real)))) : totally_disconnected_space (comm_semigroup (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_34234 (h1 : topological_space (with_one char)) : t0_space (with_one char) := sorry --non-trivial
lemma new_lemma_34235 (h0 : ring (with_zero linarith.ineq) -> linarith.ineq) (h1 : not (coe_sort (set.range h0) -> false)) : @strong_rank_condition.{0} (with_zero.{0} linarith.ineq) (@set.range_splitting.{0 0} (ring.{0} (with_zero.{0} linarith.ineq)) linarith.ineq h0 (@classical.by_contradiction'.{1} (@coe_sort.{1 2} (set.{0} linarith.ineq) Type (@set.has_coe_to_sort.{0} linarith.ineq) (@set.range.{0 1} linarith.ineq (ring.{0} (with_zero.{0} linarith.ineq)) h0)) h1))  := sorry --non-trivial
lemma new_lemma_34236 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34237 (h0 : functor.add_const (finset (add_group congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34238 (h0 : topological_space (random_gen (comm_ring to_additive.value_type))) : t0_space (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34240 (h0 : group (has_pos_part (has_add pos))) : group.fg (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_34241 (h0 : topological_space (semiring (has_top to_additive.value_type))) : t0_space (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34242 (h0 : cancel_comm_monoid_with_zero (finset (option pos))) : unique_factorization_monoid (finset (option pos)) := sorry --non-trivial
lemma new_lemma_34243 (h0 : complete_lattice (comm_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34244 (h2 : topological_space (has_lt linarith.ineq)) : t0_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_34245 (h0 : topological_space (has_norm (random_gen congr_arg_kind))) : totally_disconnected_space (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34246 (h0 : topological_space (has_one linarith.comp)) : irreducible_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_34247 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : path_connected_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_34248 (h0 : ring (finset empty)) : is_domain (finset empty) := sorry --non-trivial
lemma new_lemma_34249 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34250 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : topological_space.separable_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_34251 (h0 : topological_space (complete_semilattice_Sup linarith.comp_source)) : totally_disconnected_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34252 (h0 : function.extfun Type (functor.add_const (complete_lattice pos))) : @is_atomistic.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_34253 (h0 : topological_space (has_to_string (has_neg_part unsigned))) : totally_separated_space (has_to_string (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_34254 (h0 : ring (random_gen (has_inv (linear_ordered_cancel_comm_monoid to_additive.value_type)))) : is_domain (random_gen (has_inv (linear_ordered_cancel_comm_monoid to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_34255 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34258 (h0 : measurable_space (nondiscrete_normed_field (nondiscrete_normed_field enat))) (h1 : measure_theory.measure (nondiscrete_normed_field (nondiscrete_normed_field enat))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_34259 (h0 : ring (with_one (random_gen (comm_ring fun_info)))) : rank_condition (with_one (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_34260 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (dlist.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} char))  := sorry --non-trivial
lemma new_lemma_34261 (h0 : ring (has_scalar (add_left_cancel_semigroup empty) unsigned)) : is_domain (has_scalar (add_left_cancel_semigroup empty) unsigned) := sorry --non-trivial
lemma new_lemma_34262 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34263 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) (finset linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_34264 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_34265 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34266 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_34267 (h0 : uniform_space (complete_semilattice_Sup (with_bot to_additive.value_type))) : complete_space (complete_semilattice_Sup (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34268 (h0 : topological_space (normed_comm_ring (has_to_string num))) : totally_separated_space (normed_comm_ring (has_to_string num)) := sorry --non-trivial
lemma new_lemma_34269 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_34270 (h0 : add_group (normed_comm_ring (has_add environment.implicit_infer_kind))) : is_add_cyclic (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34271 (h0 : group (semigroup (has_Inf Type))) : group.fg (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_34272 (h0 : uniform_space (has_add (has_nndist (finset pos)))) : separated_space (has_add (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_34273 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_cancel_comm_monoid unsigned)))) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_34274 (h0 : ring (measurable_space.dynkin_system (option (option unsigned)))) : is_domain (measurable_space.dynkin_system (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_34275 (h3 : set (enat -> linarith.ineq)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_34276 (h0 : functor.add_const (list (has_pos_part pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34277 (h0 : prod (has_star (option empty)) (has_star (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_34278 (h0 : topological_space (ring environment.implicit_infer_kind)) : regular_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_34279 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add ennreal))) : archimedean (add_cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_34280 (h0 : filter (comm_group pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_34281 (h0 : fin has_zero.zero) : @is_atomistic.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_34282 (h1 : add_group (normed_field (mul_one_class environment.projection_info))) : is_add_cyclic (normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_34283 (h0 : topological_space (has_emptyc (has_top linarith.comp))) : irreducible_space (has_emptyc (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_34284 (h0 : option (group (linear_ordered_field (has_to_string name)))) (h1 : function.extfun Type option) (h2 : group (linear_ordered_field (has_to_string name))) : is_simple_group (linear_ordered_field (has_to_string name)) := sorry --non-trivial
lemma new_lemma_34285 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34286 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34287 (h0 : list (multiset Prop)) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) (@list.head.{0} (multiset.{0} Prop) (@multiset.inhabited_multiset.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_34288 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : preirreducible_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_34289 (h0 : functor.add_const (add_monoid (ordered_comm_monoid linarith.comp)) (ring (has_pos_part linarith.comp))) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34290 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) name) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_34291 (h1 : ring (nondiscrete_normed_field char)) : strong_rank_condition (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_34292 (h0 : ring (has_union (has_norm congr_arg_kind))) : is_domain (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34293 (h0 : functor.add_const (ring (has_nndist linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34294 (h0 : complete_lattice (ring (option (option (option empty))))) : is_compactly_generated (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_34295 (h0 : add_group (ordered_comm_monoid (ring name))) : is_add_cyclic (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_34296 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34297 (h0 : functor.add_const (ordered_comm_monoid (has_to_string environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_34298 (h0 : has_mem.mem (semiring (measurable_space linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} (measurable_space.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_34299 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34300 (h0 : functor.add_const (ring (finset linarith.comp)) (has_neg (has_neg Type))) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34301 (h0 : add_monoid (measurable_space fun_info)) : add_monoid.fg (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_34302 (h0 : topological_space (simple_graph (mul_one_class to_additive.value_type))) : path_connected_space (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34303 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34304 (h0 : complete_lattice (finset (boolean_algebra.core linarith.comp))) : is_compactly_generated (finset (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_34305 (h0 : topological_space (has_pos_part (sub_neg_monoid real))) : totally_separated_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_34306 (h0 : not (group (has_emptyc empty) -> false)) : @is_cyclic.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_34307 (h0 : filter (has_zero (ring (option (has_neg_part (option (ring unsigned))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34308 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_Inf (has_Inf pos))))) : totally_disconnected_space (complete_distrib_lattice (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_34309 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : totally_separated_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_34310 (h0 : not (ring (complete_linear_order congr_arg_kind) -> false)) (h1 : option (ring (complete_linear_order congr_arg_kind))) : @strong_rank_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@option.lhoare.{0} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) h0) h1)  := sorry --non-trivial
lemma new_lemma_34311 (h0 : ring (has_zero (has_add name))) : strong_rank_condition (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_34312 (h0 : topological_space (boolean_algebra (has_Inf (has_neg (has_Inf Type))))) : irreducible_space (boolean_algebra (has_Inf (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_34313 (h0 : topological_space (random_gen (random_gen (random_gen char)))) : path_connected_space (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_34314 (h0 : uniform_space (lattice (random_gen (mul_one_class (mul_one_class reducibility_hints))))) : complete_space (lattice (random_gen (mul_one_class (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_34315 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) linarith.comp) : @is_domain.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34316 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) (boolean_algebra environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_34317 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34318 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34319 (h0 : topological_space (has_ssubset (has_nnnorm linarith.comp_source))) : t0_space (has_ssubset (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34320 (h2 : group congr_arg_kind) : is_cyclic congr_arg_kind := sorry --non-trivial
lemma new_lemma_34321 (h1 : ring (random_gen (has_nnnorm linarith.ineq))) : is_domain (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34322 (h0 : filter (preorder (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34323 (h0 : topological_space (monoid_with_zero unsigned)) : preconnected_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_34324 (h0 : topological_space (has_nndist (has_to_string unsigned))) : totally_separated_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_34325 (h1 : topological_space (dlist (random_gen string_imp))) : totally_disconnected_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_34326 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34327 (h0 : group (has_nndist (option unsigned))) : is_simple_group (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_34328 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34329 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (ring Type)) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_34330 (h0 : group (ring (has_add Type))) : group.fg (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_34331 (h0 : not (ring (has_ssubset linarith.comp_source) -> false)) : @is_domain.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_34332 (h0 : uniform_space (monoid (option empty))) : separated_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_34333 (h0 : add_group (has_neg (has_nnnorm linarith.comp_source))) : is_add_cyclic (has_neg (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34334 (h0 : functor.add_const (group (ordered_cancel_add_comm_monoid empty)) num) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_cancel_add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_34335 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_union num)) := sorry --non-trivial
lemma new_lemma_34336 (h0 : add_comm_monoid (lex pos) -> add_comm_monoid (lex pos) -> Prop) : is_symm (add_comm_monoid (lex pos)) h0 := sorry --non-trivial
lemma new_lemma_34337 (h2 : topological_space (dlist (has_add fun_info))) : t0_space (dlist (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_34338 (h0 : not (has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_34339 (h0 : topological_space (mul_one_class (has_nnnorm char))) : path_connected_space (mul_one_class (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_34340 (h0 : complete_lattice (has_div (uniform_space fun_info))) : is_compactly_generated (has_div (uniform_space fun_info)) := sorry --non-trivial
lemma new_lemma_34341 (h0 : group (normed_comm_ring (option empty))) : group.fg (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_34342 (h0 : functor.add_const (complete_lattice (ring pos)) linarith.comp) : @is_atomistic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34343 (h0 : fin has_zero.zero) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34344 (h0 : ring (normed_group (has_top (has_top (has_top fun_info))))) : is_domain (normed_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_34345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34346 (h0 : functor.add_const (list (add_comm_monoid name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34347 (h0 : set (add_comm_semigroup std_gen -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_34348 (h0 : topological_space (normed_lattice_add_comm_group (finset name))) : topological_space.separable_space (normed_lattice_add_comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_34349 (h0 : uniform_space (add_semigroup congr_arg_kind)) : separated_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34350 (h0 : uniform_space (has_append (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))))) : complete_space (has_append (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_34351 (h0 : functor.add_const (add_monoid (comm_group Type)) Type) : @add_monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_34352 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34353 (h0 : cancel_comm_monoid_with_zero (has_pos_part (sub_neg_monoid real))) : unique_factorization_monoid (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_34354 (h0 : not (ring (canonically_linear_ordered_add_monoid char) -> false)) : @is_domain.{0} (canonically_linear_ordered_add_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (canonically_linear_ordered_add_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_34355 (h0 : topological_space (finset ennreal)) : t0_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_34356 (h0 : function.extfun Type metric_space) (h1 : set (group_with_zero ennreal)) : @euclidean_geometry.cospherical.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type metric_space.{0} h0 (group_with_zero.{0} ennreal)) h1  := sorry --non-trivial
lemma new_lemma_34357 (h0 : list (boolean_algebra linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34358 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @normal_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34359 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid unsigned)))) : @path_connected_space.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34360 (h3 : not (uniform_space (div_inv_monoid linarith.comp_source) -> false)) : @complete_space.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h3)  := sorry --non-trivial
lemma new_lemma_34361 (h0 : group (mul_zero_class (option pos))) : group.fg (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_34362 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_34363 (h0 : functor.add_const (complete_lattice (mul_zero_class Type)) (normed_comm_ring Type)) : @is_compactly_generated.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (mul_zero_class.{1} Type)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_34364 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34365 (h0 : functor.add_const (filter (add_cancel_monoid pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34366 (h0 : uniform_space (has_emptyc (has_inv linarith.ineq))) : complete_space (has_emptyc (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34367 (h0 : topological_space (with_bot (has_top (has_top (random_gen (has_top to_additive.value_type)))))) : irreducible_space (with_bot (has_top (has_top (random_gen (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_34368 (h0 : topological_space (has_nndist congr_arg_kind)) : preconnected_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34369 (h0 : functor.add_const (group (ordered_comm_ring pos)) Type) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_34370 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34371 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) Type) : @preconnected_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_34372 (h0 : semiring (has_neg (has_nndist ennreal))) : is_noetherian_ring (has_neg (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_34373 (h0 : functor.comp complete_lattice finset name) : @is_atomistic.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_34374 (h0 : topological_space (finset (normed_comm_ring Type))) : topological_space.separable_space (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_34375 (h0 : topological_space (has_top (has_nnnorm (random_gen fun_info)))) : t0_space (has_top (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_34376 (h0 : topological_space (has_compl linarith.comp_source)) : path_connected_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34377 (h0 : topological_space (option (has_to_string pos))) : totally_separated_space (option (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_34378 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_34379 (h0 : complete_lattice (ordered_comm_monoid (canonically_ordered_comm_semiring Type))) : is_compactly_generated (ordered_comm_monoid (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_34380 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_34381 (h0 : set (has_dist to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_34382 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_34383 (h0 : function.extfun Type semiring) : is_noetherian_ring ennreal := sorry --non-trivial
lemma new_lemma_34384 (h0 : group (with_bot (random_gen fun_info))) : is_cyclic (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_34385 (h0 : not (filter (add_right_cancel_monoid unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_34386 (h1 : not (topological_space (with_one empty) -> false)) : @t0_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_34387 (h0 : not (topological_space (measurable_space unsigned) -> false)) : @irreducible_space.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_34388 (h3 h4 : nat) (h5 : thunk (topological_space (add_comm_semigroup fun_info))) : @path_connected_space.{0} (add_comm_semigroup.{0} fun_info) (@scope_trace.{0} (topological_space.{0} (add_comm_semigroup.{0} fun_info)) h3 h4 h5)  := sorry --non-trivial
lemma new_lemma_34389 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34390 (h0 : cancel_comm_monoid_with_zero (has_nndist congr_arg_kind)) : unique_factorization_monoid (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34391 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34392 (h0 : monoid (boolean_algebra (has_add (finset (has_add (has_add name)))))) : monoid.fg (boolean_algebra (has_add (finset (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_34393 (h0 : functor.comp topological_space mul_zero_class Type) : @sequential_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_34394 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_34395 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_34396 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34397 (h1 : topological_space (has_add char)) : t0_space (has_add char) := sorry --non-trivial
lemma new_lemma_34398 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_34399 (h0 : functor.add_const (group (has_pos_part Type)) pos) : @group.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_34400 (h0 : topological_space linarith.comp) : normal_space linarith.comp := sorry --non-trivial
lemma new_lemma_34401 (h0 : functor.add_const (ring (semigroup linarith.comp)) Type) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_34402 (h0 : group (mul_zero_class (has_top (has_top (has_top (has_top (semiring (has_top unsigned)))))))) : group.fg (mul_zero_class (has_top (has_top (has_top (has_top (semiring (has_top unsigned))))))) := sorry --non-trivial
lemma new_lemma_34403 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34404 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_34405 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34406 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34407 (h0 : topological_space (has_nndist (has_add (has_to_string pos)))) : t0_space (has_nndist (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_34408 (h0 : topological_space (has_Sup (semiring empty))) : locally_compact_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_34409 (h1 : monoid (with_one to_additive.value_type)) : monoid.fg (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_34410 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @normal_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_34411 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : locally_compact_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_34412 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @locally_compact_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_34413 (h0 : add_group (normed_lattice_add_comm_group (has_neg Type))) : is_add_cyclic (normed_lattice_add_comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_34414 (h0 : not (group (has_emptyc num) -> false)) : @group.fg.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_34415 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_34416 (h0 : topological_space (linear_ordered_semiring (semiring num))) : locally_compact_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_34417 (h0 : topological_space (linear_ordered_field (option congr_arg_kind))) : t0_space (linear_ordered_field (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34418 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_34419 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34420 (h0 : not (complete_lattice congr_arg_kind -> false)) : @is_atomistic.{0} congr_arg_kind (@classical.by_contradiction'.{1} (complete_lattice.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_34421 (h0 : functor.add_const (complete_lattice (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34422 (h0 : not (complete_lattice (normed_field linarith.ineq) -> false)) : @is_compactly_generated.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_34423 (h0 : functor.add_const (group (has_bot linarith.comp)) pos) : @group.fg.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_34424 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34425 (h0 : topological_space (has_div char)) (h1 : set (has_div char)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_34426 (h0 : topological_space (metric_space unsigned)) : totally_separated_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_34427 (h0 : list (monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34428 (h0 : ordered_comm_monoid (add_cancel_monoid (finset linarith.comp))) : has_exists_mul_of_le (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_34429 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34430 (h0 : nat) (h1 : ring (nat.partition h0)) : strong_rank_condition (nat.partition h0) := sorry --non-trivial
lemma new_lemma_34431 (h0 : topological_space (has_nndist (has_nndist (has_nndist (has_to_string (has_nndist pos)))))) : regular_space (has_nndist (has_nndist (has_nndist (has_to_string (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_34432 (h1 : not (topological_space (random_gen to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_34433 (h1 : add_group (with_one char)) : is_add_cyclic (with_one char) := sorry --non-trivial
lemma new_lemma_34434 (h0 : functor.add_const (topological_space (has_neg pos)) (finset linarith.comp)) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_34435 (h0 : topological_space (ordered_comm_ring (ordered_comm_ring real))) : regular_space (ordered_comm_ring (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_34436 (h0 : add_monoid (has_one (has_top linarith.comp))) : add_monoid.fg (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_34437 (h0 : topological_space (has_nndist (has_neg_part Type))) : topological_space.separable_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_34438 (h0 : topological_space (random_gen (comm_ring fun_info))) : totally_disconnected_space (random_gen (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_34439 (h0 : topological_space (boolean_algebra (has_add Type))) : sequential_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_34440 (h0 : topological_space (has_pos_part (has_Inf name))) : path_connected_space (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_34441 (h0 : topological_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind))) : irreducible_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34442 (h0 : fin has_zero.zero) : @group.fg.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34443 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_34444 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_34445 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) pos) : @is_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_34446 (h0 : topological_space (has_nndist (mul_zero_class pos))) : t1_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_34447 (h0 : monoid (ordered_comm_monoid (has_add pos))) : monoid.fg (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_34448 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34449 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34450 (h0 : ring (has_one (has_norm congr_arg_kind))) : is_domain (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_34451 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34452 (h0 : has_lt (has_compl (mul_one_class linarith.comp_source))) : no_max_order (has_compl (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34453 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_34454 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34455 (h0 : complete_lattice (boolean_algebra.core (has_nndist Type))) : is_compactly_generated (boolean_algebra.core (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_34456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_34457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34458 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34459 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_34460 (h0 : group (boolean_algebra.core (has_to_string unsigned))) : normalizer_condition (boolean_algebra.core (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_34461 (h0 : topological_space (mul_one_class (mul_one_class linarith.comp_source))) : path_connected_space (mul_one_class (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34462 (h1 : group (encodable (has_nnnorm fun_info))) : is_cyclic (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_34463 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : preconnected_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_34464 (h0 : complete_lattice (emetric_space empty)) : is_compactly_generated (emetric_space empty) := sorry --non-trivial
lemma new_lemma_34465 (h0 : not (ring (measurable_space.dynkin_system empty) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_34466 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_pos_part pos))) : archimedean (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_34467 (h0 : functor.add_const (ring (has_neg_part Type)) ennreal) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_34468 (h0 : topological_space (add_cancel_monoid pos)) : discrete_topology (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_34469 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @totally_separated_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34470 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_34471 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add name)) pos) : @unique_factorization_monoid.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_34472 (h0 : topological_space (add_left_cancel_semigroup (option (option (option empty))))) : topological_space.separable_space (add_left_cancel_semigroup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_34473 (h0 : functor.add_const (finset (normed_linear_ordered_group congr_arg_kind)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34474 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_34475 (h0 : complete_lattice (plift (semiring num))) : is_atomistic (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_34476 (h0 : topological_space (has_to_string (option ennreal))) : totally_disconnected_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_34477 (h0 : functor.add_const (monoid (finset ennreal)) ennreal) : @monoid.fg.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_34478 (h0 : group (semiring (semiring (semiring unsigned)))) : normalizer_condition (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_34479 (h1 : set (normed_field string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_34480 (h0 : uniform_space (has_add (option (option unsigned)))) : complete_space (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_34481 (h0 : ring (generalized_boolean_algebra (has_add pos))) : is_domain (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_34482 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @totally_separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34483 (h0 : group (with_bot (has_norm (random_gen (has_norm empty))))) : is_cyclic (with_bot (has_norm (random_gen (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_34484 (h0 : has_norm ereal) (h1 : has_one ereal) : norm_one_class ereal := sorry --non-trivial
lemma new_lemma_34485 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : preirreducible_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34486 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @loc_path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_34487 (h1 : group (add_cancel_comm_monoid string_imp)) : is_cyclic (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_34488 (h1 : not (topological_space (has_compl string_imp) -> false)) : @path_connected_space.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_34489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_34490 (h0 : functor.add_const (semiring (add_comm_monoid name)) name) : @is_noetherian_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_34491 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34492 (h0 : semiring (canonically_ordered_add_monoid empty)) : is_noetherian_ring (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_34493 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_34494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_34495 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34496 (h1 : ring (fintype (random_gen (random_gen char)))) : strong_rank_condition (fintype (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_34497 (h1 : not (ring (random_gen to_additive.value_type) -> false)) : @strong_rank_condition.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_34498 (h0 : complete_lattice (with_one (with_bot (semiring (has_union linarith.comp))))) : is_atomistic (with_one (with_bot (semiring (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_34499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34500 (h0 : add_group (complete_distrib_lattice (has_nndist linarith.comp))) : is_add_cyclic (complete_distrib_lattice (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_34501 (h0 : ring (with_one (random_gen to_additive.value_type))) : strong_rank_condition (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34502 (h0 : complete_lattice (comm_group (finset environment.implicit_infer_kind))) : is_atomistic (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34503 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_34504 (h0 : ring (has_le std_gen)) : strong_rank_condition (has_le std_gen) := sorry --non-trivial
lemma new_lemma_34505 (h0 : uniform_space (sub_neg_monoid linarith.comp)) : complete_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_34506 (h0 : functor.add_const (topological_space (has_zero name)) (boolean_algebra (boolean_algebra (boolean_algebra name)))) : @irreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) (boolean_algebra.{0} (boolean_algebra.{0} (boolean_algebra.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_34507 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_34508 (h0 : functor.add_const (topological_space (has_Sup empty)) unsigned) : @locally_compact_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34509 (h0 : complete_lattice (id (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_34510 (h0 : not (ring (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_34511 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_34512 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34513 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34514 (h0 : complete_lattice (has_neg (add_comm_monoid Type))) : is_compactly_generated (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_34515 (h0 : add_group (complete_distrib_lattice (option empty))) : is_add_cyclic (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_34516 (h0 : functor.add_const (ring (generalized_boolean_algebra name)) (has_nndist (finset pos))) : @is_domain.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} name)) (has_nndist.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34517 (h0 : function.extfun Type topological_space) : @t1_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34518 (h0 : topological_space (has_neg (finset (finset pos)))) : locally_compact_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_34519 (h0 : functor.add_const (topological_space Type) name) : @discrete_topology.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_34520 (h0 : group (has_neg_part ennreal)) : is_cyclic (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_34521 (h0 : topological_space (semigroup (has_Inf Type))) : irreducible_space (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_34522 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34523 (h0 : functor.add_const (topological_space nnreal) empty) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_34524 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_34526 (h0 : finset (measure_theory.measure_space congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_34527 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist linarith.comp)) (has_neg pos)) : @unique_factorization_monoid.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_34528 (h0 : has_le (simple_graph fun_info)) (h1 : bounded_order (simple_graph fun_info)) : is_simple_order (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_34529 (h0 : topological_space (comm_semigroup (has_pos_part pos))) : locally_compact_space (comm_semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_34530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34531 (h0 : topological_space (boolean_algebra (has_neg (has_Inf real)))) : regular_space (boolean_algebra (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_34532 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34533 (h0 : function.extfun nat fin) : @complete_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_34534 (h0 : ring (normed_comm_ring (finset linarith.comp))) : is_domain (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_34535 (h0 : not (topological_space (add_group unsigned) -> false)) : @discrete_topology.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_34536 (h0 : topological_space (has_nndist (option (option (option (option unsigned)))))) : discrete_topology (has_nndist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_34537 (h0 : ring (canonically_linear_ordered_monoid linarith.comp)) : rank_condition (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_34538 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_34539 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_34540 (h0 : ring (add_semigroup (option unsigned))) : strong_rank_condition (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_34541 (h0 : complete_lattice (add_cancel_comm_monoid (metric_space linarith.comp_source))) : is_compactly_generated (add_cancel_comm_monoid (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34542 (h0 : topological_space (has_nndist (option num))) : loc_path_connected_space (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_34543 (h0 : complete_lattice (metric_space linarith.comp)) : is_compactly_generated (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_34544 (h0 : functor.add_const (group (mul_zero_class Type)) unsigned) : @is_cyclic.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (mul_zero_class.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34545 (h0 : list (has_to_string (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34546 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_add (has_Inf (has_Inf linarith.comp))))) : has_exists_mul_of_le (ordered_comm_monoid (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_34547 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @is_cyclic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_34548 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34549 (h1 : filter (div_inv_monoid linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_34550 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_34551 (h0 : topological_space (boolean_algebra.core ennreal)) : preirreducible_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_34552 (h0 : topological_space (has_nndist (finset (finset linarith.comp)))) : t1_space (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_34553 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34555 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34556 (h0 : ring (filter (option empty))) : is_principal_ideal_ring (filter (option empty)) := sorry --non-trivial
lemma new_lemma_34557 (h0 : functor.add_const (group (mul_zero_class pos)) Type) : @is_simple_group.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_34558 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_34559 (h0 : topological_space (has_nnnorm (has_lt linarith.comp_source))) : t0_space (has_nnnorm (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34560 (h0 : topological_space (ring (has_to_string environment.implicit_infer_kind))) : irreducible_space (ring (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34561 (h0 : functor.add_const (group (has_zero Type)) (ring pos)) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_34562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34563 (h0 : not (topological_space (partial_order unsigned) -> false)) : @irreducible_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_34564 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_34565 (h0 : group (boolean_algebra (ring Type))) : group.fg (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_34566 (h0 : monoid (semigroup name)) : monoid.fg (semigroup name) := sorry --non-trivial
lemma new_lemma_34567 (h0 : ring (ordered_comm_ring (generalized_boolean_algebra linarith.comp))) : is_domain (ordered_comm_ring (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_34568 (h1 : measurable_space (nondiscrete_normed_field (normed_field enat))) (h2 : measure_theory.measure (nondiscrete_normed_field (normed_field enat))) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_34569 (h1 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h2 : set (nondiscrete_normed_field string.iterator_imp)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_34570 (h0 : topological_space (ordered_ring unsigned)) : discrete_topology (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_34571 (h0 : complete_lattice (has_nndist pos)) : complete_lattice.is_Sup_finite_compact (has_nndist pos) := sorry --non-trivial
lemma new_lemma_34572 (h0 : function.extfun nat fin) : @normal_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_34573 (h0 : functor.add_const (topological_space (ring Type)) pos) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_34574 (h0 : functor.add_const (topological_space (has_Inf Type)) (boolean_algebra.core (ring Type))) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (boolean_algebra.core.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34575 (h0 : fun_info -> fun_info -> Prop) (h1 : filter fun_info) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_34576 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34577 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34578 (h0 : fin has_zero.zero) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34579 (h0 : topological_space (semigroup (finset unsigned))) : irreducible_space (semigroup (finset unsigned)) := sorry --non-trivial
lemma new_lemma_34580 (h0 : filter (complete_distrib_lattice real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_34581 (h0 : ring (is_R_or_C (option empty))) : rank_condition (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_34582 (h1 : topological_space (with_bot string_imp)) : locally_compact_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_34583 (h0 : topological_space (has_to_string Type)) : totally_separated_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_34584 (h0 : list (with_one (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34585 (h0 : group (with_bot (comm_ring (comm_ring (has_inv to_additive.value_type))))) : is_cyclic (with_bot (comm_ring (comm_ring (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_34586 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : path_connected_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_34587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_34588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_34589 (h0 : topological_space (ordered_comm_monoid (has_add (has_add pos)))) : preirreducible_space (ordered_comm_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_34590 (h0 : list (dlist (comm_ring (comm_ring linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34591 (h0 : uniform_space (boolean_algebra (cancel_monoid (has_add pos)))) : separated_space (boolean_algebra (cancel_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_34592 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34593 (h0 : topological_space (ring environment.implicit_infer_kind)) : path_connected_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_34594 (h1 : topological_space (topological_space (random_gen (random_gen char)))) : totally_disconnected_space (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_34595 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34596 (h0 : complete_lattice (encodable (random_gen to_additive.value_type))) : is_compactly_generated (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34598 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) Type) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_34599 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34600 (h0 : group (pseudo_metric_space (option (option (option (option ennreal)))))) : is_cyclic (pseudo_metric_space (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_34601 (h0 : topological_space (nondiscrete_normed_field std_gen)) : path_connected_space (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_34602 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) (semiring num)) : @normal_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_34603 (h0 : ordered_comm_monoid linarith.comp) : has_exists_mul_of_le linarith.comp := sorry --non-trivial
lemma new_lemma_34604 (h0 : list (has_zero (has_nndist (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34605 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_34606 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_34607 (h0 : add_group (add_comm_monoid (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)))) : is_add_cyclic (add_comm_monoid (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_34608 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34609 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_34610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_34611 (h0 : complete_lattice (has_top (random_gen (random_gen (random_gen string_imp))))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_34612 (h3 : set (add_comm_semigroup std_gen -> fun_info)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_34613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_34614 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @is_cyclic.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_34615 (h1 : has_lt (has_ssubset (mul_one_class linarith.comp_source))) : no_max_order (has_ssubset (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34616 (h0 : ring (random_gen (has_nnnorm bool))) : strong_rank_condition (random_gen (has_nnnorm bool)) := sorry --non-trivial
lemma new_lemma_34617 (h0 : semiring (normed_comm_ring (comm_group Type))) : is_noetherian_ring (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_34618 (h0 : list (left_cancel_monoid (ordered_ring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34619 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_34620 (h0 : functor.add_const (ordered_comm_monoid (linear_ordered_field unsigned)) pos) : @has_exists_mul_of_le.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (linear_ordered_field.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_34621 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_34622 (h0 : list (has_inner unsigned (option (option (option (option (option unsigned))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34623 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : t1_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_34624 (h1 : measurable_space (distrib linarith.ineq)) (h2 : filter (distrib linarith.ineq)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_34625 (h0 : group (add_cancel_monoid (has_to_string linarith.comp))) : is_simple_group (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_34626 (h0 : set (mul_one_class string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_34627 (h0 : function.extfun Type topological_space) : @t1_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34628 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_34629 (h0 : not (add_group (simple_graph char) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_34630 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) congr_arg_kind) : @preirreducible_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34631 (h0 : functor.comp uniform_space has_neg name) : @complete_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_34632 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_34633 (h0 : function.extfun nat fin) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_34634 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) unsigned) : @normal_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34635 (h0 : finset (boolean_algebra.core (ordered_ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_34636 (h0 : add_group (with_bot (dlist to_additive.value_type))) : is_add_cyclic (with_bot (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34637 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_34638 (h1 : ring (comm_ring fun_info)) : strong_rank_condition (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_34639 (h0 : functor.add_const (ring (has_nndist unsigned)) pos) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_34640 (h0 : uniform_space (boolean_algebra (boolean_algebra (finset pos)))) : separated_space (boolean_algebra (boolean_algebra (finset pos))) := sorry --non-trivial
lemma new_lemma_34641 (h0 : ordered_comm_monoid (has_add (has_nndist name))) : has_exists_mul_of_le (has_add (has_nndist name)) := sorry --non-trivial
lemma new_lemma_34642 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string (has_to_string unsigned)))) : irreducible_space (canonically_ordered_comm_semiring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_34643 (h1 : group (with_bot (with_one (with_one (has_top (with_one (with_one congr_arg_kind))))))) : is_cyclic (with_bot (with_one (with_one (has_top (with_one (with_one congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_34644 (h0 : add_monoid (finset (has_to_string (has_to_string Type)))) : add_monoid.fg (finset (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_34645 (h0 : uniform_space (normed_lattice_add_comm_group (has_add pos))) : complete_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_34646 (h0 : add_monoid (has_bot (boolean_algebra (boolean_algebra (has_Inf Type))))) : add_monoid.fg (has_bot (boolean_algebra (boolean_algebra (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_34647 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_34648 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @normal_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34649 (h0 : not (topological_space (has_div linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_34650 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) Type) : @separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_34651 (h0 : functor.add_const (group (left_cancel_semigroup empty)) empty) : @normalizer_condition.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_34652 (h0 : not (complete_lattice (comm_ring reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_34653 (h0 : nat -> Prop) (h1 : not (nat -> false)) : @disjointed.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra) h0 (@classical.by_contradiction'.{1} nat h1)  := sorry --non-trivial
lemma new_lemma_34654 (h0 : topological_space (semigroup (has_add (ring Type)))) : preirreducible_space (semigroup (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_34655 (h0 : functor.add_const (topological_space (has_to_string name)) unsigned) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34656 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34657 (h0 : ring (has_Sup (semiring empty))) : is_domain (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_34658 (h0 : ring (pseudo_metric_space (option (option ennreal)))) : is_principal_ideal_ring (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_34659 (h0 : functor.add_const (topological_space (add_right_cancel_monoid congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_34662 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} (option.{0} (option.{0} num))))  := sorry --non-trivial
lemma new_lemma_34663 (h0 : functor.add_const (topological_space (has_neg Type)) (has_neg (has_neg linarith.comp))) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34664 (h0 : topological_space (has_nnnorm (has_ssubset (has_ssubset (has_inv linarith.ineq))))) : locally_compact_space (has_nnnorm (has_ssubset (has_ssubset (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_34665 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) name) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_34666 (h5 : set (nondiscrete_normed_field char)) : set.finite h5 := sorry --non-trivial
lemma new_lemma_34667 (h1 : has_lt (has_ssubset (mul_one_class to_additive.value_type))) : no_max_order (has_ssubset (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34668 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : totally_separated_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_34669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34670 (h1 : topological_space (normed_group string_imp)) : t0_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_34671 (h0 : fin has_zero.zero) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_34672 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_34673 (h0 : ring (finset (has_pos_part (has_Inf linarith.comp)))) : is_principal_ideal_ring (finset (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_34674 (h0 : topological_space (has_zero (has_to_string name))) : totally_disconnected_space (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_34675 (h2 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34676 (h0 : monoid (metric_space empty)) : monoid.fg (metric_space empty) := sorry --non-trivial
lemma new_lemma_34677 (h0 : topological_space (has_norm (has_norm (semiring empty)))) : totally_disconnected_space (has_norm (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_34678 (h0 : not (complete_lattice (has_union linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34679 (h0 : fin has_zero.zero) : @path_connected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_34680 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34681 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg linarith.comp)) : @totally_separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_34682 (h0 : monoid (has_Inf (has_add Type))) : monoid.fg (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_34683 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_34684 (h0 : ring (has_to_string (ring linarith.comp))) : rank_condition (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_34685 (h0 : topological_space (normed_comm_ring (has_add (finset (has_add (has_add pos)))))) : locally_compact_space (normed_comm_ring (has_add (finset (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_34686 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34687 (h0 : filter (has_add (has_neg (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34688 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_34689 (h0 : topological_space (has_top (random_gen (has_inv (random_gen string_imp))))) : path_connected_space (has_top (random_gen (has_inv (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_34690 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_34691 (h0 : topological_space (has_Sup (option unsigned))) : loc_path_connected_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_34692 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_34693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_34694 (h0 : functor.add_const Prop (has_norm (has_norm (has_norm empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_34695 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_34696 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : complete_space (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34697 (h0 : functor.add_const (group (comm_group pos)) Type) : @group.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_34698 (h0 : functor.add_const (topological_space pos) Type) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_34699 (h0 : ring (has_zero (comm_group unsigned))) : strong_rank_condition (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_34700 (h0 : monoid (measurable_space (with_bot (has_norm (random_gen linarith.ineq))))) : monoid.fg (measurable_space (with_bot (has_norm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_34701 (h1 : group (id (random_gen string_imp))) : is_cyclic (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_34702 (h0 : set (monoid (linear_ordered_comm_group_with_zero linarith.comp_source))) (h1 : monoid (linear_ordered_comm_group_with_zero linarith.comp_source)) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_34703 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_34704 (h1 : char -> char -> Prop) : is_total_preorder char h1 := sorry --non-trivial
lemma new_lemma_34705 (h0 : uniform_space (has_pos_part (has_Inf (has_Inf (finset pos))))) : separated_space (has_pos_part (has_Inf (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_34706 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_34707 (h0 : has_coe (mul_one_class fun_info) Prop) (h1 : mul_one_class fun_info) : @coe_b.{1 1} (mul_one_class.{0} fun_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_34708 (h0 : functor.add_const (topological_space (has_Inf name)) (has_neg (has_neg (has_neg Type)))) : @irreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_34709 (h0 : topological_space (canonically_linear_ordered_monoid congr_arg_kind)) : loc_path_connected_space (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34711 (h0 : functor.comp complete_lattice linear_ordered_comm_group ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} linear_ordered_comm_group.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_34712 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_34713 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : sequential_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_34714 (h0 : add_monoid (has_union congr_arg_kind)) : add_monoid.fg (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34715 (h0 : group (has_inv linarith.comp_source)) : is_cyclic (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34716 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34717 (h1 : not (ring (uniform_space linarith.comp_source) -> false)) : @is_domain.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_34718 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add (has_Inf (has_Inf linarith.comp))))) : has_exists_mul_of_le (ordered_comm_ring (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_34719 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_34720 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_34721 (h0 : group (linear_ordered_field (linear_ordered_comm_group ennreal))) : group.fg (linear_ordered_field (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_34722 (h0 : list (dlist (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34723 (h0 : complete_lattice (normed_field (mul_one_class (mul_one_class char)))) : is_compactly_generated (normed_field (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_34724 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) empty) : @strong_rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_34725 (h0 : topological_space (semigroup (ring Type))) : t1_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_34726 (h0 : not (topological_space (has_append char) -> false)) : @path_connected_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_34727 (h1 : not (complete_lattice (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_34728 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : locally_compact_space (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_34729 (h0 : group (semigroup (finset name))) : normalizer_condition (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_34730 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_34731 (h0 : pfun (mul_one_class ereal) Prop) (h1 : Type) (h2 : h1) (h3 : h1 -> id (has_coe_to_sort.coe (pfun.dom h0))) : pfun.as_subtype h0 (id_bind h2 h3) := sorry --non-trivial
lemma new_lemma_34732 (h0 : functor.add_const (finset (semigroup pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34733 (h0 : uniform_space (random_gen (random_gen string_imp))) : complete_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_34734 (h1 : set (set string_imp)) : is_countably_spanning h1 := sorry --non-trivial
lemma new_lemma_34735 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_34736 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_34737 (h0 : semiring (canonically_ordered_monoid (has_add pos))) : is_noetherian_ring (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_34738 (h0 : functor.comp (prod (finset Type)) finset Type) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_34739 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @normalizer_condition.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_34740 (h0 : uniform_space (normed_group (with_bot (random_gen (random_gen (random_gen string_imp)))))) : complete_space (normed_group (with_bot (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_34741 (h0 : functor.add_const (group (partial_order congr_arg_kind)) congr_arg_kind) : @is_cyclic.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34742 (h0 : semiring (mul_zero_class (semiring num))) : is_noetherian_ring (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_34743 (h0 : filter (has_Inf (has_neg Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_34744 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_34745 (h0 : ring (has_inter (option ennreal))) : rank_condition (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_34746 (h0 : functor.add_const (add_monoid (has_nndist unsigned)) (has_neg environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} unsigned)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_34747 (h1 : topological_space (semi_normed_ring (mul_one_class (id to_additive.value_type)))) : t0_space (semi_normed_ring (mul_one_class (id to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_34748 (h0 : has_mem.mem (comm_ring linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (comm_ring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (comm_ring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_34749 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system num)) empty) : @complete_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_34750 (h0 : functor.add_const (topological_space (ring name)) Type) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_34751 (h1 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_34752 (h0 : ring (ordered_ring (semiring (semiring empty)))) : is_domain (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_34753 (h0 : functor.add_const (list (generalized_boolean_algebra pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34754 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : topological_space.separable_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34755 (h0 : fin has_zero.zero) : @group.fg.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_34756 (h0 : topological_space (normed_comm_ring (comm_group (has_add Type)))) : totally_disconnected_space (normed_comm_ring (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_34757 (h0 : function.extfun Type (functor.add_const (ring pos))) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_34758 (h0 : semiring (has_add linarith.comp)) : is_noetherian_ring (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_34759 (h0 : complete_lattice (has_add (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : complete_lattice.is_Sup_finite_compact (has_add (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_34760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34761 (h0 : add_group (has_div (mul_one_class fun_info))) : is_add_cyclic (has_div (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_34762 (h0 : with_bot (ulower pnat)) (h1 : ne h0 has_bot.bot) (h2 : pnat) : pnat.coprime (ulower.up (with_bot.unbot h0 h1)) h2 := sorry --non-trivial
lemma new_lemma_34763 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_34764 (h0 : functor.add_const (ring (add_comm_monoid empty)) ennreal) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_34765 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_34766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_34767 (h2 : Prop) (h3 : set ereal) : measurable_space.dynkin_system.generate_has (id (fun (h1 : set ereal), h2)) h3 := sorry --non-trivial
lemma new_lemma_34768 (h0 : ordered_comm_monoid (has_add (has_neg_part (has_neg_part environment.implicit_infer_kind)))) : has_exists_mul_of_le (has_add (has_neg_part (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_34769 (h0 : topological_space (has_zero (has_neg_part name))) : preconnected_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_34770 (h0 : topological_space (pseudo_metric_space name)) : sequential_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_34771 (h1 : ring (uniform_space (metric_space (metric_space char)))) : is_domain (uniform_space (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_34772 (h0 : topological_space (has_zero (option unsigned))) : irreducible_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_34773 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) num) : @loc_path_connected_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_34774 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_34775 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_34776 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @loc_path_connected_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_34777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34778 (h0 : functor.add_const (topological_space (comm_group Type)) (boolean_algebra pos)) : @sequential_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_34779 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) (finset (finset Type))) : @group.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34780 (h0 : topological_space (has_to_string (has_pos_part pos))) : irreducible_space (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_34781 (h0 : complete_lattice (simple_graph (mul_one_class fun_info))) : is_compactly_generated (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_34782 (h0 : add_monoid (boolean_algebra (has_add (has_add (has_add pos))))) : add_monoid.fg (boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_34783 (h0 : topological_space (has_nndist (has_nndist linarith.comp))) : totally_disconnected_space (has_nndist (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_34784 (h0 : not (complete_lattice (uniform_space to_additive.value_type) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_34785 (h0 : function.extfun Type (functor.add_const (uniform_space (free_add_monoid num)))) : @separated_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (free_add_monoid.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_34786 (h0 : functor.add_const (ring (add_comm_monoid pos)) environment.implicit_infer_kind) : @is_domain.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34787 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @regular_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34788 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_34789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_34790 (h0 : functor.add_const (monoid (has_dist num)) unsigned) : @monoid.fg.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (has_dist.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34791 (h2 : uniform_space congr_arg_kind) : complete_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_34792 (h0 : group (measurable_space linarith.comp_source)) : normalizer_condition (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34793 (h0 : not (group (complete_linear_order empty) -> false)) : @group.fg.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_34794 (h0 : topological_space (semigroup (has_add linarith.comp))) : totally_separated_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_34795 (h1 : function.extfun Type topological_space) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_34796 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_34797 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf pos)) : @discrete_topology.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} pos) h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_34798 (h0 : topological_space (has_neg (mul_zero_class name))) : sequential_space (has_neg (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_34799 (h0 : topological_space (semigroup num)) : discrete_topology (semigroup num) := sorry --non-trivial
lemma new_lemma_34800 (h0 : functor.add_const (topological_space (has_neg_part Type)) linarith.comp) : @totally_disconnected_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34801 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_34802 (h0 : functor.add_const (list (has_zero name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34803 (h0 : semiring (ordered_comm_ring (has_pos_part (has_add (has_pos_part Type))))) : is_noetherian_ring (ordered_comm_ring (has_pos_part (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_34804 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_34805 (h0 : uniform_space (topological_space (has_ssubset (has_ssubset (random_gen (random_gen char)))))) : complete_space (topological_space (has_ssubset (has_ssubset (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_34806 (h0 : complete_lattice (has_le (has_div (mul_one_class (mul_one_class (mul_one_class fun_info)))))) : is_compactly_generated (has_le (has_div (mul_one_class (mul_one_class (mul_one_class fun_info))))) := sorry --non-trivial
lemma new_lemma_34807 (h0 : function.extfun Type (functor.add_const (ring (ordered_ring congr_arg_kind)))) : @rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_34808 (h0 : functor.add_const (ordered_add_comm_monoid (ring ennreal)) congr_arg_kind) : @archimedean.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} ennreal)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_34809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_34810 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) pos) : @rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_34811 (h0 : complete_lattice (has_bot (sub_neg_monoid pos))) : is_atomistic (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_34812 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_34813 (h0 : fin has_zero.zero) : @group.fg.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34814 (h2 : ring (has_compl char)) : rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_34815 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset pos)) name) : @unique_factorization_monoid.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_34816 (h0 : topological_space (canonically_ordered_comm_semiring (has_add unsigned))) : preirreducible_space (canonically_ordered_comm_semiring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_34817 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) Type) : @normal_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_34818 (h0 : ring (add_group empty)) : is_domain (add_group empty) := sorry --non-trivial
lemma new_lemma_34819 (h0 : functor.add_const (topological_space (canonically_ordered_monoid name)) linarith.comp) : @t0_space.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34820 (h0 : group (has_nndist ennreal)) : is_cyclic (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_34821 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_34822 (h0 : ring (ordered_comm_ring (boolean_algebra.core linarith.comp))) : is_principal_ideal_ring (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_34823 (h0 : complete_lattice (has_one (semiring (has_norm (has_top congr_arg_kind))))) : is_atomistic (has_one (semiring (has_norm (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_34824 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (has_bot name)))) : discrete_topology (complete_distrib_lattice (sub_neg_monoid (has_bot name))) := sorry --non-trivial
lemma new_lemma_34825 (h0 : topological_space (has_compl (has_nnnorm reducibility_hints))) : path_connected_space (has_compl (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_34826 (h0 : group (id (with_bot to_additive.value_type))) : is_cyclic (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34827 (h1 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) num)  := sorry --non-trivial
lemma new_lemma_34828 (h2 : ring string.iterator_imp) : strong_rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_34829 (h0 : topological_space (ring (option pos))) : locally_compact_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_34830 (h0 : group (comm_ring (has_ssubset (has_top fun_info)))) : is_cyclic (comm_ring (has_ssubset (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_34831 (h0 : topological_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_34832 (h0 : not (topological_space num -> false)) : @locally_compact_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_34833 (h0 : ring (has_nnnorm (mul_one_class linarith.ineq))) : rank_condition (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34834 (h0 : topological_space (random_gen (has_top unsigned))) : locally_compact_space (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_34835 (h1 : has_mem.mem (random_gen (has_norm fun_info)) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} (has_norm.{0} fun_info)) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} (has_norm.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_34836 (h0 : functor.add_const (list (boolean_algebra Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34837 (h0 : fin has_zero.zero) : unique_factorization_monoid real := sorry --non-trivial
lemma new_lemma_34838 (h0 : add_group (finset (has_Inf (has_nndist name)))) : is_add_cyclic (finset (has_Inf (has_nndist name))) := sorry --non-trivial
lemma new_lemma_34839 (h0 : add_monoid (canonically_ordered_monoid linarith.comp)) : add_monoid.fg (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_34840 (h0 : list (has_neg (has_pos_part (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34841 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (simple_graph pos)))) : @discrete_topology.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (simple_graph.{0} pos))) h0 Type))  := sorry --non-trivial
lemma new_lemma_34842 (h0 : uniform_space (ordered_ring empty)) : separated_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_34843 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_disconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_34844 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero (option (option ennreal)))) : unique_factorization_monoid (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_34845 (h0 : functor.add_const (functor.add_const (topological_space environment.implicit_infer_kind) name) name) : @path_connected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind) name) name h0))  := sorry --non-trivial
lemma new_lemma_34846 (h0 : functor.add_const (monoid (has_zero pos)) (comm_group (has_add environment.implicit_infer_kind))) : @monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} pos)) (comm_group.{0} (has_add.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_34847 (h0 : monoid (cancel_monoid unsigned)) : monoid.fg (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_34848 (h0 : filter (boolean_algebra (has_nndist (comm_group (has_add (comm_group (boolean_algebra.core name))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34849 (h0 : not (complete_lattice (has_star congr_arg_kind) -> false)) : @is_compactly_generated.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_34850 (h0 : set (uniform_space (has_nnnorm fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_34851 (h1 : uniform_space (random_gen congr_arg_kind)) : complete_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34852 (h0 : functor.comp group cancel_monoid name) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_34853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_34854 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_34855 (h0 : functor.add_const (group (boolean_algebra Type)) (ring (has_neg pos))) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) (ring.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_34856 (h0 : functor.add_const (list (free_add_monoid empty)) (semiring (semiring empty))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34857 (h0 : list (comm_ring linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34858 (h0 : complete_lattice (cancel_monoid (add_comm_monoid Type))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_34859 (h0 : topological_space (id linarith.comp)) : normal_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_34860 (h0 : functor.add_const (topological_space (has_edist empty)) unsigned) : @totally_separated_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_34861 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_34862 (h0 : add_group (finset (has_add (finset (boolean_algebra.core (has_add name)))))) : is_add_cyclic (finset (has_add (finset (boolean_algebra.core (has_add name))))) := sorry --non-trivial
lemma new_lemma_34863 (h2 : topological_space std_gen) (h3 : has_sup std_gen) : has_continuous_sup std_gen := sorry --non-trivial
lemma new_lemma_34864 (h0 : topological_space (normed_comm_ring (finset (finset (finset (finset linarith.comp)))))) : loc_path_connected_space (normed_comm_ring (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_34865 (h0 : uniform_space (has_div linarith.comp_source)) : complete_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34866 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_34867 (h0 : complete_lattice (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : is_compactly_generated (has_div (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_34868 (h0 : ring (option (has_top empty))) : is_principal_ideal_ring (option (has_top empty)) := sorry --non-trivial
lemma new_lemma_34869 (h1 : ring (has_add linarith.ineq)) : is_domain (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_34870 (h0 : topological_space (has_union (semiring empty))) : preirreducible_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_34871 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_34872 (h0 : group (has_emptyc (has_inv linarith.comp_source))) : normalizer_condition (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34873 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @t1_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_34874 (h0 : ring (cancel_monoid ennreal)) : is_domain (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_34875 (h0 : topological_space (has_top (random_gen (has_ssubset linarith.ineq)))) : t0_space (has_top (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_34876 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : path_connected_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_34877 (h0 : not (ring (partial_order unsigned) -> false)) : @strong_rank_condition.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_34878 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : strong_rank_condition (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_34879 (h0 : ring (has_norm (semiring (linear_ordered_semiring linarith.comp)))) : rank_condition (has_norm (semiring (linear_ordered_semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_34880 (h0 : group (boolean_algebra (has_pos_part Type))) : normalizer_condition (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_34881 (h0 : topological_space (cancel_monoid (has_add (has_add unsigned)))) : irreducible_space (cancel_monoid (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_34882 (h0 : topological_space (boolean_algebra (has_pos_part Type))) : regular_space (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_34883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_34884 (h0 : add_group (boolean_algebra.core (has_add (has_add (boolean_algebra.core (has_add Type)))))) : is_add_cyclic (boolean_algebra.core (has_add (has_add (boolean_algebra.core (has_add Type))))) := sorry --non-trivial
lemma new_lemma_34885 (h0 : functor.add_const (topological_space (has_add name)) pos) : @path_connected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_34886 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_34887 (h0 : ring (linear_ordered_semiring (random_gen (random_gen (has_inv to_additive.value_type))))) : is_domain (linear_ordered_semiring (random_gen (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_34888 (h0 : uniform_space (has_one (has_top (has_top (has_top linarith.comp))))) : separated_space (has_one (has_top (has_top (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_34889 (h0 : functor.add_const (finset (normed_comm_ring name)) (has_add (semigroup Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34890 (h0 : complete_lattice (comm_group pos)) : is_compactly_generated (comm_group pos) := sorry --non-trivial
lemma new_lemma_34891 (h0 : functor.add_const (function.extfun Type group) name) : @is_simple_group.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_34892 (h0 : fin has_zero.zero) : @monoid.fg.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_34893 (h0 : add_group (canonically_ordered_monoid (finset pos))) : is_add_cyclic (canonically_ordered_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_34894 (h0 : topological_space (finset pos)) : totally_separated_space (finset pos) := sorry --non-trivial
lemma new_lemma_34895 (h0 : uniform_space (semigroup (has_add (has_neg linarith.comp)))) : separated_space (semigroup (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_34896 (h0 : functor.add_const (list (semigroup congr_arg_kind)) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34897 (h0 : ring (complete_semilattice_Sup (random_gen (has_inv (with_one (has_inv fun_info)))))) : rank_condition (complete_semilattice_Sup (random_gen (has_inv (with_one (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_34898 (h0 : functor.add_const (list (linear_ordered_cancel_comm_monoid empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34899 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_34900 (h0 : has_lt (nondiscrete_normed_field linarith.ineq)) : no_max_order (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_34901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_34902 (h0 : topological_space (has_neg (has_neg_part (has_to_string unsigned)))) : preconnected_space (has_neg (has_neg_part (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_34903 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @path_connected_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_34904 (h0 : topological_space (has_one (has_top (has_norm unsigned)))) : normal_space (has_one (has_top (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_34905 (h0 : functor.add_const (complete_lattice (ordered_ring empty)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_34906 (h0 : complete_lattice (mul_zero_class (has_neg_part ennreal))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_34907 (h0 : complete_lattice (with_zero (random_gen char))) : complete_lattice.is_Sup_finite_compact (with_zero (random_gen char)) := sorry --non-trivial
lemma new_lemma_34908 (h0 : topological_space (has_ssubset (has_ssubset (normed_field reducibility_hints)))) : t0_space (has_ssubset (has_ssubset (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_34909 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (has_add Type)) : @preconnected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_34910 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_34911 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_34912 (h0 : topological_space (cancel_monoid Type)) : preconnected_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_34913 (h0 : group (with_one (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (with_one (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_34914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_34915 (h0 : functor.add_const (monoid (has_pos_part Type)) pos) : @monoid.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_34916 (h2 : topological_space string_imp) : totally_disconnected_space string_imp := sorry --non-trivial
lemma new_lemma_34917 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34918 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_34919 (h0 : has_add (option ennreal) -> has_add (option ennreal) -> Prop) : is_symm (has_add (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_34920 (h0 : functor.add_const (list (has_to_string unsigned)) (has_neg name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34921 (h0 : not (topological_space (bin_tree num) -> false)) : @topological_space.separable_space.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_34922 (h0 : list (has_top (has_ssubset (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_34923 (h0 : list (non_assoc_semiring (comm_monoid (comm_monoid (comm_monoid unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_34924 (h0 : topological_space (boolean_algebra (has_add (add_comm_monoid name)))) : t1_space (boolean_algebra (has_add (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_34925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_34926 (h0 : not (ring (distrib linarith.comp_source) -> false)) : @strong_rank_condition.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_34927 (h0 : uniform_space (has_top (has_norm fun_info))) : complete_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_34928 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) linarith.comp) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34929 (h0 : not (ring (dlist (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))))) -> false)) : @is_domain.{0} (dlist.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char))))))) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)))))))) h0)  := sorry --non-trivial
lemma new_lemma_34930 (h0 : group (is_R_or_C (semiring (semiring empty)))) : group.fg (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_34931 (h0 : functor.add_const (monoid (ordered_comm_ring Type)) real) : @monoid.fg.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (ordered_comm_ring.{1} Type)) real h0)  := sorry --non-trivial
lemma new_lemma_34932 (h0 : uniform_space (metric_space (semiring linarith.comp))) : complete_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_34933 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_34934 (h0 : topological_space (lattice congr_arg_kind)) : preirreducible_space (lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34935 (h0 : topological_space (has_neg_part Type)) : totally_separated_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_34936 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_34937 (h0 : list (add_monoid (add_right_cancel_monoid (semiring unsigned)))) (h1 : ne h0 list.nil) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} (semiring.{0} unsigned)) (@list.last.{0} (add_monoid.{0} (add_right_cancel_monoid.{0} (semiring.{0} unsigned))) h0 h1)  := sorry --non-trivial
lemma new_lemma_34938 (h0 : topological_space (normed_comm_ring num)) : loc_path_connected_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_34939 (h0 : functor.add_const (function.extfun Type add_monoid) (finset pos)) : @add_monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (finset.{0} pos) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_34940 (h0 : filter (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_34941 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34942 (h0 : not (filter (topological_space char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_34943 (h0 : not (topological_space (id num) -> false)) : @preirreducible_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_34944 (h0 : topological_space (normed_group (semiring (semiring (semiring congr_arg_kind))))) : totally_separated_space (normed_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_34945 (h0 : complete_lattice (linear_ordered_comm_ring (semiring num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_34946 (h0 : topological_space (complete_distrib_lattice (semigroup Type))) : preirreducible_space (complete_distrib_lattice (semigroup Type)) := sorry --non-trivial
lemma new_lemma_34947 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34948 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @path_connected_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_34949 (h0 : group (has_neg_part pos)) : is_cyclic (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_34950 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_34951 (h0 : ring (has_zero (finset name))) : rank_condition (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_34952 (h0 : uniform_space (normed_linear_ordered_group (option (option empty)))) : separated_space (normed_linear_ordered_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_34953 (h0 : functor.add_const (add_group (add_semigroup empty)) empty) : @is_add_cyclic.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_34954 (h0 : complete_lattice (has_zero (add_cancel_monoid (add_cancel_monoid (boolean_algebra name))))) : is_compactly_generated (has_zero (add_cancel_monoid (add_cancel_monoid (boolean_algebra name)))) := sorry --non-trivial
lemma new_lemma_34955 (h0 : ring (simple_graph Type)) : is_domain (simple_graph Type) := sorry --non-trivial
lemma new_lemma_34956 (h0 : prod (add_comm_semigroup char) (add_comm_semigroup char)) : set.diagonal (add_comm_semigroup char) h0 := sorry --non-trivial
lemma new_lemma_34957 (h0 : topological_space (simple_graph (has_Inf pos))) : preirreducible_space (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_34958 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_34959 (h1 : complete_lattice (random_gen linarith.comp_source)) : is_compactly_generated (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34960 (h0 : measurable_space enat) (h1 : filter enat) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_34961 (h0 : functor.add_const (topological_space (has_nndist (comm_group pos))) Type) : @regular_space.{0} (has_nndist.{0} (comm_group.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} (comm_group.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_34962 (h0 : topological_space (has_inv (encodable (has_norm string_imp)))) : t0_space (has_inv (encodable (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_34963 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add (boolean_algebra.core (boolean_algebra.core pos))))) : has_exists_mul_of_le (ordered_comm_ring (has_add (boolean_algebra.core (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_34964 (h0 : topological_space (add_comm_monoid ennreal)) : loc_path_connected_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_34965 (h0 : complete_lattice (with_one congr_arg_kind)) : is_compactly_generated (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_34966 (h0 : cancel_comm_monoid_with_zero (option unsigned)) : unique_factorization_monoid (option unsigned) := sorry --non-trivial
lemma new_lemma_34967 (h0 : functor.add_const (filter (has_neg_part environment.implicit_infer_kind)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34968 (h0 : topological_space (random_gen (has_top to_additive.value_type))) : t0_space (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_34969 (h0 : ordered_add_comm_monoid (normed_comm_ring pos)) : archimedean (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_34970 (h0 : ring (normed_comm_ring Type)) : rank_condition (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_34971 (h0 : functor.add_const (semiring (has_add pos)) (has_neg (has_neg linarith.comp))) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} pos)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_34972 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option (option (option (option (option empty))))))) : archimedean (pseudo_metric_space (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_34973 (h0 : group (pseudo_metric_space (option (option (option unsigned))))) : is_cyclic (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_34974 (h0 : topological_space (measurable_space linarith.comp_source)) : t0_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_34975 (h1 : topological_space (linear_ordered_add_comm_group (random_gen char))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_34976 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @regular_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_34977 (h0 : add_group (semigroup (option (option pos)))) : is_add_cyclic (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_34978 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_34979 (h0 : complete_lattice (has_nnnorm (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34980 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_34981 (h0 : add_monoid (normed_comm_ring empty)) : add_monoid.fg (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_34982 (h1 : ring (dlist char)) : rank_condition (dlist char) := sorry --non-trivial
lemma new_lemma_34983 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) (has_add name)) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_34984 (h1 : complete_lattice (add_monoid (add_monoid char))) : complete_lattice.is_Sup_finite_compact (add_monoid (add_monoid char)) := sorry --non-trivial
lemma new_lemma_34985 (h0 : topological_space (has_to_string (finset (finset (finset (finset (finset pos))))))) : loc_path_connected_space (has_to_string (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_34986 (h0 : ring (distrib environment.projection_info)) : rank_condition (distrib environment.projection_info) := sorry --non-trivial
lemma new_lemma_34987 (h0 : topological_space (with_bot (has_norm empty))) : preirreducible_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_34988 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_add name)) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_add.{0} name) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_34989 (h0 : finset (linear_order (option (option (option (option (option (option (option (option (option unsigned))))))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_34990 (h0 : group (has_union (has_norm (has_norm (semiring congr_arg_kind))))) : group.fg (has_union (has_norm (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_34991 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : sequential_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_34992 (h0 : functor.add_const (filter (pseudo_metric_space pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_34993 (h0 : ring (normed_field (uniform_space linarith.comp_source))) : is_domain (normed_field (uniform_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_34994 (h0 : add_group (complete_semilattice_Sup (normed_group linarith.ineq))) : is_add_cyclic (complete_semilattice_Sup (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_34995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_34996 (h0 : ring (canonically_linear_ordered_monoid unsigned)) : strong_rank_condition (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_34997 (h0 : add_group (linear_ordered_add_comm_group (has_nnnorm fun_info))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_34998 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_34999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35000 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35001 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35002 (h0 : topological_space (linear_ordered_field (has_add (has_add (boolean_algebra.core (has_add name)))))) : normal_space (linear_ordered_field (has_add (has_add (boolean_algebra.core (has_add name))))) := sorry --non-trivial
lemma new_lemma_35003 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_35004 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_neg_part unsigned))) : is_atomistic (canonically_ordered_comm_semiring (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_35005 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @path_connected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_35006 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_35007 (h0 : functor.comp topological_space semigroup Type) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_35008 (h0 : topological_space (boolean_algebra (has_to_string unsigned))) : loc_path_connected_space (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_35009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_35010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_35011 (h0 : set (simple_graph (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35012 (h0 : topological_space (add_comm_semigroup fun_info)) : path_connected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_35013 (h0 : ordered_comm_monoid (complete_distrib_lattice (boolean_algebra linarith.comp))) : has_exists_mul_of_le (complete_distrib_lattice (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_35014 (h0 : group (has_add (boolean_algebra Type))) : normalizer_condition (has_add (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_35015 (h0 : monoid (has_union (measurable_space.dynkin_system congr_arg_kind))) : monoid.fg (has_union (measurable_space.dynkin_system congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35016 (h0 : topological_space (has_ssubset (random_gen (random_gen linarith.comp_source)))) : path_connected_space (has_ssubset (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_35017 (h0 : semiring (linear_ordered_comm_ring empty)) : is_noetherian_ring (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_35018 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35019 (h0 : functor.add_const (finset (ring linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35020 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_35021 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @discrete_topology.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_35022 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string environment.implicit_infer_kind)) pos) : @archimedean.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_35023 (h0 : topological_space (has_emptyc (has_top (has_norm linarith.comp_source)))) : t0_space (has_emptyc (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_35024 (h0 : topological_space (comm_group (has_to_string environment.implicit_infer_kind))) : preirreducible_space (comm_group (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35025 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35026 (h0 : group (boolean_algebra (has_pos_part pos))) : is_cyclic (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_35027 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_35028 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (finset Type)) : @archimedean.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (finset.{1} Type) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_35029 (h0 : functor.add_const (monoid (has_neg name)) pos) : @monoid.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_35030 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg (ring Type))) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35031 (h0 : ring (simple_graph (has_add linarith.comp))) : is_domain (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_35032 (h0 : functor.comp topological_space has_nndist environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) unsigned (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_35033 (h1 : has_mem.mem fun_info has_emptyc.emptyc) : @is_atomistic.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_35034 (h0 : uniform_space (distrib (has_ssubset to_additive.value_type))) : complete_space (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35035 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_35036 (h0 : topological_space (has_dist (option (option ennreal)))) : totally_disconnected_space (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_35037 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35038 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_35039 (h0 : topological_space (has_norm (semiring (semiring (semiring (semiring empty)))))) : discrete_topology (has_norm (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_35040 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@id.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35041 (h0 : uniform_space (id (linear_ordered_semiring congr_arg_kind))) : separated_space (id (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35042 (h0 : add_group (comm_monoid (option unsigned))) : is_add_cyclic (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_35043 (h0 : filter (encodable linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35044 (h0 : uniform_space (ordered_comm_ring (ring (boolean_algebra.core (finset pos))))) : complete_space (ordered_comm_ring (ring (boolean_algebra.core (finset pos)))) := sorry --non-trivial
lemma new_lemma_35045 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring (semiring unsigned)))) : rank_condition (linear_ordered_cancel_comm_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_35046 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35047 (h0 : topological_space (linear_ordered_field (finset (cancel_monoid ennreal)))) : loc_path_connected_space (linear_ordered_field (finset (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_35048 (h0 : functor.add_const (group (finset name)) (has_add pos)) : @is_simple_group.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_35049 (h0 : group (normed_comm_ring congr_arg_kind)) : normalizer_condition (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35050 (h0 : ring (comm_ring (has_ssubset string_imp))) : rank_condition (comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_35051 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @locally_compact_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_35052 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra)) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_35053 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_atomistic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_35054 (h1 : topological_space (add_comm_semigroup (mul_one_class (add_comm_semigroup (mul_one_class ereal))))) : t0_space (add_comm_semigroup (mul_one_class (add_comm_semigroup (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_35055 (h0 : topological_space (omega_complete_partial_order num)) : locally_compact_space (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_35056 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35057 (h0 : uniform_space (free_add_monoid num)) : complete_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_35058 (h0 : list (with_one (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35059 (h0 : uniform_space (canonically_ordered_monoid (has_neg real))) : separated_space (canonically_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_35060 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : path_connected_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_35061 (h0 : ring (distrib (has_ssubset (has_ssubset (has_compl char))))) : rank_condition (distrib (has_ssubset (has_ssubset (has_compl char)))) := sorry --non-trivial
lemma new_lemma_35062 (h2 : ring (complete_semilattice_Sup num)) : is_domain (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_35063 (h0 : ring (comm_group (option pos))) : is_domain (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_35064 (h0 : fin has_zero.zero) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35065 (h0 : add_group (mul_zero_class unsigned)) : is_add_cyclic (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_35066 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_35067 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35068 (h0 : functor.add_const (group (normed_comm_ring Type)) Type) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_35069 (h0 : functor.add_const (function.extfun (Type 1) filter) (normed_comm_ring (boolean_algebra name))) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_35070 (h0 : add_monoid (has_emptyc (complete_semilattice_Sup linarith.comp))) : add_monoid.fg (has_emptyc (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_35071 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : locally_compact_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_35072 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_35073 (h1 : topological_space (has_append (has_ssubset (has_ssubset (random_gen char))))) : t0_space (has_append (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_35074 (h0 : group (linear_ordered_semiring (semiring congr_arg_kind))) : normalizer_condition (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35075 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @t1_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35076 (h0 : functor.add_const (ring (has_to_string (has_to_string unsigned))) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_to_string.{0} (has_to_string.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} (has_to_string.{0} unsigned))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35077 (h0 : topological_space (finset (finset (finset pos)))) : preirreducible_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_35078 (h0 : function.extfun Type multiset) (h1 : multiset (denumerable fun_info)) : multiset.subset (function.extfun_app h0 (denumerable fun_info)) h1 := sorry --non-trivial
lemma new_lemma_35079 (h0 : set (has_lt enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35080 (h0 : functor.add_const Prop (ordered_cancel_add_comm_monoid (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_35081 (h0 : fin has_zero.zero) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35082 (h0 : ring (linear_ordered_add_comm_group (random_gen char))) : is_domain (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_35083 (h0 : not (topological_space (denumerable char) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_35084 (h0 : ordered_add_comm_monoid (order_dual ennreal)) : archimedean (order_dual ennreal) := sorry --non-trivial
lemma new_lemma_35085 (h0 : complete_lattice (has_compl linarith.ineq)) : is_compactly_generated (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_35086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_35087 (h0 : topological_space (has_dist empty)) : t0_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_35088 (h0 : ring (topological_space (random_gen char))) : strong_rank_condition (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_35089 (h0 : monoid (measurable_space (random_gen (has_norm (random_gen linarith.ineq))))) : monoid.fg (measurable_space (random_gen (has_norm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_35090 (h0 : functor.add_const (filter (has_add pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35091 (h0 : topological_space (cancel_monoid (has_neg_part (semigroup Type)))) : locally_compact_space (cancel_monoid (has_neg_part (semigroup Type))) := sorry --non-trivial
lemma new_lemma_35092 (h1 : has_lt (nondiscrete_normed_field (normed_field char))) : no_max_order (nondiscrete_normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_35093 (h0 : topological_space (linear_ordered_semiring (semiring (has_top empty)))) : t0_space (linear_ordered_semiring (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_35094 (h0 : uniform_space (cancel_monoid (has_add (has_add name)))) : complete_space (cancel_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_35095 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35096 (h1 : complete_lattice (semi_normed_ring (mul_one_class char))) : is_compactly_generated (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_35097 (h0 : ring (has_pos_part (has_add real))) : rank_condition (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_35098 (h0 : filter (uniform_space (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35099 (h0 : group (distrib_lattice (random_gen fun_info))) : group.fg (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_35100 (h0 : partial_order (bin_tree linarith.comp)) (h1 : not (order_top (bin_tree linarith.comp) -> false)) : @is_coatomic.{0} (bin_tree.{0} linarith.comp) h0 (@classical.by_contradiction'.{1} (@order_top.{0} (bin_tree.{0} linarith.comp) (@preorder.to_has_le.{0} (bin_tree.{0} linarith.comp) (@partial_order.to_preorder.{0} (bin_tree.{0} linarith.comp) h0))) h1)  := sorry --non-trivial
lemma new_lemma_35101 (h0 : topological_space (add_cancel_monoid (comm_group (has_add name)))) : irreducible_space (add_cancel_monoid (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_35102 (h0 : ordered_add_comm_monoid (has_dist (option (option (option unsigned))))) : archimedean (has_dist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_35103 (h0 : filter Prop -> option (filter Prop)) (h1 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@list.lookmap.{0} (filter.{0} Prop) h0 h1))  := sorry --non-trivial
lemma new_lemma_35104 (h0 : topological_space (has_zero (has_add environment.implicit_infer_kind))) : loc_path_connected_space (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35105 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group num))) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35106 (h0 : group (with_bot (random_gen linarith.comp))) : group.fg (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_35107 (h1 : has_lt (add_comm_semigroup (add_comm_semigroup enat))) : no_max_order (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_35108 (h0 : group (option ennreal)) : is_cyclic (option ennreal) := sorry --non-trivial
lemma new_lemma_35109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35110 (h0 : topological_space (canonically_ordered_monoid (has_Inf (sub_neg_monoid real)))) : locally_compact_space (canonically_ordered_monoid (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_35111 (h0 : semiring (normed_comm_ring (option (option pos)))) : is_noetherian_ring (normed_comm_ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_35112 (h0 : uniform_space (comm_semigroup (has_bot (comm_semigroup (has_add Type))))) : complete_space (comm_semigroup (has_bot (comm_semigroup (has_add Type)))) := sorry --non-trivial
lemma new_lemma_35113 (h0 : add_group (has_bot congr_arg_kind)) : is_add_cyclic (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35114 (h1 : add_group (measurable_space linarith.comp)) : is_add_cyclic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_35115 (h0 : complete_lattice (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : is_compactly_generated (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35116 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : t1_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_35117 (h0 : cancel_comm_monoid_with_zero (partial_order unsigned)) : unique_factorization_monoid (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_35118 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35119 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf real)))) : t1_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_35120 (h0 : topological_space (cancel_monoid (option (option (option (option (option empty))))))) : normal_space (cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_35121 (h0 : topological_space (left_cancel_monoid (option unsigned))) : loc_path_connected_space (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_35122 (h0 : topological_space (generalized_boolean_algebra (has_add (has_Inf (has_Inf (has_add Type)))))) : preirreducible_space (generalized_boolean_algebra (has_add (has_Inf (has_Inf (has_add Type))))) := sorry --non-trivial
lemma new_lemma_35123 (h0 : finset (has_nndist (finset (has_to_string Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35124 (h1 : uniform_space (has_ssubset (has_nnnorm char))) : complete_space (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_35125 (h0 : topological_space (add_cancel_comm_monoid (has_bot unsigned))) : totally_separated_space (add_cancel_comm_monoid (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_35126 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_35127 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @t0_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35128 (h0 : topological_space (with_bot (semiring (semiring empty)))) : totally_separated_space (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_35129 (h0 : functor.add_const (ring (bin_tree num)) empty) : @strong_rank_condition.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_35130 (h0 : function.extfun (has_top (has_union linarith.comp)) (fun (x : has_top (has_union linarith.comp)), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_35131 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @t1_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_35132 (h0 : ring (canonically_ordered_comm_semiring (semigroup environment.implicit_infer_kind))) : rank_condition (canonically_ordered_comm_semiring (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35133 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (normed_group.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_35134 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @preirreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_35135 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : topological_space.separable_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35136 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35137 (h0 : group (linear_ordered_semiring (semiring (semiring (semiring unsigned))))) : is_cyclic (linear_ordered_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_35138 (h0 : functor.comp topological_space has_neg linarith.comp) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35139 (h0 : complete_lattice (has_nnnorm (semi_normed_comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (semi_normed_comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35140 (h0 : complete_lattice (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : is_compactly_generated (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35141 (h0 : ring (measurable_space (random_gen (random_gen num)))) : rank_condition (measurable_space (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_35142 (h0 : add_group (has_bot (has_add (has_Inf (has_Inf real))))) : is_add_cyclic (has_bot (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_35143 (h0 : cancel_comm_monoid_with_zero (option congr_arg_kind)) : unique_factorization_monoid (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35144 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_35145 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_35146 (h0 : congr_arg_kind -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) congr_arg_kind h0  := sorry --non-trivial
lemma new_lemma_35147 (h0 : functor.add_const (uniform_space (ring environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35148 (h0 : functor.add_const (filter (boolean_algebra.core unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35149 (h0 : topological_space (has_to_string (ring Type))) : sequential_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_35150 (h3 : topological_space (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_35151 (h1 : complete_lattice (with_one (with_bot (with_bot to_additive.value_type)))) : is_atomistic (with_one (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35152 (h0 : Type -> Type -> Prop) (h1 : well_founded h0) (h2 : Pi (x : Type), (Pi (y : Type), h0 y x -> monoid y) -> monoid x) : @monoid.fg.{0} (@id.{2} Type (random_gen.{0} (random_gen.{0} string_imp))) (@well_founded.recursion.{2 1} Type h0 h1 monoid.{0} (@id.{2} Type (random_gen.{0} (random_gen.{0} string_imp))) h2)  := sorry --non-trivial
lemma new_lemma_35153 (h0 : ring (canonically_ordered_comm_semiring (has_add Type))) : strong_rank_condition (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_35154 (h0 : ordered_add_comm_monoid (linear_ordered_field (ring (has_add name)))) : archimedean (linear_ordered_field (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_35155 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_35156 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35157 (h0 : monoid (normed_comm_ring (has_nndist linarith.comp))) : monoid.fg (normed_comm_ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_35158 (h2 : topological_space (add_comm_semigroup environment.projection_info)) (h3 : add_group (add_comm_semigroup environment.projection_info)) : topological_add_group (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_35159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_35160 (h0 : multiset (simple_graph (mul_one_class (mul_one_class string.iterator_imp)))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_35161 (h1 : group (div_inv_monoid (has_nnnorm to_additive.value_type))) : is_cyclic (div_inv_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35162 (h2 : Prop) : set.finite (id (fun (h0 : linarith.ineq), h2)) := sorry --non-trivial
lemma new_lemma_35163 (h0 : functor.add_const (ring Type) (has_neg linarith.comp)) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_35164 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @t1_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35165 (h0 : ring (has_to_string (has_pos_part (has_Inf Type)))) : is_principal_ideal_ring (has_to_string (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_35166 (h0 : ring (topological_space (has_nnnorm (has_nnnorm string_imp)))) : strong_rank_condition (topological_space (has_nnnorm (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_35167 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35168 (h0 : functor.add_const (finset (add_cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35169 (h0 : functor.add_const (group (has_neg Type)) Type) : @group.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_35170 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg (has_neg linarith.comp))))) : loc_path_connected_space (generalized_boolean_algebra (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_35171 (h0 : topological_space (has_top (random_gen congr_arg_kind))) : discrete_topology (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35172 (h1 : has_lt (mul_one_class std_gen)) : no_max_order (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_35173 (h0 : group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))))) : group.fg (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos))))) := sorry --non-trivial
lemma new_lemma_35174 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35175 (h0 : topological_space (has_inv (random_gen fun_info))) : t0_space (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_35176 (h0 : functor.add_const (function.extfun (Type 1) semiring) Type) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_35177 (h0 : functor.add_const (fin has_zero.zero) real) : @archimedean.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_35178 (h0 : functor.add_const (finset (semigroup pos)) (ring (finset environment.implicit_infer_kind))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35179 (h0 : complete_lattice (option (semiring congr_arg_kind))) : is_compactly_generated (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35180 (h0 : functor.add_const (filter (has_to_string Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35181 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35182 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35183 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_35184 (h0 : uniform_space (mul_zero_class (ordered_cancel_comm_monoid congr_arg_kind))) : separated_space (mul_zero_class (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35185 (h0 : add_group (has_div (mul_one_class char))) : is_add_cyclic (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_35186 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_35187 (h0 : functor.add_const (function.extfun Type complete_lattice) (ring linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (ring.{0} linarith.comp) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35188 (h0 : topological_space (has_union (semiring (semiring (semiring linarith.comp))))) : path_connected_space (has_union (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_35189 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system num)) : unique_factorization_monoid (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_35190 (h0 : complete_lattice (with_bot (has_inv (has_inv (has_inv linarith.comp_source))))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_35191 (h0 : function.extfun Type uniform_space) : @complete_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_35192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_35193 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (comm_group name)) : @sequential_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35194 (h0 : group (has_bot (has_Inf (has_Inf linarith.comp)))) : is_simple_group (has_bot (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_35195 (h0 : has_coe (add_comm_semigroup environment.projection_info) Prop) (h1 : add_comm_semigroup environment.projection_info) : @coe_b.{1 1} (add_comm_semigroup.{0} environment.projection_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_35196 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) Type) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_35197 (h0 : ring (has_lt linarith.ineq)) : is_domain (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_35198 (h0 : topological_space (has_zero (finset linarith.comp))) : totally_disconnected_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_35199 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35200 (h0 : complete_lattice (has_norm linarith.ineq)) : is_compactly_generated (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_35201 (h0 : ring (mul_one_class to_additive.value_type)) : is_domain (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35202 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_35203 (h0 : topological_space (has_add (ring (ring linarith.comp)))) : loc_path_connected_space (has_add (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_35204 (h0 : functor.add_const (group (add_comm_monoid pos)) (finset (has_neg Type))) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) (finset.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35205 (h0 : functor.add_const (ring (pseudo_metric_space num)) ennreal) : @is_domain.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_35206 (h0 : topological_space (add_group (semiring num))) : discrete_topology (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_35207 (h0 : set occurrences) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35208 (h0 : option (topological_space (has_compl (has_lt char)))) (h1 : coe_sort (option.is_some h0)) : @t0_space.{0} (has_compl.{0} (has_lt.{0} char)) (@option.get.{0} (topological_space.{0} (has_compl.{0} (has_lt.{0} char))) h0 h1)  := sorry --non-trivial
lemma new_lemma_35209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : irreducible_space ennreal := sorry --non-trivial
lemma new_lemma_35210 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : path_connected_space (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35211 (h1 : group (semi_normed_comm_ring (random_gen (denumerable linarith.ineq)))) : group.fg (semi_normed_comm_ring (random_gen (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_35212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35213 (h2 : set (fun_info -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_35214 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) name) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35215 (h0 : not (prod (semiring unsigned) (semiring unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_35216 (h0 : topological_space (ring (has_pos_part pos))) : locally_compact_space (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_35217 (h1 : topological_space (measurable_space (has_top to_additive.value_type))) : locally_compact_space (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35218 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_35219 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_35220 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_35221 (h0 : fin has_zero.zero) : @irreducible_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35222 (h0 : topological_space (mul_zero_class unsigned)) : loc_path_connected_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_35223 (h0 : topological_space (normed_group (has_inv to_additive.value_type))) : locally_compact_space (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35224 (h0 : functor.add_const (topological_space (semigroup pos)) (has_neg linarith.comp)) : @normal_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_35225 (h0 : filter (measurable_space (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35226 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_35227 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : t1_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_35228 (h0 : group (ordered_comm_ring (has_nndist Type))) : normalizer_condition (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_35229 (h0 : has_le (add_comm_semigroup enat)) (h2 : add_comm_semigroup enat) : is_bot h2 := sorry --non-trivial
lemma new_lemma_35230 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_35231 (h0 : topological_space (distrib (comm_ring reducibility_hints))) : t0_space (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_35232 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35233 (h0 : monoid (with_bot (has_norm (random_gen num)))) : monoid.fg (with_bot (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_35234 (h0 : complete_lattice (has_union unsigned)) : is_compactly_generated (has_union unsigned) := sorry --non-trivial
lemma new_lemma_35235 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_35236 (h0 : filter (has_neg_part (has_neg_part environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35237 (h0 : topological_space (random_gen (comm_ring reducibility_hints))) : t0_space (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_35238 (h0 : topological_space (has_add (boolean_algebra real))) : irreducible_space (has_add (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_35239 (h0 : list (simple_graph (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35240 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) name) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_35241 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) name) : @is_atomistic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_35242 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35243 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35244 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_35245 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_35246 (h0 : group (ordered_ring (semiring (semiring (semiring (semiring (semiring empty))))))) : is_cyclic (ordered_ring (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_35247 (h0 : topological_space (free_add_monoid (semiring unsigned))) : preirreducible_space (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35248 (h0 : group (semigroup (option name))) : normalizer_condition (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_35249 (h0 : ring (topological_space (has_nnnorm (has_nnnorm reducibility_hints)))) : strong_rank_condition (topological_space (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_35250 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35252 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35253 (h0 : not (topological_space (complete_semilattice_Sup to_additive.value_type) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_35254 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph pos)) (ring name)) : @archimedean.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (simple_graph.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35255 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_35256 (h0 : topological_space (has_zero Type)) : regular_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_35257 (h0 : filter (has_zero (has_Inf (finset (finset pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35258 (h0 : topological_space (has_inter congr_arg_kind)) : preconnected_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35259 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf (has_Inf pos))))) : totally_separated_space (ordered_comm_monoid (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_35260 (h0 : not (complete_lattice (left_cancel_semigroup unsigned) -> false)) : @is_atomistic.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35261 (h0 : list (has_edist unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35262 (h0 : complete_lattice (has_ssubset linarith.comp_source)) : is_compactly_generated (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35263 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset Type)) : @irreducible_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} Type) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_35264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35265 (h0 h1 : multiset (normed_field char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_35266 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @discrete_topology.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_35267 (h0 : topological_space (has_pos_part real)) : irreducible_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_35268 (h0 : complete_lattice (has_nndist (mul_zero_class (option name)))) : is_compactly_generated (has_nndist (mul_zero_class (option name))) := sorry --non-trivial
lemma new_lemma_35269 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_35270 (h0 : uniform_space (has_top (has_top unsigned))) : separated_space (has_top (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_35271 (h0 : string_imp -> random_gen string_imp -> topological_space (random_gen to_additive.value_type)) (h1 : prod string_imp (random_gen string_imp)) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@function.uncurry.{0 0 0} string_imp (random_gen.{0} string_imp) (topological_space.{0} (random_gen.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_35272 (h0 : finset (group_with_zero unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_35274 (h1 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_35275 (h0 : add_monoid (ring (has_add (has_add pos)))) : add_monoid.fg (ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_35276 (h0 : uniform_space (comm_group (ring linarith.comp))) : separated_space (comm_group (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_35277 (h0 : topological_space (semigroup (finset (finset pos)))) : irreducible_space (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_35278 (h0 : topological_space (option (option unsigned))) : loc_path_connected_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_35279 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : totally_separated_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_35280 (h0 : topological_space (canonically_ordered_add_monoid empty)) : t1_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_35281 (h0 : topological_space (has_pos_part (has_pos_part (has_add pos)))) : normal_space (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_35282 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_35283 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35284 (h0 : ring (has_inv (random_gen (random_gen (random_gen fun_info))))) : rank_condition (has_inv (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_35285 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_35286 (h0 : not (topological_space (has_top linarith.ineq) -> false)) : @totally_separated_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_35287 (h0 : topological_space (has_zero (finset (ring (ring (has_to_string Type)))))) : t1_space (has_zero (finset (ring (ring (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_35288 (h0 : functor.add_const (topological_space (ring Type)) (has_neg Type)) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_35289 (h0 : add_monoid (has_neg_part (option (option (has_add (option (option name))))))) : add_monoid.fg (has_neg_part (option (option (has_add (option (option name)))))) := sorry --non-trivial
lemma new_lemma_35290 (h0 : prod (complete_linear_order (semiring congr_arg_kind)) (complete_linear_order (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_35291 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @locally_compact_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_35292 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_35293 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t0_space.{0} (has_inv.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))))) (@matrix.vec_empty.{0} (topological_space.{0} (has_inv.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)))))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_35294 (h0 : filter (has_add (has_add (normed_comm_ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35295 (h0 : complete_lattice (denumerable to_additive.value_type)) : is_compactly_generated (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35296 (h0 : has_neg (has_lt enat)) (h1 : measurable_space (has_lt enat)) : has_measurable_neg (has_lt enat) := sorry --non-trivial
lemma new_lemma_35297 (h0 : ring (linear_ordered_cancel_comm_monoid empty)) : is_domain (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_35298 (h0 : topological_space (has_sdiff reducibility_hints)) : path_connected_space (has_sdiff reducibility_hints) := sorry --non-trivial
lemma new_lemma_35299 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_35300 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @path_connected_space.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35301 (h0 : topological_space (nondiscrete_normed_field (mul_one_class fun_info))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_35302 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35303 (h0 : topological_space (boolean_algebra.core unsigned)) : loc_path_connected_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_35304 (h0 : not (complete_lattice (linear_ordered_semiring (has_top congr_arg_kind)) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_35305 (h0 : topological_space (has_zero (comm_group name))) : totally_separated_space (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_35306 (h0 : topological_space (add_cancel_comm_monoid (option unsigned))) : path_connected_space (add_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_35307 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) unsigned) : @locally_compact_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35308 (h0 : functor.add_const (ordered_comm_monoid (has_add ennreal)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_35309 (h0 : functor.add_const (functor.add_const (group Type) linarith.comp) pos) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_35310 (h0 : function.extfun Type group) : @normalizer_condition.{0} (division_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (division_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35312 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_35313 (h0 : not (add_group (has_top linarith.comp) -> false)) : @is_add_cyclic.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35314 (h0 : filter (monoid_with_zero (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35315 (h0 : semiring (ordered_comm_ring (has_bot (has_Inf (sub_neg_monoid real))))) : is_noetherian_ring (ordered_comm_ring (has_bot (has_Inf (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_35316 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35317 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_35318 (h0 : complete_lattice (nondiscrete_normed_field (add_comm_semigroup ereal))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_35319 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) (has_pos_part linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35320 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @totally_disconnected_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35321 (h0 : group (has_neg (has_to_string (has_to_string (has_add unsigned))))) : is_simple_group (has_neg (has_to_string (has_to_string (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_35322 (h0 : finset name) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35323 (h0 : uniform_space (has_top (semiring (semiring (semiring (has_norm congr_arg_kind)))))) : separated_space (has_top (semiring (semiring (semiring (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_35324 (h2 : topological_space (has_ssubset environment.projection_info)) : totally_disconnected_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_35325 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_35326 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) empty) : @t1_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_35327 (h0 : ordered_add_comm_monoid (has_neg_part ennreal)) : archimedean (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_35328 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35329 (h0 : functor.comp complete_lattice add_cancel_monoid Type) : @is_atomistic.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_35330 (h4 : measurable_space (nondiscrete_normed_field (normed_field reducibility_hints))) (h5 : measure_theory.measure (nondiscrete_normed_field (normed_field reducibility_hints))) : measure_theory.is_finite_measure h5 := sorry --non-trivial
lemma new_lemma_35331 (h0 : topological_space (simple_graph (option (option (option empty))))) : discrete_topology (simple_graph (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_35332 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) num) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_35333 (h0 : topological_space (normed_group (has_top num))) : discrete_topology (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_35334 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35335 (h0 : topological_space (has_zero (canonically_ordered_comm_semiring Type))) : totally_separated_space (has_zero (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_35336 (h0 : uniform_space (distrib_lattice reducibility_hints)) : complete_space (distrib_lattice reducibility_hints) := sorry --non-trivial
lemma new_lemma_35337 (h0 : add_group (with_bot (random_gen num))) : is_add_cyclic (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_35338 (h0 : topological_space (ordered_comm_monoid Type)) : loc_path_connected_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_35339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35340 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_35341 (h0 : functor.add_const (finset (has_neg (has_neg_part linarith.comp))) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35342 (h0 : complete_lattice (distrib_lattice (random_gen (has_top to_additive.value_type)))) : is_compactly_generated (distrib_lattice (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35343 (h0 : functor.add_const (group (has_nndist Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35344 (h0 : semiring (canonically_linear_ordered_monoid (canonically_linear_ordered_monoid Type))) : is_noetherian_ring (canonically_linear_ordered_monoid (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_35345 (h0 : linarith.comp_source -> linarith.comp_source -> linarith.comp_source) : is_right_cancel linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_35346 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_35347 (h0 : topological_space (ring (metric_space (normed_comm_ring (has_add (finset pos)))))) : irreducible_space (ring (metric_space (normed_comm_ring (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_35348 (h0 : topological_space (distrib_lattice char)) : t0_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_35349 (h0 : topological_space (has_zero (has_add pos))) : sequential_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_35350 (h0 : ring (normed_group to_additive.value_type)) : is_domain (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35351 (h0 : fin has_zero.zero) : @monoid.fg.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (sub_neg_monoid.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_35352 (h0 : group (add_cancel_comm_monoid (mul_one_class (random_gen (random_gen linarith.ineq))))) : is_cyclic (add_cancel_comm_monoid (mul_one_class (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_35353 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_35354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35355 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_neg Type))) : unique_factorization_monoid (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_35356 (h0 : uniform_space (with_one (has_norm num))) : separated_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_35357 (h0 : functor.add_const (functor.add_const (group (has_neg pos)) linarith.comp) pos) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} (has_neg.{0} pos)) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_35358 (h0 : topological_space (finset (finset Type))) : discrete_topology (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_35359 (h0 : monoid (measurable_space (random_gen (has_inv (random_gen linarith.ineq))))) : monoid.fg (measurable_space (random_gen (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_35360 (h0 : prod (ring (option (option (option empty)))) (ring (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_35361 (h0 : ring (non_unital_non_assoc_semiring enat)) : is_domain (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_35362 (h0 : complete_lattice (id (has_norm num))) : is_atomistic (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_35363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35364 (h0 : semiring (add_comm_monoid real.angle)) : is_noetherian_ring (add_comm_monoid real.angle) := sorry --non-trivial
lemma new_lemma_35365 (h0 : group (ring (has_add name))) : normalizer_condition (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_35366 (h0 : has_mem.mem Type has_emptyc.emptyc) : @totally_disconnected_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_35367 (h1 : uniform_space (normed_field (random_gen linarith.comp_source))) : complete_space (normed_field (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35368 (h3 : not (topological_space (semi_normed_comm_ring reducibility_hints) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h3)  := sorry --non-trivial
lemma new_lemma_35369 (h0 : add_monoid (generalized_boolean_algebra linarith.comp)) : add_monoid.fg (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_35370 (h0 : function.extfun nat fin) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35371 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_35372 (h1 : topological_space (has_emptyc (has_top fun_info))) : path_connected_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_35373 (h0 : filter (boolean_algebra.core congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35374 (h0 : topological_space (comm_group (finset ennreal))) : sequential_space (comm_group (finset ennreal)) := sorry --non-trivial
lemma new_lemma_35375 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_35376 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_35377 (h0 : add_group (nondiscrete_normed_field (has_to_string enat))) : is_add_cyclic (nondiscrete_normed_field (has_to_string enat)) := sorry --non-trivial
lemma new_lemma_35378 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) empty) : @t1_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_35379 (h0 : topological_space (boolean_algebra (has_add (has_Inf (has_Inf pos))))) : loc_path_connected_space (boolean_algebra (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_35380 (h0 : ring (add_comm_monoid (has_to_string unsigned))) : is_domain (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_35381 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35382 (h0 : topological_space (mul_zero_class (finset (finset (finset pos))))) : discrete_topology (mul_zero_class (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_35383 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_35384 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : loc_path_connected_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_35385 (h0 : topological_space (option (semiring congr_arg_kind))) : totally_separated_space (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35386 (h0 : topological_space (comm_group (normed_comm_ring linarith.comp))) : totally_separated_space (comm_group (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_35387 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @locally_compact_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_35388 (h0 : ordered_add_comm_monoid (ordered_comm_group congr_arg_kind)) : archimedean (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35389 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35390 (h0 : topological_space (add_cancel_monoid (linear_ordered_comm_monoid_with_zero (option name)))) : t0_space (add_cancel_monoid (linear_ordered_comm_monoid_with_zero (option name))) := sorry --non-trivial
lemma new_lemma_35391 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h1 : set (add_comm_semigroup linarith.ineq)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_35392 (h0 : topological_space (finset (normed_comm_ring pos))) : sequential_space (finset (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_35393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_35394 (h0 : ordered_comm_monoid (ring (has_neg (has_nndist (has_add name))))) : has_exists_mul_of_le (ring (has_neg (has_nndist (has_add name)))) := sorry --non-trivial
lemma new_lemma_35395 (h0 : ring (has_ssubset (semi_normed_ring fun_info))) : is_domain (has_ssubset (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_35396 (h0 : topological_space (has_neg_part (has_add (has_add Type)))) : preirreducible_space (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_35397 (h0 : filter (has_inner (has_to_string (has_nndist environment.implicit_infer_kind)) Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35398 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_field ennreal)) num) : @archimedean.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_field.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_35399 (h0 : topological_space (cancel_monoid (has_add (has_add unsigned)))) : discrete_topology (cancel_monoid (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_35400 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35401 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35402 (h0 : ring (add_group (has_norm congr_arg_kind))) : strong_rank_condition (add_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35403 (h0 : fin has_zero.zero) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35404 (h0 : topological_space (cancel_monoid (ring Type))) : regular_space (cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_35405 (h0 : add_group (normed_group (random_gen char))) : is_add_cyclic (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_35406 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_35407 (h0 : group (add_comm_monoid (comm_group name))) : is_simple_group (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_35408 (h0 : topological_space (canonically_ordered_comm_semiring (pseudo_metric_space pos))) : t0_space (canonically_ordered_comm_semiring (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_35409 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_35411 (h0 : uniform_space (random_gen (random_gen (random_gen fun_info)))) : complete_space (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_35412 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_35413 (h0 : topological_space (has_le enat)) (h1 : add_group (has_le enat)) : topological_add_group (has_le enat) := sorry --non-trivial
lemma new_lemma_35414 (h0 : add_monoid (with_one (has_top linarith.comp))) : add_monoid.fg (with_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_35415 (h0 : set (add_comm_semigroup std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_35416 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_35417 (h0 : complete_lattice (has_nndist (option (option empty)))) : complete_lattice.is_Sup_finite_compact (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_35418 (h0 : topological_space (ordered_comm_monoid (has_pos_part (ring Type)))) : t0_space (ordered_comm_monoid (has_pos_part (ring Type))) := sorry --non-trivial
lemma new_lemma_35419 (h0 : ring (distrib (mul_one_class reducibility_hints))) : is_domain (distrib (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_35420 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_35421 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid name)) name) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_35422 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35423 (h0 : functor.add_const (finset (has_Inf linarith.comp)) (finset linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35424 (h1 : ring (add_left_cancel_monoid (random_gen to_additive.value_type))) : strong_rank_condition (add_left_cancel_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35425 (h0 : ring (normed_group (has_norm linarith.comp_source))) : rank_condition (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35426 (h1 : not (topological_space (uniform_space reducibility_hints) -> false)) : @t0_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_35427 (h0 : finset (semigroup (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35428 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @preirreducible_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_35429 (h0 : finset (has_neg (ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35430 (h0 : functor.add_const (semiring (complete_distrib_lattice linarith.comp)) name) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_35431 (h0 : functor.add_const (functor.add_const Prop (normed_comm_ring linarith.comp)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35432 (h0 : topological_space (generalized_boolean_algebra (ordered_ring (ordered_ring linarith.comp)))) : normal_space (generalized_boolean_algebra (ordered_ring (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_35433 (h0 : semiring (monoid_with_zero pos)) : is_noetherian_ring (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_35434 (h0 : list (has_to_string (has_to_string (has_to_string linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35435 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) num) : @irreducible_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_35436 (h0 : functor.add_const (functor.add_const (group Type) (has_Inf linarith.comp)) pos) : @is_cyclic.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) (has_Inf.{0} linarith.comp) (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) (has_Inf.{0} linarith.comp)) pos h0))  := sorry --non-trivial
lemma new_lemma_35437 (h0 : ring (finset (option (option (option ennreal))))) : is_domain (finset (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_35438 (h0 : ring (finset (has_nndist (has_neg Type)))) : rank_condition (finset (has_nndist (has_neg Type))) := sorry --non-trivial
lemma new_lemma_35439 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @is_atomistic.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35440 (h1 : not (ring (distrib_lattice char) -> false)) : @is_domain.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_35441 (h0 : left_cancel_semigroup (mul_zero_class unsigned) -> left_cancel_semigroup (mul_zero_class unsigned) -> Prop) : is_strict_order (left_cancel_semigroup (mul_zero_class unsigned)) h0 := sorry --non-trivial
lemma new_lemma_35442 (h0 : topological_space (has_norm (random_gen linarith.comp_source))) : locally_compact_space (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35443 (h0 : group (comm_ring (random_gen (has_nnnorm linarith.comp_source)))) : is_cyclic (comm_ring (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_35444 (h0 : ring (has_add (finset (has_neg_part linarith.comp)))) : is_principal_ideal_ring (has_add (finset (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_35445 (h1 : topological_space (distrib string.iterator_imp)) : path_connected_space (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_35446 (h0 : topological_space (has_norm congr_arg_kind)) : normal_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35447 (h0 : topological_space (semi_normed_comm_ring (mul_one_class string_imp))) : path_connected_space (semi_normed_comm_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_35448 (h0 : topological_space (measure_theory.measure_space empty)) : locally_compact_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_35449 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_35450 (h0 : topological_space (has_top fun_info)) : totally_separated_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_35451 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra unsigned))) : path_connected_space (canonically_ordered_comm_semiring (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_35452 (h0 : ring (measurable_space linarith.comp)) : strong_rank_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_35453 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_35454 (h3 : has_lt (nondiscrete_normed_field environment.projection_info)) : no_max_order (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_35455 (h0 : function.extfun Type (functor.add_const (topological_space (ring pos)))) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} pos))) h0 pos))  := sorry --non-trivial
lemma new_lemma_35456 (h0 : add_group (has_bot (has_add Type))) : is_add_cyclic (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_35457 (h1 : add_monoid (id linarith.comp)) : add_monoid.fg (id linarith.comp) := sorry --non-trivial
lemma new_lemma_35458 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35459 (h0 : preorder (has_norm linarith.comp_source)) (h1 : topological_space (has_norm linarith.comp_source)) : Inf_convergence_class (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_35461 (h0 : finset (ordered_cancel_add_comm_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35462 (h0 : group (has_to_string (has_to_string num))) : group.fg (has_to_string (has_to_string num)) := sorry --non-trivial
lemma new_lemma_35463 (h0 : not (complete_lattice (plift unsigned) -> false)) : @is_compactly_generated.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35464 (h0 : complete_lattice (has_bot (has_add (has_Inf (finset Type))))) : complete_lattice.is_Sup_finite_compact (has_bot (has_add (has_Inf (finset Type)))) := sorry --non-trivial
lemma new_lemma_35465 (h0 : topological_space (has_inv (has_top fun_info))) : totally_disconnected_space (has_inv (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_35466 (h1 : uniform_space (has_div linarith.comp_source)) : complete_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35467 (h0 : topological_space (has_neg (finset Type))) : t1_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_35468 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) pos)  := sorry --non-trivial
lemma new_lemma_35469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_35470 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_35471 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) empty) : @irreducible_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_35472 (h0 : topological_space (metric_space linarith.comp)) : normal_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_35473 (h0 : functor.add_const (uniform_space (preorder empty)) congr_arg_kind) : @complete_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_35474 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35475 (h3 : complete_lattice (nondiscrete_normed_field enat)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_35476 (h0 : semiring (boolean_algebra.core (has_add name))) : is_noetherian_ring (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_35477 (h0 : ordered_comm_monoid (linear_ordered_field (ring (option (option pos))))) : has_exists_mul_of_le (linear_ordered_field (ring (option (option pos)))) := sorry --non-trivial
lemma new_lemma_35478 (h0 : topological_space (has_inter congr_arg_kind)) : preirreducible_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35479 (h0 : has_lt num) : no_max_order num := sorry --non-trivial
lemma new_lemma_35480 (h0 : function.extfun (Type 1) (functor.add_const (uniform_space (boolean_algebra linarith.comp)))) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (ordered_ring.{1} Type) (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (uniform_space.{0} (boolean_algebra.{0} linarith.comp))) h0 (ordered_ring.{1} Type)))  := sorry --non-trivial
lemma new_lemma_35481 (h0 : add_group (ring num)) : is_add_cyclic (ring num) := sorry --non-trivial
lemma new_lemma_35482 (h0 : filter (add_cancel_monoid (has_nndist ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35483 (h1 : set (mul_one_class char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_35484 (h0 : topological_space (id (has_top linarith.comp_source))) : totally_separated_space (id (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35485 (h0 : group (plift (has_top empty))) : normalizer_condition (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_35486 (h0 : filter (has_to_string (finset (finset (has_to_string (has_to_string linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35487 (h0 : ring (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : is_domain (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35488 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_35489 (h0 : uniform_space (has_bot (option unsigned))) : complete_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_35490 (h0 : topological_space (encodable (has_ssubset linarith.comp_source))) : path_connected_space (encodable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35491 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : preirreducible_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35492 (h1 : group (has_emptyc (has_norm fun_info))) : is_cyclic (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_35493 (h1 : not (topological_space (semiring linarith.comp_source) -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_35494 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_35495 (h0 : functor.add_const (topological_space (has_star unsigned)) unsigned) : @irreducible_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35496 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_35497 (h0 : list (has_to_string (has_pos_part (has_pos_part (ring linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35498 (h0 : topological_space (complete_distrib_lattice (option (option (option (option pos)))))) : regular_space (complete_distrib_lattice (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_35499 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) empty) : @group.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_35500 (h0 : measurable_space (mul_one_class (add_comm_semigroup string.iterator_imp))) (h1 : filter (mul_one_class (add_comm_semigroup string.iterator_imp))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_35501 (h0 : ring (has_ssubset (add_comm_semigroup (add_comm_semigroup fun_info)))) : strong_rank_condition (has_ssubset (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_35502 (h0 : set (has_le fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_35504 (h0 : topological_space (has_div fun_info)) : t0_space (has_div fun_info) := sorry --non-trivial
lemma new_lemma_35505 (h0 : semiring (left_cancel_monoid (option empty))) : is_noetherian_ring (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_35506 (h0 : functor.add_const (add_monoid (ordered_comm_monoid name)) linarith.comp) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35507 (h0 : ring (comm_group (has_to_string linarith.comp))) : is_domain (comm_group (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_35508 (h0 : list (semigroup (has_add environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_35509 (h0 : ring (distrib_lattice (has_norm (has_norm (has_norm string_imp))))) : is_domain (distrib_lattice (has_norm (has_norm (has_norm string_imp)))) := sorry --non-trivial
lemma new_lemma_35510 (h0 : functor.add_const (group (ring linarith.comp)) (finset pos)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_35511 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : t1_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_35512 (h0 : functor.add_const (add_group (ring ennreal)) (option unsigned)) : @is_add_cyclic.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} ennreal)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_35513 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_35514 (h0 : topological_space (linear_ordered_add_comm_group (with_bot linarith.comp_source))) : totally_separated_space (linear_ordered_add_comm_group (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35515 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35516 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_35517 (h0 : not (uniform_space (partial_order num) -> false)) : @complete_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_35518 (h0 : group (normed_linear_ordered_group (semiring (semiring empty)))) : is_cyclic (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_35519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_35520 (h0 : ring (has_ssubset (has_ssubset environment.projection_info))) : is_domain (has_ssubset (has_ssubset environment.projection_info)) := sorry --non-trivial
lemma new_lemma_35521 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : loc_path_connected_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_35522 (h0 : add_group (id (random_gen (random_gen string_imp)))) : is_add_cyclic (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_35523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_35524 (h0 : uniform_space (finset (has_to_string (finset (finset (finset pos)))))) : complete_space (finset (has_to_string (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_35525 (h1 : ring (semi_normed_ring (topological_space (comm_ring reducibility_hints)))) : is_domain (semi_normed_ring (topological_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_35526 (h0 : functor.add_const (topological_space pos) name) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_35527 (h0 : uniform_space (has_to_string (option empty))) : complete_space (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_35528 (h0 : functor.add_const (add_group (has_dist unsigned)) ennreal) : @is_add_cyclic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_dist.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_35529 (h0 : topological_space (has_le (mul_one_class (has_ssubset to_additive.value_type)))) : totally_disconnected_space (has_le (mul_one_class (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35530 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_35531 (h0 : group (has_top (random_gen num))) : normalizer_condition (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_35532 (h0 : topological_space (semigroup (option empty))) : normal_space (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_35533 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (comm_group name)) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35534 (h0 : not (topological_space (has_append (has_ssubset (has_ssubset to_additive.value_type))) -> false)) : @totally_disconnected_space.{0} (has_append.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_35535 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_field.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_field.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_35536 (h0 : not (complete_lattice (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_35537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35538 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35539 (h0 : function.extfun Type ring) : @is_domain.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_35540 (h0 : functor.add_const (uniform_space (has_neg Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35541 (h0 : topological_space (ordered_ring (semiring (semiring unsigned)))) : preirreducible_space (ordered_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_35542 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_35543 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : complete_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35544 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_35545 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35546 (h0 : ring enat) : invariant_basis_number enat := sorry --non-trivial
lemma new_lemma_35547 (h1 : topological_space (has_nnnorm ereal)) (h2 : preorder (has_nnnorm ereal)) : order_topology (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_35548 (h0 : add_monoid (with_bot (semiring (semiring (mul_zero_class unsigned))))) : add_monoid.fg (with_bot (semiring (semiring (mul_zero_class unsigned)))) := sorry --non-trivial
lemma new_lemma_35549 (h0 : functor.comp topological_space cancel_monoid environment.implicit_infer_kind) : @irreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35550 (h0 : topological_space (has_zero (has_Inf Type))) : t1_space (has_zero (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_35551 (h0 : ring (distrib (has_nnnorm linarith.ineq))) : is_domain (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35552 (h0 : functor.comp ring has_neg environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35553 (h0 : ring (distrib_lattice (add_cancel_comm_monoid linarith.comp_source))) : strong_rank_condition (distrib_lattice (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35554 (h0 : ring (has_top (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : is_domain (has_top (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_35555 (h0 : not (add_monoid (complete_semilattice_Sup unsigned) -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35556 (h0 : add_group (with_zero (uniform_space (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (with_zero (uniform_space (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_35557 (h1 : ring (dlist to_additive.value_type)) : is_domain (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35558 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_35559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_35560 (h0 : uniform_space (add_comm_monoid (normed_comm_ring (has_add (pseudo_emetric_space linarith.comp))))) : separated_space (add_comm_monoid (normed_comm_ring (has_add (pseudo_emetric_space linarith.comp)))) := sorry --non-trivial
lemma new_lemma_35561 (h0 : uniform_space (ordered_comm_ring (has_add real))) : complete_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_35562 (h0 : topological_space (has_union (semiring unsigned))) : preirreducible_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35563 (h1 : add_group (semi_normed_ring (random_gen char))) : is_add_cyclic (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_35564 (h0 : uniform_space (distrib_lattice linarith.ineq)) : complete_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_35565 (h0 : group (has_neg_part (has_add (has_add (has_add (has_add Type)))))) : is_cyclic (has_neg_part (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_35566 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_35567 (h0 : ring (topological_space (random_gen (random_gen string_imp)))) : strong_rank_condition (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_35568 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35569 (h0 : complete_lattice (has_div (has_compl enat))) : is_compactly_generated (has_div (has_compl enat)) := sorry --non-trivial
lemma new_lemma_35570 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_35571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35572 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) Type)  := sorry --non-trivial
lemma new_lemma_35573 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35574 (h0 : not (ring (partial_order unsigned) -> false)) : @rank_condition.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35575 (h0 : topological_space (comm_semigroup real)) : normal_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_35576 (h0 : not (list (left_cancel_semigroup unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_35577 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35578 (h0 : add_monoid (normed_comm_ring environment.implicit_infer_kind)) : add_monoid.fg (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_35579 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35580 (h1 : topological_space (topological_space (distrib linarith.ineq))) : t0_space (topological_space (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35581 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (ring linarith.comp)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_35582 (h0 : function.extfun Type monoid) : @monoid.exponent_exists.{0} (group_with_zero.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (group_with_zero.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_35583 (h0 : ereal -> ereal -> Prop) : pairwise h0 := sorry --non-trivial
lemma new_lemma_35584 (h1 : complete_lattice (topological_space (random_gen (random_gen string_imp)))) : is_compactly_generated (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_35585 (h0 : add_group (id (semiring (semiring congr_arg_kind)))) : is_add_cyclic (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_35586 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_35587 (h0 : add_monoid (metric_space (metric_space num))) : add_monoid.fg (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_35588 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @normal_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35589 (h0 : ring (ring (has_nndist linarith.comp))) : is_domain (ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_35590 (h0 : functor.add_const (add_monoid (comm_group name)) (has_neg linarith.comp)) : @add_monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_35591 (h0 : topological_space environment.implicit_infer_kind) : t1_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_35592 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_35593 (h0 : uniform_space (semiring (semiring unsigned))) : complete_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35594 (h0 : functor.add_const (group (comm_group name)) name) : @is_simple_group.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_35595 (h0 : left_cancel_semigroup (bin_tree empty) -> left_cancel_semigroup (bin_tree empty) -> Prop) (h1 : left_cancel_semigroup (bin_tree empty)) (h2 : rbtree (left_cancel_semigroup (bin_tree empty)) h0) : rbtree.mem h1 h2 := sorry --non-trivial
lemma new_lemma_35596 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_35597 (h0 : uniform_space (cancel_monoid empty)) : complete_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_35598 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35599 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : t0_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35600 (h0 : list (random_gen (has_nnnorm char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35601 (h0 : topological_space (generalized_boolean_algebra (has_pos_part linarith.comp))) : preconnected_space (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_35602 (h0 : complete_lattice (has_norm (random_gen (has_top fun_info)))) : is_atomistic (has_norm (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_35603 (h0 : ring (distrib_lattice linarith.ineq)) : rank_condition (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_35604 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_35605 (h0 : complete_lattice (with_bot unsigned)) : is_compactly_generated (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_35606 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @loc_path_connected_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_35607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_comm_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_35608 (h0 : functor.add_const (topological_space (boolean_algebra name)) environment.implicit_infer_kind) : @t1_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35609 (h0 : uniform_space (has_pos_part (sub_neg_monoid Type))) : complete_space (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_35610 (h0 : list (has_nndist num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35611 (h0 : functor.add_const (uniform_space (has_zero pos)) name) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_35612 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : preirreducible_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35613 (h0 : functor.add_const (add_group (normed_comm_ring linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35614 (h0 : functor.add_const (uniform_space (has_Sup empty)) name) : @complete_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) name h0)  := sorry --non-trivial
lemma new_lemma_35615 (h0 : cancel_comm_monoid_with_zero (ring (ring pos))) : unique_factorization_monoid (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_35616 (h0 : ring (has_le (mul_one_class string.iterator_imp))) : is_domain (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_35617 (h1 : ring (linear_ordered_add_comm_group_with_top to_additive.value_type)) : rank_condition (linear_ordered_add_comm_group_with_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35618 (h0 : ring (semiring (random_gen linarith.comp))) : rank_condition (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_35619 (h0 : topological_space (has_zero (comm_group name))) : discrete_topology (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_35620 (h0 : not (topological_space to_additive.value_type -> false)) : @t0_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_35621 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35622 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : totally_disconnected_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_35623 (h0 : topological_space (has_neg_part (option unsigned))) : regular_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_35624 (h1 : topological_space (add_cancel_comm_monoid (random_gen string_imp))) : totally_disconnected_space (add_cancel_comm_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_35625 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35626 (h0 : uniform_space (ordered_comm_ring name)) : complete_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_35627 (h1 : ring (topological_space (comm_ring (comm_ring (comm_ring (comm_ring char)))))) : rank_condition (topological_space (comm_ring (comm_ring (comm_ring (comm_ring char))))) := sorry --non-trivial
lemma new_lemma_35628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35629 (h0 : finset (canonically_ordered_add_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35630 (h0 : topological_space (semi_normed_comm_ring (mul_one_class environment.projection_info))) : path_connected_space (semi_normed_comm_ring (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_35631 (h0 : functor.add_const (add_monoid (boolean_algebra name)) name) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_35632 (h0 : add_group (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : is_add_cyclic (with_one (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_35633 (h0 : functor.add_const (list (has_to_string linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35634 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35635 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add linarith.comp))))) : t0_space (boolean_algebra (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_35636 (h0 : not (topological_space (with_bot unsigned) -> false)) : @path_connected_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35637 (h0 : topological_space (normed_comm_ring (has_add (comm_group (has_add Type))))) : topological_space.separable_space (normed_comm_ring (has_add (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_35638 (h0 : functor.add_const (filter (has_nndist linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35639 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35640 (h0 : not (add_group (simple_graph enat) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} enat) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_35641 (h0 : filter (add_cancel_monoid (comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35642 (h0 : topological_space (has_le (mul_one_class (mul_one_class string.iterator_imp)))) (h3 : add_group (has_le (mul_one_class (mul_one_class string.iterator_imp)))) : topological_add_group (has_le (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_35643 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35644 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup ereal))) : complete_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_35645 (h0 : topological_space (semigroup pos)) : sequential_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_35646 (h1 : add_group (distrib_lattice (random_gen char))) : is_add_cyclic (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_35647 (h0 : measurable_space (has_append to_additive.value_type)) (h1 h2 : measure_theory.measure (has_append to_additive.value_type)) : measure_theory.measure.absolutely_continuous h1 h2 := sorry --non-trivial
lemma new_lemma_35648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_35649 (h0 : functor.add_const (topological_space (has_neg pos)) (has_add name)) : @normal_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35650 (h0 : complete_lattice (add_comm_semigroup reducibility_hints)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_35651 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @sequential_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35652 (h0 : measurable_space environment.projection_info) (h1 : has_sub environment.projection_info) : has_measurable_sub₂ environment.projection_info := sorry --non-trivial
lemma new_lemma_35653 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @regular_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_35654 (h0 : complete_lattice (ordered_comm_group unsigned)) : is_compactly_generated (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_35655 (h0 : function.extfun Type (functor.comp topological_space option)) : @sequential_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} option.{0}) h0 pos))))  := sorry --non-trivial
lemma new_lemma_35656 (h0 : topological_space (has_norm (random_gen linarith.comp_source))) : t0_space (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35657 (h0 : group (normed_comm_ring pos)) : is_simple_group (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_35658 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) (has_neg pos)) : @complete_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_35659 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35660 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_35661 (h1 : topological_space (has_compl (random_gen (random_gen (random_gen (random_gen string_imp)))))) : path_connected_space (has_compl (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_35662 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35663 (h0 : list (boolean_algebra.core (add_comm_monoid name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35664 (h0 : topological_space (has_neg (option ennreal))) : preirreducible_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_35665 (h0 : ring (boolean_algebra (has_add linarith.comp))) : is_principal_ideal_ring (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_35666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_35667 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) empty) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_35668 (h0 : functor.add_const (topological_space (has_to_string ennreal)) pos) : @preconnected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_35669 (h0 : list (has_ssubset (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35670 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (filter empty)) := sorry --non-trivial
lemma new_lemma_35671 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) environment.implicit_infer_kind) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_35672 (h0 : functor.comp cancel_comm_monoid_with_zero comm_group unsigned) : @unique_factorization_monoid.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_35673 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_35674 (h0 : topological_space (mul_one_class environment.projection_info)) : t0_space (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_35675 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_35676 (h0 : filter (cancel_monoid environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35677 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35678 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35679 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35680 (h0 : complete_lattice (monoid (has_zero (option unsigned)))) : is_atomistic (monoid (has_zero (option unsigned))) := sorry --non-trivial
lemma new_lemma_35681 (h0 : functor.comp cancel_comm_monoid_with_zero add_cancel_monoid ennreal) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} add_cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_35682 (h0 : functor.add_const (list (has_neg name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35683 (h0 : group (has_div string_imp)) : is_cyclic (has_div string_imp) := sorry --non-trivial
lemma new_lemma_35684 (h0 : fin has_zero.zero) : @discrete_topology.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35685 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35686 (h0 : group (semiring num)) : is_cyclic (semiring num) := sorry --non-trivial
lemma new_lemma_35687 (h0 : functor.add_const (complete_lattice (has_Sup empty)) (semiring empty)) : @is_atomistic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_35688 (h0 : functor.add_const (semiring (semigroup congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35689 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_35690 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_35691 (h0 : functor.add_const (ring (comm_group pos)) ennreal) : @strong_rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_35692 (h0 : topological_space (boolean_algebra.core (has_add (has_add Type)))) : regular_space (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_35693 (h0 : group (has_star (option empty))) : normalizer_condition (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_35694 (h0 : topological_space std_gen) : topological_space.first_countable_topology std_gen := sorry --non-trivial
lemma new_lemma_35695 (h0 : ring (normed_field (canonically_ordered_add_monoid string.iterator_imp))) : is_domain (normed_field (canonically_ordered_add_monoid string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_35696 (h0 : function.extfun Type topological_space) : @t0_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_35697 (h0 : uniform_space (simple_graph linarith.comp)) : separated_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_35698 (h0 : topological_space (has_top (has_norm (semiring empty)))) : normal_space (has_top (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_35699 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_35700 (h0 : functor.add_const (semiring (ring name)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35701 (h0 : semiring (canonically_linear_ordered_monoid (has_neg pos))) : is_noetherian_ring (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_35702 (h0 : not (topological_space (has_ssubset (random_gen string.iterator_imp)) -> false)) : @path_connected_space.{0} (has_ssubset.{0} (random_gen.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (random_gen.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_35703 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inter.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_35704 (h0 : uniform_space (has_inner empty num)) : separated_space (has_inner empty num) := sorry --non-trivial
lemma new_lemma_35705 (h0 : functor.add_const (function.extfun Type topological_space) (ring (has_neg (ring name)))) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} (has_neg.{0} (ring.{0} name))) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35706 (h0 : functor.add_const (filter (has_nndist linarith.comp)) (finset Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35707 (h0 : functor.add_const (semiring (measurable_space.dynkin_system unsigned)) unsigned) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35708 (h0 : ordered_comm_monoid (has_Inf (has_neg pos))) : has_exists_mul_of_le (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_35709 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_sub num)) := sorry --non-trivial
lemma new_lemma_35710 (h0 : group (canonically_linear_ordered_monoid (has_add (has_Inf (has_Inf pos))))) : is_cyclic (canonically_linear_ordered_monoid (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_35711 (h0 : add_monoid (has_add (has_add pos))) : add_monoid.fg (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_35712 (h0 : complete_lattice (has_top (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_35713 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_35714 (h0 : topological_space (has_Inf (has_neg (boolean_algebra.core Type)))) : sequential_space (has_Inf (has_neg (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_35715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35716 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option num)))))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_35717 (h0 : topological_space (cancel_monoid name)) : totally_disconnected_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_35718 (h1 : topological_space (semiring num)) : totally_separated_space (semiring num) := sorry --non-trivial
lemma new_lemma_35719 (h0 : topological_space (semigroup (has_to_string pos))) : normal_space (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_35720 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid empty)))) : @t0_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_35721 (h0 : filter (canonically_ordered_comm_semiring (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_35722 (h0 : functor.comp complete_lattice sub_neg_monoid Type) : @complete_lattice.is_Sup_finite_compact.{1} (sub_neg_monoid.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} sub_neg_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_35723 (h0 : topological_space (has_inner name (has_add Type))) : discrete_topology (has_inner name (has_add Type)) := sorry --non-trivial
lemma new_lemma_35724 (h0 : ring (has_ssubset (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (has_ssubset (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_35725 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_35726 (h0 : filter (add_left_cancel_semigroup (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35727 (h0 : add_group (has_ssubset to_additive.value_type)) : is_add_cyclic (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35728 (h0 : ring (encodable (random_gen (random_gen (random_gen to_additive.value_type))))) : is_domain (encodable (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_35729 (h0 : complete_lattice (non_assoc_semiring (semiring unsigned))) : is_compactly_generated (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35730 (h0 : topological_space (id (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : path_connected_space (id (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_35731 (h0 : group (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : is_cyclic (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35732 (h0 : topological_space (has_Inf (has_add (finset pos)))) : path_connected_space (has_Inf (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_35733 (h0 : topological_space (has_bot real)) : preirreducible_space (has_bot real) := sorry --non-trivial
lemma new_lemma_35734 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_35735 (h0 : functor.add_const (topological_space (has_neg unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35736 (h0 : topological_space (has_to_string (finset (has_add (finset pos))))) : t1_space (has_to_string (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_35737 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : topological_space.separable_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35738 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) num) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_35739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_35740 (h0 : ring (has_lt (mul_one_class (non_unital_non_assoc_semiring to_additive.value_type)))) : is_domain (has_lt (mul_one_class (non_unital_non_assoc_semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35741 (h0 : add_group (add_cancel_monoid (finset Type))) : is_add_cyclic (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_35742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35743 (h0 : complete_lattice (has_add (ring pos))) : complete_lattice.is_Sup_finite_compact (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_35744 (h0 : functor.add_const (add_group (normed_comm_ring pos)) (has_neg_part (boolean_algebra.core pos))) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} pos)) (has_neg_part.{0} (boolean_algebra.core.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_35745 (h0 : group (finset (option num))) : is_cyclic (finset (option num)) := sorry --non-trivial
lemma new_lemma_35746 (h1 : semiring (nondiscrete_normed_field (normed_field (normed_field (mul_one_class enat))))) (h2 : ideal (nondiscrete_normed_field (normed_field (normed_field (mul_one_class enat))))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_35747 (h0 : monoid (with_bot (has_inv (has_inv to_additive.value_type)))) : monoid.fg (with_bot (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35748 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (ring name)) : @topological_space.separable_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35749 (h0 : functor.add_const (add_group (semigroup Type)) unsigned) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35750 (h0 : topological_space (has_neg num)) : irreducible_space (has_neg num) := sorry --non-trivial
lemma new_lemma_35751 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_35752 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : discrete_topology (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_35753 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35754 (h0 : uniform_space (add_cancel_monoid (ring Type))) : complete_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_35755 (h0 : complete_lattice (comm_group (has_to_string ennreal))) : is_compactly_generated (comm_group (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_35756 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_35757 (h0 : not (complete_lattice (has_norm linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_35758 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) (option empty)) : @locally_compact_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_35759 (h0 : add_group (pseudo_metric_space (add_comm_monoid ennreal))) : is_add_cyclic (pseudo_metric_space (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_35760 (h0 : filter (complete_distrib_lattice (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35761 (h0 : add_group (semigroup (comm_group name))) : is_add_cyclic (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_35762 (h0 : not (group (partial_order congr_arg_kind) -> false)) : @is_cyclic.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_35763 (h0 : functor.add_const (ring (ordered_comm_ring pos)) Type) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_35764 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_35765 (h0 : ring (has_add (option ennreal))) : strong_rank_condition (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_35766 (h0 : topological_space ereal) (h2 : preorder ereal) : order_topology ereal := sorry --non-trivial
lemma new_lemma_35767 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) pos) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_35768 (h1 : ring (has_emptyc linarith.ineq)) : is_domain (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_35769 (h0 : ring (complete_distrib_lattice (random_gen char))) : strong_rank_condition (complete_distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_35770 (h0 : nat) (h1 : fin (nat.succ h0) -> Prop) (h2 : fin h0) : matrix.vec_tail h1 h2 := sorry --non-trivial
lemma new_lemma_35771 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35772 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_35773 (h0 : ring (has_nnnorm (mul_one_class reducibility_hints))) : rank_condition (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_35774 (h0 : topological_space (boolean_algebra (ring pos))) : normal_space (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_35775 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35776 (h0 : list (complete_distrib_lattice (cancel_monoid (has_neg_part Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_35777 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35778 (h0 : uniform_space (ordered_ring num)) : separated_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_35779 (h0 : functor.add_const (function.extfun Type list) (has_neg pos)) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_35780 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_35781 (h0 : ring (monoid string_imp)) : is_domain (monoid string_imp) := sorry --non-trivial
lemma new_lemma_35782 (h0 : complete_lattice (linear_ordered_comm_ring empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_35783 (h0 : ring (has_compl (mul_one_class (mul_one_class to_additive.value_type)))) : rank_condition (has_compl (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35784 (h0 : ring (ordered_comm_ring (has_add linarith.comp))) : rank_condition (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_35785 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring (semiring (has_top num))))) : locally_compact_space (linear_ordered_comm_monoid_with_zero (semiring (semiring (has_top num)))) := sorry --non-trivial
lemma new_lemma_35786 (h0 : filter (with_one reducibility_hints)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35787 (h1 : topological_space (random_gen (has_ssubset (has_ssubset char)))) : path_connected_space (random_gen (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_35788 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_35789 (h0 : complete_lattice (finset (finset Type))) : is_atomistic (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_35790 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_35791 (h0 : ring (linear_ordered_add_comm_group (has_append linarith.comp_source))) : strong_rank_condition (linear_ordered_add_comm_group (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_35792 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @loc_path_connected_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_35793 (h0 : ring (canonically_linear_ordered_monoid (option (option (option ennreal))))) : is_domain (canonically_linear_ordered_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_35794 (h0 : not (add_group (linear_ordered_add_comm_group (has_nnnorm fun_info)) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_35795 (h0 : uniform_space (with_bot (has_inv fun_info))) : complete_space (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_35796 (h0 : not (topological_space (left_cancel_monoid empty) -> false)) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_35797 (h0 : topological_space (semigroup Type)) : loc_path_connected_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_35798 (h0 : functor.add_const (filter (ring Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_35799 (h0 : topological_space (has_neg_part (finset name))) : t1_space (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_35800 (h0 : group (linear_ordered_field linarith.comp)) : group.fg (linear_ordered_field linarith.comp) := sorry --non-trivial
lemma new_lemma_35801 (h0 : add_group (has_top fun_info)) : is_add_cyclic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_35802 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf name))) : has_exists_mul_of_le (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_35803 (h0 : topological_space (has_zero (comm_group pos))) : regular_space (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_35804 (h0 : group (linear_ordered_semiring num)) : group.fg (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_35805 (h3 : set (enat -> ereal)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_35806 (h0 : set (has_compl linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35807 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @loc_path_connected_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_35808 (h0 : topological_space linarith.ineq) : irreducible_space linarith.ineq := sorry --non-trivial
lemma new_lemma_35809 (h0 : functor.add_const (ring (sub_neg_monoid environment.implicit_infer_kind)) name) : @rank_condition.{0} (sub_neg_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_35810 (h0 : has_add (partial_order fun_info)) (h1 : topological_space (add_con (partial_order fun_info))) : totally_disconnected_space (add_con (partial_order fun_info)) := sorry --non-trivial
lemma new_lemma_35811 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_35812 (h0 : topological_space (semigroup (has_neg_part Type))) : preconnected_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_35813 (h0 : topological_space (cancel_monoid unsigned)) : loc_path_connected_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_35814 (h1 : topological_space (uniform_space std_gen)) : totally_disconnected_space (uniform_space std_gen) := sorry --non-trivial
lemma new_lemma_35815 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35816 (h0 : topological_space (left_cancel_monoid (semiring unsigned))) : irreducible_space (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35817 (h0 : add_group (comm_ring (has_inv (topological_space char)))) : is_add_cyclic (comm_ring (has_inv (topological_space char))) := sorry --non-trivial
lemma new_lemma_35818 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35819 (h0 : monoid (generalized_boolean_algebra linarith.comp)) : monoid.fg (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_35820 (h0 : ring (has_nnnorm (mul_one_class (has_nnnorm (mul_one_class linarith.comp_source))))) : rank_condition (has_nnnorm (mul_one_class (has_nnnorm (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_35821 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_35822 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) (h1 : set (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_35823 (h0 : complete_lattice (has_one (semiring (semiring num)))) : is_compactly_generated (has_one (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_35824 (h0 : functor.add_const (ring (bin_tree empty)) congr_arg_kind) : @is_domain.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_35825 (h0 : prod (measure_theory.measure_space empty) (measure_theory.measure_space empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_35826 (h0 : set (has_lt string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_35827 (h0 : semiring (canonically_ordered_monoid Type)) : is_noetherian_ring (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_35828 (h0 : function.extfun nat fin) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_35829 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_35830 (h0 : functor.add_const (topological_space (add_group empty)) congr_arg_kind) : @totally_separated_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_35831 (h0 : topological_space (complete_semilattice_Sup (has_ssubset (has_ssubset (has_ssubset fun_info))))) : locally_compact_space (complete_semilattice_Sup (has_ssubset (has_ssubset (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_35832 (h0 : add_monoid (with_one (has_top (semiring num)))) : add_monoid.fg (with_one (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_35833 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_35834 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (group_with_zero empty)) := sorry --non-trivial
lemma new_lemma_35835 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (matrix.vec_empty (id h0)))))) := sorry --non-trivial
lemma new_lemma_35836 (h0 : group (left_cancel_monoid (semiring unsigned))) : is_simple_group (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35837 (h0 : functor.add_const (ring (ring Type)) linarith.comp) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35838 (h0 : monoid (has_nndist (option (option (option (option ennreal)))))) : monoid.fg (has_nndist (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_35839 (h0 : topological_space (comm_group (has_neg_part pos))) : discrete_topology (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_35840 (h0 : topological_space (random_gen (has_norm empty))) : locally_compact_space (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_35841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_35842 (h0 : topological_space (group_with_zero (option congr_arg_kind))) : locally_compact_space (group_with_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35843 (h0 : complete_lattice (topological_space (topological_space (fintype linarith.ineq)))) : is_compactly_generated (topological_space (topological_space (fintype linarith.ineq))) := sorry --non-trivial
lemma new_lemma_35844 (h0 : group (finset (has_to_string (has_to_string (has_to_string pos))))) : is_cyclic (finset (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_35845 (h2 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35846 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_35847 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) : with_bot.unbot h0 h1 := sorry --non-trivial
lemma new_lemma_35848 (h0 : functor.add_const (add_group (add_comm_monoid environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_35849 (h0 : add_group (add_comm_semigroup (mul_one_class environment.projection_info))) : is_add_cyclic (add_comm_semigroup (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_35850 (h0 : complete_lattice (has_ssubset (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35851 (h0 : filter (dlist (has_inv string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35852 (h0 : nat) (h1 : list nat) : nat.less_than_or_equal h0 (list.head h1) := sorry --non-trivial
lemma new_lemma_35853 (h0 : functor.add_const (group (has_to_string ennreal)) unsigned) : @is_cyclic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35854 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_norm congr_arg_kind) h0) := sorry --non-trivial
lemma new_lemma_35855 (h0 : topological_space (has_neg (has_pos_part pos))) : preconnected_space (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_35856 (h0 : ring (generalized_boolean_algebra (has_Inf (has_add (has_add (has_add (has_Inf pos))))))) : rank_condition (generalized_boolean_algebra (has_Inf (has_add (has_add (has_add (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_35857 (h0 : functor.add_const (ring (boolean_algebra pos)) environment.implicit_infer_kind) : @is_domain.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35858 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring (ring (ring Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_35859 (h1 : topological_space (with_zero char)) : path_connected_space (with_zero char) := sorry --non-trivial
lemma new_lemma_35860 (h0 : list (monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_35861 (h0 : functor.add_const (ring (plift num)) unsigned) : @strong_rank_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_35862 (h0 : uniform_space (semi_normed_ring std_gen)) : complete_space (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_35863 (h0 : complete_lattice (has_pos_part (has_Inf (has_Inf (has_add Type))))) : is_compactly_generated (has_pos_part (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_35864 (h0 : topological_space (finset (has_pos_part (has_neg (has_to_string environment.implicit_infer_kind))))) : t0_space (finset (has_pos_part (has_neg (has_to_string environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_35865 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_35866 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_35867 (h0 : ring (has_nnnorm (random_gen to_additive.value_type))) : strong_rank_condition (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_35868 (h0 : ordered_add_comm_monoid (group_with_zero (option ennreal))) : archimedean (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_35869 (h0 : function.extfun Type (functor.add_const (ring znum))) : @is_principal_ideal_ring.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_35870 (h0 : topological_space (mul_zero_class (finset Type))) : totally_disconnected_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_35871 (h0 : complete_lattice (normed_group (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35872 (h0 : functor.add_const (function.extfun Type finset) (finset (finset environment.implicit_infer_kind))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_35873 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_35874 (h0 : function.extfun Type group) : @is_cyclic.{0} pos (@function.extfun_app.{2 1} Type group.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_35875 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_35876 (h0 : monoid (has_top (semiring (has_norm (linear_ordered_semiring empty))))) : monoid.fg (has_top (semiring (has_norm (linear_ordered_semiring empty)))) := sorry --non-trivial
lemma new_lemma_35877 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35878 (h0 : topological_space (bin_tree (semiring (option (semiring empty))))) : loc_path_connected_space (bin_tree (semiring (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_35879 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_35880 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_35881 (h0 : filter (has_Inf (has_pos_part (has_add (has_add pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35882 (h1 : ring (with_bot linarith.comp_source)) : rank_condition (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35883 (h0 : function.extfun Type group) : @group.fg.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_35884 (h0 : topological_space (measurable_space (semiring num))) : discrete_topology (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_35885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_35886 (h0 : topological_space (comm_group (has_neg name))) : t0_space (comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_35887 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) real.angle)  := sorry --non-trivial
lemma new_lemma_35888 (h0 : uniform_space (complete_linear_order (ordered_cancel_comm_monoid congr_arg_kind))) : separated_space (complete_linear_order (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_35889 (h0 : uniform_space (measure_theory.measure_space congr_arg_kind)) : complete_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_35890 (h0 : functor.comp uniform_space has_add environment.implicit_infer_kind) : @complete_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35891 (h0 : uniform_space (topological_space (has_nnnorm (denumerable reducibility_hints)))) : complete_space (topological_space (has_nnnorm (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_35892 (h0 : list (id num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35893 (h1 : set (has_nnnorm (has_top to_additive.value_type))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_35894 (h0 : function.extfun Type ring) : @rank_condition.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_35895 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35896 (h0 : functor.add_const (topological_space (normed_comm_ring name)) (has_to_string Type)) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_35897 (h0 : group (complete_semilattice_Sup (random_gen (has_inv to_additive.value_type)))) : is_cyclic (complete_semilattice_Sup (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_35898 (h0 : filter (boolean_algebra.core (has_neg_part pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35899 (h0 : ring (add_cancel_comm_monoid unsigned)) : strong_rank_condition (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_35900 (h0 : complete_lattice (with_bot (with_bot (with_bot string_imp)))) : complete_lattice.is_Sup_finite_compact (with_bot (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_35901 (h1 : topological_space (add_cancel_comm_monoid linarith.comp_source)) : totally_disconnected_space (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35902 (h0 : ring (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_35903 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_35904 (h0 : not (topological_space (has_union unsigned) -> false)) : @discrete_topology.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35905 (h0 : functor.add_const (ring pos) linarith.comp) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35906 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg pos)))) : normal_space (generalized_boolean_algebra (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_35907 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) Type) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_35908 (h2 : ring (mul_one_class (has_ssubset ereal))) : is_domain (mul_one_class (has_ssubset ereal)) := sorry --non-trivial
lemma new_lemma_35909 (h0 : functor.add_const (ring (has_neg pos)) environment.implicit_infer_kind) : @rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35910 (h0 : ring (has_pos_part linarith.comp)) : strong_rank_condition (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_35911 (h0 : functor.add_const (group (has_add Type)) linarith.comp) : @group.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_35912 (h0 : topological_space (semi_normed_comm_ring (has_ssubset linarith.ineq))) : locally_compact_space (semi_normed_comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35913 (h0 : topological_space (has_emptyc to_additive.value_type)) : locally_compact_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_35914 (h0 : ring (normed_group (has_ssubset (has_ssubset fun_info)))) : is_domain (normed_group (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_35915 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_35916 (h0 : functor.add_const (function.extfun Type add_group) unsigned) : @is_add_cyclic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) unsigned h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_35917 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) pos) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_35918 (h0 : topological_space (simple_graph (boolean_algebra.core (has_nndist pos)))) : totally_separated_space (simple_graph (boolean_algebra.core (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_35919 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_35920 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : loc_path_connected_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_35921 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_35922 (h0 : functor.comp (functor.comp ring has_neg_part) with_top nnreal) : @strong_rank_condition.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} ring.{0} has_neg_part.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_35923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_35924 (h1 : ring (mul_one_class ereal)) : strong_rank_condition (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_35925 (h0 : uniform_space (linear_ordered_cancel_comm_monoid unsigned)) : complete_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_35926 (h0 : topological_space (metric_space linarith.comp_source)) : t0_space (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35927 (h1 : complete_lattice linarith.comp) : is_compactly_generated linarith.comp := sorry --non-trivial
lemma new_lemma_35928 (h0 : finset (boolean_algebra.core (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_35929 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_35930 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_35931 (h0 h1 : multiset (linear_ordered_comm_group_with_zero enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_35932 (h0 : ring (has_top (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : is_domain (has_top (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_35933 (h0 : functor.add_const (add_group (semigroup Type)) (finset (finset linarith.comp))) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (semigroup.{1} Type)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_35934 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) linarith.comp) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_35935 (h0 : topological_space (has_bot (option unsigned))) : t0_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_35936 (h0 : complete_distrib_lattice Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_35937 (h0 : monoid (ordered_comm_monoid (has_neg (has_neg pos)))) : monoid.fg (ordered_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_35938 (h0 : ordered_add_comm_monoid (semigroup num)) : archimedean (semigroup num) := sorry --non-trivial
lemma new_lemma_35939 (h0 : functor.add_const (topological_space (boolean_algebra name)) (comm_group name)) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_35940 (h0 : add_group (has_sub (semiring linarith.comp))) : is_add_cyclic (has_sub (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_35941 (h0 : fin has_zero.zero) : @archimedean.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_35942 (h0 : topological_space (has_neg_part (has_add Type))) : irreducible_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_35943 (h0 : topological_space (add_semigroup (complete_distrib_lattice unsigned))) : preirreducible_space (add_semigroup (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_35944 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_35945 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_35946 (h0 : topological_space (add_comm_semigroup enat)) : t0_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_35947 (h0 h1 : multiset environment.projection_info) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_35948 (h0 : topological_space (comm_group (has_add pos))) : locally_compact_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_35949 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_35950 (h2 h3 : enat) : eq h2 h3 := sorry --non-trivial
lemma new_lemma_35951 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @totally_disconnected_space.{0} unsigned (@finset.pi.empty.{1 0} Type topological_space.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_35952 (h0 : uniform_space (denumerable (has_nnnorm (random_gen (random_gen linarith.ineq))))) : complete_space (denumerable (has_nnnorm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_35953 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_35954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_35955 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_35956 (h0 : uniform_space (ring (comm_group (comm_group (comm_group pos))))) : complete_space (ring (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_35957 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_35958 (h0 : topological_space (add_left_cancel_monoid (random_gen fun_info))) : totally_disconnected_space (add_left_cancel_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_35959 (h0 : not (add_monoid (metric_space unsigned) -> false)) : @add_monoid.fg.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_35960 (h0 : complete_lattice (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind))) : is_compactly_generated (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35961 (h1 : complete_lattice (has_top (has_inv string_imp))) : is_compactly_generated (has_top (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_35962 (h0 : add_monoid (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : add_monoid.fg (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_35963 (h0 : group (linear_ordered_cancel_comm_monoid (semiring empty))) : normalizer_condition (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_35964 (h0 : topological_space (has_Inf pos)) : topological_space.separable_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_35965 (h0 : ring (has_append (comm_ring linarith.ineq))) : rank_condition (has_append (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_35966 (h0 : has_mem.mem (linear_ordered_add_comm_group (has_top (has_top fun_info))) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} (has_top.{0} (has_top.{0} fun_info))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} (has_top.{0} (has_top.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_35967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_35968 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @t0_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_35969 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_35970 (h0 : add_monoid (ordered_comm_monoid linarith.comp)) : add_monoid.fg (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_35971 (h0 : topological_space (mul_zero_class (ring (has_to_string pos)))) : preconnected_space (mul_zero_class (ring (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_35972 (h0 : add_monoid (boolean_algebra (has_neg (finset environment.implicit_infer_kind)))) : add_monoid.fg (boolean_algebra (has_neg (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_35973 (h1 : topological_space (linear_ordered_comm_group_with_zero environment.projection_info)) (h2 : preorder (linear_ordered_comm_group_with_zero environment.projection_info)) : order_topology (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_35974 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_35975 (h0 : functor.comp (functor.add_const (topological_space (has_neg name))) boolean_algebra (boolean_algebra name)) : @preirreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) (boolean_algebra.{0} (boolean_algebra.{0} name)) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (topological_space.{0} (has_neg.{0} name))) boolean_algebra.{0} (boolean_algebra.{0} name) h0))  := sorry --non-trivial
lemma new_lemma_35976 (h0 : fin has_zero.zero) : @irreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_35977 (h0 : add_monoid (normed_comm_ring (has_to_string (has_to_string (has_to_string unsigned))))) : add_monoid.fg (normed_comm_ring (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_35978 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_35979 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_35980 (h0 : group (option (semiring (semiring (semiring empty))))) : normalizer_condition (option (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_35981 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t0_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_35982 (h0 : not (ring (partial_order num) -> false)) : @rank_condition.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_35983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : set (has_emptyc linarith.comp_source)) : @bdd_above.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type preorder.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 preorder.{0}) (has_emptyc.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_35985 (h0 : topological_space (has_Inf (has_pos_part (finset (finset linarith.comp))))) : discrete_topology (has_Inf (has_pos_part (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_35986 (h0 : list (canonically_linear_ordered_monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_35987 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist pos)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_35988 (h1 : topological_space (semi_normed_ring linarith.comp_source)) : totally_disconnected_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_35989 (h0 : topological_space (cancel_monoid (has_add name))) : locally_compact_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_35990 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) (semiring empty)) : @t1_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_35991 (h0 : complete_lattice (has_edist (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_35992 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf (has_Inf pos)))) : totally_separated_space (canonically_ordered_comm_semiring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_35993 (h0 : monoid (has_zero (has_neg pos))) : monoid.fg (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_35994 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (semiring unsigned))) : archimedean (add_left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_35995 (h0 : filter (add_cancel_monoid (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_35996 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_35997 (h0 : functor.add_const (functor.comp group has_neg ennreal) pos) : @group.fg.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} has_neg.{0} ennreal) pos h0))  := sorry --non-trivial
lemma new_lemma_35998 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group unsigned)))) : sequential_space (add_cancel_monoid (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_35999 (h0 : not (topological_space (uniform_space linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_36000 (h0 : group (ordered_cancel_add_comm_monoid (option (option (option (option ennreal)))))) : is_simple_group (ordered_cancel_add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_36001 (h1 : uniform_space (with_one string_imp)) : complete_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_36002 (h1 : complete_lattice (semiring (normed_group to_additive.value_type))) : is_compactly_generated (semiring (normed_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36003 (h0 : list (has_inter (option (option num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_36005 (h0 : add_group (monoid (comm_monoid (comm_monoid unsigned)))) : is_add_cyclic (monoid (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_36006 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_36007 (h0 : group (semiring (semiring (has_top (semiring congr_arg_kind))))) : is_cyclic (semiring (semiring (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_36008 (h0 : not (group (semi_normed_ring linarith.ineq) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_36009 (h0 : monoid (normed_lattice_add_comm_group (has_add (has_add (has_add linarith.comp))))) : monoid.fg (normed_lattice_add_comm_group (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36010 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_36011 (h0 : group (id (semiring (semiring unsigned)))) : normalizer_condition (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_36012 (h0 : functor.add_const (ordered_add_comm_monoid (preorder num)) unsigned) : @archimedean.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36013 (h0 : finset (has_Inf name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36014 (h0 : comm_semiring (add_left_cancel_monoid string_imp)) (h1 : topological_space (linear_recurrence (add_left_cancel_monoid string_imp))) : t0_space (linear_recurrence (add_left_cancel_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_36015 (h0 : topological_space (complete_distrib_lattice (has_add (has_add linarith.comp)))) : t1_space (complete_distrib_lattice (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_36016 (h0 : ring (monoid (option empty))) : is_domain (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_36017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_36018 (h1 : uniform_space (has_add (fintype to_additive.value_type))) : complete_space (has_add (fintype to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) empty)  := sorry --non-trivial
lemma new_lemma_36020 (h0 : topological_space (boolean_algebra.core (option unsigned))) : locally_compact_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_36021 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36022 (h0 : semiring (simple_graph (has_neg Type))) : is_noetherian_ring (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_36023 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : regular_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_36024 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36025 (h0 : uniform_space (partial_order (partial_order (has_star congr_arg_kind)))) : separated_space (partial_order (partial_order (has_star congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_36026 (h0 : topological_space (boolean_algebra (has_Inf pos))) : discrete_topology (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_36027 (h0 : ring (has_add linarith.comp)) : strong_rank_condition (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_36028 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_36029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36030 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add (has_Inf linarith.comp))))) : preconnected_space (sub_neg_monoid (has_Inf (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36031 (h0 : topological_space (free_add_monoid (semiring (semiring empty)))) : locally_compact_space (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_36032 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36033 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36034 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_36035 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : loc_path_connected_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_36036 (h0 : functor.add_const (topological_space (partial_order num)) num) : @t0_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_36037 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @path_connected_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_36038 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @locally_compact_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36039 (h1 : topological_space (has_nnnorm (random_gen fun_info))) : locally_compact_space (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_36040 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_36041 (h0 : has_add fun_info) (h1 : ring (add_con fun_info)) : strong_rank_condition (add_con fun_info) := sorry --non-trivial
lemma new_lemma_36042 (h0 : group (boolean_algebra (ring (finset (finset linarith.comp))))) : group.fg (boolean_algebra (ring (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36043 (h0 : functor.add_const Prop (linear_ordered_semiring (has_norm (linear_ordered_semiring empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_36044 (h0 : linarith.comp_source -> random_gen (has_nnnorm (has_nnnorm linarith.comp_source)) -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_36045 (h0 : add_group (has_neg (finset Type))) : is_add_cyclic (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_36046 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_36047 (h0 : ring (semiring (random_gen linarith.comp_source))) : is_domain (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_36048 (h0 : not (uniform_space (measure_theory.measure_space empty) -> false)) : @separated_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36049 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36050 (h0 : topological_space (boolean_algebra pos)) : t0_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_36051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36052 (h0 : topological_space (complete_distrib_lattice pos)) : normal_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_36053 (h0 : set (fun_info -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_36054 (h0 : group (bin_tree (semiring num))) : normalizer_condition (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_36055 (h0 : has_mem.mem (normed_group (random_gen linarith.comp_source)) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_36056 (h0 : comm_semiring char) (h1 : polynomial char) : polynomial.is_primitive h1 := sorry --non-trivial
lemma new_lemma_36057 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36058 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) name) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_36059 (h0 : uniform_space (denumerable (fintype fun_info))) : complete_space (denumerable (fintype fun_info)) := sorry --non-trivial
lemma new_lemma_36060 (h0 : has_add (linear_ordered_field pos) -> has_add (linear_ordered_field pos) -> Prop) : is_symm (has_add (linear_ordered_field pos)) h0 := sorry --non-trivial
lemma new_lemma_36061 (h0 : complete_lattice (measurable_space (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_36062 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_36063 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) pos) : @separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36064 (h0 : add_group (random_gen (random_gen (has_top linarith.comp_source)))) : is_add_cyclic (random_gen (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_36065 (h0 : topological_space (with_one unsigned)) : preirreducible_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_36066 (h0 : finset (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36067 (h0 : topological_space (has_bot (has_bot (has_bot name)))) : preirreducible_space (has_bot (has_bot (has_bot name))) := sorry --non-trivial
lemma new_lemma_36068 (h0 : monoid (distrib_lattice (has_inv (has_inv (random_gen fun_info))))) : monoid.fg (distrib_lattice (has_inv (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_36069 (h0 : complete_lattice (has_top (semiring (has_norm num)))) : complete_lattice.is_Sup_finite_compact (has_top (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_36070 (h0 : complete_lattice (has_pos_part (normed_comm_ring (has_Inf linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (normed_comm_ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_36071 (h0 : topological_space (has_to_string (has_to_string Type))) : irreducible_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_36072 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_36073 (h0 : topological_space (has_pos_part (has_neg (has_neg name)))) : totally_separated_space (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_36074 (h0 : complete_lattice (linear_ordered_field ennreal)) : complete_lattice.is_Sup_finite_compact (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_36075 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) unsigned) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36076 (h0 : topological_space (has_top (random_gen to_additive.value_type))) : locally_compact_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36077 (h0 : uniform_space (has_pos_part (has_neg pos))) : complete_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_36078 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_36079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_36080 (h0 : add_group (fintype string_imp)) : is_add_cyclic (fintype string_imp) := sorry --non-trivial
lemma new_lemma_36081 (h0 : topological_space (boolean_algebra (has_add (has_add (has_neg_part unsigned))))) : t1_space (boolean_algebra (has_add (has_add (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_36082 (h0 : topological_space (semigroup (has_nndist pos))) : t1_space (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_36083 (h0 : not (complete_lattice (has_ssubset to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_36084 (h0 : topological_space (has_pos_part (add_comm_monoid unsigned))) : path_connected_space (has_pos_part (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_36085 (h0 : partial_order (metric_space linarith.comp)) (h1 : not (order_top (metric_space linarith.comp) -> false)) : @is_coatomic.{0} (metric_space.{0} linarith.comp) h0 (@classical.by_contradiction'.{1} (@order_top.{0} (metric_space.{0} linarith.comp) (@preorder.to_has_le.{0} (metric_space.{0} linarith.comp) (@partial_order.to_preorder.{0} (metric_space.{0} linarith.comp) h0))) h1)  := sorry --non-trivial
lemma new_lemma_36086 (h0 : function.extfun Type (functor.add_const (list auto.case_option))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_36087 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup to_additive.value_type))) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36088 (h0 : ring (add_monoid linarith.comp_source)) : rank_condition (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36089 (h0 : ring (comm_ring (comm_ring char))) : strong_rank_condition (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_36090 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_36091 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) Type) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_36092 (h0 : topological_space (ring (has_add (mul_one_class pos)))) : sequential_space (ring (has_add (mul_one_class pos))) := sorry --non-trivial
lemma new_lemma_36093 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_36094 (h0 : topological_space (canonically_ordered_add_monoid empty)) : preirreducible_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_36095 (h0 : functor.add_const (add_group (rel empty unsigned)) empty) : @is_add_cyclic.{0} (rel.{0 0} empty unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (rel.{0 0} empty unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_36096 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_36097 (h0 : ordered_comm_monoid (finset (has_add linarith.comp))) : has_exists_mul_of_le (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_36098 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_36099 (h1 : ring (linear_ordered_add_comm_group to_additive.value_type)) : is_domain (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36100 (h0 : ring (add_right_cancel_monoid (has_top (has_top num)))) : rank_condition (add_right_cancel_monoid (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_36101 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @totally_separated_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_36102 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normal_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_36103 (h0 : ring (semi_normed_ring linarith.comp_source)) : strong_rank_condition (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36104 (h0 : topological_space (semigroup ennreal)) : sequential_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_36105 (h0 : list (comm_ring (denumerable fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36106 (h0 : topological_space (semigroup pos)) : locally_compact_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_36107 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_36108 (h0 : monoid (non_assoc_semiring (semiring (semiring (semiring num))))) : monoid.fg (non_assoc_semiring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_36109 (h0 : ring (boolean_algebra (has_add linarith.comp))) : rank_condition (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_36110 (h0 : functor.add_const Prop (add_group num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_36111 (h0 : topological_space (add_cancel_monoid (option (option (option pos))))) : totally_separated_space (add_cancel_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_36112 (h0 : cancel_comm_monoid_with_zero (has_neg (has_to_string (has_to_string (has_to_string pos))))) : unique_factorization_monoid (has_neg (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_36113 (h0 : ring (boolean_algebra.core (has_add (comm_group (has_nndist Type))))) : is_principal_ideal_ring (boolean_algebra.core (has_add (comm_group (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_36114 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36115 (h0 : topological_space (ring (has_pos_part linarith.comp))) : totally_separated_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_36116 (h0 : ring (ring (ring linarith.comp))) : rank_condition (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_36117 (h0 : ring (id (semiring (has_top (has_top unsigned))))) : rank_condition (id (semiring (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_36118 (h0 : topological_space (distrib (has_ssubset char))) : path_connected_space (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_36119 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_36120 (h0 : functor.add_const (group (has_Inf linarith.comp)) pos) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36121 (h0 : add_comm_semigroup std_gen -> add_comm_semigroup std_gen -> Prop) (h1 : set (add_comm_semigroup std_gen)) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_36122 (h0 : topological_space (semiring to_additive.value_type)) : path_connected_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36123 (h0 : cancel_comm_monoid_with_zero (metric_space (has_top empty))) : unique_factorization_monoid (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_36124 (h0 : ring (linear_ordered_add_comm_group reducibility_hints)) : is_domain (linear_ordered_add_comm_group reducibility_hints) := sorry --non-trivial
lemma new_lemma_36125 (h0 : topological_space string.iterator) (h1 : preorder string.iterator) : order_closed_topology string.iterator := sorry --non-trivial
lemma new_lemma_36126 (h0 : group (has_norm (has_top fun_info))) : is_cyclic (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_36127 (h0 : topological_space (add_left_cancel_semigroup empty)) : loc_path_connected_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_36128 (h0 : group (complete_semilattice_Sup fun_info)) : normalizer_condition (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_36129 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type))) : t0_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36130 (h0 : topological_space (complete_distrib_lattice (has_pos_part (has_nndist Type)))) : preirreducible_space (complete_distrib_lattice (has_pos_part (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_36131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_36132 (h0 : ring (has_add (has_Inf (has_Inf pos)))) : is_principal_ideal_ring (has_add (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_36133 (h0 : not (Type -> false)) (h1 : eq (add_group (uniform_space reducibility_hints)) (classical.by_contradiction' h0)) (h2 : classical.by_contradiction' h0) : @is_add_cyclic.{0} (uniform_space.{0} reducibility_hints) (@eq.mpr.{1} (add_group.{0} (uniform_space.{0} reducibility_hints)) (@classical.by_contradiction'.{2} Type h0) h1 h2)  := sorry --non-trivial
lemma new_lemma_36134 (h0 : uniform_space (with_bot (has_sub linarith.comp))) (h1 : add_group (with_bot (has_sub linarith.comp))) : uniform_add_group (with_bot (has_sub linarith.comp)) := sorry --non-trivial
lemma new_lemma_36135 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg (has_neg Type))) : @t0_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} (has_neg.{1} Type)) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_36136 (h0 : group (normed_comm_ring pos)) : is_cyclic (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_36137 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : t0_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_36138 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36139 (h0 : uniform_space (add_comm_monoid (has_add (has_neg (has_add (ring (ring (has_add linarith.comp)))))))) : complete_space (add_comm_monoid (has_add (has_neg (has_add (ring (ring (has_add linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_36140 (h0 : monoid (add_cancel_monoid empty)) : monoid.fg (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_36141 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36142 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_36143 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36144 (h0 : group (comm_semigroup (has_scalar (sub_neg_monoid Type) real))) : is_simple_group (comm_semigroup (has_scalar (sub_neg_monoid Type) real)) := sorry --non-trivial
lemma new_lemma_36145 (h0 : topological_space (add_comm_monoid (cancel_monoid linarith.comp))) : locally_compact_space (add_comm_monoid (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_36146 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring (semiring empty))))))) : t0_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_36147 (h0 : ordered_add_comm_monoid (has_Sup (semiring (ordered_ring (semiring empty))))) : archimedean (has_Sup (semiring (ordered_ring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_36148 (h0 : topological_space (has_nndist (finset (finset name)))) : path_connected_space (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_36149 (h0 : topological_space (has_dist (option (option empty)))) : t0_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_36150 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_36151 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36152 (h0 : functor.add_const (ring (finset Type)) Type) : @is_domain.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_36153 (h0 : complete_lattice (complete_distrib_lattice (boolean_algebra environment.implicit_infer_kind))) : is_compactly_generated (complete_distrib_lattice (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_36154 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36156 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36157 (h0 : uniform_space (has_norm (semiring empty))) : separated_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_36158 (h0 : list (comm_group Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36159 (h0 : ring (nondiscrete_normed_field (mul_one_class environment.projection_info))) : is_domain (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_36160 (h0 : ring (ordered_ring (option (option (semiring (semiring congr_arg_kind)))))) : rank_condition (ordered_ring (option (option (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_36161 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36162 (h0 : uniform_space (has_pos_part (has_top num))) : separated_space (has_pos_part (has_top num)) := sorry --non-trivial
lemma new_lemma_36163 (h0 : ordered_add_comm_monoid (add_cancel_monoid num)) : archimedean (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_36164 (h0 : add_group (canonically_linear_ordered_monoid (finset Type))) : is_add_cyclic (canonically_linear_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_36165 (h0 : functor.add_const (complete_lattice (linear_ordered_field ennreal)) ennreal) : @is_compactly_generated.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_36166 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (has_neg_part pos)) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_36167 (h0 : not (topological_space (simple_graph (mul_one_class to_additive.value_type)) -> false)) : @t0_space.{0} (simple_graph.{0} (mul_one_class.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} (mul_one_class.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_36168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_36169 (h0 : group (metric_space (with_one unsigned))) : is_cyclic (metric_space (with_one unsigned)) := sorry --non-trivial
lemma new_lemma_36170 (h0 : ring (normed_comm_ring (has_Inf linarith.comp))) : strong_rank_condition (normed_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_36171 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_36172 (h0 : topological_space (distrib to_additive.value_type)) : t0_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36173 (h0 : add_monoid (linear_ordered_semiring unsigned)) : add_monoid.fg (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_36174 (h0 : topological_space (has_top (has_ssubset linarith.ineq))) : path_connected_space (has_top (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36175 (h0 : topological_space (has_neg_part (has_add pos))) : preirreducible_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_36176 (h0 : ring (semigroup unsigned)) : is_principal_ideal_ring (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_36177 (h0 : topological_space (add_comm_monoid (has_neg (has_neg pos)))) : totally_disconnected_space (add_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_36178 (h0 : ring (has_add (has_Inf (ordered_comm_monoid real)))) : rank_condition (has_add (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_36179 (h0 : topological_space (finset (has_neg linarith.comp))) : regular_space (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_36180 (h0 : functor.add_const (monoid (cancel_monoid ennreal)) ennreal) : @monoid.fg.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_36181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36182 (h0 : monoid (normed_group (has_norm linarith.ineq))) : monoid.fg (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36183 (h0 : group (has_bot (has_add (has_add real)))) : group.fg (has_bot (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_36184 (h0 : group (ordered_comm_ring (finset (finset linarith.comp)))) : is_cyclic (ordered_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_36185 (h0 : topological_space (bin_tree (option unsigned))) : preirreducible_space (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_36186 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_36187 (h0 : filter (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36188 (h0 : has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_36189 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_36190 (h0 : topological_space (semigroup linarith.comp)) : discrete_topology (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_36191 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_36192 (h0 : group (distrib_lattice linarith.ineq)) : normalizer_condition (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_36193 (h0 : uniform_space (has_emptyc (random_gen num))) : separated_space (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_36194 (h0 : group (id empty)) : group.fg (id empty) := sorry --non-trivial
lemma new_lemma_36195 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36196 (h0 : group (with_one (has_top (has_top linarith.ineq)))) : normalizer_condition (with_one (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36197 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) pos) : @separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_36198 (h0 : functor.add_const (functor.add_const (list Type) linarith.comp) pos) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_36199 (h0 : not (topological_space (normed_field string_imp) -> false)) : @path_connected_space.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_36200 (h2 : group (measurable_space (random_gen string_imp))) : normalizer_condition (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_36201 (h0 : monoid (ordered_cancel_add_comm_monoid pos)) : monoid.fg (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_36202 (h0 : topological_space (id (has_norm (has_norm congr_arg_kind)))) : discrete_topology (id (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_36203 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_36204 (h0 : ring (semigroup (has_nndist (finset pos)))) : rank_condition (semigroup (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_36205 (h0 : functor.add_const (list (normed_comm_ring Type)) (has_to_string pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36206 (h0 : filter (option (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36207 (h0 : function.extfun nat fin) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_36209 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36210 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @t0_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_36211 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) name) : @is_atomistic.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_36212 (h0 : cancel_comm_monoid_with_zero (with_bot (has_star empty))) : unique_factorization_monoid (with_bot (has_star empty)) := sorry --non-trivial
lemma new_lemma_36213 (h0 : topological_space (uniform_space (mul_one_class string.iterator_imp))) (h1 : preorder (uniform_space (mul_one_class string.iterator_imp))) : order_topology (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_36214 (h1 : ring (with_bot linarith.ineq)) : is_domain (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_36215 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (mul_zero_class name)) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (mul_zero_class.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_36216 (h0 : ring (mul_one_class linarith.ineq)) (h1 : topological_space (normed_group (ring.total_positive_cone (mul_one_class linarith.ineq)))) : locally_compact_space (normed_group (ring.total_positive_cone (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36217 (h1 : set (comm_group_with_zero std_gen -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_36218 (h0 : topological_space (has_to_string (boolean_algebra (has_add (boolean_algebra (has_Inf (has_Inf Type))))))) : normal_space (has_to_string (boolean_algebra (has_add (boolean_algebra (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_36219 (h0 : functor.add_const (group (has_neg_part name)) pos) : @is_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_36220 (h2 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h3 : preorder (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : order_closed_topology (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36221 (h0 : not (has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_36222 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 pos)) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_36223 (h0 : functor.comp ring has_to_string pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_36224 (h0 : topological_space (has_inv (has_norm (has_norm linarith.ineq)))) : irreducible_space (has_inv (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36225 (h1 : topological_space (semi_normed_ring linarith.ineq)) : t0_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_36226 (h0 : topological_space (has_neg num)) : preirreducible_space (has_neg num) := sorry --non-trivial
lemma new_lemma_36227 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_36228 (h0 : ring (linear_ordered_semiring (semiring (semiring (semiring unsigned))))) : rank_condition (linear_ordered_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_36229 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_36230 (h0 : ordered_add_comm_monoid (ring ennreal)) : archimedean (ring ennreal) := sorry --non-trivial
lemma new_lemma_36231 (h0 : complete_lattice (linear_ordered_add_comm_group (has_inv (has_inv to_additive.value_type)))) : is_compactly_generated (linear_ordered_add_comm_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36232 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_incomp_trans linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_36233 (h0 : group (ring (option ennreal))) : group.fg (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_36234 (h0 : uniform_space (generalized_boolean_algebra real)) : complete_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_36235 (h0 : topological_space (has_star (semiring congr_arg_kind))) : irreducible_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_36236 (h0 : not (cancel_comm_monoid_with_zero (bin_tree empty) -> false)) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_36238 (h0 : topological_space (generalized_boolean_algebra (has_neg linarith.comp))) : totally_separated_space (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_36239 (h0 : finset (linear_ordered_field ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36240 (h0 : functor.add_const (add_group (finset Type)) (has_zero (ring Type))) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (finset.{1} Type)) (has_zero.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_36241 (h0 : topological_space (cancel_monoid ennreal)) : totally_disconnected_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_36242 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_36243 (h0 : functor.add_const (uniform_space (has_nndist Type)) Type) : @separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_36244 (h0 : topological_space (denumerable (with_one to_additive.value_type))) : totally_separated_space (denumerable (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36245 (h0 : topological_space (distrib enat)) (h1 : preorder (distrib enat)) : order_topology (distrib enat) := sorry --non-trivial
lemma new_lemma_36246 (h0 : finset (has_pos_part (ring (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36247 (h0 : topological_space (has_Inf (ordered_ring Type))) : discrete_topology (has_Inf (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_36248 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36249 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_36250 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid pos)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_36251 (h0 : topological_space (cancel_monoid (semiring (semiring num)))) : topological_space.separable_space (cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_36252 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_36253 (h3 : complete_lattice (normed_field to_additive.value_type)) : is_compactly_generated (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36254 (h0 : add_monoid (has_to_string (ring (finset (linear_ordered_comm_ring linarith.comp))))) : add_monoid.fg (has_to_string (ring (finset (linear_ordered_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36255 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36256 (h0 : topological_space (has_top (has_top fun_info))) : locally_compact_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_36257 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : normal_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_36258 (h0 : functor.add_const (add_monoid (complete_linear_order unsigned)) unsigned) : @add_monoid.fg.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36259 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_36260 (h0 : uniform_space (uniform_space enat)) : complete_space (uniform_space enat) := sorry --non-trivial
lemma new_lemma_36261 (h0 : group (add_comm_monoid (has_to_string (has_add (has_to_string linarith.comp))))) : is_cyclic (add_comm_monoid (has_to_string (has_add (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36262 (h0 : topological_space (canonically_ordered_comm_semiring (finset pos))) : irreducible_space (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_36263 (h0 : list (add_cancel_monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36264 (h0 : topological_space (non_unital_non_assoc_semiring (uniform_space (uniform_space fun_info)))) : totally_disconnected_space (non_unital_non_assoc_semiring (uniform_space (uniform_space fun_info))) := sorry --non-trivial
lemma new_lemma_36265 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_36266 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) (ring linarith.comp)) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_monoid.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_36267 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_36268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_36269 (h0 : topological_space (normed_comm_ring (option name))) : discrete_topology (normed_comm_ring (option name)) := sorry --non-trivial
lemma new_lemma_36270 (h0 : fun_info -> fun_info -> Prop) (h1 : function.extfun Type filter) : filter.is_cobounded h0 (function.extfun_app h1 fun_info) := sorry --non-trivial
lemma new_lemma_36271 (h0 : semiring (linear_ordered_semiring (semiring empty))) : is_noetherian_ring (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_36272 (h0 : not (topological_space (has_norm empty) -> false)) : @discrete_topology.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36273 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_36274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36275 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_36276 (h0 : complete_lattice (normed_group (has_top (has_top linarith.comp_source)))) : is_atomistic (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_36277 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36278 (h0 : topological_space (has_Inf (has_Inf pos))) : loc_path_connected_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_36279 (h0 : add_group (distrib (comm_ring char))) : is_add_cyclic (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_36280 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_36281 (h0 : complete_lattice (with_bot (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_36282 (h0 : topological_space (has_norm (semiring num))) : path_connected_space (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_36283 (h0 : monoid (option (option ennreal)) -> monoid (option (option ennreal)) -> Prop) : is_symm (monoid (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_36284 (h0 : group (denumerable (has_top (random_gen (has_top linarith.ineq))))) : is_cyclic (denumerable (has_top (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_36285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36286 (h1 : complete_lattice num) : complete_lattice.is_Sup_finite_compact num := sorry --non-trivial
lemma new_lemma_36287 (h0 : uniform_space (comm_semigroup (has_add real))) : separated_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_36288 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36289 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) Type) : @is_atomistic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_36290 (h0 : group (pseudo_metric_space pos)) : normalizer_condition (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_36291 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid unsigned)))) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_36292 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_36293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_36294 (h0 : complete_lattice (has_lt string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_36295 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class char))) : is_compactly_generated (semi_normed_comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_36296 (h0 : group (with_one (has_norm (has_norm empty)))) : is_cyclic (with_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_36297 (h0 : add_monoid (mul_zero_class (semigroup environment.implicit_infer_kind))) : add_monoid.fg (mul_zero_class (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_36298 (h0 : topological_space (semigroup (has_add (has_neg Type)))) : normal_space (semigroup (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_36299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36300 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) unsigned) : @irreducible_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36301 (h0 : semiring (generalized_boolean_algebra Type)) : is_noetherian_ring (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_36302 (h0 : filter (normed_comm_ring (ordered_semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36303 (h0 : topological_space (id (has_norm (random_gen num)))) : totally_disconnected_space (id (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_36304 (h0 : functor.add_const (topological_space (plift empty)) empty) : @t1_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_36305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_36306 (h0 : group (monoid_with_zero (option (option unsigned)))) : normalizer_condition (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_36307 (h0 : function.extfun Type (functor.add_const (list subsingleton_info))) : list.nodup (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_36308 (h0 : add_group (has_nndist (finset name))) : is_add_cyclic (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_36309 (h0 : functor.comp ring has_nndist pos) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_36310 (h0 : function.extfun Type (functor.comp semiring semigroup)) : @is_noetherian_ring.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} semigroup.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} semigroup.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_36311 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) ennreal) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_36312 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot Type)) (has_add real)) : @unique_factorization_monoid.{1} (has_bot.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_bot.{1} Type)) (has_add.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_36313 (h0 : not (ring (has_union unsigned) -> false)) : @strong_rank_condition.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_36314 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36315 (h0 : functor.add_const (list (semigroup unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36316 (h0 : functor.add_const (topological_space (option pos)) pos) : @t1_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_36317 (h0 : functor.comp cancel_comm_monoid_with_zero has_neg pos) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_36318 (h0 : topological_space (cancel_monoid (comm_group unsigned))) : preirreducible_space (cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_36319 (h0 : add_monoid (partial_order num)) : add_monoid.fg (partial_order num) := sorry --non-trivial
lemma new_lemma_36320 (h0 : ring (finset (has_add (finset pos)))) : rank_condition (finset (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_36321 (h0 : topological_space (canonically_ordered_comm_semiring (option (option empty)))) : t1_space (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_36322 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : irreducible_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_36323 (h0 : function.extfun Type group) : @group.fg.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36324 (h0 : topological_space (add_cancel_monoid (option (option num)))) : t0_space (add_cancel_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_36325 (h1 : group (uniform_space (metric_space to_additive.value_type))) : is_cyclic (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36326 (h0 : ring (add_comm_monoid (option (option (option empty))))) : strong_rank_condition (add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_36327 (h0 : topological_space (ring (finset (has_zero Type)))) : discrete_topology (ring (finset (has_zero Type))) := sorry --non-trivial
lemma new_lemma_36328 (h0 : group (add_cancel_monoid (finset name))) : is_simple_group (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_36329 (h0 : function.extfun Type ring) : @is_domain.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_36330 (h0 : add_group (simple_graph linarith.ineq)) : is_add_cyclic (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_36331 (h0 : ring (sub_neg_monoid (has_Inf real))) : strong_rank_condition (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_36332 (h0 : functor.add_const (ring (left_cancel_monoid empty)) num) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_36333 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid linarith.comp)) name) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_36334 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : is_domain (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_36336 (h0 : functor.add_const (uniform_space (ring linarith.comp)) linarith.comp) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36337 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_36338 (h0 : functor.comp (functor.comp topological_space boolean_algebra.core) with_top nnreal) : @t0_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_36339 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36340 (h1 : uniform_space (random_gen (denumerable (denumerable (denumerable reducibility_hints))))) : complete_space (random_gen (denumerable (denumerable (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_36341 (h1 : semiring (has_le linarith.ineq)) (h2 : ideal (has_le linarith.ineq)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_36342 (h0 : ring (finset num)) : is_principal_ideal_ring (finset num) := sorry --non-trivial
lemma new_lemma_36343 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @totally_disconnected_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36344 (h1 : ring (random_gen linarith.ineq)) : is_domain (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_36345 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) Type) : @is_compactly_generated.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_36346 (h0 : uniform_space (sub_neg_monoid (has_add (has_Inf Type)))) : separated_space (sub_neg_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_36347 (h0 : group (fintype linarith.comp_source)) : group.fg (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36348 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : t0_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_36349 (h0 : group (finset (has_zero unsigned))) : is_simple_group (finset (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_36350 (h0 : ring (simple_graph (mul_one_class char))) : rank_condition (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_36351 (h0 : ring (normed_field (has_lt (random_gen to_additive.value_type)))) : strong_rank_condition (normed_field (has_lt (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36352 (h0 : functor.add_const (complete_lattice znum) (option (option empty))) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36353 (h0 : complete_lattice (option congr_arg_kind)) : is_atomistic (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36354 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_36355 (h0 : add_group (generalized_boolean_algebra linarith.ineq)) : is_add_cyclic (generalized_boolean_algebra linarith.ineq) := sorry --non-trivial
lemma new_lemma_36356 (h0 : topological_space (has_top (has_top to_additive.value_type))) : t0_space (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36357 (h0 : topological_space (semigroup (has_to_string unsigned))) : regular_space (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_36358 (h0 : complete_lattice (has_emptyc (has_top fun_info))) : is_compactly_generated (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_36359 (h0 : add_monoid (sub_neg_monoid (has_add (finset pos)))) : add_monoid.fg (sub_neg_monoid (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_36360 (h1 : set (has_compl environment.projection_info)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_36361 (h0 : topological_space (has_neg_part name)) : totally_separated_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_36362 (h0 : topological_space (has_add (option name))) : sequential_space (has_add (option name)) := sorry --non-trivial
lemma new_lemma_36363 (h1 : topological_space (has_emptyc num)) : totally_disconnected_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_36364 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_36365 (h0 : function.extfun nat fin) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36366 (h0 : group (ring Type)) : group.fg (ring Type) := sorry --non-trivial
lemma new_lemma_36367 (h0 : functor.add_const (semiring (has_star num)) congr_arg_kind) : @is_noetherian_ring.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_36368 (h1 : not (group (topological_space char) -> false)) : @is_cyclic.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_36369 (h0 : topological_space (add_cancel_monoid (finset (ring linarith.comp)))) : t1_space (add_cancel_monoid (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_36370 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) Type) : @group.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_36371 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_36372 (h0 : filter (non_assoc_semiring (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_36374 (h0 : group (linear_ordered_semiring fun_info)) : is_cyclic (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_36375 (h0 : topological_space (measurable_space (has_top (random_gen (random_gen fun_info))))) : discrete_topology (measurable_space (has_top (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_36376 (h1 : topological_space (distrib_lattice linarith.ineq)) : t0_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_36377 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_36378 (h0 : finset (linear_ordered_comm_monoid_with_zero empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36379 (h0 : functor.add_const (list (has_nndist name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36380 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_36381 (h0 : filter (ring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36382 (h0 : monoid (semigroup (mul_one_class (mul_one_class linarith.comp)))) : monoid.fg (semigroup (mul_one_class (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_36383 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @preirreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36384 (h0 : set (mul_one_class enat -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_36385 (h0 : list (has_neg_part unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36386 (h0 : group (semiring (random_gen (has_norm to_additive.value_type)))) : normalizer_condition (semiring (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36387 (h0 : complete_lattice (has_div (distrib (has_lt (has_lt (has_div linarith.ineq)))))) : is_compactly_generated (has_div (distrib (has_lt (has_lt (has_div linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_36388 (h0 : list (has_zero (cancel_monoid (has_to_string ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36389 (h0 : ring (add_cancel_monoid (has_neg Type))) : is_domain (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_36390 (h0 : topological_space (boolean_algebra.core (has_add pos))) : discrete_topology (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_36391 (h1 : topological_space (has_div std_gen)) (h2 : add_group (has_div std_gen)) : topological_add_group (has_div std_gen) := sorry --non-trivial
lemma new_lemma_36392 (h0 : group (pseudo_metric_space (option (cancel_monoid ennreal)))) : group.fg (pseudo_metric_space (option (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_36393 (h0 : functor.add_const (topological_space (preorder num)) unsigned) : @preirreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36394 (h0 : filter (comm_ring (has_ssubset to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36395 (h0 : function.extfun Type ring) : @rank_condition.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_36396 (h0 : functor.add_const (add_group (has_to_string pos)) Type) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36397 (h0 : group (generalized_boolean_algebra (has_neg (has_Inf name)))) : normalizer_condition (generalized_boolean_algebra (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_36398 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36399 (h0 : functor.add_const (topological_space (linear_order empty)) (semiring empty)) : @irreducible_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_36400 (h1 : uniform_space (div_inv_monoid char)) : complete_space (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_36401 (h0 : group (pseudo_metric_space ennreal)) : group.fg (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_36402 (h0 : not (ring (div_inv_monoid linarith.comp_source) -> false)) : @is_domain.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_36403 (h0 : complete_lattice (nondiscrete_normed_field (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_compactly_generated (nondiscrete_normed_field (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_36404 (h0 : topological_space (finset linarith.comp)) : topological_space.separable_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_36405 (h0 : filter (has_star (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36406 (h0 : topological_space (add_comm_monoid (option ennreal))) : totally_separated_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_36407 (h0 : topological_space (has_Sup (has_norm (random_gen empty)))) : locally_compact_space (has_Sup (has_norm (random_gen empty))) := sorry --non-trivial
lemma new_lemma_36408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_36409 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_36410 (h0 : complete_lattice (has_Inf (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_36411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36412 (h0 : group (canonically_ordered_monoid name)) : group.fg (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_36413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36414 (h0 : add_group (ordered_comm_ring (has_bot real))) : is_add_cyclic (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_36415 (h0 : ring (canonically_linear_ordered_monoid congr_arg_kind)) : is_principal_ideal_ring (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36416 (h0 : prod (has_add Type) (has_add Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_36417 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group unsigned)))) : is_atomistic (boolean_algebra (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_36418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36419 (h0 : ring (mul_zero_class (has_nndist pos))) : rank_condition (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_36420 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (comm_group unsigned)) : @normal_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) (comm_group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_36421 (h0 h1 : multiset (add_comm_semigroup (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_36422 (h0 : ring (normed_group (has_ssubset (with_zero (random_gen fun_info))))) : rank_condition (normed_group (has_ssubset (with_zero (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_36423 (h0 : uniform_space (has_inner string_imp linarith.comp_source)) : complete_space (has_inner string_imp linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36424 (h0 : complete_lattice (has_norm (has_inv (has_inv to_additive.value_type)))) : is_atomistic (has_norm (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36425 (h0 : topological_space (boolean_algebra.core (has_neg (has_add Type)))) : preirreducible_space (boolean_algebra.core (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_36426 (h0 : topological_space (has_neg (has_nndist pos))) : sequential_space (has_neg (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_36427 (h0 : fin has_zero.zero) : @complete_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_36428 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_ring num)) := sorry --non-trivial
lemma new_lemma_36429 (h1 : semiring (add_comm_semigroup reducibility_hints)) (h2 : ideal (add_comm_semigroup reducibility_hints)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_36430 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36431 (h0 : topological_space (add_cancel_monoid Type)) : path_connected_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_36432 (h0 : function.extfun Type topological_space) : @normal_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_36433 (h0 : group (has_add (has_neg (has_neg (has_neg (has_neg (finset (has_nndist pos)))))))) : is_cyclic (has_add (has_neg (has_neg (has_neg (has_neg (finset (has_nndist pos))))))) := sorry --non-trivial
lemma new_lemma_36434 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36435 (h0 : topological_space (has_inv (has_norm fun_info))) : path_connected_space (has_inv (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_36436 (h0 : functor.add_const (filter (has_zero pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36437 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_36438 (h0 : topological_space (ring (has_add (comm_group Type)))) : preirreducible_space (ring (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_36439 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36440 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : path_connected_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36441 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_36442 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36443 (h0 : function.extfun Type ring) : @rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_36444 (h0 : list (semigroup environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36445 (h0 : topological_space (measurable_space (has_norm to_additive.value_type))) : irreducible_space (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36446 (h0 : functor.add_const (topological_space (finset ennreal)) Type) : @preirreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_36447 (h0 : topological_space (boolean_algebra (comm_group pos))) : t1_space (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_36448 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) pos) : @is_atomistic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36449 (h1 : ring (has_top to_additive.value_type)) : rank_condition (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36450 (h0 : ring (plift (option (option (option (option unsigned)))))) : is_domain (plift (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_36451 (h0 : functor.add_const (group (has_nndist num)) num) : @is_cyclic.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_36452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36453 (h0 : function.extfun Type (prod (free_add_monoid unsigned))) : id_rel (function.extfun_app h0 (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_36454 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_lt char))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (has_lt char)) := sorry --non-trivial
lemma new_lemma_36455 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_36456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_36457 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_36458 (h1 : topological_space (has_ssubset (mul_one_class string.iterator_imp))) : totally_disconnected_space (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_36459 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @monoid.fg.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36460 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36461 (h0 : topological_space (id (semiring (semiring (semiring congr_arg_kind))))) : preirreducible_space (id (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_36462 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_36463 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (matrix.vec_empty h0)))) := sorry --non-trivial
lemma new_lemma_36464 (h4 : topological_space enat) : totally_disconnected_space enat := sorry --non-trivial
lemma new_lemma_36465 (h0 : ring (mul_one_class (has_dist to_additive.value_type))) : is_domain (mul_one_class (has_dist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36466 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (semigroup name)) := sorry --non-trivial
lemma new_lemma_36467 (h0 : uniform_space (ordered_ring string.iterator_imp)) : complete_space (ordered_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_36468 (h0 : functor.add_const (cancel_comm_monoid_with_zero (group_with_zero unsigned)) unsigned) : @unique_factorization_monoid.{0} (group_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (group_with_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36469 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_36470 (h0 : ring (canonically_linear_ordered_monoid (semiring empty))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_36471 (h0 : semiring (as_linear_order empty)) : is_noetherian_ring (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_36472 (h0 : topological_space (ring name)) : path_connected_space (ring name) := sorry --non-trivial
lemma new_lemma_36473 (h0 : functor.comp group complete_distrib_lattice Type) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} group.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_36474 (h1 : list (id (random_gen (random_gen (random_gen linarith.ineq))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_36475 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : locally_compact_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_36476 (h0 : semiring (ordered_comm_ring (has_add real))) : is_noetherian_ring (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_36477 (h0 : complete_lattice (boolean_algebra (comm_group pos))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_36478 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36479 (h0 : function.extfun Type (functor.add_const (functor.add_const (function.extfun Type complete_lattice) empty))) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) empty (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) empty) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) empty)) h0 empty))) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_36480 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_36481 (h2 : ring (has_lt linarith.comp_source)) : rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36482 (h0 : filter (finset (option Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36483 (h2 : ring (dlist to_additive.value_type)) : rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36484 (h0 : topological_space (has_lt linarith.comp_source)) : t0_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36485 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_36486 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : locally_compact_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_36487 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_one.{0} (random_gen.{0} num)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_one.{0} (random_gen.{0} num)))  := sorry --non-trivial
lemma new_lemma_36488 (h0 : topological_space (normed_group (random_gen congr_arg_kind))) : totally_disconnected_space (normed_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_36489 (h0 : list (has_top (random_gen (has_inv string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36490 (h0 : group (id (with_bot (random_gen string_imp)))) : normalizer_condition (id (with_bot (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_36491 (h0 : complete_lattice (has_to_string (finset Type))) : complete_lattice.is_Sup_finite_compact (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_36492 (h0 : ordered_comm_monoid (simple_graph (ring Type))) : has_exists_mul_of_le (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_36493 (h0 : list (complete_semilattice_Sup (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36494 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36496 (h0 : topological_space (dlist (has_ssubset (random_gen (has_ssubset char))))) : t0_space (dlist (has_ssubset (random_gen (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_36497 (h0 : monoid (canonically_linear_ordered_monoid (has_Inf (has_Inf Type)))) : monoid.fg (canonically_linear_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_36498 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_36499 (h0 : functor.add_const (finset (normed_comm_ring pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36500 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @irreducible_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36501 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @normal_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_36502 (h0 : topological_space (has_pos_part (has_Inf pos))) : totally_separated_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_36503 (h0 : set (mul_one_class (mul_one_class (mul_one_class string)) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_36504 (h0 : uniform_space (has_nndist (finset (finset name)))) : complete_space (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_36505 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_add name))) : archimedean (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_36506 (h1 : has_mem.mem (id num) has_emptyc.emptyc) : @path_connected_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) h1)  := sorry --non-trivial
lemma new_lemma_36507 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_add pos))) : unique_factorization_monoid (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_36508 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_36509 (h0 : ring (random_gen (has_ssubset (linear_ordered_field char)))) : strong_rank_condition (random_gen (has_ssubset (linear_ordered_field char))) := sorry --non-trivial
lemma new_lemma_36510 (h0 : ring (linear_ordered_field fun_info)) : is_domain (linear_ordered_field fun_info) := sorry --non-trivial
lemma new_lemma_36511 (h0 : semiring (mul_one_class enat)) (h1 : pfun char (ideal (mul_one_class enat))) (h2 : coe_sort (pfun.dom h1)) : ideal.is_prime (pfun.as_subtype h1 h2) := sorry --non-trivial
lemma new_lemma_36512 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero Type))) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type)) h0 name))  := sorry --non-trivial
lemma new_lemma_36513 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) Type) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_36514 (h0 : monoid (comm_semigroup pos)) : monoid.fg (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_36515 (h0 : functor.add_const (ring ennreal) (option ennreal)) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_36516 (h0 : ulower (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) h0))  := sorry --non-trivial
lemma new_lemma_36517 (h0 : topological_space (option ennreal)) : discrete_topology (option ennreal) := sorry --non-trivial
lemma new_lemma_36518 (h0 : topological_space (has_add (finset (has_Inf pos)))) : topological_space.separable_space (has_add (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_36519 (h2 : semiring (add_comm_semigroup ereal)) (h3 : ideal (add_comm_semigroup ereal)) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_36520 (h0 : topological_space (random_gen (has_top (has_top (has_top to_additive.value_type))))) : totally_disconnected_space (random_gen (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_36521 (h2 : prod linarith.ineq linarith.ineq) : set.diagonal linarith.ineq h2 := sorry --non-trivial
lemma new_lemma_36522 (h0 : ring (normed_comm_ring congr_arg_kind)) : is_domain (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36523 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36524 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_36525 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36526 (h0 : semiring (has_Inf (ring Type))) : is_noetherian_ring (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_36527 (h0 : functor.add_const (finset (has_bot unsigned)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36528 (h0 : topological_space (has_union (semiring (has_top (has_top unsigned))))) : preirreducible_space (has_union (semiring (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_36529 (h0 : functor.add_const (finset (finset Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36530 (h0 : topological_space (fintype reducibility_hints)) : path_connected_space (fintype reducibility_hints) := sorry --non-trivial
lemma new_lemma_36531 (h0 : add_monoid (canonically_ordered_comm_semiring (option empty))) : add_monoid.fg (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_36532 (h0 : topological_space (metric_space char)) : path_connected_space (metric_space char) := sorry --non-trivial
lemma new_lemma_36533 (h0 : function.extfun nat fin) : @t1_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36534 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_36535 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36536 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_36537 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_add real)))))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_add real))))) := sorry --non-trivial
lemma new_lemma_36538 (h0 : ring (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36539 (h0 : list (add_comm_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36540 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @t0_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_36541 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra Type)) name) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_36542 (h0 : ring (normed_group (has_ssubset fun_info))) : strong_rank_condition (normed_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_36543 (h0 : complete_lattice (has_norm (has_norm linarith.comp))) : is_compactly_generated (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_36544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36545 (h0 : functor.add_const (uniform_space (has_to_string pos)) (ring environment.implicit_infer_kind)) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_36546 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36547 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36548 (h0 : filter (has_neg_part (has_add (add_comm_monoid environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36549 (h0 : ring (monoid_with_zero congr_arg_kind)) : rank_condition (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36550 (h0 : has_add (metric_space char)) (h1 : uniform_space (add_con (metric_space char))) : complete_space (add_con (metric_space char)) := sorry --non-trivial
lemma new_lemma_36551 (h0 : functor.add_const (list (finset pos)) (has_add linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36552 (h0 : filter (complete_distrib_lattice (has_add (boolean_algebra name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_36553 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36554 (h0 : functor.add_const (topological_space znum) (option num)) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_36555 (h0 : topological_space (has_compl (mul_one_class enat))) : totally_disconnected_space (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_36556 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) Type) : @t1_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_36557 (h0 : ring (has_compl (random_gen (random_gen (random_gen char))))) : rank_condition (has_compl (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_36558 (h0 : filter (has_nndist (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_36559 (h0 : topological_space (add_comm_monoid name)) : regular_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_36560 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_36561 (h0 : ring (denumerable (random_gen char))) : strong_rank_condition (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_36562 (h0 : topological_space (bin_tree congr_arg_kind)) : preirreducible_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36563 (h0 : group (mul_zero_class (has_top unsigned))) : group.fg (mul_zero_class (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_36564 (h0 : functor.add_const (topological_space (comm_group ennreal)) pos) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_36565 (h0 : not (group (with_one linarith.ineq) -> false)) : @normalizer_condition.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_36566 (h0 : functor.add_const (function.extfun (Type 1) semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) environment.implicit_infer_kind h0) Type)  := sorry --non-trivial
lemma new_lemma_36567 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : is_compactly_generated (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_36568 (h0 : list (boolean_algebra (has_neg_part name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_36570 (h0 : not (uniform_space (has_div to_additive.value_type) -> false)) : @complete_space.{0} (has_div.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_36571 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (finset linarith.comp))) : unique_factorization_monoid (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36572 (h0 : not (uniform_space (random_gen congr_arg_kind) -> false)) : @separated_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_36573 (h0 : ring (linear_ordered_field (option (option (option (option unsigned)))))) : is_principal_ideal_ring (linear_ordered_field (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_36574 (h0 : cancel_comm_monoid_with_zero (boolean_algebra Type)) : unique_factorization_monoid (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_36575 (h0 : group (complete_distrib_lattice congr_arg_kind)) : normalizer_condition (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36576 (h0 h1 : set real) (h2 : fin has_zero.zero) : set.re_prod_im h0 h1 (matrix.vec_empty (matrix.vec_empty (id h2))) := sorry --non-trivial
lemma new_lemma_36577 (h0 : filter (ring (ring pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36578 (h0 : filter (add_group (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36579 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @regular_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_36580 (h0 : list (measurable_space fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36581 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36582 (h0 : topological_space (has_add (has_Inf (finset (ordered_comm_monoid pos))))) : normal_space (has_add (has_Inf (finset (ordered_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_36583 (h0 : ring (has_pos_part linarith.comp)) : is_domain (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_36584 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class pos)) Type) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36585 (h0 : functor.add_const (topological_space (finset Type)) Type) : @t0_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_36586 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36587 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : locally_compact_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36588 (h1 : ring (linear_ordered_add_comm_group (has_lt char))) : strong_rank_condition (linear_ordered_add_comm_group (has_lt char)) := sorry --non-trivial
lemma new_lemma_36589 (h0 : functor.add_const (ring (semiring num)) congr_arg_kind) : @strong_rank_condition.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_36590 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36591 (h0 : complete_lattice (distrib (mul_one_class string.iterator_imp))) : is_compactly_generated (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_36592 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_36593 (h0 : ring (complete_distrib_lattice (semiring empty))) : is_domain (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_36594 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring (semiring unsigned))))) : unique_factorization_monoid (partial_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_36595 (h0 : group (comm_semigroup (ordered_comm_monoid real))) : normalizer_condition (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_36596 (h0 : functor.add_const (complete_lattice (boolean_algebra.core linarith.comp)) environment.implicit_infer_kind) : @is_atomistic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_36597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36598 (h1 : ring (normed_field (comm_monoid reducibility_hints))) : rank_condition (normed_field (comm_monoid reducibility_hints)) := sorry --non-trivial
lemma new_lemma_36599 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_36600 (h0 : not (ring (semi_normed_comm_ring char) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_36601 (h0 : topological_space (has_Inf (has_add name))) : locally_compact_space (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_36602 (h0 : functor.add_const (add_group (semigroup Type)) linarith.comp) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36603 (h0 : functor.add_const (ring (has_Sup unsigned)) (semiring (semiring empty))) : @is_domain.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36604 (h0 : add_monoid (sub_neg_monoid (has_add linarith.comp))) : add_monoid.fg (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_36605 (h1 : semiring (add_comm_semigroup (add_comm_semigroup linarith.ineq))) (h2 : add_comm_semigroup (add_comm_semigroup linarith.ineq)) : even h2 := sorry --non-trivial
lemma new_lemma_36606 (h0 : functor.add_const (add_group (complete_distrib_lattice num)) ennreal) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_36607 (h0 : topological_space (id empty)) : loc_path_connected_space (id empty) := sorry --non-trivial
lemma new_lemma_36608 (h0 : ring string_imp) : is_domain string_imp := sorry --non-trivial
lemma new_lemma_36609 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (comm_group Type)) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_36610 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) name) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_36611 (h0 : topological_space (has_to_string (normed_comm_ring (has_Inf Type)))) : discrete_topology (has_to_string (normed_comm_ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_36612 (h0 : topological_space (linear_ordered_comm_group (option (option unsigned)))) : totally_separated_space (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_36613 (h3 : ring (denumerable (random_gen (denumerable char)))) : is_domain (denumerable (random_gen (denumerable char))) := sorry --non-trivial
lemma new_lemma_36614 (h0 : topological_space (has_nnnorm environment.projection_info)) : totally_disconnected_space (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_36615 (h0 : topological_space (comm_ring (has_ssubset linarith.ineq))) : totally_disconnected_space (comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36616 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) congr_arg_kind) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_36617 (h1 : topological_space (has_norm congr_arg_kind)) : locally_compact_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36618 (h0 : semiring (has_zero (option pos))) : is_noetherian_ring (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_36619 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : locally_compact_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_36620 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_36621 (h0 : topological_space (ordered_comm_ring (has_Inf (has_bot pos)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_bot pos))) := sorry --non-trivial
lemma new_lemma_36622 (h0 : functor.comp topological_space has_nndist name) : @regular_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_36623 (h0 : ring (boolean_algebra (has_add unsigned))) : is_domain (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_36624 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36625 (h0 : add_monoid (boolean_algebra (has_neg (ring (has_neg Type))))) : add_monoid.fg (boolean_algebra (has_neg (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_36626 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @is_compactly_generated.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_36627 (h0 : topological_space (ordered_comm_ring (has_nndist (ring (finset (has_add linarith.comp)))))) : irreducible_space (ordered_comm_ring (has_nndist (ring (finset (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_36628 (h0 : functor.add_const (ring (has_neg pos)) Type) : @rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36629 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_36630 (h0 : topological_space (cancel_monoid (boolean_algebra pos))) : normal_space (cancel_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_36631 (h0 : functor.add_const (function.extfun (Type 1) filter) (finset linarith.comp)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_36632 (h0 : function.extfun Type group) : @is_cyclic.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36633 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_36634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36635 (h0 : functor.add_const (add_group (complete_distrib_lattice linarith.comp)) pos) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36636 (h0 : ring (normed_group (semiring (semiring num)))) : is_domain (normed_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_36637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36638 (h0 : topological_space (has_to_string (finset pos))) : irreducible_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_36639 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @path_connected_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36640 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36641 (h0 : functor.add_const (group (boolean_algebra.core Type)) pos) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_36642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_36643 (h0 : filter (has_top (dlist (has_norm (comm_ring to_additive.value_type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36644 (h0 : topological_space (free_add_monoid (option empty))) : topological_space.separable_space (free_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_36645 (h1 : ring (has_nnnorm ereal)) : is_domain (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_36646 (h0 : not (group (with_bot empty) -> false)) : @normalizer_condition.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36647 (h0 : function.extfun (Type 1) (functor.comp topological_space has_zero)) : @regular_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_zero.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_36648 (h0 : ring (add_comm_monoid num)) : rank_condition (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_36649 (h0 : not (complete_lattice (comm_ring to_additive.value_type) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_36650 (h0 : add_monoid (comm_monoid empty)) : add_monoid.fg (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_36651 (h0 : fin has_zero.zero) : @preconnected_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_36652 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_36653 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36655 (h0 : topological_space (linear_ordered_add_comm_group (measurable_space to_additive.value_type))) : totally_separated_space (linear_ordered_add_comm_group (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36656 (h0 : functor.add_const (topological_space (has_add pos)) (option ennreal)) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_36657 (h0 : functor.comp topological_space mul_zero_class name) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_36658 (h0 : ring (normed_comm_ring (option empty))) : is_domain (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_36659 (h0 : function.extfun Type (prod (has_neg_part name))) : id_rel (function.extfun_app h0 (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_36660 (h0 : ring (normed_group (has_compl (encodable to_additive.value_type)))) : rank_condition (normed_group (has_compl (encodable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36661 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_36662 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring empty)) ennreal) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_36663 (h0 : function.extfun Type group) : @is_cyclic.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36664 (h0 : ring (mul_zero_class unsigned)) : rank_condition (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_36665 (h0 : functor.add_const (uniform_space (has_neg unsigned)) linarith.comp) : @complete_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36666 (h0 : has_neg (mul_one_class char)) (h1 : measurable_space (mul_one_class char)) : has_measurable_neg (mul_one_class char) := sorry --non-trivial
lemma new_lemma_36667 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_36668 (h0 : topological_space (normed_group (has_top congr_arg_kind))) : irreducible_space (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_36669 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_36670 (h2 : ring (fintype linarith.comp_source)) : is_domain (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36671 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) empty) : @loc_path_connected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_36672 (h0 : uniform_space (denumerable reducibility_hints)) : complete_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_36673 (h0 : monoid (boolean_algebra (has_neg_part (finset (semigroup unsigned))))) : monoid.fg (boolean_algebra (has_neg_part (finset (semigroup unsigned)))) := sorry --non-trivial
lemma new_lemma_36674 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_36675 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_36676 (h0 : ring (has_inv (random_gen (random_gen linarith.comp_source)))) : strong_rank_condition (has_inv (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_36677 (h0 : semiring (has_top empty)) : is_noetherian_ring (has_top empty) := sorry --non-trivial
lemma new_lemma_36678 (h1 : ring (add_cancel_comm_monoid (random_gen reducibility_hints))) : is_domain (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_36679 (h1 : topological_space (has_ssubset environment.projection_info)) : totally_disconnected_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_36680 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36681 (h0 : not (add_group (id unsigned) -> false)) : @is_add_cyclic.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_36682 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_36683 (h0 : functor.add_const (topological_space pos) unsigned) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36684 (h0 : ring (fintype (has_nnnorm to_additive.value_type))) : rank_condition (fintype (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36685 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_36686 (h0 : list (has_nndist (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_36687 (h0 : topological_space (add_group (semiring (semiring empty)))) : preirreducible_space (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_36688 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_36689 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring empty))))) : locally_compact_space (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_36690 (h0 : topological_space (comm_group (has_neg_part pos))) : sequential_space (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_36691 (h0 : functor.comp topological_space has_neg_part (option (cancel_monoid (has_to_string pos)))) : @preirreducible_space.{0} (has_neg_part.{0} (option.{0} (cancel_monoid.{0} (has_to_string.{0} pos)))) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (option.{0} (cancel_monoid.{0} (has_to_string.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_36692 (h0 : has_add (pseudo_metric_space ennreal) -> has_add (pseudo_metric_space ennreal) -> Prop) : is_symm (has_add (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_36693 (h0 : ordered_comm_monoid (has_add (option (option ennreal)))) : has_exists_mul_of_le (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_36694 (h0 : not (semiring (free_add_monoid unsigned) -> false)) : @is_noetherian_ring.{0} (free_add_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (free_add_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_36695 (h0 : ring (has_neg (finset (finset pos)))) : is_domain (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_36696 (h0 : ordered_add_comm_monoid (has_neg (option unsigned))) : archimedean (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_36697 (h0 : ring (distrib (has_lt (has_nnnorm (has_nnnorm reducibility_hints))))) : is_domain (distrib (has_lt (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_36698 (h0 : ring (has_zero environment.implicit_infer_kind)) : is_domain (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_36699 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36700 (h0 : ring (comm_group (finset (finset environment.implicit_infer_kind)))) : strong_rank_condition (comm_group (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_36701 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_36702 (h0 : topological_space (add_comm_monoid Type)) : normal_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_36703 (h0 : functor.add_const (semiring (has_nndist environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_36704 (h0 : preorder (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) (h1 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_36705 (h0 : complete_lattice (has_to_string (ring pos))) : is_atomistic (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_36706 (h0 : random_gen to_additive.value_type -> string_imp -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_36707 (h0 : functor.add_const (add_group (has_neg_part pos)) Type) : @is_add_cyclic.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_36708 (h0 : ring (has_top (semiring (semiring linarith.comp)))) : rank_condition (has_top (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_36709 (h0 : ring (linear_ordered_semiring unsigned)) : is_domain (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_36710 (h0 : not (ring (topological_space fun_info) -> false)) : @strong_rank_condition.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_36711 (h0 : monoid (has_nndist (has_neg name))) : monoid.fg (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_36712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36713 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_36714 (h0 : topological_space (has_neg_part ennreal)) : t1_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_36715 (h0 : semiring (sub_neg_monoid (has_add Type))) : is_noetherian_ring (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_36716 (h0 : ring (linear_ordered_add_comm_group (has_inv (random_gen to_additive.value_type)))) : is_domain (linear_ordered_add_comm_group (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36717 (h0 : not (has_mem.mem (has_top linarith.comp) has_emptyc.emptyc -> false)) : @group.fg.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_36718 (h0 : functor.add_const (filter (has_zero pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36719 (h0 : topological_space (left_cancel_monoid (option (option (option (option (option unsigned))))))) : t0_space (left_cancel_monoid (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_36720 (h0 : group (random_gen (semiring unsigned))) : group.fg (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_36721 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) (semiring empty)) : @t1_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_36722 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_36723 (h0 : functor.add_const (ring (normed_comm_ring name)) linarith.comp) : @is_domain.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36724 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36725 (h0 : topological_space (has_union (free_add_monoid linarith.comp))) : preirreducible_space (has_union (free_add_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_36726 (h0 : not (group (has_top linarith.comp) -> false)) : @group.fg.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_36727 (h0 : complete_lattice (has_emptyc (random_gen to_additive.value_type))) : is_atomistic (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset pos)) := sorry --non-trivial
lemma new_lemma_36729 (h1 : topological_space (has_top fun_info)) : path_connected_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_36730 (h0 : filter (has_top (has_ssubset (has_ssubset fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36731 (h0 : complete_lattice (comm_monoid unsigned)) : is_compactly_generated (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_36732 (h0 : functor.add_const (complete_lattice (partial_order empty)) num) : @is_compactly_generated.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_36733 (h1 : ring (distrib_lattice linarith.comp_source)) : rank_condition (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_36734 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_36735 (h0 : monoid (normed_comm_ring (ring (ring (has_zero linarith.comp))))) : monoid.fg (normed_comm_ring (ring (ring (has_zero linarith.comp)))) := sorry --non-trivial
lemma new_lemma_36736 (h0 : complete_lattice (has_add to_additive.value_type)) : is_compactly_generated (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36737 (h0 : group (linear_ordered_field empty)) : normalizer_condition (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_36738 (h0 : topological_space (has_pos_part (boolean_algebra.core Type))) : preirreducible_space (has_pos_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_36739 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_36740 (h0 : ring (measurable_space.dynkin_system (semiring unsigned))) : is_domain (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_36741 (h0 : topological_space (has_add name)) : locally_compact_space (has_add name) := sorry --non-trivial
lemma new_lemma_36742 (h0 : ordered_comm_monoid (has_pos_part (ordered_comm_ring Type))) : has_exists_mul_of_le (has_pos_part (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_36743 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36744 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_36745 (h0 : topological_space (has_to_string (option (option (option (option ennreal)))))) : loc_path_connected_space (has_to_string (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_36746 (h0 : finset (free_add_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36747 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @is_compactly_generated.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 pos)) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_36748 (h0 : measurable_space char) (h2 : filter char -> add_comm_semigroup enat) (h3 : coe_sort (set.range h2)) : filter.is_measurably_generated (set.range_splitting h2 h3) := sorry --non-trivial
lemma new_lemma_36749 (h0 : functor.add_const (filter (add_comm_monoid Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36750 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_36751 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_36752 (h0 : topological_space (canonically_ordered_comm_semiring (ring (has_add Type)))) : loc_path_connected_space (canonically_ordered_comm_semiring (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_36753 (h0 : complete_lattice (has_compl (random_gen to_additive.value_type))) : is_compactly_generated (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36754 (h0 : functor.add_const (complete_lattice (comm_group name)) pos) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_36755 (h0 : ordered_add_comm_monoid (has_nndist name)) : archimedean (has_nndist name) := sorry --non-trivial
lemma new_lemma_36756 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_36757 (h0 h1 : multiset (nondiscrete_normed_field ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_36758 (h0 : complete_lattice (has_sub (semiring empty))) : is_atomistic (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_36759 (h0 : function.extfun Type (functor.comp list finset)) : list.nodup (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_36760 (h0 : ring (semi_normed_comm_ring fun_info)) : strong_rank_condition (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_36761 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_36762 (h0 : functor.add_const (list (semiring congr_arg_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36763 (h0 : monoid (left_cancel_semigroup (semiring (semiring (semiring empty))))) : monoid.fg (left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_36764 (h0 : ordered_comm_monoid (pseudo_metric_space (option pos))) : has_exists_mul_of_le (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_36765 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_36766 (h0 : add_group (has_lt (mul_one_class linarith.ineq))) : is_add_cyclic (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36767 (h0 : topological_space (cancel_monoid (option (option (option ennreal))))) : preconnected_space (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_36768 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_36769 (h0 : topological_space (add_comm_monoid (option empty))) : loc_path_connected_space (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_36770 (h0 : functor.add_const (ring (add_right_cancel_monoid unsigned)) unsigned) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_right_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36771 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_36772 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) (finset Type)) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_36773 (h0 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36774 (h0 : uniform_space (has_emptyc unsigned)) : separated_space (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_36775 (h0 : topological_space (option (measurable_space.dynkin_system pos))) : totally_separated_space (option (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_36776 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (canonically_ordered_comm_semiring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_36777 (h0 : complete_lattice (add_cancel_monoid (finset linarith.comp))) : is_atomistic (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36778 (h0 : group (semigroup (option ennreal))) : group.fg (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_36779 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @sequential_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36780 (h0 : has_lt (plift (semiring (semiring (semiring (semiring (semiring empty))))))) : densely_ordered (plift (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_36781 (h2 : set (uniform_space linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_36782 (h0 : fin has_zero.zero) : matrix.vec_empty (ulower.up (matrix.vec_empty (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_36783 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add (has_Inf name))) : @normalizer_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} (has_Inf.{0} name)) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_36784 (h0 : group (distrib_lattice (comm_ring string_imp))) : normalizer_condition (distrib_lattice (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_36785 (h0 : function.extfun Type group) : @group.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_36786 (h0 : group (canonically_ordered_add_monoid num)) : group.fg (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_36787 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_36788 (h0 : ring (linear_ordered_semiring (has_norm empty))) : is_domain (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_36789 (h0 : topological_space (ring (ring (boolean_algebra.core linarith.comp)))) : totally_separated_space (ring (ring (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_36790 (h1 : group (comm_ring (random_gen (dlist (has_inv char))))) : is_cyclic (comm_ring (random_gen (dlist (has_inv char)))) := sorry --non-trivial
lemma new_lemma_36791 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_36792 (h0 : topological_space (random_gen num)) : totally_disconnected_space (random_gen num) := sorry --non-trivial
lemma new_lemma_36793 (h0 : topological_space (measurable_space (has_norm empty))) : preirreducible_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_36794 (h0 : not (topological_space (has_norm linarith.comp) -> false)) : @t0_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_36795 (h0 : functor.add_const (function.extfun (Type 1) group) (ring pos)) : @normalizer_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{0} pos) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_36796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_36797 (h0 : complete_lattice (distrib_lattice (has_norm (has_inv fun_info)))) : is_compactly_generated (distrib_lattice (has_norm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_36798 (h0 : complete_lattice (add_comm_monoid Type)) : is_compactly_generated (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_36799 (h0 : ring (random_gen (random_gen (has_norm num)))) : is_domain (random_gen (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_36800 (h0 : topological_space (has_Inf (has_Inf real))) : loc_path_connected_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_36801 (h0 : topological_space (semigroup (has_neg (finset (finset (has_nndist pos)))))) : sequential_space (semigroup (has_neg (finset (finset (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_36802 (h0 : complete_lattice (simple_graph linarith.comp)) : complete_lattice.is_Sup_finite_compact (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_36803 (h0 : functor.add_const (add_monoid (ring name)) Type) : @add_monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_36804 (h0 : group (boolean_algebra (comm_semigroup (has_add (sub_neg_monoid Type))))) : is_simple_group (boolean_algebra (comm_semigroup (has_add (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_36805 (h0 : pnat) : pnat.prime h0 := sorry --non-trivial
lemma new_lemma_36806 (h0 : topological_space (normed_field (has_compl (has_lt (has_sdiff char))))) : t0_space (normed_field (has_compl (has_lt (has_sdiff char)))) := sorry --non-trivial
lemma new_lemma_36807 (h0 : group (canonically_ordered_comm_semiring (has_Inf (has_add linarith.comp)))) : normalizer_condition (canonically_ordered_comm_semiring (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_36808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_36809 (h0 : finset (has_neg_part (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36810 (h0 : topological_space (normed_group (has_top (random_gen linarith.comp_source)))) : totally_disconnected_space (normed_group (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_36811 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_36812 (h0 : group (canonically_ordered_monoid name)) : normalizer_condition (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_36813 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_36814 (h0 : topological_space (linear_ordered_field (has_to_string pos))) : t0_space (linear_ordered_field (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_36815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_36816 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_36817 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_36818 (h0 : filter (with_zero (random_gen (random_gen (random_gen (has_inv (has_ssubset to_additive.value_type))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36819 (h0 : functor.add_const (ring (plift empty)) empty) : @is_domain.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_36820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_36821 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_group.{0} (option.{0} (option.{0} (option.{0} empty)))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} (option.{0} (option.{0} (option.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_36822 (h0 : functor.add_const (functor.add_const (complete_lattice auto.case_option) empty) unsigned) : @is_compactly_generated.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option) empty) unsigned h0))  := sorry --non-trivial
lemma new_lemma_36823 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : locally_compact_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36824 (h0 : uniform_space (mul_zero_class num)) : complete_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_36825 (h0 : group (has_nndist (finset Type))) : normalizer_condition (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_36826 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_36827 (h0 : topological_space (has_neg linarith.comp)) : preirreducible_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_36828 (h0 : functor.add_const Prop (has_neg pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_36829 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system num)) empty) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_36830 (h2 : ring (comm_ring (has_ssubset char))) : is_domain (comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_36831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_36832 (h0 : monoid_with_zero (add_comm_monoid congr_arg_kind) -> monoid_with_zero (add_comm_monoid congr_arg_kind) -> Prop) : is_symm (monoid_with_zero (add_comm_monoid congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_36833 (h0 : complete_lattice (mul_one_class (has_abs (add_comm_semigroup char)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (has_abs (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_36834 (h0 : topological_space (semigroup (has_to_string (has_to_string (has_to_string name))))) : t1_space (semigroup (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_36835 (h0 : functor.add_const (topological_space (preorder num)) empty) : @discrete_topology.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_36836 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_36837 (h0 : topological_space (has_to_string (finset linarith.comp))) : preirreducible_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36838 (h0 : monoid (normed_group (has_inv (has_inv (has_inv to_additive.value_type))))) : monoid.fg (normed_group (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_36839 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice pos)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36840 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : topological_space.separable_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36841 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_36842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist name)) := sorry --non-trivial
lemma new_lemma_36843 (h0 : group (has_nnnorm reducibility_hints)) : is_cyclic (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_36844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_36845 (h0 : complete_lattice (has_top fun_info)) : is_compactly_generated (has_top fun_info) := sorry --non-trivial
lemma new_lemma_36846 (h0 : topological_space (with_one (has_norm (has_norm fun_info)))) : t0_space (with_one (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_36847 (h0 : topological_space (has_to_string (ring linarith.comp))) : totally_separated_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_36848 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_36849 (h0 : topological_space (semigroup (ring (has_Inf pos)))) : preirreducible_space (semigroup (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_36850 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_36851 (h0 : monoid (distrib_lattice (random_gen string_imp))) : monoid.fg (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_36852 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_36853 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36854 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_36855 (h0 : topological_space (cancel_monoid (comm_group (has_to_string (comm_group (has_add name)))))) : locally_compact_space (cancel_monoid (comm_group (has_to_string (comm_group (has_add name))))) := sorry --non-trivial
lemma new_lemma_36856 (h0 : filter (with_bot linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36857 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36858 (h0 : functor.add_const (topological_space (option empty)) (semiring empty)) : @t1_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_36859 (h0 : ring (finset (option (option (option unsigned))))) : rank_condition (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_36860 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_36861 (h0 : complete_lattice (with_bot (has_top linarith.ineq))) : is_compactly_generated (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36862 (h0 : topological_space (has_add (has_pos_part (has_pos_part name)))) : path_connected_space (has_add (has_pos_part (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_36863 (h0 : topological_space (has_edist unsigned)) : t1_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_36864 (h0 : group (random_gen (random_gen linarith.ineq))) : normalizer_condition (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36865 (h0 : topological_space (has_zero (comm_group (comm_group Type)))) : path_connected_space (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_36866 (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup (normed_field linarith.ineq)))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_36867 (h0 : ring (normed_comm_ring ennreal)) : strong_rank_condition (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_36868 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_36869 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_36870 (h0 : filter (ordered_comm_ring (has_neg pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_36871 (h0 : topological_space (random_gen unsigned)) : locally_compact_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_36872 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (monoid_with_zero.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid_with_zero.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_36873 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid pos))) : totally_disconnected_space (sub_neg_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_36874 (h0 : not (ring (add_left_cancel_monoid fun_info) -> false)) : @rank_condition.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_36875 (h0 : functor.add_const Prop (has_zero (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_36876 (h0 : ring (finset (ring Type))) : rank_condition (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_36877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_36878 (h0 : functor.add_const (group (bin_tree congr_arg_kind)) unsigned) : @is_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36879 (h0 : functor.add_const (list (complete_linear_order congr_arg_kind)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_36880 (h0 : topological_space (has_add (finset pos))) : topological_space.separable_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_36881 (h0 : char -> char -> Prop) (h1 : multiset char) : multiset.pairwise h0 h1 := sorry --non-trivial
lemma new_lemma_36882 (h0 : topological_space (ring (ring (finset (has_Inf pos))))) : discrete_topology (ring (ring (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_36883 (h0 : list (pseudo_metric_space congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36884 (h0 : group (metric_space (semiring (semiring congr_arg_kind)))) : group.fg (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_36885 (h0 : not (monoid (measurable_space.dynkin_system empty) -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36886 (h0 : functor.comp topological_space has_to_string name) : @preconnected_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_36887 (h0 : topological_space (has_to_string num)) : topological_space.separable_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_36888 (h0 : filter (add_cancel_monoid (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36889 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_36890 (h0 : not (topological_space (comm_ring (has_ssubset to_additive.value_type)) -> false)) : @path_connected_space.{0} (comm_ring.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_36891 (h0 : functor.add_const (semiring (has_nndist unsigned)) pos) : @is_noetherian_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_36892 (h0 : add_group (nondiscrete_normed_field (mul_one_class std_gen))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_36893 (h0 : ordered_comm_monoid (has_nndist (has_add environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_36894 (h0 : ring (denumerable (has_nnnorm (has_nnnorm char)))) : rank_condition (denumerable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_36895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_36896 (h0 : monoid (linear_ordered_add_comm_group (random_gen (has_inv fun_info)))) : monoid.fg (linear_ordered_add_comm_group (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_36897 (h0 : complete_lattice (has_to_string (has_add (has_add pos)))) : is_atomistic (has_to_string (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_36898 (h0 : fin has_zero.zero) : @separated_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_36899 (h0 : functor.add_const (function.extfun Type finset) (finset (ring environment.implicit_infer_kind))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_36900 (h0 : filter (normed_comm_ring name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36901 (h0 : topological_space (bin_tree num)) : discrete_topology (bin_tree num) := sorry --non-trivial
lemma new_lemma_36902 (h0 : topological_space (ordered_comm_ring (has_add pos))) : normal_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_36903 (h0 : topological_space (semiring (has_norm to_additive.value_type))) : t0_space (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_36904 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (partial_order num)) := sorry --non-trivial
lemma new_lemma_36905 (h0 : monoid (linear_ordered_semiring (has_norm (has_norm congr_arg_kind)))) : monoid.fg (linear_ordered_semiring (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_36906 (h1 : list (normed_group (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_36907 (h0 : ordered_add_comm_monoid (add_cancel_monoid Type)) : archimedean (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_36908 (h0 : topological_space (id (random_gen fun_info))) : locally_compact_space (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_36909 (h0 : not (add_group (linear_ordered_semiring empty) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_36910 (h0 : topological_space (has_star (semiring (semiring congr_arg_kind)))) : topological_space.separable_space (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_36911 (h0 : filter (has_zero (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_36912 (h0 : ring (mul_zero_class (add_comm_monoid pos))) : strong_rank_condition (mul_zero_class (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_36913 (h1 : group (random_gen reducibility_hints)) : is_cyclic (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_36914 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_36915 (h0 : functor.add_const (add_monoid (has_add Type)) linarith.comp) : @add_monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36916 (h0 : topological_space (has_nndist (ring (has_zero (has_neg (has_neg linarith.comp)))))) : loc_path_connected_space (has_nndist (ring (has_zero (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_36917 (h0 : topological_space (comm_group (has_to_string (add_cancel_monoid unsigned)))) : preconnected_space (comm_group (has_to_string (add_cancel_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_36918 (h0 : not (topological_space (with_one linarith.ineq) -> false)) : @discrete_topology.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_36919 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_36920 (h1 : topological_space (has_ssubset enat)) : t0_space (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_36921 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : sequential_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_36922 (h1 : ring fun_info) : is_domain fun_info := sorry --non-trivial
lemma new_lemma_36923 (h0 : topological_space (has_star num)) : t0_space (has_star num) := sorry --non-trivial
lemma new_lemma_36924 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_36925 (h0 : semiring (comm_semigroup (finset Type))) : is_noetherian_ring (comm_semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_36926 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_36927 (h0 : not (ring (has_nnnorm fun_info) -> false)) : @rank_condition.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_36928 (h0 : list (has_add (has_add (has_neg_part Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36929 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_36930 (h0 : functor.comp group comm_group Type) : @is_cyclic.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} group.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_36931 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) unsigned) : @totally_separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36932 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : topological_space.separable_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_36933 (h0 : string_imp -> option (has_inv string_imp)) (h1 : list string_imp) : list.nodup (list.filter_map h0 h1) := sorry --non-trivial
lemma new_lemma_36934 (h0 : functor.add_const (function.extfun Type complete_lattice) (option pos)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} pos) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_36935 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (ring Type)) := sorry --non-trivial
lemma new_lemma_36936 (h0 : topological_space (complete_distrib_lattice (finset Type))) : discrete_topology (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_36937 (h0 : group (partial_order (semiring (semiring (semiring congr_arg_kind))))) : is_cyclic (partial_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_36938 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36939 (h0 : topological_space (comm_group (has_to_string unsigned))) : sequential_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_36940 (h0 : functor.add_const (group (has_Inf Type)) (has_neg pos)) : @is_simple_group.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_36941 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string linarith.comp)) name) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_36942 (h0 : functor.add_const (complete_lattice (semiring congr_arg_kind)) num) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_36943 (h0 : add_group (semiring (has_top linarith.comp))) : is_add_cyclic (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_36944 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_36945 (h0 : group (has_Inf (finset linarith.comp))) : is_cyclic (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_36946 (h1 : complete_lattice (add_comm_semigroup fun_info)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_36947 (h1 : ring (mul_one_class (add_comm_semigroup (add_comm_semigroup char)))) : strong_rank_condition (mul_one_class (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_36948 (h0 : topological_space (normed_comm_ring (ring (finset pos)))) : loc_path_connected_space (normed_comm_ring (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_36949 (h0 : uniform_space (nondiscrete_normed_field (mul_one_class fun_info))) : complete_space (nondiscrete_normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_36950 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_36951 (h0 : semiring (has_Sup unsigned)) : is_noetherian_ring (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_36952 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @irreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_36953 (h0 : filter (add_comm_monoid (has_to_string (normed_comm_ring Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_36954 (h0 : not (complete_lattice (encodable string_imp) -> false)) : @is_compactly_generated.{0} (encodable.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_36955 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra unsigned)) environment.implicit_infer_kind) : @archimedean.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_36956 (h0 : functor.add_const (ordered_comm_monoid (finset environment.implicit_infer_kind)) (ring Type)) : @has_exists_mul_of_le.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_36957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_36958 (h0 : complete_lattice (measurable_space (semiring empty))) : is_atomistic (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_36959 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) num) : @totally_disconnected_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_36960 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_36961 (h0 : ordered_add_comm_monoid (filter congr_arg_kind)) : archimedean (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36962 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_36963 (h0 : ordered_comm_monoid (has_bot real)) : has_exists_mul_of_le (has_bot real) := sorry --non-trivial
lemma new_lemma_36964 (h0 : functor.add_const (group (ring linarith.comp)) linarith.comp) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_36965 (h0 : functor.add_const (topological_space (monoid_with_zero unsigned)) pos) : @discrete_topology.{0} (monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_36966 (h2 : topological_space (with_zero fun_info)) : path_connected_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_36967 (h0 : complete_lattice (has_emptyc (random_gen (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36968 (h0 : ring (has_zero (ring (has_zero Type)))) : rank_condition (has_zero (ring (has_zero Type))) := sorry --non-trivial
lemma new_lemma_36969 (h0 : finset pos) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36970 (h0 : list (has_to_string (finset (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_36971 (h0 : add_monoid (metric_space (has_top linarith.comp))) : add_monoid.fg (metric_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_36972 (h0 : ring (boolean_algebra (has_add (has_add (has_to_string (has_add pos)))))) : strong_rank_condition (boolean_algebra (has_add (has_add (has_to_string (has_add pos))))) := sorry --non-trivial
lemma new_lemma_36973 (h0 : functor.add_const (add_group (has_to_string ennreal)) pos) : @is_add_cyclic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_36974 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_36975 (h0 : finset (has_bot (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_36976 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @group.fg.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_36977 (h1 : ring (has_append fun_info)) : is_domain (has_append fun_info) := sorry --non-trivial
lemma new_lemma_36978 (h0 : topological_space (free_add_monoid (option unsigned))) : irreducible_space (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_36979 (h0 : functor.add_const (topological_space (has_add Type)) (ring (has_neg Type))) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_36980 (h0 : not (uniform_space (linear_ordered_comm_ring num) -> false)) : @complete_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_36981 (h0 : functor.add_const (add_monoid (has_nndist pos)) (finset pos)) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_36982 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_36983 (h0 : ring (ring (has_nndist pos))) : is_domain (ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_36984 (h0 : uniform_space (has_neg (has_nndist (finset name)))) : separated_space (has_neg (has_nndist (finset name))) := sorry --non-trivial
lemma new_lemma_36985 (h0 : add_group (with_bot (random_gen (has_inv to_additive.value_type)))) : is_add_cyclic (with_bot (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_36986 (h0 : topological_space (has_neg (has_add (finset (finset (finset linarith.comp)))))) : locally_compact_space (has_neg (has_add (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_36987 (h0 : complete_lattice (normed_group (random_gen (random_gen (random_gen fun_info))))) : is_compactly_generated (normed_group (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_36988 (h0 : complete_lattice (linear_ordered_add_comm_group (denumerable linarith.ineq))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_36989 (h0 : functor.add_const (ring (has_zero Type)) name) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_36990 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup char))) (h1 : preorder (nondiscrete_normed_field (add_comm_semigroup char))) : order_topology (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_36991 (h0 : ring (linear_ordered_add_comm_group to_additive.value_type)) : strong_rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_36992 (h0 : functor.add_const (complete_lattice (has_nndist empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_36993 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_36994 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : discrete_topology (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_36995 (h0 : reducibility_hints -> reducibility_hints -> Prop) : is_total_preorder reducibility_hints h0 := sorry --non-trivial
lemma new_lemma_36996 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @is_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_36997 (h0 : monoid (has_one (semiring (division_ring fun_info)))) : monoid.fg (has_one (semiring (division_ring fun_info))) := sorry --non-trivial
lemma new_lemma_36998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_36999 (h1 : group (with_one num)) : group.fg (with_one num) := sorry --non-trivial
lemma new_lemma_37000 (h0 : functor.add_const (functor.add_const (add_monoid pos) pos) (finset Type)) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (add_monoid.{0} pos) pos) (finset.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_37001 (h2 : topological_space (semi_normed_ring fun_info)) : path_connected_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_37002 (h0 : option unsigned -> option unsigned -> Prop) : is_total_preorder (option unsigned) h0 := sorry --non-trivial
lemma new_lemma_37003 (h0 : ring (uniform_space (metric_space char))) : rank_condition (uniform_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_37004 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option (option empty)))) : totally_disconnected_space (linear_ordered_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_37005 (h0 : function.extfun (has_norm fun_info) (fun (x : has_norm fun_info), Prop)) : set.infinite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_37006 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37007 (h0 : uniform_space (with_bot (random_gen linarith.ineq))) : separated_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37008 (h0 : functor.add_const (group (has_zero Type)) Type) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_37009 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : topological_space.separable_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37010 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_37011 (h0 : topological_space (has_neg_part (has_add (has_neg_part ennreal)))) : preconnected_space (has_neg_part (has_add (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_37012 (h0 : function.extfun Type (functor.add_const (semiring (semigroup empty)))) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semigroup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_37013 (h0 : functor.comp finset has_nndist ennreal) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_37014 (h0 : functor.add_const (function.extfun Type group) (has_neg (has_to_string Type))) : @group.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg.{1} (has_to_string.{1} Type)) h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_37015 (h0 : topological_space (has_to_string (ring unsigned))) : t1_space (has_to_string (ring unsigned)) := sorry --non-trivial
lemma new_lemma_37016 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_semigroup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_37017 (h0 : not (complete_lattice (normed_group char) -> false)) : @is_compactly_generated.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_37018 (h0 : ring (has_top (random_gen fun_info))) : rank_condition (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_37019 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @regular_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_37020 (h3 : congr_arg_kind -> congr_arg_kind -> congr_arg_kind) : is_right_cancel congr_arg_kind h3 := sorry --non-trivial
lemma new_lemma_37021 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_37022 (h1 : functor.comp ring has_add string_imp) : @is_domain.{0} (has_add.{0} string_imp) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} string_imp h1)  := sorry --non-trivial
lemma new_lemma_37023 (h0 : group (uniform_space (random_gen (has_nnnorm to_additive.value_type)))) : is_cyclic (uniform_space (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_37024 (h0 : add_monoid (semigroup (has_to_string Type))) : add_monoid.fg (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_37025 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string pos)))) : regular_space (boolean_algebra (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_37026 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37027 (h1 : set (mul_one_class char -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_37028 (h0 : add_monoid (metric_space (semiring (semiring num)))) : add_monoid.fg (metric_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_37029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : monoid.fg real := sorry --non-trivial
lemma new_lemma_37030 (h0 : function.extfun Type ring) : @is_domain.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_union num)) := sorry --non-trivial
lemma new_lemma_37032 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37033 (h0 : semiring (metric_space congr_arg_kind)) : is_noetherian_ring (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37034 (h0 : finset (has_to_string linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37035 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_37036 (h0 : string.iterator_imp -> std_gen) (h2 : std_gen) : set.range h0 h2 := sorry --non-trivial
lemma new_lemma_37037 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (has_zero Type)) := sorry --non-trivial
lemma new_lemma_37038 (h0 : uniform_space string.iterator_imp) (h1 : filter string.iterator_imp) : cauchy h1 := sorry --non-trivial
lemma new_lemma_37039 (h0 : topological_space (cancel_monoid (option ennreal))) : totally_separated_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_37040 (h0 : functor.comp ring mul_zero_class Type) : @rank_condition.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_37041 (h0 : complete_lattice (boolean_algebra (ring name))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_37042 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_37043 (h0 : topological_space (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : path_connected_space (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_37044 (h0 : functor.add_const Prop (boolean_algebra (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_37045 (h0 : not (ring (measurable_space.dynkin_system unsigned) -> false)) : @is_domain.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37046 (h0 : not (ring (has_add fun_info) -> false)) : @rank_condition.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_37047 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_37048 (h0 : uniform_space (simple_graph (has_pos_part Type))) : separated_space (simple_graph (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_37049 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37050 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37051 (h0 : topological_space (has_norm (random_gen num))) : totally_disconnected_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_37052 (h0 : finset (semigroup (mul_one_class linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37053 (h0 : topological_space (ordered_comm_monoid (has_add (has_add pos)))) : discrete_topology (ordered_comm_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_37054 (h0 : finset (topological_space (random_gen (random_gen char)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37055 (h0 : group (finset (has_add (has_add (has_neg linarith.comp))))) : group.fg (finset (has_add (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_37056 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) pos) : @separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_37057 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37058 (h2 : uniform_space (with_zero linarith.ineq)) : complete_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_37059 (h2 : uniform_space (add_comm_semigroup std_gen)) : complete_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_37060 (h0 : topological_space (boolean_algebra (has_pos_part environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_37061 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @discrete_topology.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37062 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_37063 (h0 : topological_space (semiring to_additive.value_type)) : locally_compact_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_37064 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : topological_space.separable_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_37065 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37066 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_37067 (h0 : functor.add_const (complete_lattice (has_add Type)) (finset linarith.comp)) : @is_atomistic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_37068 (h2 : add_group (with_zero (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : is_add_cyclic (with_zero (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_37069 (h0 : topological_space (plift (has_top empty))) : t0_space (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_37070 (h0 : group (random_gen to_additive.value_type)) : normalizer_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_37071 (h0 : not (complete_lattice (semi_normed_ring string_imp) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_37072 (h0 : group (has_neg_part (normed_comm_ring Type))) : group.fg (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_37073 (h0 : group (plift (semiring (semiring num)))) : group.fg (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_37074 (h0 : group (canonically_ordered_monoid (has_pos_part Type))) : group.fg (canonically_ordered_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_37075 (h0 : functor.add_const (filter (filter empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37076 (h0 : ring (add_group (semiring (semiring empty)))) : strong_rank_condition (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_37077 (h0 : topological_space (random_gen (has_lt (comm_ring (comm_ring linarith.ineq))))) : t0_space (random_gen (has_lt (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_37078 (h0 : ring (with_one (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (with_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_37079 (h0 : filter (has_edist unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37080 (h0 : functor.comp ordered_comm_monoid ring name) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_37081 (h0 : topological_space (normed_comm_ring (comm_group (has_to_string pos)))) : t0_space (normed_comm_ring (comm_group (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_37082 (h0 : topological_space (monoid (option (option (option (option empty)))))) : totally_disconnected_space (monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_37083 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_37084 (h0 : ring (complete_distrib_lattice (comm_group (comm_group name)))) : strong_rank_condition (complete_distrib_lattice (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_37085 (h0 : topological_space (complete_semilattice_Sup (comm_ring linarith.ineq))) : totally_disconnected_space (complete_semilattice_Sup (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37086 (h0 : complete_lattice (linear_ordered_comm_group_with_zero char)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_37087 (h0 : uniform_space (comm_ring (random_gen linarith.ineq))) : complete_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37088 (h0 : add_group (has_neg_part (has_add environment.implicit_infer_kind))) : is_add_cyclic (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_37089 (h0 : filter (ring (ordered_comm_ring (ring (has_add pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37090 (h0 : topological_space (cancel_monoid (boolean_algebra.core name))) : preirreducible_space (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_37091 (h0 : functor.add_const (topological_space (has_zero (ring linarith.comp))) pos) : @regular_space.{0} (has_zero.{0} (ring.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} (ring.{0} linarith.comp))) pos h0)  := sorry --non-trivial
lemma new_lemma_37092 (h0 : functor.comp topological_space has_neg_part Type) : @path_connected_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_37093 (h0 : list (monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37094 (h0 : list (has_star (semiring (semiring num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37095 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : preconnected_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_37096 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37097 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @t0_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_37098 (h0 : not (topological_space (has_inv to_additive.value_type) -> false)) : @locally_compact_space.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_37099 (h0 : semiring (boolean_algebra (has_to_string (has_to_string pos)))) : is_noetherian_ring (boolean_algebra (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_37100 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring unsigned)) name) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_37101 (h4 : topological_space linarith.ineq) : t0_space linarith.ineq := sorry --non-trivial
lemma new_lemma_37102 (h0 : list (has_neg name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37103 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_37104 (h0 : group (has_norm (has_norm congr_arg_kind))) : is_cyclic (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37105 (h0 : topological_space (distrib_lattice (random_gen linarith.ineq))) : path_connected_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37106 (h0 : functor.add_const (add_group (has_bot linarith.comp)) pos) : @is_add_cyclic.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_bot.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_37107 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @sequential_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_37108 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add (has_neg (ring Type))))) : archimedean (add_cancel_monoid (has_add (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_37109 (h0 : topological_space (has_lt (mul_one_class char))) (h1 : add_group (has_lt (mul_one_class char))) : topological_add_group (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_37110 (h0 : fin has_zero.zero) : @regular_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_37111 (h0 : not (ring (option empty) -> false)) : @is_principal_ideal_ring.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37112 (h0 : ordered_comm_monoid (has_neg (has_add (has_nndist linarith.comp)))) : has_exists_mul_of_le (has_neg (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_37113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_37114 (h0 : ordered_comm_monoid (has_nndist (has_Inf pos))) : has_exists_mul_of_le (has_nndist (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_37115 (h0 : not (ring (has_append (has_nnnorm linarith.comp_source)) -> false)) : @rank_condition.{0} (has_append.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_37116 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_37117 (h0 : topological_space (mul_zero_class name)) : irreducible_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_37118 (h0 : functor.add_const (function.extfun Type ring) (has_add linarith.comp)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_add.{0} linarith.comp) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37120 (h0 h1 : multiset (has_nnnorm linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_37121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37122 (h0 : topological_space (distrib_lattice (has_inv linarith.comp_source))) : path_connected_space (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37123 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37124 (h0 : functor.add_const (complete_lattice (option pos)) name) : @is_atomistic.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_37125 (h0 : not (topological_space (linear_ordered_cancel_comm_monoid num) -> false)) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_37126 (h0 : not (topological_space (fintype linarith.comp_source) -> false)) : @path_connected_space.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_37127 (h0 : list (with_one (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37128 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_37129 (h2 : set (linarith.ineq -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_37130 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_37131 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) (finset Type)) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_37132 (h0 : topological_space (add_cancel_monoid num)) : topological_space.separable_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_37133 (h0 : functor.add_const (ring (has_Sup empty)) num) : @is_domain.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_37134 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37135 (h0 : not (topological_space (with_bot linarith.comp_source) -> false)) : @path_connected_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_37136 (h0 : add_monoid (with_one (semiring (semiring (semiring congr_arg_kind))))) : add_monoid.fg (with_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_37137 (h0 : group (complete_distrib_lattice (option (option (option (option pos)))))) : is_simple_group (complete_distrib_lattice (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_37138 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_37139 (h0 : topological_space (add_cancel_monoid unsigned)) : normal_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_37140 (h0 : complete_lattice (simple_graph empty)) : is_atomistic (simple_graph empty) := sorry --non-trivial
lemma new_lemma_37141 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_37142 (h0 : functor.add_const (group (semigroup Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37143 (h0 : not (filter (semiring unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_37144 (h0 : topological_space (has_norm (random_gen fun_info))) : path_connected_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_37145 (h0 : functor.add_const (group (semiring unsigned)) unsigned) : @normalizer_condition.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37146 (h0 : topological_space (add_comm_monoid name)) : preconnected_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_37147 (h0 : topological_space (sub_neg_monoid pos)) : path_connected_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_37148 (h0 : group (has_edist (option (option (option (option unsigned)))))) : is_cyclic (has_edist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_37149 (h0 : topological_space (semigroup ennreal)) : totally_separated_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_37150 (h0 : monoid (id linarith.ineq)) : monoid.fg (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_37151 (h0 : ring (distrib_lattice (comm_ring (random_gen linarith.ineq)))) : rank_condition (distrib_lattice (comm_ring (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_37152 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37153 (h0 : measurable_space (add_comm_semigroup char)) (h1 : has_mul (add_comm_semigroup char)) : has_measurable_mul (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_37154 (h4 : preorder (add_comm_semigroup linarith.ineq)) (h5 : set (add_comm_semigroup linarith.ineq)) : set.is_pwo h5 := sorry --non-trivial
lemma new_lemma_37155 (h0 : group (normed_group linarith.comp_source)) : normalizer_condition (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37156 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_37157 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (has_Inf (has_nndist (has_add Type)))) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (has_Inf.{1} (has_nndist.{1} (has_add.{1} Type))) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_37158 (h0 : finset (cancel_monoid (has_add (boolean_algebra pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37159 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_37160 (h0 : function.extfun nat fin) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type (@matrix.vec_empty.{0} (functor.add_const.{0 1} (function.extfun.{1 1} nat fin) Type) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp (@matrix.vec_empty.{0} (functor.add_const.{0 0} (function.extfun.{1 1} nat fin) linarith.comp) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))) (@has_zero.zero.{0} nat nat.has_zero)))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_37161 (h0 : functor.add_const (filter (left_cancel_monoid empty)) (option empty)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37162 (h0 : topological_space (normed_linear_ordered_group (semiring empty))) : discrete_topology (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_37163 (h0 : not (ring (semiring unsigned) -> false)) : @is_domain.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37164 (h0 : complete_lattice (canonically_linear_ordered_monoid (option (option ennreal)))) : is_compactly_generated (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_37165 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf pos)))) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} pos))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_37166 (h0 : topological_space (has_to_string (finset ennreal))) : normal_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_37167 (h0 : topological_space (free_add_monoid congr_arg_kind)) : totally_disconnected_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37168 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37169 (h0 : ring (semigroup (has_nndist Type))) : is_principal_ideal_ring (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_37170 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : locally_compact_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_37171 (h0 : filter (finset ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37172 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_37173 (h0 : functor.add_const (topological_space (add_group num)) empty) : @t1_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_37174 (h0 : topological_space (has_sub empty)) : topological_space.separable_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_37175 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} congr_arg_kind (@matrix.vec_empty.{0} (add_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_37176 (h0 : uniform_space (has_sub (has_inv (random_gen (comm_ring (comm_ring linarith.ineq)))))) : complete_space (has_sub (has_inv (random_gen (comm_ring (comm_ring linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_37177 (h3 : add_group (has_nnnorm enat)) : is_add_cyclic (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_37178 (h2 : add_group (nondiscrete_normed_field char)) : is_add_cyclic (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_37179 (h0 : ring (with_one (random_gen to_additive.value_type))) : rank_condition (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_37180 (h0 : ring (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37181 (h0 : functor.add_const (add_group (normed_comm_ring Type)) Type) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_37182 (h0 : ring (semi_normed_comm_ring (random_gen (random_gen char)))) : strong_rank_condition (semi_normed_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_37183 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @t0_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_37184 (h0 : topological_space (filter congr_arg_kind)) : preirreducible_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37185 (h0 : topological_space (cancel_monoid (mul_zero_class name))) : irreducible_space (cancel_monoid (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_37186 (h0 : cancel_comm_monoid_with_zero (cancel_monoid congr_arg_kind)) : unique_factorization_monoid (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37187 (h0 : filter (add_comm_monoid (ring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37188 (h0 : topological_space (has_neg num)) : t1_space (has_neg num) := sorry --non-trivial
lemma new_lemma_37189 (h0 : complete_lattice (has_union (semiring num))) : is_atomistic (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_37190 (h0 : list (topological_space (has_neg_part string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37191 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg Type)) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_37192 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) Type) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_37193 (h0 : topological_space (has_norm (with_one linarith.comp_source))) : totally_disconnected_space (has_norm (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37194 (h0 : group (add_cancel_monoid (comm_group (comm_group unsigned)))) : group.fg (add_cancel_monoid (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_37195 (h0 : group (distrib_lattice (has_nnnorm (has_top (has_nnnorm fun_info))))) : group.fg (distrib_lattice (has_nnnorm (has_top (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_37196 (h0 : functor.comp topological_space has_nndist Type) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_37197 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_zero pos)) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_37198 (h0 : topological_space (id (has_norm linarith.ineq))) : totally_separated_space (id (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37200 (h1 : uniform_space (encodable (has_nnnorm (has_nnnorm char)))) : complete_space (encodable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_37201 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37202 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)))) : @preirreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_37203 (h0 : add_monoid (add_comm_monoid (boolean_algebra name))) : add_monoid.fg (add_comm_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_37204 (h0 : topological_space (free_add_monoid empty)) : preirreducible_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_37205 (h0 : not (ring (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_37206 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37207 (h0 : add_monoid (boolean_algebra (has_add (ring (ring (has_add (ring Type))))))) : add_monoid.fg (boolean_algebra (has_add (ring (ring (has_add (ring Type)))))) := sorry --non-trivial
lemma new_lemma_37208 (h0 : filter (distrib_lattice (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37209 (h0 : topological_space (with_bot (has_norm (has_norm (has_norm empty))))) : discrete_topology (with_bot (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_37210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37211 (h0 : functor.add_const (topological_space (has_neg name)) (ring environment.implicit_infer_kind)) : @path_connected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_37212 (h1 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37213 (h0 : complete_lattice (random_gen (comm_ring (has_nnnorm reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (random_gen (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_37214 (h0 : list (distrib_lattice (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37215 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_37216 (h0 : add_group (has_append (has_nnnorm char))) : is_add_cyclic (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_37217 (h0 : group (encodable (random_gen to_additive.value_type))) : group.fg (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_37218 (h0 : group (has_emptyc (with_bot linarith.comp_source))) : normalizer_condition (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37219 (h0 : functor.add_const (add_monoid (has_to_string pos)) name) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_37220 (h0 : function.extfun Type (functor.add_const (topological_space (has_neg linarith.comp)))) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_37221 (h0 : add_monoid (ring (finset (has_add pos)))) : add_monoid.fg (ring (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_37222 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_37223 (h0 : functor.add_const (group (has_dist unsigned)) (option num)) : @is_cyclic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} unsigned)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_37224 (h0 : ring (has_zero (finset (finset pos)))) : strong_rank_condition (has_zero (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_37225 (h0 : add_group (complete_semilattice_Sup (has_top linarith.ineq))) : is_add_cyclic (complete_semilattice_Sup (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37226 (h0 : filter (canonically_ordered_comm_semiring unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_37228 (h0 : set (has_lt reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_37229 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_37230 (h0 : ring (measurable_space (has_norm num))) : is_domain (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_37231 (h0 : not (uniform_space congr_arg_kind -> false)) : @separated_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (uniform_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_37232 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37233 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_37234 (h0 : ordered_add_comm_monoid (has_neg_part unsigned)) : archimedean (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_37235 (h0 : set (mul_one_class (add_comm_semigroup environment.projection_info) -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_37236 (h2 : add_group (has_le string_imp)) : is_add_cyclic (has_le string_imp) := sorry --non-trivial
lemma new_lemma_37237 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @t0_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37238 (h0 : ring (has_compl (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset char))))))) : is_domain (has_compl (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset char)))))) := sorry --non-trivial
lemma new_lemma_37239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37240 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_37241 (h0 : functor.add_const (topological_space (semigroup num)) empty) : @t0_space.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_37242 (h0 : complete_lattice (complete_semilattice_Sup (with_bot linarith.comp_source))) : is_atomistic (complete_semilattice_Sup (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37243 (h0 : topological_space (boolean_algebra (has_zero Type))) : irreducible_space (boolean_algebra (has_zero Type)) := sorry --non-trivial
lemma new_lemma_37244 (h0 : add_monoid (finset (has_to_string pos))) : add_monoid.fg (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_37245 (h0 : list (ordered_comm_monoid linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_37247 (h0 : uniform_space (has_norm linarith.ineq)) : separated_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_37248 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_37249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37250 (h0 : topological_space (ring (has_Inf (has_pos_part linarith.comp)))) : preirreducible_space (ring (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_37251 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_37252 (h0 : topological_space (ring (has_Inf Type))) : irreducible_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_37253 (h0 : topological_space (add_cancel_monoid (ring Type))) : locally_compact_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_37254 (h3 : set (has_ssubset string.iterator_imp)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_37255 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37256 (h0 : functor.add_const nat empty) : nat.prime (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37257 (h0 : uniform_space (dlist (has_add fun_info))) : complete_space (dlist (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_37258 (h0 : complete_lattice (has_inf char)) : complete_lattice.is_Sup_finite_compact (has_inf char) := sorry --non-trivial
lemma new_lemma_37259 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (ring (has_add unsigned)))) : unique_factorization_monoid (normed_comm_ring (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_37260 (h0 : not (monoid (measurable_space fun_info) -> false)) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_37261 (h0 : add_monoid (has_add (option (option unsigned)))) : add_monoid.fg (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_37262 (h0 : group (boolean_algebra (add_comm_monoid (has_add (has_add Type))))) : is_simple_group (boolean_algebra (add_comm_monoid (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_37263 (h0 : topological_space (has_top (random_gen (random_gen to_additive.value_type)))) : t0_space (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_37264 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_37265 (h0 : ordered_comm_monoid (has_to_string (has_Inf (simple_graph Type)))) : has_exists_mul_of_le (has_to_string (has_Inf (simple_graph Type))) := sorry --non-trivial
lemma new_lemma_37266 (h0 : not (topological_space (has_union empty) -> false)) : @discrete_topology.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37267 (h0 : ring (ring (option congr_arg_kind))) : is_principal_ideal_ring (ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37268 (h0 : complete_lattice (has_nndist (finset (has_add (finset (finset pos)))))) : is_compactly_generated (has_nndist (finset (has_add (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_37269 (h0 : filter (boolean_algebra.core (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37270 (h0 : group (semigroup (option (option ennreal)))) : is_cyclic (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_37271 (h0 : complete_lattice (random_gen (has_top (has_norm linarith.comp_source)))) : is_compactly_generated (random_gen (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_37272 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_37273 (h0 : complete_lattice (semi_normed_ring (has_nnnorm (has_lt (has_nnnorm fun_info))))) : is_compactly_generated (semi_normed_ring (has_nnnorm (has_lt (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_37274 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37275 (h0 : topological_space (generalized_boolean_algebra Type)) : preconnected_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_37276 (h0 : functor.add_const (ring (finset linarith.comp)) (ring (has_neg linarith.comp))) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (ring.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37277 (h0 : topological_space (has_edist unsigned)) : discrete_topology (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_37278 (h0 : finset (option ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37279 (h0 : ring (has_top linarith.ineq)) : strong_rank_condition (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_37280 (h0 : monoid (add_cancel_monoid (finset pos))) : monoid.fg (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_37281 (h0 : complete_lattice (boolean_algebra (has_add (has_bot real)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_37282 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) num) : @loc_path_connected_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_37283 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37284 (h0 : group (has_neg_part (option ennreal))) : normalizer_condition (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_37285 (h0 : function.extfun Type (functor.add_const (add_group (filter empty)))) : @is_add_cyclic.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (filter.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (filter.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_37286 (h0 : has_edist (as_linear_order unsigned) -> has_edist (as_linear_order unsigned) -> Prop) : is_irrefl (has_edist (as_linear_order unsigned)) h0 := sorry --non-trivial
lemma new_lemma_37287 (h0 : functor.add_const (ring (boolean_algebra.core Type)) linarith.comp) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37288 (h0 : list (finset (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37289 (h0 : complete_lattice (has_div linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37290 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_37291 (h0 : topological_space (has_add (measurable_space pos))) : preirreducible_space (has_add (measurable_space pos)) := sorry --non-trivial
lemma new_lemma_37292 (h0 : filter (semiring congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37293 (h0 : semiring (ordered_comm_monoid pos)) : is_noetherian_ring (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_37294 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37295 (h0 : add_group (add_group (semiring (linear_ordered_semiring empty)))) : is_add_cyclic (add_group (semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_37296 (h0 : topological_space (normed_field std_gen)) : t0_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_37297 (h0 : ring unsigned) : is_domain unsigned := sorry --non-trivial
lemma new_lemma_37298 (h1 : uniform_space (semi_normed_comm_ring (comm_ring (comm_ring char)))) : complete_space (semi_normed_comm_ring (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_37299 (h0 : uniform_space (has_pos_part (canonically_ordered_monoid real))) : complete_space (has_pos_part (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_37300 (h0 : ring (has_nndist (has_add (comm_group unsigned)))) : strong_rank_condition (has_nndist (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_37301 (h0 : topological_space (normed_group num)) : t0_space (normed_group num) := sorry --non-trivial
lemma new_lemma_37302 (h0 : function.extfun Type topological_space) : @regular_space.{0} (option.{0} real.angle) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} real.angle))  := sorry --non-trivial
lemma new_lemma_37303 (h0 : list (has_inner num (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37304 (h0 : topological_space (ring (has_neg (has_neg Type)))) : irreducible_space (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_37305 (h0 : topological_space (linear_ordered_field num)) : loc_path_connected_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_37306 (h0 : ring (filter congr_arg_kind)) : strong_rank_condition (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37307 (h2 : ring (random_gen linarith.ineq)) : is_domain (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_37308 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37309 (h0 : functor.add_const (group (comm_group Type)) (semigroup name)) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_37310 (h0 : complete_lattice (pseudo_metric_space num)) : is_atomistic (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_37311 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space congr_arg_kind)) : unique_factorization_monoid (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37312 (h0 : ring (finset (ring pos))) : strong_rank_condition (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_37313 (h0 : add_group (has_compl (mul_one_class linarith.comp_source))) : is_add_cyclic (has_compl (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37314 (h0 : list (linear_ordered_comm_ring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37315 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @locally_compact_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_37316 (h0 : function.extfun Type ring) : @is_domain.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_37317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37318 (h0 : functor.add_const (group (ordered_comm_monoid Type)) (has_add name)) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ordered_comm_monoid.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_37319 (h0 : ring (filter empty)) : is_domain (filter empty) := sorry --non-trivial
lemma new_lemma_37320 (h0 : topological_space (finset (has_neg Type))) : t0_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_37321 (h0 : group (ring (finset linarith.comp))) : is_simple_group (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_37322 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) string_imp) := sorry --non-trivial
lemma new_lemma_37324 (h0 : ring (has_zero (has_to_string linarith.comp))) : strong_rank_condition (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_37325 (h0 : topological_space (omega_complete_partial_order (option (option empty)))) : t1_space (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_37326 (h0 : functor.comp topological_space has_neg_part Type) : @t0_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_37327 (h0 : functor.add_const (group (left_cancel_monoid num)) unsigned) : @is_cyclic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37328 (h0 : group (measurable_space (semiring empty))) : normalizer_condition (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_37329 (h0 : functor.add_const (ring (has_add pos)) (has_add Type)) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_37330 (h0 : topological_space (add_cancel_monoid enat)) : path_connected_space (add_cancel_monoid enat) := sorry --non-trivial
lemma new_lemma_37331 (h0 : ring (has_norm (has_top unsigned))) : is_domain (has_norm (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_37332 (h0 : group (has_pos_part (has_nndist (finset (has_neg pos))))) : normalizer_condition (has_pos_part (has_nndist (finset (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_37333 (h0 : not (has_mem.mem empty has_emptyc.emptyc -> false)) : @monoid.fg.{0} empty (@finset.pi.empty.{1 0} Type monoid.{0} empty (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_37334 (h0 : ring (fintype (encodable char))) : strong_rank_condition (fintype (encodable char)) := sorry --non-trivial
lemma new_lemma_37335 (h0 : not (uniform_space (semiring (semiring congr_arg_kind)) -> false)) : @separated_space.{0} (semiring.{0} (semiring.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_37336 (h0 : functor.add_const (semiring (boolean_algebra pos)) linarith.comp) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37337 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37338 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_37339 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_37340 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_37341 (h0 : functor.add_const (function.extfun Type uniform_space) (finset linarith.comp)) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} linarith.comp) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_37342 (h0 : ring (normed_group (has_top congr_arg_kind))) : strong_rank_condition (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37343 (h0 h1 : multiset (has_le enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_37344 (h0 : add_group (monoid (option unsigned))) : is_add_cyclic (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_37345 (h0 : functor.add_const (topological_space (finset Type)) (finset environment.implicit_infer_kind)) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_37346 (h0 : auto.case_option -> Prop) (h1 : filter auto.case_option) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@filter.map.{0 0} auto.case_option Prop h0 h1)  := sorry --non-trivial
lemma new_lemma_37347 (h0 : cancel_comm_monoid_with_zero (has_add (has_pos_part (has_Inf (has_Inf real))))) : unique_factorization_monoid (has_add (has_pos_part (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_37348 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_37349 (h0 : add_monoid (non_assoc_semiring (semiring num))) : add_monoid.fg (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_37350 (h0 : filter (normed_lattice_add_comm_group real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37351 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @normal_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_37352 (h0 : topological_space (has_Inf (has_nndist name))) : loc_path_connected_space (has_Inf (has_nndist name)) := sorry --non-trivial
lemma new_lemma_37353 (h0 : ring (boolean_algebra (has_Inf linarith.comp))) : rank_condition (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_37354 (h0 : not (ring (measurable_space.dynkin_system congr_arg_kind) -> false)) : @is_domain.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_37355 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37356 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_37357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_37358 (h0 : group (random_gen (random_gen linarith.ineq))) : is_cyclic (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37359 (h0 : functor.add_const (ring (option congr_arg_kind)) (semiring num)) : @rank_condition.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_37360 (h0 : monoid (complete_distrib_lattice (ring Type))) : monoid.fg (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_37361 (h0 : functor.add_const (ordered_comm_monoid (has_to_string Type)) Type) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_37362 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_37363 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen to_additive.value_type))))) : path_connected_space (has_norm (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_37364 (h0 : topological_space (has_div string.iterator_imp)) : t0_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_37365 (h0 : ordered_add_comm_monoid (has_to_string ennreal)) : archimedean (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_37366 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @locally_compact_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37367 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) linarith.comp) : @path_connected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_37368 (h0 : ring (canonically_ordered_comm_semiring ennreal)) : rank_condition (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_37369 (h0 : decidable_eq (has_inv linarith.comp_source)) (h1 : equiv.perm (has_inv linarith.comp_source)) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_37370 (h8 : add_group (add_comm_semigroup char)) : is_add_cyclic (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_37371 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) congr_arg_kind) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_37372 (h0 : functor.add_const (list (normed_linear_ordered_group num)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37373 (h0 : list (simple_graph (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37374 (h1 : complete_lattice (fintype (random_gen fun_info))) : is_compactly_generated (fintype (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_37375 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_37376 (h0 : topological_space (topological_space (random_gen string_imp))) : locally_compact_space (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_37377 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37378 (h0 : add_monoid (with_bot (semiring (has_top (semiring empty))))) : add_monoid.fg (with_bot (semiring (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_37379 (h0 : ring (non_unital_non_assoc_semiring enat)) : rank_condition (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_37380 (h1 : topological_space (comm_ring string.iterator_imp)) : t0_space (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_37381 (h0 : list (ordered_comm_group empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37382 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37383 (h0 : topological_space (has_to_string name)) : preconnected_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_37384 (h0 : topological_space (has_compl string_imp)) : totally_disconnected_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_37385 (h0 : topological_space (left_cancel_monoid num)) : path_connected_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_37386 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_37387 (h0 : functor.add_const (topological_space znum) num) : @preconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_37388 (h0 : semiring char) (h1 : polynomial char) (h2 : vector Prop (has_add.add (polynomial.nat_degree h1) has_one.one)) : vector.last h2 := sorry --non-trivial
lemma new_lemma_37389 (h0 : functor.add_const (functor.add_const (uniform_space environment.implicit_infer_kind) name) name) : @separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (uniform_space.{0} environment.implicit_infer_kind) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} environment.implicit_infer_kind) name) name h0))  := sorry --non-trivial
lemma new_lemma_37390 (h0 : ring (comm_group (add_cancel_monoid pos))) : rank_condition (comm_group (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_37391 (h0 : topological_space (normed_comm_ring (finset (finset (finset linarith.comp))))) : totally_disconnected_space (normed_comm_ring (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_37392 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37393 (h0 : not (topological_space (has_norm name) -> false)) : @totally_separated_space.{0} (has_norm.{0} name) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_37394 (h0 : filter (distrib_lattice (has_ssubset linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37395 (h1 : ring (topological_space (has_nnnorm fun_info))) : strong_rank_condition (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_37396 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (ring Type)) : @discrete_topology.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_37397 (h0 : functor.add_const (uniform_space (free_add_monoid unsigned)) (option (option unsigned))) : @separated_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37398 (h0 : complete_lattice (normed_linear_ordered_group num)) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_37399 (h0 h1 : multiset std_gen) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_37400 (h0 : topological_space (boolean_algebra (has_add (comm_group (has_to_string pos))))) : totally_disconnected_space (boolean_algebra (has_add (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_37401 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37402 (h0 : functor.add_const (monoid (has_neg linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37403 (h1 : topological_space (mul_one_class std_gen)) : path_connected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_37404 (h0 : measurable_space (has_div (mul_one_class linarith.comp_source))) (h1 : filter (has_div (mul_one_class linarith.comp_source))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_37405 (h0 : ring (preorder empty)) : strong_rank_condition (preorder empty) := sorry --non-trivial
lemma new_lemma_37406 (h0 : ring (mul_zero_class pos)) : rank_condition (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_37407 (h0 : uniform_space (preorder num)) : complete_space (preorder num) := sorry --non-trivial
lemma new_lemma_37408 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @locally_compact_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_37409 (h0 : set nat) : set.finite h0 := sorry --non-trivial
lemma new_lemma_37410 (h1 : group (has_top (random_gen (random_gen (random_gen fun_info))))) : group.fg (has_top (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_37411 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 unsigned) := sorry --non-trivial
lemma new_lemma_37412 (h0 : functor.add_const (ring (mul_zero_class unsigned)) unsigned) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37413 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part Type))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_37414 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37415 (h0 : group (sub_neg_monoid (has_add (has_add linarith.comp)))) : normalizer_condition (sub_neg_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_37416 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37417 (h0 : ring (has_nndist (option unsigned))) : strong_rank_condition (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_37418 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : discrete_topology (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_37419 (h0 : not (topological_space (has_nnnorm reducibility_hints) -> false)) (h1 : not (measurable_space (has_nnnorm reducibility_hints) -> false)) : @borel_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} reducibility_hints)) h0) (@classical.by_contradiction'.{1} (measurable_space.{0} (has_nnnorm.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_37420 (h0 : topological_space (normed_comm_ring (measurable_space (has_to_string (boolean_algebra unsigned))))) : preconnected_space (normed_comm_ring (measurable_space (has_to_string (boolean_algebra unsigned)))) := sorry --non-trivial
lemma new_lemma_37421 (h0 : has_lt (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : no_max_order (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_37422 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_37423 (h0 : not (complete_lattice (normed_lattice_add_comm_group num) -> false)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_37424 (h0 : has_neg (cancel_monoid ennreal) -> has_neg (cancel_monoid ennreal) -> Prop) : is_symm (has_neg (cancel_monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_37425 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) environment.implicit_infer_kind) name) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) environment.implicit_infer_kind) name h0))  := sorry --non-trivial
lemma new_lemma_37426 (h0 : topological_space (semigroup Type)) : sequential_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_37427 (h0 : add_group (semiring unsigned)) : is_add_cyclic (semiring unsigned) := sorry --non-trivial
lemma new_lemma_37428 (h1 : not (complete_lattice (measurable_space linarith.ineq) -> false)) : is_atomistic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_37429 (h0 : uniform_space (has_union (has_norm (has_top congr_arg_kind)))) : separated_space (has_union (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_37430 (h0 : topological_space (fintype (has_nnnorm linarith.comp_source))) : t0_space (fintype (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37431 (h0 : topological_space (linear_ordered_field (option (option (option (option (option ennreal))))))) : locally_compact_space (linear_ordered_field (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_37432 (h0 : monoid (has_to_string (cancel_monoid (has_add (finset environment.implicit_infer_kind))))) : monoid.fg (has_to_string (cancel_monoid (has_add (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_37433 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_37434 (h0 : filter (fintype (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37435 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) (boolean_algebra name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37436 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_37437 (h0 : ring (with_bot (has_norm (has_norm empty)))) : is_domain (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_37438 (h0 : functor.add_const (topological_space (add_group empty)) empty) : @loc_path_connected_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_37439 (h1 : uniform_space (has_compl (has_ssubset char))) : complete_space (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_37440 (h0 : group (has_nndist (has_neg_part Type))) : group.fg (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_37441 (h0 : topological_space (complete_distrib_lattice Type)) : locally_compact_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_37442 (h0 : add_group (has_Sup (semiring num))) : is_add_cyclic (has_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_37443 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @normal_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37444 (h0 : add_group (has_neg (has_zero (finset Type)))) : is_add_cyclic (has_neg (has_zero (finset Type))) := sorry --non-trivial
lemma new_lemma_37445 (h0 : uniform_space (with_one (has_norm (semiring num)))) : separated_space (with_one (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_37446 (h0 : functor.add_const (complete_lattice (has_add environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_37447 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.comp))) : path_connected_space (complete_semilattice_Sup (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_37448 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37449 (h0 : topological_space (complete_distrib_lattice (has_nndist pos))) : totally_separated_space (complete_distrib_lattice (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_37450 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) name) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_37451 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) unsigned) : @totally_disconnected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37452 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @normal_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37453 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @normal_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_37454 (h0 : complete_lattice (has_neg (has_nndist (add_comm_monoid pos)))) : complete_lattice.is_Sup_finite_compact (has_neg (has_nndist (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_37455 (h0 : topological_space (boolean_algebra.core (add_comm_monoid (finset Type)))) : preirreducible_space (boolean_algebra.core (add_comm_monoid (finset Type))) := sorry --non-trivial
lemma new_lemma_37456 (h0 : ring (add_cancel_monoid (comm_group name))) : is_domain (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_37457 (h1 : has_neg (nondiscrete_normed_field char)) (h2 : measurable_space (nondiscrete_normed_field char)) : has_measurable_neg (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_37458 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37459 (h0 : not (semiring (linear_ordered_comm_ring unsigned) -> false)) : @is_noetherian_ring.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37460 (h0 : ring (ring (has_pos_part Type))) : is_domain (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_37461 (h0 : topological_space (denumerable fun_info)) : sequential_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_37462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_37463 (h0 : topological_space (boolean_algebra (has_nndist (has_add (has_Inf (has_Inf (has_add Type))))))) : preconnected_space (boolean_algebra (has_nndist (has_add (has_Inf (has_Inf (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_37464 (h0 : functor.add_const (add_monoid (comm_group Type)) (has_neg environment.implicit_infer_kind)) : @add_monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (comm_group.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_37465 (h0 : functor.add_const (topological_space (semigroup name)) unsigned) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37466 (h0 : ring (has_ssubset (denumerable to_additive.value_type))) : is_domain (has_ssubset (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_37467 (h0 : ring (semiring (semiring num))) : is_domain (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_37468 (h0 : group (id (random_gen (random_gen linarith.comp_source)))) : group.fg (id (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_37469 (h0 : not (group (semiring fun_info) -> false)) : @is_cyclic.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_37470 (h1 : ring (boolean_algebra.core std_gen)) : strong_rank_condition (boolean_algebra.core std_gen) := sorry --non-trivial
lemma new_lemma_37471 (h0 : topological_space (has_zero (has_to_string name))) : normal_space (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_37472 (h0 : functor.comp ring has_nndist name) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_37473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37474 (h0 : semiring (add_right_cancel_monoid (has_top empty))) : is_noetherian_ring (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_37475 (h0 : filter (encodable (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37476 (h0 : complete_lattice (random_gen (random_gen (random_gen to_additive.value_type)))) : is_atomistic (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_37477 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_37478 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : t0_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_37479 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_add Type))) : unique_factorization_monoid (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_37480 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg pos)) (has_add pos)) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_37481 (h0 : filter (monoid_with_zero pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37482 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) name) : @irreducible_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_37483 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_37484 (h0 : topological_space (has_bot name)) : normal_space (has_bot name) := sorry --non-trivial
lemma new_lemma_37485 (h0 : uniform_space (ordered_comm_ring (finset pos))) : separated_space (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_37486 (h0 : ring (has_bot pos)) : rank_condition (has_bot pos) := sorry --non-trivial
lemma new_lemma_37487 (h0 : list (div_inv_monoid (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37488 (h0 : functor.add_const (complete_lattice (has_neg name)) linarith.comp) : @is_compactly_generated.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37489 (h0 : topological_space (has_pos_part (sub_neg_monoid pos))) : preconnected_space (has_pos_part (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_37490 (h0 : fin has_zero.zero) : @is_cyclic.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_37492 (h0 : complete_lattice (semigroup unsigned)) : complete_lattice.is_Sup_finite_compact (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_37493 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_37494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_37495 (h0 : functor.add_const (topological_space (has_neg unsigned)) (has_neg (has_neg linarith.comp))) : @regular_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37496 (h0 : topological_space (has_zero (finset (finset environment.implicit_infer_kind)))) : totally_disconnected_space (has_zero (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_37497 (h0 : topological_space (has_neg_part (ring (ring pos)))) : topological_space.separable_space (has_neg_part (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_37498 (h0 : topological_space (linear_ordered_comm_group (option num))) : totally_separated_space (linear_ordered_comm_group (option num)) := sorry --non-trivial
lemma new_lemma_37499 (h0 : group (has_emptyc (has_top (has_top fun_info)))) : normalizer_condition (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_37500 (h0 : prod (preorder num) (preorder num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_37501 (h0 : topological_space (has_add (ring (ring linarith.comp)))) : topological_space.separable_space (has_add (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_37502 (h0 h2 : multiset char) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_37503 (h0 : functor.add_const (list (has_nndist Type)) (has_pos_part Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37504 (h2 : uniform_space to_additive.value_type) : complete_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_37505 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_37506 (h0 : not (add_group (has_emptyc linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_37507 (h0 : functor.add_const (semiring (has_nndist pos)) name) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_37508 (h0 : function.extfun Type (prod (has_sub empty))) : id_rel (function.extfun_app h0 (has_sub empty)) := sorry --non-trivial
lemma new_lemma_37509 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_37510 (h0 : group (has_top (semiring (semiring empty)))) : normalizer_condition (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_37511 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) pos) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_37512 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_37513 (h0 : functor.add_const (list (simple_graph pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37514 (h0 : topological_space (has_top (has_inv linarith.comp_source))) : totally_separated_space (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37515 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37516 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) (finset pos)) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_37517 (h0 : ring (add_group (has_top (has_top (semiring empty))))) : rank_condition (add_group (has_top (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_37518 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @preconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_37519 (h0 : topological_space (has_to_string (has_neg_part (comm_group pos)))) : topological_space.separable_space (has_to_string (has_neg_part (comm_group pos))) := sorry --non-trivial
lemma new_lemma_37520 (h0 : ring (encodable (has_top linarith.ineq))) : strong_rank_condition (encodable (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37521 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_37522 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid (has_Inf (has_add linarith.comp)))) : unique_factorization_monoid (sub_neg_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_37523 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_37524 (h0 : ring (linear_ordered_comm_monoid_with_zero unsigned)) : is_domain (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_37525 (h0 : topological_space (has_to_string pos)) : sequential_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_37526 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_37527 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_37528 (h0 : functor.add_const (filter (has_nndist unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_37530 (h0 : topological_space (linear_ordered_semiring (has_norm linarith.comp))) : discrete_topology (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_37531 (h0 : functor.add_const (finset (has_nndist ennreal)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37532 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : preconnected_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_37533 (h0 : topological_space (random_gen empty)) : preirreducible_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_37534 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_monoid.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_37535 (h0 : topological_space (has_neg_part (option (option pos)))) : path_connected_space (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_37536 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_37537 (h0 : complete_lattice (has_emptyc num)) : is_atomistic (has_emptyc num) := sorry --non-trivial
lemma new_lemma_37538 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space num) := sorry --non-trivial
lemma new_lemma_37539 (h0 : functor.add_const (finset (partial_order num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37540 (h0 : group (has_pos_part (has_neg linarith.comp))) : normalizer_condition (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_37541 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) (ring pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37542 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_37543 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) pos) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37544 (h0 : topological_space (normed_field (comm_ring fun_info))) : t0_space (normed_field (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_37545 (h0 : option (topological_space (has_bot congr_arg_kind))) (h1 : topological_space (has_bot congr_arg_kind)) : locally_compact_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37546 (h0 : topological_space (measurable_space linarith.comp)) : discrete_topology (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_37547 (h0 : topological_space (has_inner (option unsigned) num)) : normal_space (has_inner (option unsigned) num) := sorry --non-trivial
lemma new_lemma_37548 (h0 : list (with_one (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37549 (h0 : functor.add_const (complete_lattice (boolean_algebra environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37550 (h0 : not (complete_lattice (normed_field (has_nnnorm (has_nnnorm fun_info))) -> false)) : @is_compactly_generated.{0} (normed_field.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_37551 (h0 : functor.add_const (finset (has_nndist Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37552 (h0 : not (list (add_right_cancel_monoid empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_37553 (h1 : ring (encodable fun_info)) : rank_condition (encodable fun_info) := sorry --non-trivial
lemma new_lemma_37554 (h0 : add_group (has_le (has_le (has_nnnorm std_gen)))) : is_add_cyclic (has_le (has_le (has_nnnorm std_gen))) := sorry --non-trivial
lemma new_lemma_37555 (h0 : topological_space (finset (option empty))) : path_connected_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_37556 (h0 : topological_space (has_to_string (has_neg_part name))) : preirreducible_space (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_37557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_37558 (h0 : not (monoid (mul_zero_class unsigned) -> false)) : @monoid.fg.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37559 (h0 : measurable_space linarith.comp) (h1 : function.extfun Type has_add) : @has_measurable_add.{0} linarith.comp h0 (@function.extfun_app.{2 1} Type has_add.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_37560 (h0 : topological_space (parser empty)) : preirreducible_space (parser empty) := sorry --non-trivial
lemma new_lemma_37561 (h0 : list (has_zero (has_neg_part unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37562 (h0 : topological_space (linear_ordered_semiring (semiring num))) : totally_separated_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_37563 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring (semiring empty))))) : unique_factorization_monoid (partial_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_37564 (h0 : functor.add_const (topological_space (boolean_algebra real)) (has_neg (has_Inf Type))) : @t0_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} real)) (has_neg.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_37565 (h0 : topological_space (has_neg_part (has_add name))) : path_connected_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_37566 (h0 : functor.add_const (group (has_nndist name)) pos) : @is_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_37567 (h0 : ordered_add_comm_monoid (semigroup (ring linarith.comp))) : archimedean (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_37568 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_37569 (h0 : list (has_neg (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37570 (h0 : topological_space (boolean_algebra (sub_neg_monoid real))) : discrete_topology (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_37571 (h0 : uniform_space (has_Inf (has_nndist (has_nndist pos)))) : separated_space (has_Inf (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_37572 (h0 : group (has_to_string (has_add (ring (has_add pos))))) : is_cyclic (has_to_string (has_add (ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_37573 (h0 : ordered_add_comm_monoid (has_to_string (has_neg_part (has_to_string linarith.comp)))) : archimedean (has_to_string (has_neg_part (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_37574 (h0 : ring (has_inv (random_gen linarith.comp_source))) : is_domain (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37575 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) num) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_37576 (h0 : filter (has_add fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37577 (h0 : function.extfun Type (functor.add_const (ring pos))) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_37578 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) real) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_37579 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_37580 (h0 : topological_space (has_zero (ring (finset (finset environment.implicit_infer_kind))))) : path_connected_space (has_zero (ring (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_37581 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37582 (h0 : topological_space (has_norm (semiring linarith.comp))) : irreducible_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_37583 (h0 : topological_space (semigroup (semiring (semiring empty)))) : t0_space (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_37584 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37585 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37586 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37587 (h1 : topological_space linarith.ineq) : t0_space linarith.ineq := sorry --non-trivial
lemma new_lemma_37588 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_37589 (h0 : topological_space (semigroup empty)) : totally_disconnected_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_37590 (h0 : not (complete_lattice (id empty) -> false)) : @is_atomistic.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_37591 (h0 : not (semiring (measurable_space congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_37592 (h0 : topological_space (finset (has_neg_part Type))) : loc_path_connected_space (finset (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_37593 (h1 : complete_lattice (measurable_space string_imp)) : is_compactly_generated (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_37594 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_ring unsigned)) num) : @unique_factorization_monoid.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_37595 (h0 : ring (uniform_space char)) : strong_rank_condition (uniform_space char) := sorry --non-trivial
lemma new_lemma_37596 (h0 : functor.add_const (filter (group_with_zero ennreal)) ennreal) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37597 (h0 : not (group (normed_group char) -> false)) : @group.fg.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_37598 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @preirreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_37599 (h0 : ring (uniform_space (metric_space reducibility_hints))) : strong_rank_condition (uniform_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_37600 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_37601 (h0 : complete_lattice (uniform_space reducibility_hints)) : complete_lattice.is_Sup_finite_compact (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_37602 (h0 : complete_lattice (left_cancel_semigroup num)) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_37603 (h0 : functor.add_const (monoid (has_zero Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37604 (h0 : topological_space (with_bot (denumerable linarith.ineq))) : path_connected_space (with_bot (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37605 (h0 : semiring (normed_linear_ordered_group congr_arg_kind)) : is_noetherian_ring (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37606 (h0 : functor.add_const Prop (normed_lattice_add_comm_group real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_37607 (h0 : topological_space (has_compl ereal)) (h1 : add_group (has_compl ereal)) : topological_add_group (has_compl ereal) := sorry --non-trivial
lemma new_lemma_37608 (h0 : complete_lattice (has_add (has_bot real))) : is_compactly_generated (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_37609 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @discrete_topology.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_37610 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @topological_space.separable_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37611 (h0 : functor.add_const (list (plift empty)) (option (option (option unsigned)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37612 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) congr_arg_kind) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_37613 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_37614 (h0 : filter (measurable_space.dynkin_system (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37615 (h2 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37616 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_37617 (h0 : list (uniform_space (has_ssubset fun_info))) (h1 : ne h0 list.nil) : @complete_space.{0} (has_ssubset.{0} fun_info) (@list.last.{0} (uniform_space.{0} (has_ssubset.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_37618 (h0 : topological_space (generalized_boolean_algebra (finset Type))) : t0_space (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_37619 (h0 : list (add_comm_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_37621 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_cyclic.{0} fun_info (@finset.pi.empty.{1 0} Type group.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_37622 (h0 : pnat) (h1 : thunk pnat) : pnat.coprime h0 (@trace_call_stack.{0} pnat h1)  := sorry --non-trivial
lemma new_lemma_37623 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_37624 (h0 : ring (has_scalar Type name)) : rank_condition (has_scalar Type name) := sorry --non-trivial
lemma new_lemma_37625 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37626 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_37627 (h2 : filter (has_top linarith.ineq)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_37628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_37629 (h0 : list (linear_ordered_comm_ring (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37630 (h0 : group (preorder (option empty))) : normalizer_condition (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_37631 (h1 : ring (with_zero char)) : rank_condition (with_zero char) := sorry --non-trivial
lemma new_lemma_37632 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_37633 (h0 : group (group_with_zero ennreal)) : group.fg (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_37634 (h0 : topological_space (has_pos_part (has_neg name))) : path_connected_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_37635 (h0 : not (semiring (semiring unsigned) -> false)) : @is_noetherian_ring.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37636 (h1 : topological_space (has_union (id (has_top (has_union (id empty)))))) : totally_disconnected_space (has_union (id (has_top (has_union (id empty))))) := sorry --non-trivial
lemma new_lemma_37637 (h0 : filter (complete_semilattice_Sup (has_top (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37638 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : preirreducible_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_37639 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (has_zero linarith.comp)) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_37640 (h0 : fin has_zero.zero) : @is_atomistic.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_37641 (h0 : fin has_zero.zero) : @is_simple_group.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37642 (h1 : topological_space (has_append linarith.comp_source)) : t0_space (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37643 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_37644 (h0 : group (ordered_comm_monoid (has_Inf real))) : normalizer_condition (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_37645 (h0 : functor.add_const (uniform_space (add_cancel_monoid name)) environment.implicit_infer_kind) : @complete_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37646 (h0 : functor.comp monoid cancel_monoid Type) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_37647 (h0 : topological_space (monoid (option (option (option congr_arg_kind))))) : totally_disconnected_space (monoid (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_37648 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_37649 (h0 : functor.add_const (topological_space (has_add unsigned)) pos) : @regular_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_37650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37651 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37652 (h0 : functor.add_const (topological_space (ring name)) pos) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_37653 (h0 : filter (dlist (has_inv (has_ssubset to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37654 (h0 : filter (generalized_boolean_algebra (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37655 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group environment.implicit_infer_kind)) pos) : @archimedean.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37656 (h0 : cancel_comm_monoid_with_zero (with_one unsigned)) : unique_factorization_monoid (with_one unsigned) := sorry --non-trivial
lemma new_lemma_37657 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_37658 (h0 : add_monoid (has_neg_part (comm_group (comm_group (comm_group (comm_group Type)))))) : add_monoid.fg (has_neg_part (comm_group (comm_group (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_37659 (h0 : functor.add_const (functor.add_const (ring (has_nndist linarith.comp)) pos) environment.implicit_infer_kind) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) pos) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_37660 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_37661 (h1 : ring linarith.comp) : is_domain linarith.comp := sorry --non-trivial
lemma new_lemma_37662 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring name)) pos) : @archimedean.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_37663 (h0 : uniform_space (semigroup (finset (has_add environment.implicit_infer_kind)))) : separated_space (semigroup (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_37664 (h0 : not (complete_lattice (distrib reducibility_hints) -> false)) : @is_compactly_generated.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_37665 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup empty)) (semiring unsigned)) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_37666 (h0 : complete_lattice (uniform_space (metric_space (random_gen char)))) : is_compactly_generated (uniform_space (metric_space (random_gen char))) := sorry --non-trivial
lemma new_lemma_37667 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) (has_neg_part pos)) : @is_atomistic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_37668 (h0 : ring (comm_ring (comm_ring char))) : rank_condition (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_37669 (h0 : not (topological_space (normed_group char) -> false)) : @path_connected_space.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_37670 (h0 : functor.add_const (topological_space (boolean_algebra name)) (has_add (boolean_algebra (boolean_algebra pos)))) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (has_add.{0} (boolean_algebra.{0} (boolean_algebra.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_37671 (h2 : topological_space ereal) : topological_space.first_countable_topology ereal := sorry --non-trivial
lemma new_lemma_37672 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37673 (h0 : uniform_space (add_cancel_monoid ennreal)) : complete_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_37674 (h2 : list (id (has_top linarith.ineq))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_37675 (h0 : topological_space (cancel_monoid (has_to_string ennreal))) : preirreducible_space (cancel_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_37676 (h0 : function.extfun Type uniform_space) : separated_space real := sorry --non-trivial
lemma new_lemma_37677 (h0 : uniform_space (has_star (semiring empty))) : separated_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_37678 (h0 : not (topological_space (add_cancel_comm_monoid (random_gen string.iterator_imp)) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} (random_gen.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} (random_gen.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_37679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_37680 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_37681 (h0 : complete_lattice (add_cancel_monoid (has_add pos))) : is_compactly_generated (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_37682 (h0 : set (add_comm_semigroup enat -> nondiscrete_normed_field fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_37683 (h0 : add_group (with_one (has_inv (comm_ring to_additive.value_type)))) : is_add_cyclic (with_one (has_inv (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_37684 (h0 : list (comm_group pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37685 (h0 : topological_space (canonically_ordered_add_monoid (option empty))) : t1_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_37686 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_37687 (h0 : ring (has_norm (random_gen (has_inv string_imp)))) : is_domain (has_norm (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_37688 (h4 : ring (distrib char)) : rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_37689 (h0 : uniform_space (has_sub unsigned)) : separated_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_37690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (finset pos)) := sorry --non-trivial
lemma new_lemma_37691 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_37692 (h0 : ring (linear_ordered_cancel_comm_monoid unsigned)) : rank_condition (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_37693 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf name))) : is_compactly_generated (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_37694 (h0 : fin has_zero.zero) : @regular_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37695 (h1 : complete_lattice (topological_space (comm_ring char))) : is_compactly_generated (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_37696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_37697 (h0 : uniform_space (semigroup (mul_one_class Type))) : separated_space (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_37698 (h0 : topological_space (finset (finset (has_add ennreal)))) : irreducible_space (finset (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_37699 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg name)) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_37700 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_37701 (h0 : topological_space (finset real)) : totally_disconnected_space (finset real) := sorry --non-trivial
lemma new_lemma_37702 (h0 : filter (ring (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37703 (h0 : not (ring (add_group unsigned) -> false)) : @is_principal_ideal_ring.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37704 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_37705 (h0 : functor.add_const (topological_space (add_group empty)) unsigned) : @totally_disconnected_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37706 (h0 : functor.add_const (topological_space (finset unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37707 (h0 : cancel_comm_monoid_with_zero (has_neg_part (finset ennreal))) : unique_factorization_monoid (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_37708 (h0 : not (topological_space (has_nndist unsigned) -> false)) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nndist.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_37709 (h0 : functor.add_const (topological_space Type) (ring (ring linarith.comp))) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37710 (h0 : not (topological_space (bin_tree num) -> false)) : @t1_space.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_37711 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37712 (h0 : uniform_space (has_top (has_inv fun_info))) : complete_space (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_37713 (h0 : functor.add_const (topological_space (monoid unsigned)) congr_arg_kind) : @t0_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_37714 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) linarith.comp) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37715 (h0 : topological_space (normed_field (mul_one_class string.iterator_imp))) : t0_space (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_37716 (h0 : ring (preorder congr_arg_kind)) : rank_condition (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37717 (h0 : group (linear_ordered_add_comm_group linarith.ineq)) : is_cyclic (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_37718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37719 (h0 : topological_space (with_bot (has_top fun_info))) : t0_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_37720 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37721 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_37722 (h0 : functor.comp filter comm_group name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_37723 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_37724 (h0 : ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg linarith.comp))))) : has_exists_mul_of_le (has_neg (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_37725 (h0 : functor.add_const (group (option pos)) pos) : @normalizer_condition.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_37726 (h0 : add_group (ordered_comm_ring (ring Type))) : is_add_cyclic (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_37727 (h3 : ring (topological_space (random_gen char))) : is_domain (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_37728 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37729 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (option empty)) := sorry --non-trivial
lemma new_lemma_37730 (h0 : topological_space (linear_ordered_add_comm_group fun_info)) : totally_disconnected_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_37731 (h0 : functor.add_const (topological_space (bin_tree unsigned)) empty) : @irreducible_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_37732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_37733 (h0 : topological_space (has_bot empty)) : totally_disconnected_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_37734 (h0 : semiring (ordered_comm_ring (has_Inf Type))) : is_noetherian_ring (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_37735 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part name)) linarith.comp) : @unique_factorization_monoid.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37736 (h0 : ring (has_append (has_nnnorm (random_gen (random_gen linarith.comp_source))))) : strong_rank_condition (has_append (has_nnnorm (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_37737 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_37738 (h0 : functor.add_const (ring (has_pos_part name)) name) : @is_domain.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_37739 (h0 : topological_space (generalized_boolean_algebra (has_neg pos))) : path_connected_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_37740 (h0 : fin has_zero.zero) : @normal_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_37741 (h0 : finset (ordered_cancel_add_comm_monoid (option (option (option ennreal))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37742 (h0 : group (complete_distrib_lattice (canonically_linear_ordered_monoid name))) : group.fg (complete_distrib_lattice (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_37743 (h0 : not (ring (has_norm linarith.comp_source) -> false)) : @is_domain.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_37744 (h0 : functor.add_const Prop (has_zero (boolean_algebra Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_37745 (h0 : not (uniform_space (measurable_space empty) -> false)) : @separated_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37747 (h0 : add_group (has_to_string (comm_group (has_neg_part (measurable_space Type))))) : is_add_cyclic (has_to_string (comm_group (has_neg_part (measurable_space Type)))) := sorry --non-trivial
lemma new_lemma_37748 (h0 : topological_space (bin_tree (semiring (semiring unsigned)))) : topological_space.separable_space (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_37749 (h0 : finset (ring (add_cancel_monoid (has_neg_part (has_neg_part name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37750 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) (has_Inf linarith.comp)) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ring.{1} Type)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_37751 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_37752 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_37753 (h0 : uniform_space (add_comm_monoid (finset (has_nndist (mul_zero_class pos))))) : complete_space (add_comm_monoid (finset (has_nndist (mul_zero_class pos)))) := sorry --non-trivial
lemma new_lemma_37754 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_37755 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37756 (h0 : complete_distrib_lattice unsigned -> complete_distrib_lattice unsigned -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_37757 (h0 : ring (has_norm (random_gen (random_gen linarith.ineq)))) : is_domain (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_37758 (h1 : group (add_left_cancel_monoid (has_nnnorm char))) : is_cyclic (add_left_cancel_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_37759 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_37760 (h0 : functor.add_const (add_monoid (canonically_linear_ordered_monoid unsigned)) unsigned) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_linear_ordered_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37761 (h1 : topological_space (simple_graph fun_info)) (h2 : preorder (simple_graph fun_info)) : order_closed_topology (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_37762 (h0 : not (monoid linarith.comp -> false)) : @monoid.fg.{0} linarith.comp (@classical.by_contradiction'.{1} (monoid.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_37763 (h0 : semiring (ordered_comm_ring (has_add (has_add (has_Inf (has_add real)))))) : is_noetherian_ring (ordered_comm_ring (has_add (has_add (has_Inf (has_add real))))) := sorry --non-trivial
lemma new_lemma_37764 (h0 : list (ring (denumerable (random_gen to_additive.value_type)))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @rank_condition.{0} (denumerable.{0} (random_gen.{0} to_additive.value_type)) (@list.nth_le.{0} (ring.{0} (denumerable.{0} (random_gen.{0} to_additive.value_type))) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_37765 (h1 : has_mem.mem (complete_lattice linarith.comp_source) has_emptyc.emptyc) (h2 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_compactly_generated.{0} linarith.comp_source (@option.get_or_else.{0} (complete_lattice.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type option.{0} (complete_lattice.{0} linarith.comp_source) h1) (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source h2))  := sorry --non-trivial
lemma new_lemma_37766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37767 (h0 : complete_distrib_lattice ennreal -> complete_distrib_lattice ennreal -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_37768 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (monoid (option ennreal))) := sorry --non-trivial
lemma new_lemma_37769 (h0 : functor.add_const (finset (has_neg unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37770 (h0 : functor.add_const (complete_lattice (has_zero Type)) pos) : @is_atomistic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_37771 (h0 : filter (linear_ordered_semiring (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37772 (h0 : list (has_nndist (has_to_string unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37773 (h0 : complete_lattice (has_norm (has_norm congr_arg_kind))) : is_compactly_generated (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_37775 (h0 : has_lt (has_nnnorm char)) : no_max_order (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_37776 (h0 : topological_space (ordered_comm_ring (comm_semigroup linarith.comp))) : normal_space (ordered_comm_ring (comm_semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_37777 (h0 : function.extfun nat fin) : @t0_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_37778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_37779 (h0 : ring (linear_ordered_field (option ennreal))) : is_principal_ideal_ring (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_37780 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_37781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_37782 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @t0_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37783 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37784 (h0 : set (has_lt environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_37785 (h0 : not (group (id linarith.comp) -> false)) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_37786 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @totally_disconnected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_37787 (h0 : topological_space (simple_graph (option empty))) : discrete_topology (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_37788 (h0 : semiring (has_pos_part (has_Inf (ring (has_nndist pos))))) : is_noetherian_ring (has_pos_part (has_Inf (ring (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_37789 (h0 : uniform_space (has_top (random_gen (has_inv fun_info)))) : complete_space (has_top (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_37790 (h1 : ring (fintype (has_append (comm_ring char)))) : rank_condition (fintype (has_append (comm_ring char))) := sorry --non-trivial
lemma new_lemma_37791 (h0 : topological_space (filter empty)) : irreducible_space (filter empty) := sorry --non-trivial
lemma new_lemma_37792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_37793 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) : locally_compact_space (complete_semilattice_Sup (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_37794 (h0 : topological_space (has_zero (boolean_algebra (boolean_algebra linarith.comp)))) : preirreducible_space (has_zero (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_37795 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_37796 (h0 : topological_space (has_add (ring (ring Type)))) : preirreducible_space (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_37797 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : locally_compact_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37799 (h0 : functor.comp filter complete_distrib_lattice name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_37800 (h0 : functor.add_const (ring (mul_zero_class pos)) Type) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_37801 (h0 : topological_space (has_emptyc (has_norm congr_arg_kind))) : totally_separated_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37802 (h0 : topological_space (has_div string.iterator_imp)) : path_connected_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_37803 (h0 : functor.add_const (complete_lattice (bin_tree empty)) (semiring num)) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_37804 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_37805 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @t0_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_37806 (h0 : not (topological_space complex -> false)) : path_connected_space complex := sorry --non-trivial
lemma new_lemma_37807 (h0 : functor.add_const (ring (has_add pos)) pos) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_37808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_37809 (h0 : group (generalized_boolean_algebra (has_pos_part linarith.comp))) : is_cyclic (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_37810 (h0 : topological_space (normed_group (has_ssubset linarith.ineq))) : t0_space (normed_group (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37811 (h0 : uniform_space (normed_comm_ring congr_arg_kind)) : complete_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37812 (h0 : ring (ring linarith.comp)) : strong_rank_condition (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_37813 (h0 : functor.add_const (add_monoid (has_to_string environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_37814 (h0 : topological_space (has_star (semiring congr_arg_kind))) : locally_compact_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37815 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid Type)) (has_neg_part pos)) : @archimedean.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_comm_monoid.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_37816 (h0 : topological_space (linear_ordered_semiring (has_top num))) : discrete_topology (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_37817 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) name) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_37818 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_37819 (h0 : group (has_pos_part (has_Inf Type))) : normalizer_condition (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_37820 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_37821 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_37822 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_37823 (h0 : functor.add_const (filter (has_nndist pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37824 (h0 : not (complete_lattice (has_one empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_37825 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_37826 (h0 : semiring (has_zero (has_neg_part pos))) : is_noetherian_ring (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_37827 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_37828 (h0 : ordered_add_comm_monoid (has_star (option unsigned))) : archimedean (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_37829 (h0 : not (topological_space (has_add linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_37830 (h0 : functor.add_const (topological_space (plift empty)) empty) : @loc_path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_37831 (h0 : function.extfun Type (functor.add_const (monoid pos))) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_37832 (h0 : topological_space (has_zero (boolean_algebra Type))) : totally_separated_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_37833 (h0 : group (normed_comm_ring (finset (finset ennreal)))) : group.fg (normed_comm_ring (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_37834 (h1 : uniform_space (simple_graph linarith.ineq)) : complete_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_37835 (h0 : complete_lattice (add_right_cancel_monoid (semiring congr_arg_kind))) : is_compactly_generated (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_37837 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_lattice_add_comm_group pos)) Type) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_37838 (h0 : functor.add_const (group (add_comm_monoid name)) Type) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_37839 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37840 (h0 : group (boolean_algebra (comm_group Type))) : is_simple_group (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_37841 (h0 : complete_lattice (linear_ordered_field (option pos))) : is_compactly_generated (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_37842 (h0 : topological_space (has_nnnorm enat)) (h1 : add_group (has_nnnorm enat)) : topological_add_group (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_37843 (h9 : uniform_space (topological_space char)) : complete_space (topological_space char) := sorry --non-trivial
lemma new_lemma_37844 (h0 : functor.add_const (list (ring linarith.comp)) (finset linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37845 (h0 : list (has_inter (add_comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37846 (h0 : topological_space (linear_ordered_field (option (option (option (option (option unsigned))))))) : t1_space (linear_ordered_field (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_37847 (h0 : topological_space (normed_comm_ring empty)) : loc_path_connected_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_37848 (h0 : topological_space (has_sub (semiring (semiring num)))) : locally_compact_space (has_sub (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_37849 (h0 : functor.add_const (ordered_comm_monoid (comm_group Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37850 (h0 : group (has_add ennreal)) : normalizer_condition (has_add ennreal) := sorry --non-trivial
lemma new_lemma_37851 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_37852 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_37853 (h0 : group (distrib (has_nnnorm string_imp))) : is_cyclic (distrib (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_37854 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_37855 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37856 (h0 : ring (has_emptyc (random_gen (random_gen (random_gen (random_gen fun_info)))))) : strong_rank_condition (has_emptyc (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_37857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_37858 (h0 : list (mul_zero_class congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_37859 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37860 (h0 : functor.add_const (semiring (has_add environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_37861 (h0 : group (has_star (semiring (semiring unsigned)))) : group.fg (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_37862 (h2 : topological_space (topological_space linarith.comp_source)) : t0_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37863 (h0 : topological_space (group_with_zero congr_arg_kind)) : totally_disconnected_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37864 (h0 : function.extfun (linarith.comp_source -> Type) (function.extfun linarith.comp_source)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.comp_source (@function.extfun_app.{1 1} linarith.comp_source (λ (x : linarith.comp_source), Prop) (@function.extfun_app.{2 1} (linarith.comp_source → Type) (function.extfun.{1 1} linarith.comp_source) h0 (λ (x : linarith.comp_source), Prop)))  := sorry --non-trivial
lemma new_lemma_37865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37866 (h0 : topological_space (order_dual unsigned)) : totally_disconnected_space (order_dual unsigned) := sorry --non-trivial
lemma new_lemma_37867 (h0 : functor.comp group has_neg_part pos) : @group.fg.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_37868 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37869 (h0 : monoid (has_neg_part unsigned)) : monoid.fg (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_37870 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring (semiring unsigned)))) : unique_factorization_monoid (left_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_37871 (h0 h1 : list enat) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_37872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_37873 (h0 : has_coe (nondiscrete_normed_field (normed_field linarith.ineq)) Prop) (h1 : nondiscrete_normed_field (normed_field linarith.ineq)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (normed_field.{0} linarith.ineq)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_37874 (h0 : functor.add_const (topological_space (finset pos)) environment.implicit_infer_kind) : @sequential_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37875 (h0 : ring (has_lt (mul_one_class char))) : strong_rank_condition (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_37876 (h0 : group (has_neg (add_comm_monoid (finset pos)))) : is_cyclic (has_neg (add_comm_monoid (finset pos))) := sorry --non-trivial
lemma new_lemma_37877 (h0 : has_zero (dlist linarith.comp_source)) (h1 : not (ring (nat.arithmetic_function (dlist linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (@nat.arithmetic_function.{0} (dlist.{0} linarith.comp_source) h0) (@classical.by_contradiction'.{1} (ring.{0} (@nat.arithmetic_function.{0} (dlist.{0} linarith.comp_source) h0)) h1)  := sorry --non-trivial
lemma new_lemma_37878 (h0 : functor.add_const (functor.add_const (group (has_to_string environment.implicit_infer_kind)) linarith.comp) Type) : @normalizer_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_37879 (h0 : functor.add_const (add_monoid (semigroup empty)) (option empty)) : @add_monoid.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_37880 (h0 : topological_space (has_add (ordered_comm_ring (has_Inf (has_Inf (has_neg pos)))))) : preconnected_space (has_add (ordered_comm_ring (has_Inf (has_Inf (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_37881 (h0 : ring (complete_semilattice_Sup (has_ssubset (random_gen to_additive.value_type)))) : is_domain (complete_semilattice_Sup (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_37882 (h0 : ring (generalized_boolean_algebra (has_pos_part (has_Inf (has_Inf linarith.comp))))) : strong_rank_condition (generalized_boolean_algebra (has_pos_part (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_37883 (h0 : list (has_top (random_gen (canonically_linear_ordered_add_monoid (has_ssubset to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37884 (h0 : ring (comm_semigroup (has_neg (add_comm_monoid (has_neg (has_bot name)))))) : rank_condition (comm_semigroup (has_neg (add_comm_monoid (has_neg (has_bot name))))) := sorry --non-trivial
lemma new_lemma_37885 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37886 (h1 h2 : multiset linarith.ineq) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_37887 (h1 : group (complete_semilattice_Sup string_imp)) : group.fg (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_37888 (h0 : filter (has_neg (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37889 (h0 : cancel_comm_monoid_with_zero (has_nndist (monoid linarith.comp))) : unique_factorization_monoid (has_nndist (monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_37890 (h0 : ring (mul_one_class (comm_group ennreal))) : is_domain (mul_one_class (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_37891 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_37892 (h0 : functor.add_const (monoid (complete_linear_order num)) (semiring (semiring (semiring num)))) : @monoid.fg.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (complete_linear_order.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_37893 (h0 : topological_space (has_top unsigned)) : totally_separated_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_37894 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_37895 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) environment.implicit_infer_kind) : @rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37896 (h0 : topological_space (add_group linarith.comp)) : totally_separated_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_37897 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @preconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37898 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : locally_compact_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_37899 (h0 : topological_space (finset (finset (has_add (finset (finset ennreal)))))) : path_connected_space (finset (finset (has_add (finset (finset ennreal))))) := sorry --non-trivial
lemma new_lemma_37900 (h0 : functor.add_const (ring (has_nndist linarith.comp)) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_37901 (h0 : functor.add_const (monoid (has_nndist empty)) empty) : @monoid.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_37902 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_37903 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37904 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) unsigned) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37905 (h0 : functor.comp filter canonically_ordered_comm_semiring ennreal) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_37906 (h0 : topological_space (finset (finset (has_pos_part (has_pos_part linarith.comp))))) : loc_path_connected_space (finset (finset (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_37907 (h0 : topological_space (ordered_comm_monoid (ordered_comm_ring Type))) : irreducible_space (ordered_comm_monoid (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_37908 (h0 : topological_space (monoid (option (option (option (option empty)))))) : t0_space (monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_37909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_37910 (h0 h1 : multiset (has_nnnorm reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_37911 (h0 : topological_space (normed_comm_ring (boolean_algebra linarith.comp))) : totally_disconnected_space (normed_comm_ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_37912 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @discrete_topology.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_37913 (h1 : complete_lattice (normed_group string_imp)) : is_compactly_generated (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_37914 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @t0_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_37915 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_37916 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (ring (has_neg Type))) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_37917 (h0 : ring (semigroup (add_comm_monoid name))) : strong_rank_condition (semigroup (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_37918 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37919 (h1 : ring (distrib (denumerable (has_nnnorm (has_append reducibility_hints))))) : is_domain (distrib (denumerable (has_nnnorm (has_append reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_37920 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_37921 (h0 : functor.comp ring complete_distrib_lattice environment.implicit_infer_kind) : @rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_37922 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @preirreducible_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_37923 (h0 : add_group (normed_comm_ring (ring Type))) : is_add_cyclic (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_37924 (h0 : complete_lattice (id (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_37925 (h0 : ordered_comm_monoid (has_add (option pos))) : has_exists_mul_of_le (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_37926 (h0 : group (ring (has_neg Type))) : is_simple_group (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_37927 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_neg linarith.comp))) : archimedean (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_37928 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option pos))) : unique_factorization_monoid (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_37929 (h0 : complete_lattice (free_add_monoid congr_arg_kind)) : is_atomistic (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37930 (h0 : functor.add_const (group (has_to_string linarith.comp)) Type) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_37931 (h0 : ring (ring (has_add (boolean_algebra.core name)))) : strong_rank_condition (ring (has_add (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_37932 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_37933 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_37934 (h0 : functor.add_const (functor.add_const (list pos) pos) (has_pos_part linarith.comp)) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_37935 (h0 : finset (semigroup (has_to_string name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_37936 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_37937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37938 (h0 : fin has_zero.zero) : @archimedean.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37939 (h0 : filter (has_pos_part (ring (has_neg (has_neg (has_neg name)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_37940 (h0 : complete_lattice (distrib_lattice linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37941 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_37942 (h0 : uniform_space (has_zero (has_pos_part environment.implicit_infer_kind))) : complete_space (has_zero (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_37943 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_37944 (h0 : topological_space (has_to_string (option (option (option (option empty)))))) : totally_disconnected_space (has_to_string (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_37945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_37946 (h0 : filter (dlist (random_gen (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_37947 (h1 : (topological_space char -> false) -> false) (h2 : topological_space char -> false) (h3 : false) : @t0_space.{0} char (@classical.by_contradiction'.{1} (topological_space.{0} char) (@function.update.{0 0} (topological_space.{0} char → false) (λ (a : topological_space.{0} char → false), false) (λ (a b : topological_space.{0} char → false), @decidable_eq_of_subsingleton.{0} (topological_space.{0} char → false) (@pi.subsingleton.{1 0} (topological_space.{0} char) (λ (ᾰ : topological_space.{0} char), false) (λ (a : topological_space.{0} char), subsingleton_prop false)) a b) h1 h2 h3))  := sorry --trivial
lemma new_lemma_37948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_37949 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_37950 (h0 : monoid (has_bot empty)) : monoid.fg (has_bot empty) := sorry --non-trivial
lemma new_lemma_37951 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_37952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_37953 (h0 : topological_space (cancel_monoid (add_comm_monoid name))) : irreducible_space (cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_37954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_37955 (h0 : monoid (normed_comm_ring (has_add (has_add name)))) : monoid.fg (normed_comm_ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_37956 (h0 : complete_lattice (has_zero (has_add (has_add Type)))) : is_compactly_generated (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_37957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_37958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_37959 (h0 : ring (denumerable (random_gen fun_info))) : is_domain (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_37960 (h2 : topological_space (dlist linarith.comp_source)) : totally_disconnected_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_37961 (h0 : functor.add_const (monoid (semigroup pos)) Type) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_37962 (h0 : function.extfun Type group) : @is_cyclic.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_37963 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring unsigned)))) : @topological_space.separable_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_37964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37965 (h0 : topological_space (with_one congr_arg_kind)) : totally_separated_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_37966 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @preirreducible_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_37967 (h0 : topological_space (non_assoc_semiring num)) : discrete_topology (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_37968 (h0 : topological_space (cancel_monoid (option (option (option num))))) : preconnected_space (cancel_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_37969 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_37970 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37971 (h0 : fin has_zero.zero) : @is_atomistic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_37972 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37973 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_37974 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_37975 (h0 : not (group (topological_space linarith.comp_source) -> false)) : @group.fg.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_37976 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring ennreal)) unsigned) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_37977 (h0 : topological_space (random_gen fun_info)) : discrete_topology (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_37978 (h0 : uniform_space (uniform_space string.iterator_imp)) : complete_space (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_37979 (h1 : complete_lattice ereal) : complete_lattice.is_Sup_finite_compact ereal := sorry --non-trivial
lemma new_lemma_37980 (h0 : function.extfun nat fin) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_37981 (h0 : functor.add_const (topological_space (boolean_algebra name)) (boolean_algebra Type)) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_37982 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) Type) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_37983 (h0 : list (has_zero (ring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_37984 (h0 : semiring (id char)) (h1 : id char) : even h1 := sorry --non-trivial
lemma new_lemma_37985 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) pos) : @is_domain.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_37986 (h0 : topological_space (filter empty)) : loc_path_connected_space (filter empty) := sorry --non-trivial
lemma new_lemma_37987 (h0 : group (complete_linear_order (semiring (semiring num)))) : group.fg (complete_linear_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_37988 (h4 : ring (semi_normed_comm_ring reducibility_hints)) : strong_rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_37989 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : topological_space.separable_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_37990 (h0 : topological_space (has_neg Type)) : totally_separated_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_37991 (h0 : topological_space (normed_lattice_add_comm_group Type)) : t1_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_37992 (h0 : topological_space (has_Inf (finset linarith.comp))) : topological_space.separable_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_37993 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_37994 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_37995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_37996 (h0 : complete_lattice (has_div (mul_one_class char))) : is_compactly_generated (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_37997 (h1 : complete_lattice (with_bot (random_gen (random_gen linarith.comp_source)))) : is_compactly_generated (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_37998 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_37999 (h0 : lattice (complete_distrib_lattice pos)) : is_modular_lattice (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_38000 (h0 : functor.add_const (filter (monoid_with_zero pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38001 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) congr_arg_kind) : @locally_compact_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38002 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_38003 (h0 : functor.comp group has_neg_part pos) : @is_cyclic.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_38004 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class pos)) name) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_38005 (h0 : topological_space (finset (option (option (option ennreal))))) : irreducible_space (finset (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_38006 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_38007 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38008 (h0 : topological_space (filter environment.implicit_infer_kind)) : loc_path_connected_space (filter environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_38009 (h0 : functor.add_const (complete_lattice (finset name)) (option unsigned)) : @is_atomistic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_38010 (h0 : functor.add_const (ordered_add_comm_monoid (plift empty)) empty) : @archimedean.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_38011 (h2 : ring (complete_distrib_lattice to_additive.value_type)) : strong_rank_condition (complete_distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38012 (h0 : functor.add_const (finset (has_zero linarith.comp)) (has_add linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38013 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @loc_path_connected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_38014 (h0 : uniform_space (with_one (normed_group linarith.comp))) : complete_space (with_one (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_38015 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_38016 (h0 : topological_space (simple_graph reducibility_hints)) : totally_disconnected_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_38017 (h0 : topological_space (boolean_algebra (has_to_string name))) : loc_path_connected_space (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_38018 (h1 : topological_space (has_norm fun_info)) : path_connected_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_38019 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_38020 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_38021 (h0 : complete_lattice (topological_space (comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38022 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_38023 (h0 : topological_space (boolean_algebra.core Type)) : discrete_topology (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_38024 (h0 : topological_space (normed_comm_ring name)) : t0_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_38025 (h0 : functor.add_const (topological_space (has_add Type)) name) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_38026 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38027 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) (semiring (semiring (semiring empty)))) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_38028 (h1 : set (simple_graph std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_38029 (h0 : functor.add_const (topological_space pos) Type) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_38030 (h0 : not (uniform_space (non_assoc_semiring empty) -> false)) : @separated_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_38031 (h0 : topological_space (ordered_comm_ring (finset name))) : preirreducible_space (ordered_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_38032 (h0 : filter (semi_normed_comm_ring string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38033 (h0 : function.extfun Type ring) : @is_domain.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38034 (h0 : topological_space (has_add (has_add pos))) : sequential_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_38035 (h0 : ring (add_comm_monoid (has_to_string (has_to_string unsigned)))) : strong_rank_condition (add_comm_monoid (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_38036 (h0 : add_group (canonically_ordered_monoid pos)) : is_add_cyclic (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_38037 (h0 : uniform_space (has_Inf (has_Inf pos))) : separated_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_38038 (h0 : group (add_comm_monoid (has_to_string pos))) : is_simple_group (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_38039 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : locally_compact_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38040 (h0 : topological_space (functor.comp has_Sup add_left_cancel_semigroup fun_info)) : totally_separated_space (functor.comp has_Sup add_left_cancel_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_38041 (h0 : functor.add_const (ring (ring pos)) linarith.comp) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38042 (h0 : set (has_lt linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_38043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_38044 (h0 : uniform_space (boolean_algebra.core (comm_group Type))) : separated_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_38045 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_38046 (h0 : functor.add_const (filter (add_comm_monoid linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38047 (h0 : uniform_space (measurable_space.dynkin_system empty)) : separated_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_38048 (h0 : not (function.extfun (finset Type) (has_mem.mem (with_one num)) -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38049 (h0 : fin has_zero.zero) : @t1_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_38050 (h0 : functor.comp ring cancel_monoid pos) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_38051 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38052 (h1 : complete_lattice (semiring linarith.comp)) : complete_lattice.is_Sup_finite_compact (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_38053 (h0 : topological_space (add_cancel_monoid empty) -> Prop) (h1 : Exists (fun (x : topological_space (add_cancel_monoid empty)), h0 x)) : @t1_space.{0} (add_cancel_monoid.{0} empty) (@classical.some.{1} (topological_space.{0} (add_cancel_monoid.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_38054 (h0 : finset (left_cancel_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_38055 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38056 (h0 : functor.add_const (finset (has_neg pos)) (add_comm_monoid (has_add (has_add linarith.comp)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38057 (h0 : cancel_comm_monoid_with_zero (ring (add_comm_monoid Type))) : unique_factorization_monoid (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_38058 (h0 : ring (complete_distrib_lattice (has_pos_part Type))) : is_principal_ideal_ring (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_38059 (h0 : topological_space (has_top (has_union (id (id linarith.comp))))) : irreducible_space (has_top (has_union (id (id linarith.comp)))) := sorry --non-trivial
lemma new_lemma_38060 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) (normed_comm_ring environment.implicit_infer_kind)) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ring.{1} Type)) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_38061 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_38062 (h0 : ring (has_one (has_norm congr_arg_kind))) : strong_rank_condition (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38063 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_38064 (h1 : not (topological_space (has_compl string_imp) -> false)) : @t0_space.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_38065 (h0 : topological_space (semigroup (option unsigned))) : locally_compact_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_38066 (h0 : functor.comp topological_space has_zero Type) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_38067 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38068 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38069 (h0 : functor.add_const (group (add_cancel_monoid Type)) unsigned) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38070 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_inner unsigned congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38071 (h0 : functor.comp topological_space add_comm_monoid Type) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_38072 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_38073 (h0 : filter (partial_order num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38074 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) pos) Type) : @is_domain.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) pos) Type h0)) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_38075 (h0 : uniform_space (has_one (semiring congr_arg_kind))) : separated_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38076 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : topological_space.separable_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_38077 (h0 : ring (metric_space congr_arg_kind)) : strong_rank_condition (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38078 (h0 : functor.add_const (uniform_space (has_neg Type)) (has_neg_part Type)) : @complete_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_neg.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38079 (h0 : not (topological_space (has_compl (mul_one_class char)) -> false)) : @path_connected_space.{0} (has_compl.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_38080 (h0 : ring (has_top empty)) : is_principal_ideal_ring (has_top empty) := sorry --non-trivial
lemma new_lemma_38081 (h0 : group (semiring (semiring num))) : normalizer_condition (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_38082 (h0 : group (measurable_space (semiring (semiring unsigned)))) : is_cyclic (measurable_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_38083 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) num) : @is_atomistic.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_38084 (h0 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_38085 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_38086 (h0 : not (ring (semiring num) -> false)) : @rank_condition.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_38087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_38088 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38089 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group (semiring (semiring empty)))) : archimedean (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_38090 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38091 (h0 : add_monoid (comm_group (ring Type))) : add_monoid.fg (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_38092 (h0 : ring (has_neg (finset name))) : strong_rank_condition (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_38093 (h0 : topological_space (encodable (random_gen (random_gen linarith.ineq)))) : t0_space (encodable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_38094 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_38095 (h0 : ring (canonically_ordered_comm_semiring (has_nndist (finset (finset name))))) : rank_condition (canonically_ordered_comm_semiring (has_nndist (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_38096 (h0 : complete_lattice (has_top empty)) : complete_lattice.is_Sup_finite_compact (has_top empty) := sorry --non-trivial
lemma new_lemma_38097 (h0 : topological_space (has_add (has_ssubset to_additive.value_type))) : t0_space (has_add (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38098 (h0 : ordered_add_comm_monoid (has_zero (finset (finset (finset (finset pos)))))) : archimedean (has_zero (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_38099 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (comm_group pos)) := sorry --non-trivial
lemma new_lemma_38100 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_38101 (h0 : topological_space (complete_distrib_lattice (ring pos))) : path_connected_space (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_38102 (h0 : not (monoid (has_dist unsigned) -> false)) : @monoid.fg.{0} (has_dist.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_dist.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_38103 (h0 : functor.add_const (list (has_Inf linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38104 (h0 : add_monoid (canonically_ordered_comm_semiring num)) : add_monoid.fg (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_38105 (h0 : list (ring (id congr_arg_kind))) (h1 : function.extfun (eq h0 list.nil) (fun (x : eq h0 list.nil), false)) : @rank_condition.{0} (@id.{2} Type congr_arg_kind) (@list.last.{0} (ring.{0} (@id.{2} Type congr_arg_kind)) h0 (@function.extfun_app.{0 0} (@eq.{1} (list.{0} (ring.{0} (@id.{2} Type congr_arg_kind))) h0 (@list.nil.{0} (ring.{0} (@id.{2} Type congr_arg_kind)))) (λ (x : @eq.{1} (list.{0} (ring.{0} (@id.{2} Type congr_arg_kind))) h0 (@list.nil.{0} (ring.{0} (@id.{2} Type congr_arg_kind)))), false) h1))  := sorry --non-trivial
lemma new_lemma_38106 (h0 : functor.add_const (add_monoid (cancel_monoid Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38107 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : path_connected_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38108 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_38109 (h0 : measurable_space enat) (h2 : Prop) : measurable_set (id (fun (h1 : enat), h2)) := sorry --non-trivial
lemma new_lemma_38110 (h0 : not (uniform_space (semiring to_additive.value_type) -> false)) : @separated_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_38111 (h0 : topological_space (normed_lattice_add_comm_group (has_add name))) : totally_disconnected_space (normed_lattice_add_comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_38112 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38113 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38114 (h0 : ring (finset (finset Type))) : strong_rank_condition (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_38115 (h0 : group (sub_neg_monoid (has_pos_part (has_Inf linarith.comp)))) : is_cyclic (sub_neg_monoid (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_38116 (h0 : ring (normed_comm_ring (has_add (has_add environment.implicit_infer_kind)))) : rank_condition (normed_comm_ring (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_38117 (h0 : measurable_space (has_lt linarith.ineq)) (h1 : filter (has_lt linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_38118 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38119 (h0 : topological_space (simple_graph (has_add (has_add pos)))) : loc_path_connected_space (simple_graph (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_38120 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_38121 (h0 : group (boolean_algebra.core (has_neg_part (has_add Type)))) : is_cyclic (boolean_algebra.core (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_38122 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (ulower.up (id (id h0))) := sorry --non-trivial
lemma new_lemma_38123 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_38124 (h0 : list (left_cancel_monoid num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38125 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @t1_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_38126 (h0 : complete_lattice (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : is_compactly_generated (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38127 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_38128 (h1 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38129 (h0 : topological_space (add_comm_monoid (comm_group (has_zero (comm_group (comm_group Type)))))) : preconnected_space (add_comm_monoid (comm_group (has_zero (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_38130 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_38131 (h0 : list (has_dist unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38132 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : regular_space (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_38133 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) congr_arg_kind) : @complete_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38134 (h0 : topological_space (comm_group (comm_group (comm_group Type)))) : topological_space.separable_space (comm_group (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_38135 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_38136 (h0 : finset (canonically_ordered_comm_semiring name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_38137 (h0 : uniform_space (has_neg (has_add (cancel_monoid pos)))) : separated_space (has_neg (has_add (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_38138 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field ennreal)) : unique_factorization_monoid (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_38139 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : path_connected_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_38140 (h0 : add_monoid (has_zero (has_add (has_add (has_add (has_add Type)))))) : add_monoid.fg (has_zero (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_38141 (h0 : topological_space (boolean_algebra.core (comm_group (comm_group name)))) : normal_space (boolean_algebra.core (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_38142 (h0 : topological_space (has_nndist (has_nndist pos))) : t0_space (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_38143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_38144 (h0 : add_group (metric_space (comm_ring string_imp))) : is_add_cyclic (metric_space (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_38145 (h0 : functor.add_const Prop (ring (has_add linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_38146 (h0 : topological_space (boolean_algebra.core (comm_group name))) : sequential_space (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_38147 (h0 : topological_space (add_comm_monoid (comm_group unsigned))) : loc_path_connected_space (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_38148 (h0 : fin has_zero.zero) : @separated_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_38149 (h0 : ring (sub_neg_monoid (has_pos_part Type))) : strong_rank_condition (sub_neg_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_38150 (h0 : add_group (complete_semilattice_Sup (comm_ring linarith.ineq))) : is_add_cyclic (complete_semilattice_Sup (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38151 (h0 : complete_lattice (measure_theory.measure_space (semiring congr_arg_kind))) : is_compactly_generated (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38152 (h0 : list (add_comm_monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38153 (h0 : random_gen linarith.comp_source -> topological_space (with_one fun_info)) : @totally_separated_space.{0} (with_one.{0} fun_info) (@infi.{0 1} (topological_space.{0} (with_one.{0} fun_info)) (@conditionally_complete_lattice.to_has_Inf.{0} (topological_space.{0} (with_one.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (with_one.{0} fun_info)) (@topological_space.complete_lattice.{0} (with_one.{0} fun_info)))) (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_38154 (h0 : not (add_monoid (has_union num) -> false)) : @add_monoid.fg.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_38155 (h0 : topological_space (has_pos_part (ring (finset linarith.comp)))) : irreducible_space (has_pos_part (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_38156 (h0 : topological_space (comm_monoid unsigned)) : t1_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_38157 (h0 : group (sub_neg_monoid (finset linarith.comp))) : group.fg (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_38158 (h0 : semiring (add_group num)) : is_noetherian_ring (add_group num) := sorry --non-trivial
lemma new_lemma_38159 (h0 : topological_space (add_comm_monoid (has_Inf (has_bot linarith.comp)))) : path_connected_space (add_comm_monoid (has_Inf (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_38160 (h0 : topological_space (has_inv (has_inv linarith.ineq))) : totally_disconnected_space (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38161 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38162 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38163 (h0 : ring (semigroup (option (option pos)))) : is_domain (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_38164 (h0 : ring (omega_complete_partial_order unsigned)) : is_principal_ideal_ring (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_38165 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_38167 (h0 : filter (simple_graph (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38168 (h0 : list (canonically_ordered_comm_semiring (finset ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38169 (h0 : ring (has_top (encodable (has_top to_additive.value_type)))) : is_domain (has_top (encodable (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_38170 (h0 : ring (generalized_boolean_algebra (has_Inf linarith.comp))) : is_domain (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_38171 (h0 : topological_space (with_bot (add_group unsigned))) : totally_disconnected_space (with_bot (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_38172 (h0 : ring (has_neg (has_neg environment.implicit_infer_kind))) : is_domain (has_neg (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38173 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_38174 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38175 (h1 : ring (normed_field linarith.comp_source)) : rank_condition (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_38176 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring num)) : unique_factorization_monoid (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_38177 (h0 : topological_space (distrib (has_nnnorm (ordered_comm_semiring char)))) : path_connected_space (distrib (has_nnnorm (ordered_comm_semiring char))) := sorry --non-trivial
lemma new_lemma_38178 (h1 : not (add_group (complete_semilattice_Sup string_imp) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_38179 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_38180 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38181 (h0 : uniform_space (has_neg (finset Type))) : separated_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_38182 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_38183 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38184 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_38185 (h0 : functor.add_const (complete_lattice (has_neg_part name)) name) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_38186 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @separated_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_38187 (h0 : add_monoid (complete_linear_order congr_arg_kind)) : add_monoid.fg (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38188 (h0 : function.extfun Type (functor.comp topological_space ring)) : @sequential_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_38189 (h0 : functor.add_const (group Type) Type) : @group.fg.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_38190 (h0 : set (random_gen string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_38191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_38192 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38193 (h3 : ring (fintype to_additive.value_type)) : strong_rank_condition (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38194 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_38195 (h0 : option Prop) (h1 : Prop) : option.get_or_else h0 h1 := sorry --non-trivial
lemma new_lemma_38196 (h0 : not (uniform_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @complete_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38197 (h0 : not (topological_space (div_inv_monoid linarith.ineq) -> false)) : @t0_space.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_38198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38199 (h0 : ring (comm_ring (random_gen string_imp))) : rank_condition (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_38200 (h0 : ring (has_neg_part (finset (has_nndist (has_nndist pos))))) : rank_condition (has_neg_part (finset (has_nndist (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_38201 (h0 : functor.add_const (add_monoid (left_cancel_monoid num)) num) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_38202 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} (has_top.{0} (has_inv.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} (has_top.{0} (has_inv.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_38203 (h0 : functor.add_const (group (has_neg_part pos)) (has_neg_part Type)) : @normalizer_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38204 (h0 : functor.add_const (function.extfun (Type 1) group) ordering) : @group.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) ordering h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_38205 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring pos)) name) : @unique_factorization_monoid.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_38206 (h0 : monoid (boolean_algebra.core (has_add pos))) : monoid.fg (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_38207 (h0 : ordered_add_comm_monoid (has_nndist (option (option (option num))))) : archimedean (has_nndist (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_38208 (h0 : topological_space (mul_one_class (mul_one_class char))) : topological_space.first_countable_topology (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_38209 (h0 : filter (linear_ordered_add_comm_group to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38210 (h0 : functor.add_const (finset (finset name)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38211 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (option num)) := sorry --non-trivial
lemma new_lemma_38213 (h0 : functor.add_const (functor.comp topological_space canonically_ordered_comm_semiring name) pos) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_38214 (h0 : measurable_space (random_gen (has_top (has_top congr_arg_kind)))) (h1 : has_div (random_gen (has_top (has_top congr_arg_kind)))) : has_measurable_div₂ (random_gen (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_38215 (h0 : topological_space (encodable (has_ssubset linarith.ineq))) : irreducible_space (encodable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38216 (h2 : uniform_space (nondiscrete_normed_field linarith.ineq)) : complete_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_38217 (h0 : functor.add_const (complete_lattice (mul_zero_class name)) pos) : @is_compactly_generated.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_38218 (h0 : topological_space (normed_group (with_bot to_additive.value_type))) : irreducible_space (normed_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38219 (h0 : topological_space (filter congr_arg_kind)) : irreducible_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38220 (h0 : ring (has_Inf (ring Type))) : is_domain (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_38221 (h0 : not (group (has_star unsigned) -> false)) : @group.fg.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_38222 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38223 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38224 (h0 : topological_space (cancel_monoid (boolean_algebra.core Type))) : preconnected_space (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_38225 (h0 : function.extfun Type group) : @group.fg.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_38226 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_Inf.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_38227 (h0 : functor.comp add_group comm_group name) : @is_add_cyclic.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_38228 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_38229 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38230 (h0 : functor.add_const (topological_space (semigroup ennreal)) pos) : @t0_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_38231 (h0 : not (filter (distrib_lattice fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_38232 (h0 : function.extfun Type group) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_38233 (h0 : topological_space (has_ssubset (random_gen linarith.ineq))) : locally_compact_space (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38235 (h0 : topological_space (finset congr_arg_kind)) : totally_separated_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38236 (h0 : semiring (normed_lattice_add_comm_group linarith.comp)) : is_noetherian_ring (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_38237 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @complete_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38238 (h0 : ring (has_one (has_norm (semiring empty)))) : is_domain (has_one (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_38239 (h0 : group (complete_semilattice_Sup linarith.comp)) : group.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_38240 (h0 : ordered_comm_monoid (has_nndist (finset (add_comm_monoid (has_to_string pos))))) : has_exists_mul_of_le (has_nndist (finset (add_comm_monoid (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_38241 (h0 : functor.add_const (complete_lattice (has_zero Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_38242 (h0 : topological_space (has_zero (has_neg Type))) : preirreducible_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_38243 (h0 : functor.add_const (add_group (bin_tree empty)) empty) : @is_add_cyclic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_38244 (h0 : topological_space (has_inter (option empty))) : path_connected_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_38245 (h0 : ring (semi_normed_ring enat)) : is_domain (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_38246 (h1 : ring (add_comm_semigroup (add_comm_semigroup environment.projection_info))) : is_domain (add_comm_semigroup (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_38247 (h0 : ring (add_group (semiring num))) : rank_condition (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_38248 (h0 : topological_space (add_comm_monoid (has_neg Type))) : t1_space (add_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_38249 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_38250 (h0 : has_mem.mem (has_emptyc complex) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} complex) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} complex) h0)  := sorry --non-trivial
lemma new_lemma_38251 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @strong_rank_condition.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38252 (h0 : complete_lattice (id empty)) : complete_lattice.is_Sup_finite_compact (id empty) := sorry --non-trivial
lemma new_lemma_38253 (h0 : monoid (normed_group (normed_group linarith.comp_source))) : monoid.fg (normed_group (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38254 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @path_connected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38255 (h0 : functor.add_const (functor.comp semiring boolean_algebra.core pos) name) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} boolean_algebra.core.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} semiring.{0} boolean_algebra.core.{0} pos) name h0))  := sorry --non-trivial
lemma new_lemma_38256 (h0 : functor.add_const (function.extfun Type filter) (has_nndist Type)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_38257 (h0 : ring (has_div (mul_one_class string.iterator_imp))) : strong_rank_condition (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_38258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_comm_ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_38259 (h1 : uniform_space (mul_one_class linarith.ineq)) : complete_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_38260 (h0 : group (normed_comm_ring (random_gen fun_info))) : normalizer_condition (normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_38261 (h1 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @group.fg.{0} linarith.comp_source (@id.{1} (group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1)))  := sorry --non-trivial
lemma new_lemma_38262 (h1 : group (with_bot string_imp)) : normalizer_condition (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_38263 (h0 : comm_semiring (has_norm linarith.comp_source)) (h1 : not (topological_space (linear_recurrence (has_norm linarith.comp_source)) -> false)) : @path_connected_space.{0} (@linear_recurrence.{0} (has_norm.{0} linarith.comp_source) h0) (@classical.by_contradiction'.{1} (topological_space.{0} (@linear_recurrence.{0} (has_norm.{0} linarith.comp_source) h0)) h1)  := sorry --non-trivial
lemma new_lemma_38264 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (ring pos)) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_38265 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) (option ennreal)) : @is_compactly_generated.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_38266 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) name) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_38267 (h0 : topological_space (has_emptyc (with_bot linarith.comp_source))) : locally_compact_space (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38268 (h0 : topological_space (linear_order unsigned)) : locally_compact_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_38269 (h0 : functor.add_const (add_monoid (sub_neg_monoid pos)) (has_Inf (has_add name))) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) (has_Inf.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_38270 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_38271 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38272 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid name)) name) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_38273 (h0 : uniform_space (has_union (semiring congr_arg_kind))) : complete_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38274 (h0 : add_group (has_compl (mul_one_class (mul_one_class char)))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_38275 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @sequential_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38276 (h0 : topological_space (boolean_algebra (has_add (finset pos)))) : topological_space.separable_space (boolean_algebra (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_38277 (h0 : topological_space (linear_ordered_field (option pos))) : totally_separated_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_38278 (h1 : topological_space (with_bot (has_norm (has_norm linarith.comp_source)))) : totally_separated_space (with_bot (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_38279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38280 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : is_total_preorder to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_38281 (h0 : functor.add_const (ring (has_zero empty)) num) : @is_domain.{0} (has_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_38282 (h0 : not (complete_lattice (partial_order char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_38283 (h0 : complete_lattice (add_cancel_monoid num)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_38284 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group (comm_group Type)))) : totally_separated_space (canonically_ordered_comm_semiring (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_38285 (h0 : not (group fun_info -> false)) : @is_cyclic.{0} fun_info (@classical.by_contradiction'.{1} (group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_38286 (h1 : topological_space (add_cancel_comm_monoid reducibility_hints)) : t0_space (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_38287 (h0 : group (ordered_comm_monoid (has_neg (ring name)))) : group.fg (ordered_comm_monoid (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_38288 (h0 : group (normed_group (random_gen (random_gen string_imp)))) : group.fg (normed_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_38289 (h0 : complete_lattice (has_nnnorm (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_38290 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_38291 (h0 : filter (dlist (canonically_ordered_comm_semiring char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38292 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (boolean_algebra Type)) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38293 (h0 : topological_space (boolean_algebra name)) : t0_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_38294 (h0 : ordered_add_comm_monoid (has_Sup empty)) : archimedean (has_Sup empty) := sorry --non-trivial
lemma new_lemma_38295 (h0 : ring (has_bot (option empty))) : strong_rank_condition (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_38296 (h0 : topological_space (has_append (comm_ring (comm_ring reducibility_hints)))) : t0_space (has_append (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_38297 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_38298 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38299 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_38300 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38301 (h0 : topological_space (has_Sup (semiring (semiring (semiring (semiring (semiring empty))))))) : discrete_topology (has_Sup (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_38302 (h0 : list (has_add num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38303 (h0 : ring (has_neg (has_pos_part Type))) : is_domain (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_38304 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_38305 (h0 : topological_space (comm_semigroup real)) : t1_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_38306 (h0 : ring (comm_group (add_comm_monoid name))) : rank_condition (comm_group (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_38307 (h1 : topological_space (id linarith.comp)) : path_connected_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_38308 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring num)))) : t1_space (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_38309 (h0 : functor.add_const (group (option empty)) congr_arg_kind) : @normalizer_condition.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38310 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf pos)) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} pos) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38311 (h0 : functor.add_const (topological_space (ring Type)) name) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_38312 (h0 : uniform_space (normed_group (has_top (has_top linarith.ineq)))) : complete_space (normed_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_38313 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_38314 (h0 : ring (distrib reducibility_hints)) : is_domain (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_38315 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38316 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring unsigned))))) : t0_space (measure_theory.measure_space (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_38317 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_38318 (h0 : cancel_comm_monoid_with_zero (add_group (semiring empty))) : unique_factorization_monoid (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_38319 (h0 : complete_lattice (linear_ordered_field (option num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_38320 (h0 : topological_space (linear_ordered_comm_group_with_zero enat)) : totally_disconnected_space (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_38321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38322 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_38323 (h0 : complete_lattice (finset (option name))) : is_atomistic (finset (option name)) := sorry --non-trivial
lemma new_lemma_38324 (h0 : list (has_inv (semiring (has_nnnorm (has_nnnorm to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38325 (h0 : function.extfun Type (functor.comp add_group has_nndist)) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_38326 (h0 : group (distrib_lattice (has_inv fun_info))) : normalizer_condition (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_38327 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_38328 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38329 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) name)  := sorry --non-trivial
lemma new_lemma_38330 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @discrete_topology.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_38331 (h0 : function.extfun nat fin) : @topological_space.separable_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38332 (h0 : order_hom nat nat) : nat.prime (monotonic_sequence_limit h0) := sorry --non-trivial
lemma new_lemma_38333 (h0 : finset (has_bot (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_38334 (h0 : complete_lattice (complete_semilattice_Sup (has_norm linarith.comp_source))) : is_atomistic (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38335 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf real))))) : preconnected_space (has_pos_part (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_38336 (h0 : monoid (semiring string_imp)) : monoid.fg (semiring string_imp) := sorry --non-trivial
lemma new_lemma_38337 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring (semiring num)))))) : complete_space (mul_zero_class (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_38338 (h0 : functor.add_const (function.extfun Type ring) (finset Type)) : @rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (finset.{1} Type) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_38339 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38340 (h0 : topological_space (add_group (random_gen congr_arg_kind))) : preirreducible_space (add_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38341 (h0 : topological_space (as_linear_order (option empty))) : preirreducible_space (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_38342 (h0 : functor.add_const (finset (ordered_ring empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38343 (h0 : not (group (bin_tree congr_arg_kind) -> false)) : @is_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38344 (h0 : add_group (add_cancel_monoid (has_zero name))) : is_add_cyclic (add_cancel_monoid (has_zero name)) := sorry --non-trivial
lemma new_lemma_38345 (h0 : topological_space (mul_zero_class (ring name))) : regular_space (mul_zero_class (ring name)) := sorry --non-trivial
lemma new_lemma_38346 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) pos) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_38347 (h0 : functor.add_const (group (add_comm_monoid name)) linarith.comp) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38348 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group (comm_group (has_add Type))))) : preirreducible_space (canonically_ordered_comm_semiring (comm_group (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_38349 (h0 : topological_space (left_cancel_monoid (semiring empty))) : topological_space.separable_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_38350 (h0 : ring (has_bot (has_neg real))) : strong_rank_condition (has_bot (has_neg real)) := sorry --non-trivial
lemma new_lemma_38351 (h0 : not (complete_lattice (with_bot congr_arg_kind) -> false)) : @is_compactly_generated.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38352 (h0 : functor.add_const (topological_space (partial_order unsigned)) congr_arg_kind) : @path_connected_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38353 (h0 : add_monoid std_gen) (h1 : add_submonoid std_gen) : add_submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_38354 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_38355 (h0 : topological_space (sub_neg_monoid (has_neg Type))) : normal_space (sub_neg_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_38356 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) (boolean_algebra Type)) : @t0_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38357 (h1 : filter (has_add string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_38358 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : t1_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_38359 (h0 : group (has_union (random_gen (has_norm (has_norm unsigned))))) : is_cyclic (has_union (random_gen (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_38360 (h1 : topological_space (has_nnnorm (has_nnnorm (semi_normed_ring string_imp)))) : path_connected_space (has_nnnorm (has_nnnorm (semi_normed_ring string_imp))) := sorry --non-trivial
lemma new_lemma_38361 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset pos)) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_38362 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : loc_path_connected_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38363 (h0 : not (group (has_sub congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38364 (h1 : uniform_space (with_one linarith.ineq)) : complete_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_38365 (h0 : ordered_comm_monoid (has_add (has_add (has_Inf (ring name))))) : has_exists_mul_of_le (has_add (has_add (has_Inf (ring name)))) := sorry --non-trivial
lemma new_lemma_38366 (h0 : complete_lattice (has_well_founded linarith.ineq)) : is_compactly_generated (has_well_founded linarith.ineq) := sorry --non-trivial
lemma new_lemma_38367 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_38368 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : fin has_zero.zero) : pnat.coprime (with_bot.unbot h0 h1) (matrix.vec_empty h2) := sorry --non-trivial
lemma new_lemma_38369 (h0 : topological_space (has_Inf (has_neg name))) : t0_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_38370 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @normal_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38371 (h0 : ring (finset (has_add pos))) : is_principal_ideal_ring (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_38372 (h0 : topological_space (denumerable (has_inv fun_info))) : locally_compact_space (denumerable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_38373 (h0 : add_group (with_bot (semiring (has_top unsigned)))) : is_add_cyclic (with_bot (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_38374 (h0 : group (normed_comm_ring (finset (ring pos)))) : is_cyclic (normed_comm_ring (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_38375 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_38376 (h0 : complete_lattice (non_assoc_semiring (option unsigned))) : is_atomistic (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_38377 (h0 : uniform_space (has_neg environment.implicit_infer_kind)) : complete_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_38378 (h1 : group (encodable (random_gen (random_gen (has_well_founded linarith.ineq))))) : is_cyclic (encodable (random_gen (random_gen (has_well_founded linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_38379 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) ennreal) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_38380 (h0 : add_group (canonically_ordered_monoid (has_Inf (has_add (finset real))))) : is_add_cyclic (canonically_ordered_monoid (has_Inf (has_add (finset real)))) := sorry --non-trivial
lemma new_lemma_38381 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup fun_info))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_38382 (h0 : ring (has_inter num)) : strong_rank_condition (has_inter num) := sorry --non-trivial
lemma new_lemma_38383 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_38384 (h0 : topological_space (option pos)) : preconnected_space (option pos) := sorry --non-trivial
lemma new_lemma_38385 (h0 : topological_space (cancel_monoid (option pos))) : locally_compact_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_38386 (h0 : add_monoid (generalized_boolean_algebra pos)) : add_monoid.fg (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_38387 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : loc_path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_38388 (h0 : topological_space (with_bot (has_top (has_top num)))) : totally_separated_space (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_38389 (h0 : topological_space (add_comm_monoid (has_bot Type))) : t0_space (add_comm_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_38390 (h0 : topological_space (has_nndist unsigned)) : normal_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_38391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_38392 (h0 : group (has_Inf (has_neg (has_neg (has_neg (has_neg (has_neg (finset (has_neg name))))))))) : is_simple_group (has_Inf (has_neg (has_neg (has_neg (has_neg (has_neg (finset (has_neg name)))))))) := sorry --non-trivial
lemma new_lemma_38393 (h0 : functor.add_const (add_group (boolean_algebra.core Type)) (ring linarith.comp)) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.core.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38395 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_38396 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38397 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_38398 (h0 : topological_space (semigroup (has_neg_part pos))) : discrete_topology (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_38399 (h0 : functor.comp ring linear_ordered_field ennreal) : @is_domain.{0} (linear_ordered_field.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_field.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_38400 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_38401 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_38402 (h0 : has_mem.mem (semiring unsigned) has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_38403 (h0 : group (option (option (option (option ennreal))))) : normalizer_condition (option (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_38404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38405 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_38406 (h0 : add_group (add_cancel_monoid environment.implicit_infer_kind)) : is_add_cyclic (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_38407 (h0 : uniform_space (simple_graph (ring pos))) : separated_space (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_38408 (h0 : topological_space (pseudo_metric_space empty)) : irreducible_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_38409 (h0 : topological_space (has_Inf (has_add (has_add (finset Type))))) : t1_space (has_Inf (has_add (has_add (finset Type)))) := sorry --non-trivial
lemma new_lemma_38410 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_38412 (h1 : set (char -> reducibility_hints)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_38413 (h0 : functor.add_const (group (has_nndist name)) linarith.comp) : @group.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38414 (h0 : topological_space (measurable_space (has_top fun_info))) : irreducible_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_38415 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_ring.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_38416 (h0 : functor.comp list complete_distrib_lattice pos) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_38417 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_38418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (emetric_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (emetric_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38419 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : normal_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_38420 (h0 : functor.add_const (complete_lattice (has_zero pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38421 (h0 : set (distrib linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_38422 (h0 : ring (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid (has_Inf Type))))) : rank_condition (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_38423 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38424 (h0 : topological_space (has_to_string linarith.comp)) : regular_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_38425 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_38426 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_add linarith.comp)) : @normal_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38427 (h0 : monoid (normed_group (has_norm empty))) : monoid.fg (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_38428 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_38429 (h0 : not (has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_38430 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38431 (h0 : ring (bin_tree (semiring (semiring (left_cancel_monoid (semiring unsigned)))))) : is_principal_ideal_ring (bin_tree (semiring (semiring (left_cancel_monoid (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_38432 (h0 : functor.add_const (list (ring pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38433 (h0 : topological_space (finset ennreal)) : t1_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_38434 (h0 : functor.add_const (functor.add_const (complete_lattice Type) pos) pos) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (complete_lattice.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_38435 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38436 (h0 : topological_space (has_top (semiring (semiring unsigned)))) : path_connected_space (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_38437 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38438 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_38439 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : discrete_topology (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_38440 (h0 : topological_space (left_cancel_semigroup (semiring (semiring (semiring unsigned))))) : topological_space.separable_space (left_cancel_semigroup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_38441 (h0 : uniform_space (canonically_linear_ordered_monoid (option (option pos)))) : separated_space (canonically_linear_ordered_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_38442 (h0 : group (has_ssubset linarith.comp_source)) : is_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_38443 (h0 : list (ring (has_neg name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38444 (h0 : functor.add_const (group (comm_group Type)) name) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_38445 (h0 : functor.comp group has_zero pos) : @group.fg.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_38446 (h0 : list (complete_semilattice_Sup (has_ssubset (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38447 (h0 : uniform_space (boolean_algebra.core (option (option (option (option unsigned)))))) : separated_space (boolean_algebra.core (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_38448 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid Type))) : is_domain (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_38449 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_38450 (h0 : filter (option (option (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38451 (h0 : topological_space (has_inner environment.implicit_infer_kind congr_arg_kind)) : t0_space (has_inner environment.implicit_infer_kind congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38452 (h0 : functor.add_const (ring (ring linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38453 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_38454 (h0 : list (monoid (option (option (option empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38455 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_38456 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38457 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38458 (h0 : add_monoid (plift (has_one empty))) : add_monoid.fg (plift (has_one empty)) := sorry --non-trivial
lemma new_lemma_38459 (h0 : ring (linear_ordered_field unsigned)) : is_principal_ideal_ring (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_38460 (h0 : not (filter (add_left_cancel_monoid linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_38461 (h0 : ring (ring (has_to_string (has_to_string pos)))) : is_domain (ring (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_38462 (h0 : group (ring (has_Inf pos))) : normalizer_condition (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_38463 (h0 : not (uniform_space (random_gen (has_top (has_top linarith.comp_source))) -> false)) : @complete_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_38464 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38465 (h0 : functor.add_const (semiring (has_add Type)) (has_neg name)) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_add.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_38466 (h0 : functor.add_const (add_group (finset linarith.comp)) (has_Inf linarith.comp)) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38467 (h0 : not (add_group (uniform_space to_additive.value_type) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_38468 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38469 (h0 : group (sub_neg_monoid (has_neg name))) : is_simple_group (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_38470 (h0 : functor.add_const (complete_lattice (has_pos_part real)) real) : @is_atomistic.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_38471 (h0 : set (simple_graph fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_38472 (h0 : functor.add_const (list (monoid_with_zero pos)) (mul_zero_class pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38473 (h0 : not (topological_space (metric_space string_imp) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_38474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38475 (h0 : functor.add_const (topological_space (ordered_ring num)) unsigned) : @topological_space.separable_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38476 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38477 (h0 : has_lt (has_lt (mul_one_class environment.projection_info))) : no_max_order (has_lt (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_38478 (h0 : not (list (denumerable to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_38479 (h0 : group (dlist (random_gen (random_gen (has_ssubset (has_nnnorm fun_info)))))) : group.fg (dlist (random_gen (random_gen (has_ssubset (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_38480 (h0 : measurable_space ereal) (h2 : filter ereal) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_38481 (h0 : list (with_bot congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38482 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38483 (h0 : functor.add_const (complete_lattice (pseudo_metric_space num)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38484 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring name)) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_38485 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38486 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : normal_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38487 (h0 : pfun (add_comm_semigroup fun_info) Prop) (h2 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h2 := sorry --non-trivial
lemma new_lemma_38488 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_38489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38490 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @t0_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_38491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38492 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : discrete_topology (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38493 (h0 : complete_lattice to_additive.value_type) : complete_lattice.is_Sup_finite_compact to_additive.value_type := sorry --non-trivial
lemma new_lemma_38494 (h0 : topological_space (dlist (random_gen (distrib_lattice (random_gen string_imp))))) : t0_space (dlist (random_gen (distrib_lattice (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_38495 (h0 : add_group (has_zero (has_add linarith.comp))) : is_add_cyclic (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_38496 (h0 : ordered_add_comm_monoid (comm_group (comm_group pos))) : archimedean (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_38497 (h0 : topological_space (random_gen (has_top (has_top congr_arg_kind)))) : t0_space (random_gen (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_38498 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_38499 (h0 : functor.add_const (topological_space (has_Inf pos)) (add_cancel_monoid name)) : @preirreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_38500 (h0 : preorder (has_norm num)) (h1 : complete_lattice (locally_finite_order (has_norm num))) : complete_lattice.is_Sup_finite_compact (locally_finite_order (has_norm num)) := sorry --non-trivial
lemma new_lemma_38501 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38502 (h0 : functor.add_const (ring (finset pos)) environment.implicit_infer_kind) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38503 (h1 : semiring (linear_ordered_add_comm_group fun_info)) (h2 : linear_ordered_add_comm_group fun_info) : odd h2 := sorry --non-trivial
lemma new_lemma_38504 (h0 : uniform_space (ordered_comm_ring (finset (finset linarith.comp)))) : complete_space (ordered_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_38505 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38506 (h0 : uniform_space (sub_neg_monoid (has_add pos))) : separated_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_38507 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_38508 (h0 : uniform_space (distrib_lattice (has_inv (has_inv linarith.comp_source)))) : complete_space (distrib_lattice (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_38509 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_38510 (h0 : ring (has_norm (has_top congr_arg_kind))) : is_domain (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38511 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (finset environment.implicit_infer_kind)) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_38512 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38513 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (comm_group (comm_group (comm_group Type)))) : @topological_space.separable_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) (comm_group.{1} (comm_group.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_38514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_38515 (h0 : ring (has_top (semiring unsigned))) : strong_rank_condition (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_38516 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero empty)) : complete_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_38517 (h0 : list (finset (finset ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38518 (h0 : functor.add_const (topological_space (plift name)) empty) : @topological_space.separable_space.{1} (plift.{1} name) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} name)) empty h0)  := sorry --non-trivial
lemma new_lemma_38519 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (matrix.vec_empty (id (id (matrix.vec_empty h0)))))) := sorry --non-trivial
lemma new_lemma_38520 (h0 : group (complete_distrib_lattice (option (option (option empty))))) : group.fg (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_38521 (h0 : set (set char)) (h1 : set char) : measurable_space.generate_measurable h0 h1 := sorry --non-trivial
lemma new_lemma_38522 (h0 : complete_lattice (with_bot (random_gen num))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_38523 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38524 (h0 : semiring (has_bot (has_add real))) : is_noetherian_ring (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_38525 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38526 (h0 : uniform_space (with_one (random_gen linarith.ineq))) : separated_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38527 (h0 : filter (has_nnnorm (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38528 (h0 : add_group (has_norm (random_gen num))) : is_add_cyclic (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_38529 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_38530 (h0 : functor.add_const (ring (has_Inf pos)) (has_Inf (has_Inf (ring (ring (has_Inf (has_Inf linarith.comp))))))) : @rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_Inf.{0} (has_Inf.{0} (ring.{0} (ring.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp)))))) h0)  := sorry --non-trivial
lemma new_lemma_38531 (h0 : topological_space (has_nndist (ring environment.implicit_infer_kind))) : topological_space.separable_space (has_nndist (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38532 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} (has_norm.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (has_norm.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_38533 (h0 : group (has_bot Type)) : is_simple_group (has_bot Type) := sorry --non-trivial
lemma new_lemma_38534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_38535 (h1 : ring (fintype linarith.ineq)) : strong_rank_condition (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_38536 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_38537 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_38538 (h0 : not (group (with_zero linarith.ineq) -> false)) : @is_cyclic.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_38539 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : path_connected_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38540 (h0 : topological_space (left_cancel_semigroup num)) : normal_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_38541 (h0 : topological_space (has_inter (option (option ennreal)))) : totally_disconnected_space (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_38542 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38543 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38544 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid real))) : t0_space (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_38545 (h0 : group (measurable_space.dynkin_system (semiring (semiring unsigned)))) : normalizer_condition (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_38546 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_38547 (h0 : has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_38548 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) real) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_38549 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf Type)))) : preirreducible_space (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_38550 (h0 : topological_space (has_compl (has_inv char))) : path_connected_space (has_compl (has_inv char)) := sorry --non-trivial
lemma new_lemma_38551 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : sequential_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_38552 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @discrete_topology.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_38553 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @is_cyclic.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38554 (h0 : topological_space (normed_lattice_add_comm_group name)) : normal_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_38555 (h0 : add_group (has_norm (has_inv (has_inv to_additive.value_type)))) : is_add_cyclic (has_norm (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_38556 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_38557 (h2 h3 : multiset (non_unital_non_assoc_semiring to_additive.value_type)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_38558 (h1 : uniform_space (add_left_cancel_monoid to_additive.value_type)) : complete_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38559 (h0 : group (complete_semilattice_Sup unsigned)) : normalizer_condition (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_38560 (h0 : monoid (sub_neg_monoid (has_bot (sub_neg_monoid (sub_neg_monoid name))))) : monoid.fg (sub_neg_monoid (has_bot (sub_neg_monoid (sub_neg_monoid name)))) := sorry --non-trivial
lemma new_lemma_38561 (h0 : group (comm_group (has_neg_part Type))) : normalizer_condition (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_38562 (h0 : functor.add_const (uniform_space (plift num)) empty) : @complete_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_38563 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38564 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_38565 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_38566 (h0 : uniform_space (has_to_string (has_add Type))) : complete_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_38567 (h0 : has_lt (has_le std_gen)) : no_max_order (has_le std_gen) := sorry --non-trivial
lemma new_lemma_38568 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38569 (h0 : list (canonically_ordered_comm_semiring (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38570 (h0 : functor.add_const (semiring (has_nndist linarith.comp)) Type) : @is_noetherian_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_38571 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38572 (h0 : topological_space (has_bot (has_add (has_add (has_add pos))))) : loc_path_connected_space (has_bot (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_38573 (h0 : topological_space (ring (has_pos_part (has_Inf Type)))) : regular_space (ring (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_38574 (h0 : topological_space (mul_zero_class (option (option (option pos))))) : loc_path_connected_space (mul_zero_class (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_38575 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : t0_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38576 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_38577 (h0 : complete_lattice (measure_theory.measure_space (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38578 (h2 : set (has_ssubset to_additive.value_type)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_38579 (h0 : topological_space (ring num)) : loc_path_connected_space (ring num) := sorry --non-trivial
lemma new_lemma_38580 (h0 : group (has_neg (finset linarith.comp))) : group.fg (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_38581 (h0 : group (dlist (comm_ring (has_inv (has_norm (comm_ring to_additive.value_type)))))) : is_cyclic (dlist (comm_ring (has_inv (has_norm (comm_ring to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_38582 (h0 : topological_space (has_compl (mul_one_class (mul_one_class enat)))) : t0_space (has_compl (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_38583 (h0 : topological_space (mul_one_class linarith.ineq)) : t0_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_38584 (h0 : group (boolean_algebra (ring linarith.comp))) : normalizer_condition (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_38585 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_38586 (h0 : ring (add_right_cancel_monoid (semiring unsigned))) : strong_rank_condition (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_38587 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @normal_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_38588 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : t0_space (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_38589 (h0 : topological_space (has_to_string (has_add Type))) : path_connected_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_38590 (h0 : topological_space (has_dist congr_arg_kind)) : normal_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38591 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_38592 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @locally_compact_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_38593 (h0 : topological_space (has_ssubset (random_gen (random_gen fun_info)))) : irreducible_space (has_ssubset (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_38594 (h0 : complete_lattice (ordered_comm_monoid (has_add name))) : is_compactly_generated (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_38595 (h0 : functor.add_const (ring (has_zero Type)) name) : @strong_rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_38596 (h0 : topological_space (has_Inf name)) : t1_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_38597 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @t1_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_38599 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_38600 (h0 : complete_lattice (left_cancel_semigroup congr_arg_kind)) : is_compactly_generated (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38601 (h0 : functor.add_const (semiring (semigroup environment.implicit_infer_kind)) (has_neg linarith.comp)) : @is_noetherian_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38602 (h0 : topological_space (with_bot string_imp)) : locally_compact_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_38603 (h0 : function.extfun Type topological_space) : @t0_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_38604 (h0 : group (dlist (has_nnnorm linarith.comp_source))) : is_cyclic (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38605 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38606 (h0 : monoid (sub_neg_monoid (has_add linarith.comp))) : monoid.fg (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_38607 (h0 : ring (has_add (has_neg (finset linarith.comp)))) : rank_condition (has_add (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_38608 (h0 : group (semigroup ennreal)) : is_cyclic (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_38609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38610 (h0 : semiring (has_pos_part (sub_neg_monoid real))) : is_noetherian_ring (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_38611 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.comp_source))) : totally_disconnected_space (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38612 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38613 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : sequential_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_38614 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38615 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_38616 (h0 : uniform_space (with_one (random_gen (random_gen fun_info)))) : complete_space (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_38617 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38618 (h1 : uniform_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) : complete_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_38619 (h1 : topological_space (distrib_lattice to_additive.value_type)) : totally_separated_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38620 (h0 : ring (add_comm_monoid unsigned)) : rank_condition (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_38621 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @discrete_topology.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38622 (h0 : functor.add_const (functor.add_const Prop Type) (comm_group (has_to_string Type))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38623 (h0 : topological_space (has_neg (finset environment.implicit_infer_kind))) : locally_compact_space (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38624 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) num) : @discrete_topology.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_38625 (h0 : topological_space (has_inner pos (has_add name))) : topological_space.separable_space (has_inner pos (has_add name)) := sorry --non-trivial
lemma new_lemma_38626 (h1 : list (topological_space reducibility_hints)) : @totally_disconnected_space.{0} reducibility_hints (@list.ilast.{0} (topological_space.{0} reducibility_hints) (@inhabited_topological_space.{0} reducibility_hints) h1)  := sorry --non-trivial
lemma new_lemma_38627 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38629 (h0 : topological_space (has_norm (random_gen linarith.comp))) : totally_disconnected_space (has_norm (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_38630 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_38631 (h0 : functor.add_const (filter (has_pos_part linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38632 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38634 (h0 : topological_space (has_lt char)) : totally_disconnected_space (has_lt char) := sorry --non-trivial
lemma new_lemma_38635 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @strong_rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_38636 (h0 : complete_lattice (has_dist (option (option (option num))))) : is_compactly_generated (has_dist (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_38637 (h0 : group (generalized_boolean_algebra char)) : is_cyclic (generalized_boolean_algebra char) := sorry --non-trivial
lemma new_lemma_38638 (h0 : topological_space (partial_order (semiring (semiring (semiring empty))))) : preirreducible_space (partial_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_38639 (h0 : ordered_add_comm_monoid (boolean_algebra (finset linarith.comp))) : archimedean (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_38640 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38641 (h1 : not (topological_space (semiring to_additive.value_type) -> false)) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_38642 (h0 : topological_space (finset (has_neg_part pos))) : topological_space.separable_space (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_38643 (h0 : topological_space linarith.comp) : sequential_space linarith.comp := sorry --non-trivial
lemma new_lemma_38644 (h0 : topological_space (denumerable (add_group_with_zero_nhd linarith.ineq))) : totally_disconnected_space (denumerable (add_group_with_zero_nhd linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38645 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_38646 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_38647 (h0 : complete_lattice (bin_tree unsigned)) : is_atomistic (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_38648 (h0 : function.extfun Type (functor.comp list add_cancel_monoid)) : palindrome (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_38649 (h0 : topological_space (finset (normed_comm_ring linarith.comp))) : normal_space (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_38650 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class fun_info)))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_38651 (h0 : functor.add_const (topological_space (finset pos)) pos) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_38652 (h0 : list (linear_ordered_comm_group num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38653 (h0 : functor.comp list has_add Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_38654 (h0 : topological_space (add_cancel_monoid (has_Inf (has_pos_part pos)))) : preconnected_space (add_cancel_monoid (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_38655 (h0 : list (random_gen (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38656 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_38657 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (finset Type)) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (finset.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_38658 (h0 : topological_space (semiring (has_norm linarith.comp))) : discrete_topology (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_38659 (h0 : cancel_comm_monoid_with_zero (has_neg pos)) (h1 : unique_factorization_monoid (has_neg pos) -> Type) : function.has_right_inverse h1 := sorry --non-trivial
lemma new_lemma_38660 (h0 : functor.add_const (add_group (ring linarith.comp)) (finset Type)) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38661 (h0 : list (ordered_comm_ring (normed_lattice_add_comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38662 (h0 : functor.add_const (semiring (add_comm_monoid unsigned)) Type) : @is_noetherian_ring.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_38663 (h0 : ring (is_R_or_C (option unsigned))) : strong_rank_condition (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_38664 (h0 : topological_space (add_right_cancel_monoid num)) : t1_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_38665 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (order_dual.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (order_dual.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_38666 (h0 : functor.add_const (list (complete_linear_order empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38667 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_38668 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @is_atomistic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_38669 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_38670 (h0 : linear_ordered_comm_group (has_zero pos) -> linear_ordered_comm_group (has_zero pos) -> Prop) : is_symm (linear_ordered_comm_group (has_zero pos)) h0 := sorry --non-trivial
lemma new_lemma_38671 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38672 (h0 : uniform_space (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : separated_space (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_38673 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 group.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38674 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring name)) linarith.comp) : @archimedean.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38675 (h0 : complete_lattice (linear_ordered_add_comm_monoid string_imp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_38676 (h0 : uniform_space (has_neg_part unsigned)) : separated_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_38677 (h0 : fin has_zero.zero) : @archimedean.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_38678 (h0 : add_group (uniform_space linarith.ineq)) : is_add_cyclic (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_38679 (h0 : topological_space (has_bot (has_neg name))) : sequential_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_38680 (h0 : functor.add_const (finset (comm_monoid_with_zero unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38681 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_38682 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_38684 (h0 : topological_space (linear_ordered_semiring (semiring num))) : topological_space.separable_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_38685 (h0 : measurable_space (ordered_comm_monoid linarith.comp)) (h1 : has_add (ordered_comm_monoid linarith.comp)) : has_measurable_add (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_38686 (h0 : functor.add_const (complete_lattice (mul_zero_class ennreal)) name) : @is_atomistic.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_38687 (h0 : filter (semigroup (semigroup pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_38688 (h0 : list (add_cancel_monoid (finset (finset (finset (finset pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38689 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_38690 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_38691 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @normal_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38692 (h0 : uniform_space (has_neg (ring linarith.comp))) : separated_space (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_38693 (h0 : ring (has_neg_part (option name))) : strong_rank_condition (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_38694 (h0 : complete_lattice (normed_group linarith.comp)) : complete_lattice.is_Sup_finite_compact (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_38695 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38696 (h0 : has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_38697 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38698 (h1 : ring (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38699 (h0 : functor.add_const (ring (comm_monoid empty)) congr_arg_kind) : @rank_condition.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_38700 (h0 : field (has_ssubset fun_info)) : is_alg_closed (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_38701 (h2 : monoid (has_emptyc (with_one congr_arg_kind))) : monoid.fg (has_emptyc (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38702 (h1 : not (complete_lattice (denumerable char) -> false)) : @is_compactly_generated.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_38703 (h3 : topological_space (topological_space (random_gen char))) : t0_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_38704 (h0 : prod (mul_one_class linarith.ineq) (mul_one_class linarith.ineq)) : set.diagonal (mul_one_class linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_38705 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38706 (h0 : ring (has_top (random_gen linarith.comp_source))) : rank_condition (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38707 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38708 (h0 : functor.add_const (functor.add_const (add_group pos) linarith.comp) (finset linarith.comp)) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} pos) linarith.comp) (finset.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_38709 (h0 : topological_space (ring (has_pos_part environment.implicit_infer_kind))) : irreducible_space (ring (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38710 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) name) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_38711 (h1 : char -> Prop) (h2 h3 : char) : eqv_gen (fun (h0 : char), h1) h2 h3 := sorry --non-trivial
lemma new_lemma_38712 (h0 : topological_space (mul_zero_class (has_add Type))) : preconnected_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_38713 (h0 : topological_space (has_add (has_Inf (has_bot real)))) : totally_disconnected_space (has_add (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_38714 (h0 : semiring (ordered_comm_ring (has_pos_part linarith.comp))) : is_noetherian_ring (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_38715 (h0 : functor.add_const (topological_space (comm_semigroup pos)) real) : @sequential_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_38716 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_38717 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_38718 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_edist.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_38719 (h0 : fin has_zero.zero) (h1 : Pi (b : bool) (n : nat), fin n -> fin (nat.bit b n)) : matrix.vec_empty (nat.binary_rec h0 h1 has_zero.zero) := sorry --non-trivial
lemma new_lemma_38720 (h0 : semiring (has_bot (has_add (sub_neg_monoid real)))) : is_noetherian_ring (has_bot (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_38721 (h0 : functor.add_const (functor.add_const (complete_lattice (ring unsigned)) linarith.comp) (comm_group name)) : @is_compactly_generated.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) linarith.comp) (comm_group.{0} name) h0))  := sorry --non-trivial
lemma new_lemma_38722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38723 (h0 : list (bin_tree (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_38724 (h0 : functor.add_const (filter (add_comm_monoid Type)) (ring Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38725 (h0 : topological_space (semigroup (has_neg (normed_comm_ring linarith.comp)))) : totally_separated_space (semigroup (has_neg (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_38726 (h0 : set (semi_normed_comm_ring (simple_graph enat))) (h1 : semi_normed_comm_ring (simple_graph enat)) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_38727 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_38728 (h0 : function.extfun Type ring) : @is_domain.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_38729 (h0 : group (linear_ordered_comm_group empty)) : is_cyclic (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_38730 (h0 : topological_space (sub_neg_monoid (finset Type))) : normal_space (sub_neg_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_38731 (h0 : functor.add_const (ring Type) name) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_38732 (h0 : topological_space (canonically_ordered_monoid (has_pos_part name))) : discrete_topology (canonically_ordered_monoid (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_38733 (h0 : cancel_comm_monoid_with_zero (partial_order (with_bot congr_arg_kind))) : unique_factorization_monoid (partial_order (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38734 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_38735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_38736 (h0 : finset (has_to_string (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_38737 (h0 : topological_space (plift (bin_tree (semiring (semiring num))))) : totally_disconnected_space (plift (bin_tree (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_38738 (h0 : ordered_add_comm_monoid (add_comm_monoid pos)) : archimedean (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_38739 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38740 (h0 : functor.add_const (group (generalized_boolean_algebra real)) real) : @group.fg.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_38741 (h0 : topological_space (add_group num)) : topological_space.separable_space (add_group num) := sorry --non-trivial
lemma new_lemma_38742 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_38743 (h0 : complete_lattice (complete_distrib_lattice pos)) : is_atomistic (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_38744 (h1 : filter (random_gen to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_38745 (h0 : complete_lattice (plift (option unsigned))) : is_compactly_generated (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_38746 (h0 : prod (measurable_space.dynkin_system (semiring unsigned)) (measurable_space.dynkin_system (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_38747 (h0 : complete_lattice (semiring (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_38748 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38749 (h0 : set (complete_linear_order char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_38750 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : regular_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_38751 (h0 : function.extfun (Type 1) (functor.comp ring cancel_monoid)) : @rank_condition.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} cancel_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} cancel_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_38752 (h0 : functor.comp topological_space cancel_monoid name) : @t0_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_38753 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg pos)))) : totally_disconnected_space (sub_neg_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_38754 (h0 : ordered_add_comm_monoid (semigroup (ordered_ring (option (semiring empty))))) : archimedean (semigroup (ordered_ring (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_38755 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) Type) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_38756 (h0 : list (normed_linear_ordered_group (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38757 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @sequential_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_38758 (h0 : not (semiring (partial_order num) -> false)) : @is_noetherian_ring.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_38759 (h0 : topological_space (cancel_monoid linarith.comp)) : locally_compact_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_38760 (h0 : group (boolean_algebra (has_add (has_add unsigned)))) : is_simple_group (boolean_algebra (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_38761 (h0 : uniform_space (finset (option congr_arg_kind))) : separated_space (finset (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_38762 (h0 : functor.add_const (group (add_comm_monoid name)) real) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_38763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_neg_part.{0} (has_add.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_neg_part.{0} (has_add.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_38764 (h0 : ring (generalized_boolean_algebra name)) : is_principal_ideal_ring (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_38765 (h0 : topological_space (comm_group (normed_comm_ring name))) : regular_space (comm_group (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_38766 (h0 : complete_lattice (has_top (has_inv fun_info))) : is_atomistic (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_38767 (h0 : not (ring (semiring (has_top linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (semiring.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_38768 (h0 : function.extfun nat fin) : @sequential_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38769 (h1 : ring (random_gen reducibility_hints)) : is_domain (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_38770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_38771 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_38772 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid (has_add real)))) : rank_condition (normed_lattice_add_comm_group (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_38773 (h0 : topological_space (has_union (id empty))) : discrete_topology (has_union (id empty)) := sorry --non-trivial
lemma new_lemma_38774 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_38775 (h0 : fin has_zero.zero) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_38776 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38777 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_38778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_38779 (h0 : functor.add_const (filter (has_to_string Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38780 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_38781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_38782 (h0 : group (boolean_algebra Type)) : normalizer_condition (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_38783 (h0 : ring (boolean_algebra.core (finset (ring (ring (ring Type)))))) : is_principal_ideal_ring (boolean_algebra.core (finset (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_38784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38785 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset (finset name)))) : unique_factorization_monoid (has_to_string (finset (finset name))) := sorry --non-trivial
lemma new_lemma_38786 (h0 : ring (normed_group (denumerable fun_info))) : rank_condition (normed_group (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_38787 (h0 : topological_space (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) : totally_disconnected_space (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_38788 (h0 : not (complete_lattice (with_zero (has_nnnorm linarith.comp_source)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_38789 (h0 : topological_space (ring (has_Inf (has_to_string (mul_one_class environment.implicit_infer_kind))))) : preconnected_space (ring (has_Inf (has_to_string (mul_one_class environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_38790 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_38791 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field (option ennreal))) := sorry --non-trivial
lemma new_lemma_38792 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_38793 (h0 : topological_space (normed_comm_ring (has_Inf (has_Inf (has_neg (has_neg (has_Inf (has_add pos)))))))) : t0_space (normed_comm_ring (has_Inf (has_Inf (has_neg (has_neg (has_Inf (has_add pos))))))) := sorry --non-trivial
lemma new_lemma_38794 (h0 : topological_space (simple_graph (has_neg (has_neg Type)))) : irreducible_space (simple_graph (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_38795 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_38796 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38797 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option (option ennreal)))) : unique_factorization_monoid (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_38798 (h0 : complete_lattice (has_neg_part (has_add (boolean_algebra.core Type)))) : is_atomistic (has_neg_part (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_38799 (h0 : functor.comp topological_space has_neg name) : @irreducible_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_38800 (h0 : uniform_space (has_emptyc (has_top (semiring empty)))) : separated_space (has_emptyc (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_38801 (h0 : not (group (metric_space empty) -> false)) : @group.fg.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_38802 (h0 : group (linear_ordered_field (option (canonically_ordered_comm_semiring (option ennreal))))) : is_cyclic (linear_ordered_field (option (canonically_ordered_comm_semiring (option ennreal)))) := sorry --non-trivial
lemma new_lemma_38803 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_38804 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_38805 (h1 : topological_space (topological_space char)) : totally_disconnected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_38806 (h0 : complete_lattice (has_neg_part (has_neg_part ennreal))) : complete_lattice.is_Sup_finite_compact (has_neg_part (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_38807 (h0 : monoid (canonically_ordered_comm_semiring unsigned) -> Prop) (h1 : Exists (fun (x : monoid (canonically_ordered_comm_semiring unsigned)), h0 x)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@classical.some.{1} (monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_38808 (h5 : topological_space (nondiscrete_normed_field ereal)) : totally_disconnected_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_38809 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @topological_space.separable_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_38810 (h0 : is_empty (random_gen string_imp)) (h1 : not (random_gen string_imp -> false)) : is_empty.elim' h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_38811 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_38812 (h0 : functor.add_const (list (ordered_ring unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38813 (h0 : topological_space (has_nndist Type)) : irreducible_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_38814 (h0 : topological_space (has_neg_part (has_add Type))) : t0_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_38815 (h0 : functor.add_const (topological_space (ring Type)) (ring Type)) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_38816 (h0 : functor.add_const (add_monoid (comm_group pos)) linarith.comp) : @add_monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38818 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_38819 (h0 : functor.add_const (topological_space (has_Sup num)) num) : @loc_path_connected_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_38820 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char)))) : strong_rank_condition (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_38821 (h0 : cancel_comm_monoid_with_zero (linear_order (semiring (semiring empty)))) : unique_factorization_monoid (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_38822 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_38823 (h0 : topological_space (has_zero (boolean_algebra pos))) : t0_space (has_zero (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_38824 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38825 (h0 : functor.add_const (topological_space (ring empty)) unsigned) : @preirreducible_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38826 (h0 : group (fintype string_imp)) : is_cyclic (fintype string_imp) := sorry --non-trivial
lemma new_lemma_38827 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) Type) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_38828 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_38829 (h0 : ring (boolean_algebra (has_add (has_add (has_to_string unsigned))))) : is_domain (boolean_algebra (has_add (has_add (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_38830 (h0 : functor.add_const (complete_lattice (has_Inf real)) (has_Inf real)) : @is_compactly_generated.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} real)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_38831 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38832 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_38833 (h0 : uniform_space (has_bot (option ennreal))) : separated_space (has_bot (option ennreal)) := sorry --non-trivial
lemma new_lemma_38834 (h0 : uniform_space (has_pos_part (has_add (has_neg (has_neg (has_Inf name)))))) : separated_space (has_pos_part (has_add (has_neg (has_neg (has_Inf name))))) := sorry --non-trivial
lemma new_lemma_38835 (h0 : ordered_comm_monoid (finset (has_neg pos))) : has_exists_mul_of_le (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_38836 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38837 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_38838 (h0 : ordered_add_comm_monoid (non_assoc_semiring congr_arg_kind)) : archimedean (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_38840 (h0 : function.extfun (left_cancel_semigroup empty) (fun (x : left_cancel_semigroup empty), Prop)) (h1 : left_cancel_semigroup empty -> left_cancel_semigroup empty -> Prop) : set.partially_well_ordered_on (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_38841 (h0 : topological_space (mul_zero_class (has_neg pos))) : topological_space.separable_space (mul_zero_class (has_neg pos)) := sorry --non-trivial
lemma new_lemma_38842 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_38843 (h0 : has_lt (has_lt std_gen)) : no_max_order (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_38844 (h0 : has_mul (has_ssubset (random_gen char))) (h1 : has_zero (has_ssubset (random_gen char))) : no_zero_divisors (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_38845 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38846 (h0 : enat -> Prop) (h1 : filter enat) : filter.eventually h0 h1 := sorry --non-trivial
lemma new_lemma_38847 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : topological_space.separable_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_38848 (h0 : topological_space (has_neg num)) : totally_disconnected_space (has_neg num) := sorry --non-trivial
lemma new_lemma_38849 (h0 : functor.add_const (filter (comm_monoid empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38850 (h0 : functor.add_const (group (ring Type)) (boolean_algebra (finset Type))) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (boolean_algebra.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_38851 (h0 : topological_space (has_to_string num)) : totally_disconnected_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_38852 (h0 : list (finset congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38853 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_38854 (h0 : has_mem.mem Type has_emptyc.emptyc) : @locally_compact_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_38855 (h0 : not (uniform_space (with_one to_additive.value_type) -> false)) : @complete_space.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_38856 (h0 : complete_lattice (random_gen (has_norm linarith.comp))) : is_atomistic (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_38857 (h0 : not (filter (dlist linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_38858 (h0 : complete_lattice (normed_group (has_norm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_38859 (h0 : group (complete_distrib_lattice (ring pos))) : group.fg (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_38860 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38861 (h0 : semiring (has_Sup (semiring empty))) : is_noetherian_ring (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_38862 (h0 : function.extfun Type (functor.comp topological_space option)) : @loc_path_connected_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} option.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_38863 (h0 : group (add_comm_monoid congr_arg_kind)) : group.fg (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38864 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) (has_nndist pos)) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_38865 (h1 : set (uniform_space linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_38866 (h0 : not (topological_space (with_bot linarith.comp) -> false)) : @discrete_topology.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_38867 (h0 : topological_space (linear_order unsigned)) : normal_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_38868 (h0 : topological_space (has_to_string name)) : t0_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_38869 (h0 : functor.comp topological_space pseudo_metric_space ennreal) : @preirreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_38870 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_38871 (h0 : topological_space (has_to_string (has_to_string (has_to_string environment.implicit_infer_kind)))) : discrete_topology (has_to_string (has_to_string (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_38872 (h0 : list (has_norm (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_38873 (h0 : ring (has_bot (option (option (option (option (option empty))))))) : is_domain (has_bot (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_38874 (h0 : topological_space (has_zero (has_neg_part unsigned))) : loc_path_connected_space (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_38875 (h0 : prod (ordered_ring congr_arg_kind) (ordered_ring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_38876 (h0 : ordered_add_comm_monoid (has_bot name)) : archimedean (has_bot name) := sorry --non-trivial
lemma new_lemma_38877 (h0 : functor.add_const (topological_space (cancel_monoid (ring linarith.comp))) name) : @irreducible_space.{0} (cancel_monoid.{0} (ring.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} (ring.{0} linarith.comp))) name h0)  := sorry --non-trivial
lemma new_lemma_38878 (h0 : topological_space (ordered_comm_ring real)) : preconnected_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_38879 (h0 : uniform_space (omega_complete_partial_order (semiring empty))) : complete_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_38880 (h0 : topological_space (add_cancel_monoid unsigned)) : locally_compact_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_38881 (h0 : ring (boolean_algebra (has_add unsigned))) : is_principal_ideal_ring (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_38882 (h0 : topological_space (has_zero (has_neg_part (comm_group (option unsigned))))) : regular_space (has_zero (has_neg_part (comm_group (option unsigned)))) := sorry --non-trivial
lemma new_lemma_38883 (h3 : not (filter (fintype string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h3) := sorry --non-trivial
lemma new_lemma_38884 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preconnected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_38885 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @totally_separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_38886 (h0 : uniform_space (add_cancel_monoid (has_zero Type))) : separated_space (add_cancel_monoid (has_zero Type)) := sorry --non-trivial
lemma new_lemma_38887 (h0 : add_monoid (generalized_boolean_algebra (has_add linarith.comp))) : add_monoid.fg (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_38888 (h0 : linarith.ineq -> linarith.comp_source -> linarith.ineq) : right_commutative h0 := sorry --non-trivial
lemma new_lemma_38889 (h0 : semiring num -> semiring num -> Prop) (h1 : function.extfun (semiring num -> Type) (function.extfun (semiring num))) : set.bounded h0 (function.extfun_app (function.extfun_app h1 (fun (x : semiring num), Prop))) := sorry --non-trivial
lemma new_lemma_38890 (h0 : ring (has_edist (option (option unsigned)))) : is_principal_ideal_ring (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_38891 (h0 : topological_space (has_emptyc (has_norm (has_norm (has_norm fun_info))))) : path_connected_space (has_emptyc (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_38892 (h0 : set (nondiscrete_normed_field ereal -> environment.projection_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_38893 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) linarith.comp) : @is_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38894 (h0 : not (topological_space to_additive.value_type -> false)) : @totally_separated_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_38895 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @preconnected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_38896 (h0 : add_group (bin_tree congr_arg_kind)) : is_add_cyclic (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38897 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_38898 (h0 : ring (has_sub (semiring num))) : rank_condition (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_38899 (h1 : ring (has_compl string.iterator_imp)) : rank_condition (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_38900 (h0 : functor.add_const (uniform_space (has_neg environment.implicit_infer_kind)) Type) : @separated_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_38901 (h1 : topological_space (mul_one_class (mul_one_class std_gen))) : path_connected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_38902 (h0 : add_group (distrib linarith.comp_source)) : is_add_cyclic (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_38903 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class (random_gen string_imp))))) : strong_rank_condition (semi_normed_ring (mul_one_class (mul_one_class (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_38904 (h0 : monoid (has_to_string (ring (has_add (ring Type))))) : monoid.fg (has_to_string (ring (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_38905 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_38906 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38907 (h0 : group (random_gen unsigned)) : normalizer_condition (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_38908 (h0 : not (topological_space (normed_group num) -> false)) : @preirreducible_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_38909 (h0 : topological_space (normed_comm_ring (ring environment.implicit_infer_kind))) : loc_path_connected_space (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_38910 (h0 : topological_space (dlist linarith.ineq)) : irreducible_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_38911 (h0 : function.extfun Type (functor.comp ring semigroup)) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_38912 (h0 : functor.add_const (semiring (has_add name)) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38913 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_38914 (h0 : monoid (random_gen (comm_ring linarith.ineq))) : monoid.fg (random_gen (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_38915 (h0 : ring (ring (ordered_ring linarith.comp))) : rank_condition (ring (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_38916 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38917 (h0 : functor.add_const (group (boolean_algebra.core name)) environment.implicit_infer_kind) : @is_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_38918 (h1 : monoid (distrib_lattice (random_gen (random_gen linarith.ineq)))) : monoid.fg (distrib_lattice (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_38919 (h0 : monoid (ordered_comm_monoid name)) : monoid.fg (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_38920 (h0 : comm_semiring (has_union empty)) (h1 : not (ring (measurable_space (has_union (has_top (has_top (mv_polynomial empty (has_union empty)))))) -> false)) : @is_domain.{0} (measurable_space.{0} (has_union.{0} (has_top.{0} (has_top.{0} (@mv_polynomial.{0 0} empty (has_union.{0} empty) h0))))) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} (has_union.{0} (has_top.{0} (has_top.{0} (@mv_polynomial.{0 0} empty (has_union.{0} empty) h0)))))) h1)  := sorry --non-trivial
lemma new_lemma_38921 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_38922 (h0 : topological_space (has_to_string (finset (ring linarith.comp)))) : discrete_topology (has_to_string (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_38923 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : totally_disconnected_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_38924 (h0 : ring (add_group (has_top fun_info))) : strong_rank_condition (add_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_38925 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space name)) unsigned) : @archimedean.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38926 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_38927 (h0 : topological_space (semigroup (finset linarith.comp))) : locally_compact_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_38928 (h0 : functor.add_const (group (has_nndist name)) pos) : @normalizer_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_38929 (h0 : topological_space (semigroup (ring Type))) : totally_separated_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_38930 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38931 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_38932 (h0 : ring (measurable_space (has_norm num))) : strong_rank_condition (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_38933 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_38934 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_38935 (h0 : monoid (canonically_linear_ordered_monoid (has_neg (has_neg (has_neg (has_neg pos)))))) : monoid.fg (canonically_linear_ordered_monoid (has_neg (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_38936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_38937 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_38938 (h1 : complete_lattice (mul_one_class string_imp)) : is_compactly_generated (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_38939 (h0 : ring (measurable_space (random_gen (with_bot to_additive.value_type)))) : rank_condition (measurable_space (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_38940 (h0 : add_group (distrib (linear_ordered_add_comm_group to_additive.value_type))) : is_add_cyclic (distrib (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_38941 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @loc_path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38942 (h1 : add_group environment.projection_info) : is_add_cyclic environment.projection_info := sorry --non-trivial
lemma new_lemma_38943 (h0 : has_mem.mem empty has_emptyc.emptyc) : @is_compactly_generated.{0} empty (@finset.pi.empty.{1 0} Type complete_lattice.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_38944 (h0 : not (ring (semi_normed_ring (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} (add_left_cancel_monoid.{0} (has_nnnorm.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (add_left_cancel_monoid.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_38945 (h0 : topological_space (ring Type)) : sequential_space (ring Type) := sorry --non-trivial
lemma new_lemma_38946 (h0 : ring (complete_distrib_lattice name)) : rank_condition (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_38947 (h0 : filter (add_comm_monoid pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_38948 (h0 : functor.add_const (functor.add_const (add_group Type) linarith.comp) linarith.comp) : @is_add_cyclic.{1} Type (@functor.add_const.run.{1 0} (add_group.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (add_group.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_38949 (h0 : group (has_neg_part (has_neg_part (boolean_algebra Type)))) : is_cyclic (has_neg_part (has_neg_part (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_38950 (h0 : group (has_to_string (monoid_with_zero pos))) : is_cyclic (has_to_string (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_38951 (h0 : topological_space (boolean_algebra (has_add pos))) : t1_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_38952 (h0 : add_group (has_neg (has_add Type))) : is_add_cyclic (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_38953 (h0 : complete_lattice (with_one (with_bot (with_bot string_imp)))) : is_compactly_generated (with_one (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_38954 (h0 : has_mem.mem (semiring (has_norm linarith.comp_source)) has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_38955 (h0 : group (has_add (has_add Type))) : is_cyclic (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_38956 (h0 : topological_space (has_bot (has_bot real))) : locally_compact_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_38957 (h0 : functor.add_const (complete_lattice (has_nndist pos)) name) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_38958 (h0 : ring (add_cancel_comm_monoid to_additive.value_type)) : is_domain (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38959 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_38960 (h0 : topological_space (linear_ordered_semiring (has_top (has_top (random_gen fun_info))))) : path_connected_space (linear_ordered_semiring (has_top (has_top (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_38961 (h0 : functor.add_const (complete_lattice (comm_group pos)) (ring (ring Type))) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_38962 (h0 : not (add_group (add_left_cancel_monoid linarith.ineq) -> false)) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_38963 (h0 : ring (topological_space to_additive.value_type)) : is_domain (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_38964 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_38965 (h0 : ring (metric_space (comm_ring reducibility_hints))) : rank_condition (metric_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_38966 (h0 : not (topological_space linarith.comp -> false)) : @totally_disconnected_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_38967 (h0 : functor.add_const (filter (generalized_boolean_algebra pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38968 (h0 : not (add_monoid (linear_ordered_comm_ring congr_arg_kind) -> false)) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_38969 (h0 : functor.add_const (finset (semigroup unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_38970 (h0 : function.extfun nat fin) : @normal_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38971 (h0 : fin has_zero.zero) : @is_cyclic.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_38972 (h0 : topological_space (with_bot linarith.comp_source)) : t0_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_38973 (h0 : ring (has_emptyc (random_gen (random_gen (random_gen linarith.ineq))))) : is_domain (has_emptyc (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_38974 (h0 : topological_space (boolean_algebra unsigned)) : discrete_topology (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_38975 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg (has_neg (has_neg name)))) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{0} (has_neg.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_38976 (h0 : ring (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos)))))) : rank_condition (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_38977 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @locally_compact_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_38978 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))  := sorry --non-trivial
lemma new_lemma_38979 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_38980 (h0 : ring (with_bot (has_norm string_imp))) : is_domain (with_bot (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_38981 (h0 : complete_lattice (topological_space (has_Inf string_imp))) : is_compactly_generated (topological_space (has_Inf string_imp)) := sorry --non-trivial
lemma new_lemma_38982 (h0 : topological_space (has_add pos)) : t1_space (has_add pos) := sorry --non-trivial
lemma new_lemma_38983 (h0 : topological_space (add_comm_semigroup complex)) : totally_disconnected_space (add_comm_semigroup complex) := sorry --non-trivial
lemma new_lemma_38984 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @discrete_topology.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_38985 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @t1_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38986 (h0 : topological_space (has_nndist (option (option empty)))) : totally_disconnected_space (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_38987 (h0 : topological_space (add_group (has_norm linarith.comp))) : irreducible_space (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_38988 (h0 : ring (ordered_comm_monoid Type)) : rank_condition (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_38989 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @t0_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_38990 (h0 : topological_space (random_gen congr_arg_kind)) : locally_compact_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_38991 (h0 : topological_space (has_Inf (has_neg (has_neg Type)))) : regular_space (has_Inf (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_38992 (h0 : functor.add_const (topological_space (mul_zero_class empty)) empty) : @t1_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_38993 (h0 : functor.add_const (topological_space (has_inter Type)) unsigned) : @regular_space.{1} (has_inter.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_inter.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_38994 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (mul_one_class pos)) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (mul_one_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_38995 (h0 : function.extfun nat fin) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_38996 (h1 : complete_lattice (complete_semilattice_Sup fun_info)) : is_atomistic (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_38997 (h0 : cancel_comm_monoid_with_zero (free_add_monoid unsigned)) : unique_factorization_monoid (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_38998 (h0 : function.extfun Type group) : @normalizer_condition.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_38999 (h0 : ordered_comm_monoid (monoid_with_zero (option pos))) : has_exists_mul_of_le (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_39000 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39001 (h0 : functor.add_const (functor.add_const (complete_lattice pos) pos) Type) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} pos) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_39002 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (finset (has_neg name))) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (finset.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_39003 (h0 : set (has_ssubset enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_39004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_39005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_39006 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39007 (h0 : topological_space (add_right_cancel_monoid (has_top num))) : totally_separated_space (add_right_cancel_monoid (has_top num)) := sorry --non-trivial
lemma new_lemma_39008 (h0 : topological_space (add_comm_monoid (mul_zero_class environment.implicit_infer_kind))) : loc_path_connected_space (add_comm_monoid (mul_zero_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39009 (h0 : topological_space (partial_order (semiring (semiring empty)))) : t1_space (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_39010 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (sub_neg_monoid real)))) : t0_space (canonically_linear_ordered_monoid (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_39011 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39012 (h0 : ring (monoid_with_zero (option pos))) : rank_condition (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_39013 (h0 : functor.add_const (ring (semigroup name)) (comm_group (comm_group environment.implicit_infer_kind))) : @strong_rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) (comm_group.{0} (comm_group.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39014 (h0 : topological_space (has_neg (finset Type))) : preconnected_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_39015 (h0 : add_group (linear_ordered_comm_group ereal)) : is_add_cyclic (linear_ordered_comm_group ereal) := sorry --non-trivial
lemma new_lemma_39016 (h0 : topological_space (normed_comm_ring name)) : totally_disconnected_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_39017 (h0 : functor.add_const (finset (add_left_cancel_semigroup empty)) (semiring (semiring (semiring empty)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39018 (h0 : topological_space (ordered_ring empty)) : loc_path_connected_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_39019 (h0 : topological_space (boolean_algebra.core (ring unsigned))) : preconnected_space (boolean_algebra.core (ring unsigned)) := sorry --non-trivial
lemma new_lemma_39020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_39021 (h0 : uniform_space (simple_graph fun_info)) : complete_space (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_39022 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_39023 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39024 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_39025 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39026 (h0 : topological_space (has_nnnorm (mul_one_class ereal))) : totally_disconnected_space (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_39027 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints))) : path_connected_space (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_39028 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : irreducible_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_39029 (h0 : list (boolean_algebra.core pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_39030 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39031 (h0 : topological_space (ring (option (option (option empty))))) : locally_compact_space (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_39032 (h0 : functor.add_const (group (ordered_comm_ring pos)) (finset pos)) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39033 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39035 (h0 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : t0_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39036 (h0 : uniform_space (linear_order congr_arg_kind)) : complete_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39037 (h0 : group (random_gen (has_norm (has_norm fun_info)))) : normalizer_condition (random_gen (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_39038 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39039 (h0 : uniform_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : complete_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_39040 (h0 : add_monoid (boolean_algebra.core ennreal)) : add_monoid.fg (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_39041 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : discrete_topology (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39042 (h0 : fin has_zero.zero) : @group.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_39043 (h0 : not (topological_space (non_assoc_semiring unsigned) -> false)) : @totally_separated_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39044 (h0 : uniform_space (boolean_algebra (has_Inf pos))) : separated_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_39045 (h0 : ring (has_neg_part (has_add (has_add (boolean_algebra.core pos))))) : is_principal_ideal_ring (has_neg_part (has_add (has_add (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_39046 (h0 : fin has_zero.zero) : @group.fg.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_39047 (h0 : monoid (has_top linarith.comp_source)) : monoid.fg (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39048 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39049 (h0 : functor.add_const (function.extfun (Type 1) filter) (ring name)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_39050 (h0 : function.extfun nat fin) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39051 (h0 : functor.comp topological_space dlist linarith.ineq) : @irreducible_space.{0} (dlist.{0} linarith.ineq) (@functor.comp.run.{0 0 0} topological_space.{0} dlist.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_39052 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot empty)) unsigned) : @unique_factorization_monoid.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39053 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_39054 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39055 (h0 : group (add_right_cancel_monoid (has_top fun_info))) : normalizer_condition (add_right_cancel_monoid (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_39056 (h0 : function.extfun Type topological_space) : @t1_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_39057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_39058 (h0 : pseudo_metric_space (mul_one_class fun_info)) (h1 : set (mul_one_class fun_info)) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_39059 (h0 : ring (has_one (has_norm (has_norm unsigned)))) : rank_condition (has_one (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_39060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39061 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_comm_monoid empty)))) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_39062 (h0 : set (fun_info -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_39063 (h0 : ring (add_comm_semigroup (normed_field (mul_one_class std_gen)))) : strong_rank_condition (add_comm_semigroup (normed_field (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_39064 (h0 : add_group (ring empty)) : is_add_cyclic (ring empty) := sorry --non-trivial
lemma new_lemma_39065 (h0 : not (topological_space (measure_theory.measure_space to_additive.value_type) -> false)) : @path_connected_space.{0} (measure_theory.measure_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_39066 (h0 : ring (ring (has_add (has_add (has_add pos))))) : is_domain (ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_39067 (h0 : topological_space (has_sub (semiring (semiring unsigned)))) : path_connected_space (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_39068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39069 (h1 : complete_lattice (normed_field environment.projection_info)) : complete_lattice.is_Sup_finite_compact (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_39070 (h0 : functor.add_const (semiring (has_to_string pos)) (has_neg environment.implicit_infer_kind)) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_39071 (h2 : cancel_comm_monoid_with_zero (has_div to_additive.value_type)) : unique_factorization_monoid (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39072 (h0 : group (has_inv (comm_ring linarith.comp_source))) : is_cyclic (has_inv (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39073 (h0 : list (distrib_lattice (random_gen to_additive.value_type))) : list.nodup (id h0) := sorry --non-trivial
lemma new_lemma_39074 (h0 : topological_space (random_gen (has_norm to_additive.value_type))) : totally_disconnected_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39075 (h0 : add_group (complete_distrib_lattice pos)) : is_add_cyclic (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_39076 (h0 : not (add_group (non_assoc_semiring empty) -> false)) : @is_add_cyclic.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_39077 (h0 : topological_space (finset (option (option (option (option unsigned)))))) : normal_space (finset (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_39078 (h0 : group (has_nnnorm (add_cancel_comm_monoid (comm_ring reducibility_hints)))) : is_cyclic (has_nnnorm (add_cancel_comm_monoid (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_39079 (h0 : measurable_space (comm_monoid empty)) (h1 : function.extfun Type has_sup) : @has_measurable_sup.{0} (comm_monoid.{0} empty) h0 (@function.extfun_app.{2 1} Type has_sup.{0} h1 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_39080 (h0 : functor.add_const (uniform_space (simple_graph name)) Type) : @complete_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (simple_graph.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_39081 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_39082 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39083 (h0 : topological_space (has_dist num)) : preconnected_space (has_dist num) := sorry --non-trivial
lemma new_lemma_39084 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_39085 (h0 : function.extfun Type topological_space) : @t0_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39086 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_39087 (h0 : add_monoid (boolean_algebra (comm_group pos))) : add_monoid.fg (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_39088 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_39089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (pseudo_emetric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_emetric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_39090 (h0 : monoid (normed_lattice_add_comm_group (ordered_comm_monoid Type))) : monoid.fg (normed_lattice_add_comm_group (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_39091 (h0 : has_inv linarith.ineq -> has_inv linarith.ineq -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_39092 (h0 : monoid (comm_ring linarith.ineq)) : monoid.fg (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_39093 (h0 : ordered_comm_monoid (semigroup (option pos))) : has_exists_mul_of_le (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_39094 (h0 : measurable_space environment.implicit_infer_kind) (h1 : filter environment.implicit_infer_kind) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_39095 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_pos_part pos))) : unique_factorization_monoid (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_39096 (h0 : group (has_top (semiring to_additive.value_type))) : normalizer_condition (has_top (semiring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39097 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @t0_space.{1} (plift.{1} fun_info) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} fun_info))  := sorry --non-trivial
lemma new_lemma_39098 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_39099 (h0 : not (complete_lattice (random_gen reducibility_hints) -> false)) : @is_compactly_generated.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_39100 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39101 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : loc_path_connected_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_39102 (h0 : group (has_add (finset (finset Type)))) : is_cyclic (has_add (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_39103 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (uniform_space.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (uniform_space.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39105 (h0 : cancel_comm_monoid_with_zero (has_to_string empty)) : unique_factorization_monoid (has_to_string empty) := sorry --non-trivial
lemma new_lemma_39106 (h0 : functor.comp filter normed_comm_ring name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_39107 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39108 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @normal_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39109 (h0 : functor.add_const (ring (add_cancel_monoid Type)) name) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_39110 (h0 : topological_space (cancel_monoid name)) : t1_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_39111 (h0 : filter (canonically_linear_ordered_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_39113 (h0 : function.extfun Type (functor.add_const (list (normed_group empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_39114 (h0 : ring (boolean_algebra.core (comm_group (boolean_algebra.core name)))) : rank_condition (boolean_algebra.core (comm_group (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_39115 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_39116 (h0 : ring (has_norm (random_gen fun_info))) : rank_condition (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_39117 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @totally_separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_39118 (h0 : topological_space (non_assoc_semiring (option empty))) : preirreducible_space (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_39119 (h0 : topological_space (comm_group (add_comm_monoid unsigned))) : t0_space (comm_group (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_39120 (h0 : uniform_space (complete_semilattice_Sup unsigned)) : separated_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_39121 (h0 : not (topological_space (add_monoid linarith.ineq) -> false)) : @totally_disconnected_space.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_39122 (h0 : group (ordered_cancel_add_comm_monoid (option empty))) : group.fg (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_39123 (h0 : filter (finset (has_to_string unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39124 (h0 : ring (canonically_ordered_add_monoid char)) : is_domain (canonically_ordered_add_monoid char) := sorry --non-trivial
lemma new_lemma_39125 (h0 : functor.comp ring semigroup Type) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_39126 (h0 : uniform_space (has_neg (has_nndist linarith.comp))) : complete_space (has_neg (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_39127 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39128 (h0 : topological_space std_gen) : t0_space std_gen := sorry --non-trivial
lemma new_lemma_39129 (h0 : ring (uniform_space (uniform_space char))) : rank_condition (uniform_space (uniform_space char)) := sorry --non-trivial
lemma new_lemma_39130 (h0 : finset (finset (ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39131 (h0 : complete_lattice (add_cancel_comm_monoid (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_39132 (h0 : topological_space (has_add (ring Type))) : regular_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_39133 (h0 : ring (has_to_string (finset (finset pos)))) : is_principal_ideal_ring (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_39134 (h1 : group (has_top linarith.ineq)) : group.fg (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_39135 (h0 : filter (has_neg (finset ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39136 (h0 : group (semi_normed_comm_ring (random_gen reducibility_hints))) : is_cyclic (semi_normed_comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_39137 (h0 : topological_space (comm_semigroup name)) : topological_space.separable_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_39138 (h0 : complete_lattice (canonically_ordered_add_monoid (option empty))) : is_atomistic (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_39139 (h0 : functor.comp topological_space mul_zero_class name) : @path_connected_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_39140 (h0 : topological_space (has_compl to_additive.value_type)) : t0_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39141 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_39142 (h0 : cancel_comm_monoid_with_zero (has_Inf (ring (ring (canonically_ordered_comm_semiring Type))))) : unique_factorization_monoid (has_Inf (ring (ring (canonically_ordered_comm_semiring Type)))) := sorry --non-trivial
lemma new_lemma_39143 (h0 : functor.add_const (topological_space (has_add real)) real) : @normal_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_39144 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @separated_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_39145 (h0 : functor.add_const (add_group (ordered_comm_ring pos)) (finset Type)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ordered_comm_ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39146 (h0 : functor.add_const (monoid (normed_comm_ring Type)) pos) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_39147 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} auto.case_option (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_39148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_39149 (h0 : list (has_inv (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39150 (h0 : topological_space (finset pos)) : topological_space.separable_space (finset pos) := sorry --non-trivial
lemma new_lemma_39151 (h0 : topological_space (mul_zero_class name)) : preirreducible_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_39152 (h0 : finset (finset (ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39153 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39154 (h0 : functor.add_const (topological_space (ordered_ring empty)) (option empty)) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_39155 (h0 : group (linear_ordered_semiring empty)) : normalizer_condition (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_39156 (h1 : ring (mul_one_class linarith.ineq)) : rank_condition (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_39157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39158 (h1 : ring (add_cancel_comm_monoid string_imp)) : is_domain (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_39159 (h0 : set (add_comm_semigroup environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_39160 (h0 : complete_lattice (pseudo_metric_space (finset ennreal))) : is_compactly_generated (pseudo_metric_space (finset ennreal)) := sorry --non-trivial
lemma new_lemma_39161 (h0 : topological_space (sub_neg_monoid unsigned)) : normal_space (sub_neg_monoid unsigned) := sorry --non-trivial
lemma new_lemma_39162 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @is_domain.{1} Type (@finset.pi.empty.{2 1} (Type 1) ring.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_39163 (h0 : ring (has_norm linarith.ineq)) : is_domain (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_39164 (h1 : complete_lattice (has_lt (normed_field (mul_one_class to_additive.value_type)))) : is_compactly_generated (has_lt (normed_field (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_39165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39166 (h0 : ring (linear_ordered_semiring congr_arg_kind)) : is_domain (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39167 (h0 : topological_space (topological_space (has_nnnorm (distrib to_additive.value_type)))) : path_connected_space (topological_space (has_nnnorm (distrib to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_39168 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid Type))) : is_compactly_generated (generalized_boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_39169 (h0 : functor.add_const (uniform_space (ring name)) (ring Type)) : @complete_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39170 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_39171 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39172 (h0 : has_add (measure_theory.measure_space (denumerable char))) (h1 : has_le (measure_theory.measure_space (denumerable char))) (h2 : measure_theory.measure_space (denumerable char)) : add_le_cancellable h2 := sorry --non-trivial
lemma new_lemma_39173 (h3 : complete_lattice (with_zero (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_39174 (h0 : not (has_mem.mem (semiring linarith.comp) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_39175 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39176 (h0 : complete_lattice (cancel_monoid (has_add ennreal))) : is_compactly_generated (cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_39177 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : totally_separated_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39178 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39179 (h2 : complete_lattice (normed_group to_additive.value_type)) : is_compactly_generated (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39180 (h1 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_39181 (h0 : topological_space (has_emptyc (semiring linarith.comp))) : path_connected_space (has_emptyc (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_39182 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39183 (h0 : topological_space (partial_order (semiring (semiring empty)))) : irreducible_space (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_39184 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_39185 (h0 : topological_space (has_add (has_Inf pos))) : totally_disconnected_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_39186 (h0 : functor.add_const (list (canonically_ordered_comm_semiring ennreal)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39187 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39188 (h0 : topological_space (dlist (has_top to_additive.value_type))) : path_connected_space (dlist (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39189 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_39190 (h0 : has_mem.mem (add_group_with_zero_nhd fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (add_group_with_zero_nhd.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (add_group_with_zero_nhd.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_39191 (h0 : functor.add_const (list (has_nndist linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39192 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_39193 (h0 : ring (semi_normed_ring string_imp)) : rank_condition (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_39194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39195 (h0 : topological_space (add_comm_monoid linarith.comp)) : path_connected_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_39196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39197 (h0 : not (complete_lattice (comm_ring string_imp) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_39198 (h0 : functor.add_const (monoid (has_neg_part Type)) (add_comm_monoid (has_add pos))) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) (add_comm_monoid.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_39199 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_39200 (h0 : functor.add_const (ring (semigroup unsigned)) empty) : @is_domain.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_39201 (h0 : complete_lattice (comm_ring (metric_space linarith.comp_source))) : is_compactly_generated (comm_ring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39202 (h0 : semiring (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h1 : ideal (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_39203 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39204 (h0 : topological_space (ring (has_add linarith.comp))) : preconnected_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_39205 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) Type) := sorry --non-trivial
lemma new_lemma_39206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39207 (h0 : complete_lattice (ordered_comm_monoid (simple_graph (ring (has_pos_part Type))))) : is_compactly_generated (ordered_comm_monoid (simple_graph (ring (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_39208 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_39209 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_39210 (h0 : uniform_space (boolean_algebra.core (has_neg name))) : complete_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_39211 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra real)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_39212 (h0 : filter (has_add (has_to_string (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39213 (h0 : group (group_with_zero unsigned)) : normalizer_condition (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_39214 (h0 : functor.add_const (topological_space (finset pos)) (has_zero pos)) : @preirreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39215 (h1 : add_group (has_append (random_gen to_additive.value_type))) : is_add_cyclic (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39216 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid pos)) Type) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39217 (h0 : ring (has_pos_part (sub_neg_monoid real))) : rank_condition (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_39218 (h0 : set.set_semiring (linear_ordered_add_comm_group (random_gen (has_nnnorm fun_info)))) (h1 : linear_ordered_add_comm_group (random_gen (has_nnnorm fun_info))) : set.set_semiring.down h0 h1 := sorry --non-trivial
lemma new_lemma_39219 (h4 : topological_space (semi_normed_ring char)) : path_connected_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_39220 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_39221 (h0 : ring (has_nndist (has_to_string unsigned))) : is_domain (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_39222 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_39223 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39224 (h0 : topological_space (semigroup (finset pos))) : totally_disconnected_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_39225 (h0 : semiring (add_cancel_monoid (ring linarith.comp))) : is_noetherian_ring (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_39226 (h0 : topological_space (finset (has_to_string (has_to_string linarith.comp)))) : totally_disconnected_space (finset (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_39227 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_39228 (h0 : finset (normed_comm_ring (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39230 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_39231 (h0 : topological_space (with_one linarith.ineq)) : path_connected_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_39232 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @t1_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39233 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_39234 (h0 : topological_space (dlist (has_ssubset fun_info))) : totally_disconnected_space (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_39235 (h0 : topological_space (semiring (has_top empty))) : preirreducible_space (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_39236 (h0 : functor.add_const (functor.add_const (list pos) (ring Type)) (has_add pos)) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_39237 (h0 : filter (complete_distrib_lattice (has_add (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39238 (h0 : list (complete_semilattice_Sup linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39239 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_39240 (h0 : topological_space (as_linear_order empty)) : totally_disconnected_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_39241 (h0 : topological_space (ordered_comm_ring real)) : topological_space.separable_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_39242 (h0 : group (complete_semilattice_Sup (has_norm fun_info))) : normalizer_condition (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_39243 (h0 : add_group (random_gen (has_nnnorm to_additive.value_type))) : is_add_cyclic (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39244 (h0 : group (has_norm (random_gen (random_gen to_additive.value_type)))) : group.fg (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_39245 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_39246 (h0 : complete_lattice (complete_semilattice_Sup (has_top linarith.ineq))) : is_atomistic (complete_semilattice_Sup (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39247 (h2 : measurable_space std_gen) (h3 : set std_gen) : measurable_set h3 := sorry --non-trivial
lemma new_lemma_39248 (h0 : filter (ordered_ring empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39249 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_39250 (h0 : list (semi_normed_comm_ring (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39251 (h0 : ring (boolean_algebra.core (has_nndist pos))) : rank_condition (boolean_algebra.core (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_39252 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_39253 (h0 : uniform_space (sub_neg_monoid (has_Inf Type))) : complete_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_39254 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_39255 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_39256 (h0 : topological_space (add_group (semiring (semiring (semiring unsigned))))) : t0_space (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_39257 (h0 : semiring (has_nndist (ring (finset pos)))) : is_noetherian_ring (has_nndist (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_39258 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39259 (h0 : topological_space (semiring (has_top (has_top (has_top linarith.ineq))))) : totally_disconnected_space (semiring (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_39260 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39261 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_39263 (h0 : multiset (has_ssubset string_imp)) (h1 : not (multiset (has_ssubset string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_39264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39265 (h2 : not (ring (has_append char) -> false)) : @is_domain.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_39266 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39267 (h0 : topological_space (measurable_space unsigned)) : path_connected_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_39268 (h1 : group (has_compl char)) : is_cyclic (has_compl char) := sorry --non-trivial
lemma new_lemma_39269 (h0 : functor.add_const (filter (has_nndist environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39270 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39271 (h0 : functor.add_const (ring (boolean_algebra.core pos)) unsigned) : @is_domain.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39272 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) unsigned) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39273 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_39274 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39275 (h0 : topological_space (ring (finset (finset pos)))) : preconnected_space (ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_39276 (h0 : topological_space (has_nndist (has_neg (has_neg (normed_comm_ring Type))))) : loc_path_connected_space (has_nndist (has_neg (has_neg (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_39277 (h2 : filter (normed_linear_ordered_group to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_39278 (h0 : add_group (plift (semiring (semiring num)))) : is_add_cyclic (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_39279 (h0 : ring (linear_ordered_add_comm_group (has_ssubset (distrib_lattice linarith.ineq)))) : rank_condition (linear_ordered_add_comm_group (has_ssubset (distrib_lattice linarith.ineq))) := sorry --non-trivial
lemma new_lemma_39280 (h0 : complete_lattice (has_nndist (add_cancel_monoid Type))) : is_atomistic (has_nndist (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_39281 (h0 : topological_space (has_add (option ennreal))) : preirreducible_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_39282 (h0 : semiring (mul_zero_class (finset environment.implicit_infer_kind))) : is_noetherian_ring (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39283 (h0 : function.extfun Type (functor.add_const (list (plift num)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_39284 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_39285 (h0 : ring (normed_group linarith.comp_source)) : rank_condition (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39286 (h0 : finset (complete_distrib_lattice (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39287 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39288 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39289 (h0 : add_group (div_inv_monoid string_imp)) : is_add_cyclic (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_39290 (h0 : not (ring (semiring (random_gen num)) -> false)) : @rank_condition.{0} (semiring.{0} (random_gen.{0} num)) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} (random_gen.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_39291 (h0 : functor.add_const (ring (add_comm_monoid (has_neg_part unsigned))) Type) : @is_domain.{0} (add_comm_monoid.{0} (has_neg_part.{0} unsigned)) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} (has_neg_part.{0} unsigned))) Type h0)  := sorry --non-trivial
lemma new_lemma_39292 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_39293 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_bot.{1} (has_add.{1} (has_Inf.{1} (has_Inf.{1} (has_Inf.{1} (has_add.{1} Type)))))) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_bot.{1} (has_add.{1} (has_Inf.{1} (has_Inf.{1} (has_Inf.{1} (has_add.{1} Type)))))))  := sorry --non-trivial
lemma new_lemma_39294 (h0 : not (group (metric_space unsigned) -> false)) : @normalizer_condition.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39295 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39296 (h0 : functor.add_const (group (ordered_comm_monoid pos)) linarith.comp) : @is_simple_group.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39297 (h0 : list (has_Inf (has_Inf pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39298 (h0 : complete_lattice (has_add (has_add (normed_lattice_add_comm_group real)))) : is_atomistic (has_add (has_add (normed_lattice_add_comm_group real))) := sorry --non-trivial
lemma new_lemma_39299 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_39300 (h0 : functor.add_const (filter (ordered_comm_ring empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39301 (h0 : not (group (with_one to_additive.value_type) -> false)) : @group.fg.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_39302 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : regular_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_39303 (h0 : uniform_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) : complete_space (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_39304 (h0 : filter znum) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39305 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_39306 (h0 : ring (linear_ordered_field (option (option (option (option ennreal)))))) : is_domain (linear_ordered_field (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_39307 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_39308 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_39309 (h0 h1 : fin has_zero.zero) : matrix.vec_empty (fin.sub h0 h1) := sorry --non-trivial
lemma new_lemma_39310 (h1 : topological_space (add_comm_semigroup environment.projection_info)) : totally_disconnected_space (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_39311 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring name)) name) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_39312 (h0 : topological_space (has_nndist empty)) : totally_separated_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_39313 (h0 : topological_space (semigroup (option (has_to_string ennreal)))) : totally_disconnected_space (semigroup (option (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_39314 (h0 : functor.add_const (group (normed_comm_ring pos)) Type) : @is_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39315 (h0 : topological_space (has_top (random_gen (random_gen (random_gen linarith.ineq))))) : path_connected_space (has_top (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_39316 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_39317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39318 (h0 : topological_space (has_nndist (normed_comm_ring (finset (finset Type))))) : irreducible_space (has_nndist (normed_comm_ring (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_39319 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_39320 (h0 : ring (has_neg (comm_group (has_neg pos)))) : rank_condition (has_neg (comm_group (has_neg pos))) := sorry --non-trivial
lemma new_lemma_39321 (h0 : topological_space (comm_ring (with_bot (with_bot to_additive.value_type)))) : t0_space (comm_ring (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_39322 (h0 : functor.add_const (group (add_cancel_monoid empty)) empty) : @is_cyclic.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39323 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_39324 (h0 : set (has_nnnorm (semi_normed_comm_ring linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_39325 (h1 : topological_space (measurable_space unsigned)) : totally_separated_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_39326 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39327 (h0 : topological_space (simple_graph (has_add pos))) : regular_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_39328 (h0 : ordered_comm_monoid (simple_graph (has_neg Type))) : has_exists_mul_of_le (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_39329 (h0 : group (measurable_space (random_gen linarith.comp_source))) : normalizer_condition (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39330 (h0 : topological_space (ordered_comm_monoid pos)) : locally_compact_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_39331 (h0 : uniform_space (semiring (semiring empty))) : complete_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_39332 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_39333 (h0 : list (with_one fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39334 (h0 : topological_space string.iterator_imp) (h1 : preorder string.iterator_imp) : order_closed_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_39335 (h0 : uniform_space (with_one string_imp)) : complete_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_39336 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (normed_lattice_add_comm_group.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_39337 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) name) : @preconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_39338 (h0 : topological_space (random_gen (random_gen (random_gen fun_info)))) : discrete_topology (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_39339 (h1 : topological_space (has_inv (random_gen to_additive.value_type))) : path_connected_space (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39340 (h0 : semiring (has_neg (has_zero Type))) : is_noetherian_ring (has_neg (has_zero Type)) := sorry --non-trivial
lemma new_lemma_39341 (h0 : set (prod congr_arg_kind congr_arg_kind)) (h1 : prod congr_arg_kind congr_arg_kind) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_39342 (h0 : monoid (normed_group (random_gen linarith.comp_source))) : monoid.fg (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39343 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39344 (h0 : functor.add_const (semiring (has_nndist linarith.comp)) name) : @is_noetherian_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_39345 (h0 : topological_space (complete_semilattice_Sup (has_top fun_info))) : totally_separated_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_39346 (h0 : not (ring (semi_normed_ring fun_info) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_39347 (h0 : ring (distrib_lattice (random_gen (random_gen (random_gen char))))) : is_domain (distrib_lattice (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_39348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39349 (h0 : not (cancel_comm_monoid_with_zero (measure_theory.measure_space unsigned) -> false)) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39350 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_39351 (h0 : functor.add_const (topological_space (ring pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_39352 (h0 : topological_space (cancel_monoid (ring unsigned))) : preconnected_space (cancel_monoid (ring unsigned)) := sorry --non-trivial
lemma new_lemma_39353 (h0 : not (topological_space (normed_field linarith.comp_source) -> false)) : @path_connected_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_39354 (h0 : functor.add_const (topological_space (has_Sup empty)) (option unsigned)) : @normal_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_39355 (h0 : functor.add_const (list (free_add_monoid empty)) (semiring (semiring congr_arg_kind))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39356 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @t1_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_39357 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : topological_space.separable_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_39358 (h0 : function.extfun (with_bot to_additive.value_type) (fun (x : with_bot to_additive.value_type), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (with_bot.{0} to_additive.value_type) (@function.extfun_app.{1 1} (with_bot.{0} to_additive.value_type) (λ (x : with_bot.{0} to_additive.value_type), Prop) h0)  := sorry --non-trivial
lemma new_lemma_39359 (h1 : topological_space linarith.comp) : t0_space linarith.comp := sorry --non-trivial
lemma new_lemma_39360 (h0 : complete_lattice (distrib string_imp)) : complete_lattice.is_Sup_finite_compact (distrib string_imp) := sorry --non-trivial
lemma new_lemma_39361 (h0 : complete_lattice (nondiscrete_normed_field fun_info)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_39362 (h0 : filter (topological_space char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39363 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (ring pos))) : unique_factorization_monoid (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_39364 (h0 : topological_space (mul_zero_class (comm_group pos))) : irreducible_space (mul_zero_class (comm_group pos)) := sorry --non-trivial
lemma new_lemma_39365 (h0 : topological_space (has_zero (finset name))) : t0_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_39366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39367 (h0 : ring (random_gen (has_inv (random_gen linarith.ineq)))) : strong_rank_condition (random_gen (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_39368 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_39369 (h0 : not (function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type))) -> false)) : @monoid.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type)))) h0) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39370 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39371 (h0 : topological_space (linear_ordered_field (option ennreal))) : irreducible_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_39372 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_union.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_union.{0} real))  := sorry --non-trivial
lemma new_lemma_39373 (h0 : add_monoid (has_Inf (has_Inf (has_pos_part Type)))) : add_monoid.fg (has_Inf (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_39374 (h0 : group (canonically_ordered_comm_semiring Type)) : is_cyclic (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_39375 (h0 : topological_space (filter num)) : locally_compact_space (filter num) := sorry --non-trivial
lemma new_lemma_39376 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) (has_add (has_to_string linarith.comp))) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_39377 (h0 : add_group (measurable_space (has_inv linarith.comp_source))) : is_add_cyclic (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39378 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39379 (h0 : list (with_bot Prop)) (h1 : nat) (h2 : ne (list.inth h0 h1) has_bot.bot) : with_bot.unbot (list.inth h0 h1) h2 := sorry --non-trivial
lemma new_lemma_39380 (h0 : functor.add_const (uniform_space (has_nndist pos)) pos) : @complete_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_39381 (h0 : uniform_space (has_neg (has_Inf (mul_one_class (has_pos_part Type))))) : complete_space (has_neg (has_Inf (mul_one_class (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_39382 (h0 : group (has_pos_part (has_zero (has_zero num)))) : normalizer_condition (has_pos_part (has_zero (has_zero num))) := sorry --non-trivial
lemma new_lemma_39383 (h0 : ring (has_Inf (ring linarith.comp))) : is_domain (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_39384 (h1 : ring (comm_ring string_imp)) : strong_rank_condition (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_39385 (h1 : function.extfun Type has_lt) : @no_max_order.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type has_lt.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_39386 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_39387 (h0 : fin has_zero.zero) : @complete_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_39388 (h0 : ring (boolean_algebra (has_add linarith.comp))) : strong_rank_condition (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_39389 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @t0_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39390 (h1 : group (random_gen to_additive.value_type)) : is_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39391 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_39392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39393 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_39394 (h0 : group (has_compl char)) : group.fg (has_compl char) := sorry --non-trivial
lemma new_lemma_39395 (h0 : function.extfun nat fin) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39396 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : normal_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_39398 (h1 : ring (has_nnnorm (has_top string_imp))) : is_domain (has_nnnorm (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_39399 (h0 : list (left_cancel_monoid (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_39400 (h0 : topological_space (mul_zero_class Type)) : topological_space.separable_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_39401 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_39402 (h0 : functor.add_const (ring (preorder num)) congr_arg_kind) : @strong_rank_condition.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_39403 (h0 : ring (semi_normed_comm_ring (has_top (random_gen char)))) : strong_rank_condition (semi_normed_comm_ring (has_top (random_gen char))) := sorry --non-trivial
lemma new_lemma_39404 (h0 : functor.add_const (complete_lattice (add_cancel_monoid empty)) unsigned) : @is_atomistic.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39405 (h0 : function.extfun Type (functor.add_const (functor.add_const (monoid (left_cancel_monoid num)) unsigned))) : @monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} num)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} (left_cancel_monoid.{0} num)) unsigned) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (monoid.{0} (left_cancel_monoid.{0} num)) unsigned)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_39406 (h0 : ordered_comm_monoid (has_nndist unsigned)) : has_exists_mul_of_le (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_39407 (h0 : not (ring (option unsigned) -> false)) : @is_domain.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39408 (h0 : functor.add_const (topological_space (has_to_string name)) (has_to_string linarith.comp)) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_39409 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39410 (h1 : add_group (add_cancel_comm_monoid to_additive.value_type)) : is_add_cyclic (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39411 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_39412 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (ring Type)) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39413 (h0 : group (complete_semilattice_Sup (semiring unsigned))) : normalizer_condition (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_39414 (h0 : ring (has_neg (finset pos))) : strong_rank_condition (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_39415 (h0 : functor.comp group has_neg environment.implicit_infer_kind) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_39416 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39417 (h0 : functor.add_const (topological_space (has_to_string name)) unsigned) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39418 (h0 : topological_space (generalized_boolean_algebra (ring name))) : preirreducible_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_39419 (h0 : ordered_comm_monoid (has_to_string (finset name))) : has_exists_mul_of_le (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_39420 (h0 : set (linear_ordered_comm_group_with_zero enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_39421 (h0 : ring (has_neg (finset (has_Inf (has_Inf pos))))) : is_domain (has_neg (finset (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_39422 (h0 : functor.add_const (filter (has_nndist linarith.comp)) (has_Inf Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39423 (h1 : has_coe (nondiscrete_normed_field (add_comm_semigroup std_gen)) Prop) (h2 : nondiscrete_normed_field (add_comm_semigroup std_gen)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} std_gen)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_39424 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_39425 (h0 : ring (left_cancel_semigroup empty)) : is_domain (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_39426 (h0 : group (normed_group num)) : normalizer_condition (normed_group num) := sorry --non-trivial
lemma new_lemma_39427 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (linear_ordered_semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_39428 (h0 : monoid (normed_comm_ring (ring (ring linarith.comp)))) : monoid.fg (normed_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_39429 (h0 : topological_space (boolean_algebra (has_add (has_Inf linarith.comp)))) : irreducible_space (boolean_algebra (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_39430 (h0 : monoid (has_add (has_neg linarith.comp))) : monoid.fg (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_39431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39432 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39433 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : t0_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_39434 (h0 : function.extfun nat fin) : @path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_39435 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_39436 (h0 : prod (boolean_algebra.core (has_add name)) (boolean_algebra.core (has_add name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_39437 (h0 : topological_space (has_Inf (has_neg name))) : regular_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_39438 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_39439 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_39440 (h0 : topological_space (denumerable (random_gen string_imp))) : totally_disconnected_space (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_39441 (h0 : ring (with_bot (has_norm (has_top (semiring congr_arg_kind))))) : rank_condition (with_bot (has_norm (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_39442 (h0 : ring (with_one (has_norm linarith.comp_source))) : is_domain (with_one (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39443 (h0 : ring (has_nndist (has_neg (has_neg environment.implicit_infer_kind)))) : is_domain (has_nndist (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_39444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39445 (h0 : topological_space (generalized_boolean_algebra Type)) : discrete_topology (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_39446 (h0 : filter (linear_ordered_add_comm_group (random_gen (has_top linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39447 (h1 : group (simple_graph linarith.comp_source)) : group.fg (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39448 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39449 (h0 : filter (topological_space (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39450 (h0 : complete_lattice (denumerable char)) : complete_lattice.is_Sup_finite_compact (denumerable char) := sorry --non-trivial
lemma new_lemma_39451 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39452 (h0 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : totally_disconnected_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39453 (h0 : functor.add_const (fin has_zero.zero) real) : @path_connected_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_39454 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39455 (h0 : topological_space (denumerable (random_gen string_imp))) : path_connected_space (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_39456 (h0 : complete_lattice (has_ssubset (has_ssubset reducibility_hints))) : is_compactly_generated (has_ssubset (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_39457 (h0 : functor.comp semiring mul_zero_class Type) : @is_noetherian_ring.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_39458 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg linarith.comp)))) : preirreducible_space (add_cancel_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_39459 (h0 : function.extfun Type ring) : @is_domain.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_39461 (h0 : is_empty Type) : @complete_space.{0} (semi_normed_ring.{0} fun_info) (@is_empty.elim.{2 1} Type h0 uniform_space.{0} (semi_normed_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39462 (h1 : topological_space (mul_one_class reducibility_hints)) : path_connected_space (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_39463 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : loc_path_connected_space (add_right_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_39464 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39465 (h0 : not (complete_lattice (div_inv_monoid to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_39466 (h0 : not (topological_space (partial_order empty) -> false)) : @discrete_topology.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_39467 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @normal_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39468 (h0 : ring (semi_normed_comm_ring linarith.comp_source)) : rank_condition (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39469 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_39470 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @t1_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39471 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39472 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 linarith.ineq) := sorry --non-trivial
lemma new_lemma_39473 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semigroup.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_39475 (h0 : topological_space (add_group (semiring (semiring (semiring unsigned))))) : path_connected_space (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_39476 (h2 : complete_lattice (div_inv_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_39477 (h0 : group (ordered_cancel_add_comm_monoid (ring pos))) : is_simple_group (ordered_cancel_add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_39478 (h0 : functor.comp topological_space add_cancel_monoid environment.implicit_infer_kind) : @path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_39479 (h0 : group (has_add (comm_semigroup pos))) : is_simple_group (has_add (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_39480 (h0 : functor.add_const (add_monoid (has_to_string Type)) Type) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_39481 (h0 : group (has_ssubset string_imp)) : group.fg (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_39482 (h0 : topological_space (ring (finset (has_Inf linarith.comp)))) : discrete_topology (ring (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_39483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_39484 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_39485 (h0 : function.extfun nat fin) : @separated_space.{0} (has_nndist.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_nndist.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_39487 (h0 : not (filter (with_one linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_39488 (h0 : boolean_algebra.core ennreal -> boolean_algebra.core ennreal -> Prop) : is_symm (boolean_algebra.core ennreal) h0 := sorry --non-trivial
lemma new_lemma_39489 (h0 : list (ring (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_39490 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (semigroup.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_39491 (h0 : not (ring (complete_linear_order empty) -> false)) : @strong_rank_condition.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_39492 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) linarith.comp) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39493 (h0 : topological_space (topological_space (random_gen (random_gen char)))) : totally_disconnected_space (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_39494 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @t0_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39495 (h0 : topological_space (add_cancel_monoid (option empty))) : loc_path_connected_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_39496 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_39497 (h0 : complete_lattice (distrib_lattice (has_inv fun_info))) : is_atomistic (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_39498 (h0 : functor.add_const (ring (semigroup linarith.comp)) Type) : @is_domain.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39499 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) (has_nndist name)) : @is_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_39500 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39501 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_39502 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39503 (h1 : ring (has_compl (random_gen string_imp))) : rank_condition (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_39504 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39505 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_39506 (h0 : not (topological_space (random_gen unsigned) -> false)) : @irreducible_space.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39507 (h0 : semiring (normed_comm_ring (option empty))) : is_noetherian_ring (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_39508 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39509 (h0 : topological_space (has_Inf name)) : path_connected_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_39510 (h0 : topological_space (has_to_string congr_arg_kind)) : discrete_topology (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39512 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @path_connected_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_39513 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_neg pos))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_39514 (h0 : topological_space (semilattice_inf (random_gen (random_gen num)))) : totally_disconnected_space (semilattice_inf (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_39515 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39516 (h0 : group (has_to_string environment.implicit_infer_kind)) : group.fg (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_39517 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_39518 (h0 : functor.comp list has_add environment.implicit_infer_kind) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_39519 (h0 h1 : multiset (add_cancel_comm_monoid (mul_one_class char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_39520 (h0 : group (add_cancel_monoid (has_nndist pos))) : group.fg (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_39521 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_39522 (h0 : ring (ordered_comm_ring pos)) : is_domain (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_39523 (h0 : not (topological_space (semi_normed_comm_ring to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_39524 (h0 : functor.add_const (ring (ordered_comm_ring Type)) Type) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_39525 (h0 : uniform_space (normed_comm_ring (boolean_algebra.core (add_comm_monoid name)))) : separated_space (normed_comm_ring (boolean_algebra.core (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_39526 (h0 : topological_space (has_inter congr_arg_kind)) : locally_compact_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39527 (h0 : uniform_space (measurable_space (random_gen (random_gen linarith.comp_source)))) : complete_space (measurable_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_39528 (h0 : filter (has_union (has_norm (has_norm (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39529 (h0 : option (function.extfun Type topological_space)) (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@option.get_or_else.{1} (function.extfun.{2 1} Type topological_space.{0}) h0 h1) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39531 (h0 : functor.add_const (group (has_to_string pos)) (has_neg name)) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_39532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39533 (h0 : topological_space (boolean_algebra (semigroup Type))) : irreducible_space (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_39534 (h0 : ordered_add_comm_monoid (has_neg (has_to_string unsigned))) : archimedean (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_39535 (h1 : topological_space (semi_normed_comm_ring linarith.ineq)) : t0_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_39536 (h0 : group (option name)) : normalizer_condition (option name) := sorry --non-trivial
lemma new_lemma_39537 (h0 : function.extfun Type (functor.add_const (list (linear_ordered_field empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_39538 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @totally_disconnected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39539 (h0 : filter (normed_comm_ring (has_nndist linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39540 (h0 : uniform_space (has_Inf (has_neg (has_add Type)))) : separated_space (has_Inf (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_39541 (h0 : topological_space (ordered_comm_ring (has_add real))) : totally_separated_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_39542 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39543 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) pos) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_39544 (h0 : monoid (has_nndist (comm_group name))) : monoid.fg (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_39545 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39547 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.ineq))) : t0_space (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39548 (h0 : functor.add_const (topological_space (ring unsigned)) (option pos)) : @irreducible_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39549 (h0 : set (uniform_space (mul_one_class (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_39550 (h1 : add_group (semi_normed_comm_ring (random_gen char))) : is_add_cyclic (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_39551 (h0 : complete_lattice (add_monoid linarith.comp_source)) : is_compactly_generated (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39552 (h0 : topological_space (measurable_space (semiring unsigned))) : locally_compact_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_39553 (h0 : functor.add_const (function.extfun (Type 1) semiring) name) : @is_noetherian_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_39554 (h0 : topological_space (filter num)) : path_connected_space (filter num) := sorry --non-trivial
lemma new_lemma_39555 (h0 : topological_space (monoid (option unsigned))) : discrete_topology (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_39556 (h0 : not (topological_space (linear_ordered_comm_ring nnreal) -> false)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} nnreal) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} nnreal)) h0)  := sorry --non-trivial
lemma new_lemma_39557 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39558 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_39559 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (ring pos)) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39560 (h0 : uniform_space (has_zero (linear_ordered_comm_ring name))) : separated_space (has_zero (linear_ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_39561 (h0 : functor.comp add_group has_zero pos) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_39562 (h0 : topological_space (ordered_cancel_add_comm_monoid (semiring (semiring empty)))) : totally_disconnected_space (ordered_cancel_add_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_39563 (h0 : functor.add_const (group (ring Type)) (mul_one_class pos)) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (mul_one_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39565 (h2 : topological_space (mul_one_class enat)) : path_connected_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_39566 (h0 : group (with_bot linarith.comp)) : group.fg (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_39567 (h0 : has_mem.mem (add_left_cancel_monoid linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (add_left_cancel_monoid.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_39568 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @preirreducible_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_39569 (h0 : ring (has_inv fun_info)) : rank_condition (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_39570 (h0 : functor.add_const (functor.add_const Prop (comm_group Type)) unsigned) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39571 (h0 : simple_graph fun_info) (h1 : fun_info) : simple_graph.support h0 h1 := sorry --non-trivial
lemma new_lemma_39572 (h0 : complete_lattice (dlist (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (dlist (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_39573 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : normal_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_39574 (h0 : topological_space (rel string_imp linarith.ineq)) (h1 : not (preorder (rel string_imp linarith.ineq) -> false)) : order_topology (rel string_imp linarith.ineq) := sorry --non-trivial
lemma new_lemma_39575 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (has_add Type)) := sorry --non-trivial
lemma new_lemma_39576 (h2 : topological_space string.iterator_imp) : topological_space.first_countable_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_39577 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) num) : @path_connected_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_39578 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_39579 (h0 : ring (distrib_lattice (has_nnnorm fun_info))) : rank_condition (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_39580 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @path_connected_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39581 (h0 : functor.add_const (group (option pos)) (option name)) : @is_simple_group.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (option.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_39582 (h0 : group (has_add (has_Inf (has_add linarith.comp)))) : is_simple_group (has_add (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_39583 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_39584 (h0 : topological_space (has_add (has_neg (has_add (ring (ring (ring linarith.comp))))))) : t1_space (has_add (has_neg (has_add (ring (ring (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_39585 (h1 : ring (has_compl linarith.comp_source)) : strong_rank_condition (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39586 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : irreducible_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_39587 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : is_domain (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39588 (h2 : topological_space (has_lt char)) : path_connected_space (has_lt char) := sorry --non-trivial
lemma new_lemma_39589 (h0 : filter pos) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39591 (h0 : has_neg (add_comm_semigroup linarith.ineq)) (h2 : measurable_space (add_comm_semigroup linarith.ineq)) : has_measurable_neg (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_39592 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_39593 (h0 : functor.add_const (ring (add_comm_monoid pos)) (has_add (comm_group Type))) : @is_domain.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} pos)) (has_add.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_39594 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39595 (h1 : ring (mul_one_class (mul_one_class ereal))) : rank_condition (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_39596 (h3 : complete_lattice (has_ssubset environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_39597 (h0 : topological_space (ordered_comm_monoid (has_add name))) : preirreducible_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_39598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39599 (h0 : topological_space (monoid congr_arg_kind)) : t1_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39600 (h0 : topological_space (normed_comm_ring Type)) : preconnected_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_39601 (h0 : add_group (has_add (random_gen char))) : is_add_cyclic (has_add (random_gen char)) := sorry --non-trivial
lemma new_lemma_39602 (h0 : not (ring (has_add linarith.comp_source) -> false)) : @rank_condition.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_39603 (h0 h1 : list string.iterator_imp) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_39604 (h0 : functor.add_const (ring (has_to_string unsigned)) name) : @is_principal_ideal_ring.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_39605 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_39606 (h0 : ring (add_group (semiring (semiring empty)))) : rank_condition (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_39607 (h0 : functor.add_const (add_monoid (comm_group pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_39608 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_39609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_39610 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 group.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_39611 (h0 : group (has_top (has_top to_additive.value_type))) : normalizer_condition (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39612 (h0 : topological_space (finset (option (option unsigned)))) : preirreducible_space (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_39613 (h0 : topological_space (topological_space (has_nnnorm fun_info))) : t0_space (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_39614 (h1 : add_group (has_append reducibility_hints)) : is_add_cyclic (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_39615 (h0 : ring (comm_group Type)) : strong_rank_condition (comm_group Type) := sorry --non-trivial
lemma new_lemma_39616 (h0 : topological_space (has_top (has_norm linarith.comp))) : totally_separated_space (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_39617 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39618 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39619 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_39620 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info)))))) : t0_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info))))) := sorry --non-trivial
lemma new_lemma_39621 (h0 : prod (ring (option unsigned)) (ring (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_39622 (h0 : function.extfun Type (functor.add_const (complete_lattice (comm_monoid empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_39623 (h0 : topological_space (has_nndist (comm_group Type))) : totally_disconnected_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_39624 (h1 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h1) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_39625 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39626 (h0 : topological_space (has_zero (boolean_algebra Type))) : preirreducible_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_39627 (h0 : ring (add_group linarith.comp)) : strong_rank_condition (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_39628 (h0 : set (set (mul_one_class ereal))) (h1 : set (mul_one_class ereal)) : topological_space.generate_open h0 h1 := sorry --non-trivial
lemma new_lemma_39629 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_39630 (h0 : functor.add_const (function.extfun nat fin) name) : @separated_space.{0} (add_comm_monoid.{0} (has_neg.{0} pos)) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} (has_neg.{0} pos))) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) name h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39631 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) Type) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39632 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @totally_separated_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_39633 (h1 : group (has_append (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_39634 (h0 : add_group (comm_semigroup Type)) : is_add_cyclic (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_39635 (h0 : functor.comp topological_space add_comm_monoid name) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_39636 (h0 : topological_space (mul_zero_class Type)) : irreducible_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_39637 (h0 : group (random_gen (has_inv linarith.ineq))) : normalizer_condition (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39638 (h0 : function.extfun Type group) : @normalizer_condition.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_39639 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) (has_to_string Type)) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39640 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : path_connected_space (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39641 (h0 : set (has_ssubset (mul_one_class linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_39642 (h0 : ring (boolean_algebra (has_add pos))) : strong_rank_condition (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_39643 (h0 : filter (ring num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39644 (h0 h1 : list (add_cancel_monoid empty)) : list.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_39645 (h0 : topological_space (simple_graph (has_add (ring linarith.comp)))) : locally_compact_space (simple_graph (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_39646 (h0 : not (group (linear_ordered_comm_ring num) -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_39647 (h0 : topological_space (option (semiring (semiring (semiring num))))) : totally_disconnected_space (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_39648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_39649 (h0 : ring (semigroup (has_add (normed_comm_ring environment.implicit_infer_kind)))) : is_principal_ideal_ring (semigroup (has_add (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_39650 (h0 : group (measurable_space (has_norm (has_norm empty)))) : normalizer_condition (measurable_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_39651 (h0 : ring (normed_group (random_gen (random_gen linarith.ineq)))) : is_domain (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_39652 (h0 : functor.add_const (ring (comm_group unsigned)) Type) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_39653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_39654 (h0 : topological_space (semigroup (has_add (cancel_monoid name)))) : sequential_space (semigroup (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_39655 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_39656 (h0 : add_group (has_neg (has_add (has_add (has_add (has_add unsigned)))))) : is_add_cyclic (has_neg (has_add (has_add (has_add (has_add unsigned))))) := sorry --non-trivial
lemma new_lemma_39657 (h0 : add_group (has_to_string (has_Inf pos))) : is_add_cyclic (has_to_string (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_39658 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : t0_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_39659 (h0 : ring (has_compl (random_gen (random_gen string_imp)))) : strong_rank_condition (has_compl (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_39660 (h0 : ring (semigroup (finset Type))) : rank_condition (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_39661 (h0 : topological_space (has_to_string (finset (finset (has_add Type))))) : locally_compact_space (has_to_string (finset (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_39662 (h0 : functor.add_const (finset (has_bot empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39664 (h1 : uniform_space (normed_field enat)) : complete_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_39665 (h0 : ring (has_one (has_norm (semiring (has_norm (semiring (semiring linarith.comp))))))) : rank_condition (has_one (has_norm (semiring (has_norm (semiring (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_39666 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_39667 (h0 : add_group (topological_space (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_39668 (h1 : complete_lattice (normed_field linarith.comp_source)) : is_compactly_generated (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39669 (h0 : has_neg (nondiscrete_normed_field (add_comm_semigroup fun_info))) (h1 : measurable_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_39670 (h0 : group (complete_distrib_lattice linarith.comp_source)) : normalizer_condition (complete_distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39671 (h1 : function.extfun (finset Type) (has_mem.mem empty)) : @monoid.fg.{0} empty (@finset.pi.empty.{1 0} Type monoid.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_39672 (h0 : ring (has_norm (random_gen (random_gen (random_gen fun_info))))) : rank_condition (has_norm (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_39673 (h0 : not (monoid (has_emptyc to_additive.value_type) -> false)) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_39674 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (free_add_monoid.{0} (option.{0} (semigroup.{0} empty))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (free_add_monoid.{0} (option.{0} (semigroup.{0} empty))))  := sorry --non-trivial
lemma new_lemma_39675 (h0 : complete_lattice (normed_comm_ring (has_to_string pos))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_39676 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_add name)) : @sequential_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_39677 (h2 : complete_lattice ereal) : complete_lattice.is_Sup_finite_compact ereal := sorry --non-trivial
lemma new_lemma_39678 (h0 : topological_space (dlist linarith.comp_source)) : t0_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39679 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_39680 (h0 : topological_space (simple_graph (has_pos_part (has_add (ring linarith.comp))))) : normal_space (simple_graph (has_pos_part (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_39681 (h0 : functor.add_const (topological_space (has_star unsigned)) congr_arg_kind) : @totally_separated_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_39682 (h0 : topological_space (has_nndist (has_neg name))) : regular_space (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_39683 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) linarith.comp) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39684 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) congr_arg_kind) : @irreducible_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_39685 (h0 : functor.add_const (topological_space (linear_ordered_field num)) num) : @loc_path_connected_space.{0} (linear_ordered_field.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_39686 (h0 : complete_lattice (has_zero (finset (has_zero (finset (finset Type)))))) : complete_lattice.is_Sup_finite_compact (has_zero (finset (has_zero (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_39687 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) (finset (finset (ring (finset (has_pos_part Type)))))) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) (finset.{1} (finset.{1} (ring.{1} (finset.{1} (has_pos_part.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_39688 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39689 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @loc_path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39690 (h0 : functor.add_const (ordered_comm_monoid (has_neg Type)) (has_neg_part Type)) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_neg.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39691 (h0 : complete_lattice (has_compl string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_39692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_39693 (h0 : functor.add_const (ring pos) Type) : @rank_condition.{0} pos (@functor.add_const.run.{0 1} (ring.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_39694 (h0 : topological_space (has_nndist (canonically_ordered_comm_semiring (has_neg ennreal)))) : preconnected_space (has_nndist (canonically_ordered_comm_semiring (has_neg ennreal))) := sorry --non-trivial
lemma new_lemma_39695 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg (has_neg Type))) : @t0_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_39696 (h0 : ring (has_one (has_norm unsigned))) : is_domain (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_39697 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (comm_group Type)) : @t1_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_39698 (h0 : topological_space (option (has_to_string pos))) : regular_space (option (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_39699 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39700 (h1 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_39701 (h0 : complete_lattice (pseudo_metric_space (has_nndist (has_nndist name)))) : is_compactly_generated (pseudo_metric_space (has_nndist (has_nndist name))) := sorry --non-trivial
lemma new_lemma_39702 (h0 : with_bot (filter Prop)) (h1 : ne h0 has_bot.bot) (h2 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.ilast'.{0} (filter.{0} Prop) (@with_bot.unbot.{0} (filter.{0} Prop) h0 h1) h2)  := sorry --non-trivial
lemma new_lemma_39703 (h0 : functor.add_const (group (free_add_monoid empty)) empty) : @group.fg.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_39704 (h0 : ring (complete_distrib_lattice (has_add linarith.comp))) : is_domain (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_39705 (h0 : ring (has_append (metric_space char))) : rank_condition (has_append (metric_space char)) := sorry --non-trivial
lemma new_lemma_39706 (h0 : not (ring (linear_ordered_semiring linarith.comp) -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_39707 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39708 (h0 : uniform_space (normed_linear_ordered_group congr_arg_kind)) : separated_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39709 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : normal_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_39710 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_39711 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) Type) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39712 (h3 : ring (normed_field linarith.ineq)) : is_domain (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_39713 (h0 : not (topological_space (has_norm num) -> false)) : @t0_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_39714 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @preconnected_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39715 (h0 : topological_space (cancel_monoid (has_nndist (finset pos)))) : sequential_space (cancel_monoid (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_39716 (h0 : topological_space (add_comm_monoid (has_nndist name))) : irreducible_space (add_comm_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_39717 (h0 : filter (has_to_string (has_to_string (has_to_string pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_39718 (h0 : topological_space (has_lt (mul_one_class char))) (h1 : preorder (has_lt (mul_one_class char))) : order_topology (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_39719 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) (has_add pos)) : @is_atomistic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39720 (h0 : ring (option (with_bot num))) : is_principal_ideal_ring (option (with_bot num)) := sorry --non-trivial
lemma new_lemma_39721 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : path_connected_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_39722 (h0 : functor.add_const (complete_lattice (has_Inf pos)) (has_Inf linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_39723 (h0 : not (topological_space (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) -> false)) : @path_connected_space.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_39724 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39725 (h0 : ordered_comm_monoid (normed_comm_ring Type)) : has_exists_mul_of_le (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_39726 (h0 : monoid (canonically_ordered_comm_semiring linarith.comp)) : monoid.fg (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_39727 (h0 : ring (comm_ring (has_nnnorm char))) : strong_rank_condition (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_39728 (h0 : not (group (metric_space congr_arg_kind) -> false)) : @normalizer_condition.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39729 (h0 : ring (has_norm linarith.ineq)) : rank_condition (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_39730 (h0 : topological_space (div_inv_monoid fun_info)) : path_connected_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_39731 (h0 : monoid (has_norm (has_top (has_top fun_info)))) : monoid.fg (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_39732 (h0 : topological_space (semigroup (boolean_algebra (has_neg name)))) : topological_space.separable_space (semigroup (boolean_algebra (has_neg name))) := sorry --non-trivial
lemma new_lemma_39733 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option empty))) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_39734 (h0 : ring (cancel_monoid (option (option (option empty))))) : rank_condition (cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_39735 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_39736 (h0 : ring (has_inv (has_nnnorm linarith.ineq))) : is_domain (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39737 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39738 (h0 : uniform_space (has_zero (option name))) : complete_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_39739 (h0 : group (non_assoc_semiring unsigned)) : normalizer_condition (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_39740 (h0 : ring (ring (ring pos))) : rank_condition (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_39741 (h0 : uniform_space (boolean_algebra.core ennreal)) : complete_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_39742 (h0 : topological_space (ring environment.implicit_infer_kind)) : totally_disconnected_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_39743 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39744 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_39745 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39746 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : preirreducible_space (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_39747 (h0 : topological_space (add_cancel_monoid (has_add pos))) : normal_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_39748 (h0 : ring (normed_group (semiring unsigned))) : is_principal_ideal_ring (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_39749 (h0 : topological_space (has_zero (comm_group Type))) : totally_separated_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_39750 (h1 : complete_lattice (add_cancel_comm_monoid char)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_39751 (h0 : topological_space (has_top (has_union (semiring linarith.comp)))) : preirreducible_space (has_top (has_union (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_39752 (h0 : ring (has_sub (semiring empty))) : strong_rank_condition (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_39753 (h1 : topological_space (uniform_space string_imp)) : totally_disconnected_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_39754 (h0 : has_inner empty unsigned -> congr_arg_kind -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_39755 (h0 : ordered_comm_monoid (has_sdiff ennreal)) : has_exists_mul_of_le (has_sdiff ennreal) := sorry --non-trivial
lemma new_lemma_39756 (h0 : group (distrib_lattice (random_gen (has_nnnorm fun_info)))) : group.fg (distrib_lattice (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_39757 (h0 : complete_lattice (measurable_space.dynkin_system unsigned)) : is_compactly_generated (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_39758 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) Type) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39759 (h4 : ring (semi_normed_ring linarith.comp_source)) : is_domain (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39760 (h0 : add_group (has_ssubset ereal)) : is_add_cyclic (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_39761 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_39762 (h0 : topological_space (metric_space (has_top (semiring congr_arg_kind)))) : preirreducible_space (metric_space (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_39763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39764 (h0 : functor.add_const (ring (normed_comm_ring name)) Type) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_39765 (h1 : ring (has_top (random_gen char))) : is_domain (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_39766 (h1 : ring enat) : rank_condition enat := sorry --non-trivial
lemma new_lemma_39767 (h0 : group (measure_theory.measure_space (complete_linear_order congr_arg_kind))) : group.fg (measure_theory.measure_space (complete_linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_39768 (h0 : group (random_gen (has_top linarith.ineq))) : group.fg (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39769 (h0 : group (metric_space (linear_ordered_semiring unsigned))) : normalizer_condition (metric_space (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_39770 (h0 : complete_lattice (ring (has_pos_part pos))) : complete_lattice.is_Sup_finite_compact (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_39771 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg (has_neg name)))) : regular_space (canonically_ordered_comm_semiring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_39772 (h0 : group (has_to_string (option (option (option (option unsigned)))))) : is_cyclic (has_to_string (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_39773 (h1 : monoid (linear_ordered_semiring num)) : monoid.fg (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_39774 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring num))) : unique_factorization_monoid (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_39775 (h0 : ring (has_nndist (has_neg environment.implicit_infer_kind))) : is_principal_ideal_ring (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39776 (h0 : functor.add_const (group (has_pos_part pos)) pos) : @is_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_39777 (h0 : topological_space (has_bot (sub_neg_monoid real))) : discrete_topology (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_39778 (h0 : add_group (has_to_string linarith.comp)) : is_add_cyclic (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_39779 (h0 : complete_lattice (random_gen (has_norm empty))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_39780 (h0 : topological_space (has_neg (has_add name))) : discrete_topology (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_39781 (h0 : has_mem.mem Type has_emptyc.emptyc) : @is_compactly_generated.{1} Type (@finset.pi.empty.{2 1} (Type 1) complete_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_39782 (h0 : not (uniform_space (random_gen linarith.comp_source) -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_39783 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_39784 (h0 : ring (simple_graph (has_Inf (has_Inf (has_add linarith.comp))))) : strong_rank_condition (simple_graph (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_39785 (h0 : ring (canonically_ordered_monoid (has_Inf real))) : is_principal_ideal_ring (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_39786 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) Type) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39787 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_39788 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) Type) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_39789 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class fun_info))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_39790 (h0 : finset (option pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39792 (h0 : group (add_comm_monoid (comm_group (comm_group (has_to_string (comm_group Type)))))) : is_simple_group (add_comm_monoid (comm_group (comm_group (has_to_string (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_39793 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_ssubset linarith.ineq))) : is_compactly_generated (non_unital_non_assoc_semiring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39794 (h0 : functor.add_const (add_group (has_star empty)) congr_arg_kind) : @is_add_cyclic.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_39795 (h0 : ring (linear_ordered_add_comm_group (has_norm linarith.comp_source))) : is_domain (linear_ordered_add_comm_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_39796 (h0 : functor.add_const (add_group (has_zero pos)) Type) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_39797 (h2 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_39798 (h3 : ring (has_lt string_imp)) : is_domain (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_39799 (h0 : ring (has_neg_part (has_add Type))) : is_domain (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_39800 (h0 : ring (has_bot (option (option (option empty))))) : strong_rank_condition (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_39801 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_39802 (h0 : filter (has_nndist pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39803 (h0 : not (cancel_comm_monoid_with_zero (has_top unsigned) -> false)) : @unique_factorization_monoid.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39804 (h0 : not (topological_space (semi_normed_comm_ring reducibility_hints) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_39805 (h0 : not (topological_space unsigned -> false)) : @normal_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_39806 (h0 : topological_space (left_cancel_monoid (semiring (semiring empty)))) : path_connected_space (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_39807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39808 (h0 : not (complete_lattice (uniform_space string.iterator_imp) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_39809 (h0 : group (canonically_ordered_monoid (has_bot (has_bot pos)))) : is_cyclic (canonically_ordered_monoid (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_39810 (h2 : topological_space (with_one congr_arg_kind)) : path_connected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39811 (h0 : ring (has_union (has_norm unsigned))) : is_domain (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_39812 (h0 : complete_distrib_lattice (has_neg linarith.comp) -> complete_distrib_lattice (has_neg linarith.comp) -> Prop) : is_antisymm (complete_distrib_lattice (has_neg linarith.comp)) h0 := sorry --non-trivial
lemma new_lemma_39813 (h0 : functor.add_const (add_group (has_nndist environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_39814 (h0 : fin has_zero.zero) : @normal_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (@has_zero.zero.{0} nat nat.has_zero))))))) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_39815 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_Inf pos)) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_39816 (h0 : list (has_inv linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39817 (h0 : ring (simple_graph (has_ssubset (add_right_cancel_monoid fun_info)))) : is_domain (simple_graph (has_ssubset (add_right_cancel_monoid fun_info))) := sorry --non-trivial
lemma new_lemma_39818 (h0 : group (bin_tree unsigned)) : is_simple_group (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_39819 (h0 : function.extfun Type (functor.comp topological_space canonically_linear_ordered_monoid)) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_39820 (h0 : fin has_zero.zero) : matrix.vec_empty (id h0) := sorry --non-trivial
lemma new_lemma_39821 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39822 (h0 : filter (has_inv linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39823 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_39824 (h0 : ring (ordered_comm_monoid linarith.comp)) : strong_rank_condition (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_39825 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39826 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_39827 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) real) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_39828 (h0 : filter (boolean_algebra (comm_group (comm_group unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39829 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) (semiring num)) : @discrete_topology.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_39830 (h0 : group (has_Inf (has_nndist (ordered_ring (has_add Type))))) : group.fg (has_Inf (has_nndist (ordered_ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_39831 (h0 : topological_space (filter (option empty))) : t0_space (filter (option empty)) := sorry --non-trivial
lemma new_lemma_39832 (h0 : group (finset (has_neg (has_add Type)))) : group.fg (finset (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_39833 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) unsigned) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39834 (h1 : add_group (mul_one_class (add_comm_semigroup environment.projection_info))) : is_add_cyclic (mul_one_class (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_39835 (h0 : not (cancel_comm_monoid_with_zero (has_sub congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39836 (h0 : not (topological_space (random_gen char) -> false)) (h1 : not (preorder (random_gen char) -> false)) : @order_topology.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h0) (@classical.by_contradiction'.{1} (preorder.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_39837 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_39838 (h0 : complete_lattice (has_one (semiring (random_gen linarith.comp)))) : is_compactly_generated (has_one (semiring (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_39839 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39840 (h0 : topological_space (comm_group linarith.comp)) : topological_space.separable_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_39841 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39842 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : t0_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_39843 (h0 : topological_space (has_Inf (has_add Type))) : regular_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_39844 (h0 : functor.add_const (monoid (ring name)) name) : @monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_39845 (h0 : group (has_one num)) : is_cyclic (has_one num) := sorry --non-trivial
lemma new_lemma_39846 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_39847 (h0 : functor.add_const (filter (has_to_string environment.implicit_infer_kind)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39848 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_39849 (h0 : topological_space (monoid (option (option unsigned)))) : locally_compact_space (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_39850 (h0 : ring (semigroup ennreal)) : rank_condition (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_39851 (h0 : topological_space enat) : irreducible_space enat := sorry --non-trivial
lemma new_lemma_39852 (h0 : functor.add_const (list (ordered_comm_monoid pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39853 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_neg Type))) : unique_factorization_monoid (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_39854 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_39855 (h0 : complete_lattice (has_emptyc congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_39856 (h0 : group (linear_order unsigned)) : group.fg (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_39857 (h0 : not (ring (measurable_space (semiring (semiring (semiring (semiring (semiring empty)))))) -> false)) : @is_domain.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))) h0)  := sorry --non-trivial
lemma new_lemma_39858 (h0 : functor.add_const (function.extfun Type complete_lattice) (ring Type)) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (ring.{1} Type) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39859 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_39860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_39861 (h0 : functor.add_const (add_group (non_assoc_semiring unsigned)) empty) : @is_add_cyclic.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_39862 (h0 : list (has_add (normed_comm_ring environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_39863 (h0 : group (normed_group (with_bot to_additive.value_type))) : normalizer_condition (normed_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39864 (h0 : topological_space (has_add (has_to_string num))) : t0_space (has_add (has_to_string num)) := sorry --non-trivial
lemma new_lemma_39865 (h0 : not (topological_space (has_add char) -> false)) : @path_connected_space.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_39866 (h0 : canonically_ordered_comm_semiring (option empty) -> canonically_ordered_comm_semiring (option empty) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_39867 (h0 : not (semiring (non_assoc_semiring empty) -> false)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_39868 (h0 : functor.add_const (ring pos) unsigned) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_39869 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39870 (h0 : topological_space (has_zero (has_add name))) : totally_disconnected_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_39871 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39872 (h0 : group (normed_group (has_nnnorm (has_nnnorm (has_top fun_info))))) : group.fg (normed_group (has_nnnorm (has_nnnorm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_39873 (h0 : topological_space (has_nndist name)) : totally_separated_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_39874 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char)))) : t0_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_39875 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_39876 (h0 : complete_lattice (normed_field (has_nnnorm reducibility_hints))) : is_compactly_generated (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_39877 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 real) := sorry --non-trivial
lemma new_lemma_39878 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39879 (h0 : topological_space (has_neg (boolean_algebra.core pos))) : normal_space (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_39880 (h0 : finset (simple_graph (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39881 (h0 : topological_space (has_div string_imp)) : totally_disconnected_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_39882 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_39883 (h0 : topological_space (has_to_string (has_neg_part name))) : normal_space (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_39884 (h0 : topological_space (monoid_with_zero pos)) : path_connected_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_39885 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_39886 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : locally_compact_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_39887 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) ennreal) : @regular_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_39888 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @regular_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_39889 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : path_connected_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_39890 (h0 : list (has_emptyc (has_emptyc (has_emptyc fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39891 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @t1_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_39892 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_39893 (h0 : topological_space (boolean_algebra (has_add (has_neg_part Type)))) : totally_separated_space (boolean_algebra (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_39894 (h0 : filter (comm_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39895 (h0 : functor.comp topological_space has_zero unsigned) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_39896 (h0 : ordered_add_comm_monoid (linear_ordered_field empty)) : archimedean (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_39897 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (has_to_string (has_to_string congr_arg_kind)))) : archimedean (ordered_cancel_add_comm_monoid (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_39898 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39899 (h0 : not (cancel_comm_monoid_with_zero (normed_group unsigned) -> false)) : @unique_factorization_monoid.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_39900 (h0 : complete_lattice (has_zero (has_add (finset (has_pos_part linarith.comp))))) : complete_lattice.is_Sup_finite_compact (has_zero (has_add (finset (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_39901 (h0 : finset (normed_lattice_add_comm_group (has_add (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_39903 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) name) : @locally_compact_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_39904 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @totally_disconnected_space.{0} unsigned (@finset.pi.empty.{1 0} Type topological_space.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_39905 (h0 : uniform_space (has_nnnorm ereal)) : complete_space (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_39906 (h0 : multiset (simple_graph string_imp)) (h1 : not (multiset (simple_graph string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_39907 (h0 : ring (fintype (linear_ordered_semiring string_imp))) : strong_rank_condition (fintype (linear_ordered_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_39908 (h0 : ring (has_bot (option (option empty)))) : is_domain (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_39909 (h0 : functor.add_const (topological_space (as_linear_order empty)) num) : @preirreducible_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_39910 (h1 : ring (mul_one_class reducibility_hints)) : is_domain (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_39911 (h0 : complete_lattice (sub_neg_monoid (has_add Type))) : is_compactly_generated (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_39912 (h0 : char -> char -> char) (h1 : char) : left_identity h0 h1 := sorry --non-trivial
lemma new_lemma_39913 (h0 : topological_space (with_bot (semiring linarith.comp))) : normal_space (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_39914 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39916 (h0 : not (group (complete_linear_order empty) -> false)) : @normalizer_condition.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_39917 (h0 : not (complete_lattice (semiring congr_arg_kind) -> false)) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_39918 (h0 : list (ordered_cancel_add_comm_monoid (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39919 (h1 : measurable_space (mul_one_class to_additive.value_type)) (h2 : filter (mul_one_class to_additive.value_type)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_39920 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_39921 (h0 : functor.add_const (functor.add_const (group Type) pos) name) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) pos) name h0))  := sorry --non-trivial
lemma new_lemma_39922 (h0 : filter (boolean_algebra (comm_group (has_neg_part name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39923 (h0 : topological_space (comm_group (normed_comm_ring environment.implicit_infer_kind))) : locally_compact_space (comm_group (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_39924 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_39925 (h0 : topological_space std_gen) (h1 : topological_space (measure_theory.content std_gen)) (h2 : set (measure_theory.content std_gen)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_39926 (h0 : set (non_unital_non_assoc_semiring (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_39927 (h0 : complete_lattice (canonically_ordered_monoid (comm_semigroup real))) : is_compactly_generated (canonically_ordered_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_39928 (h0 : group (generalized_boolean_algebra (finset (has_neg pos)))) : is_simple_group (generalized_boolean_algebra (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_39929 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_39930 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class string.iterator_imp)))) (h1 : preorder (has_ssubset (mul_one_class (mul_one_class string.iterator_imp)))) : order_closed_topology (has_ssubset (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_39931 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @regular_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_39932 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39933 (h0 : topological_space (has_to_string (finset name))) : totally_disconnected_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_39934 (h0 : ring (normed_field (mul_one_class enat))) : rank_condition (normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_39935 (h0 : topological_space (boolean_algebra unsigned)) : loc_path_connected_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_39936 (h0 : monoid (with_one (comm_ring to_additive.value_type))) : monoid.fg (with_one (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39937 (h0 : fin has_zero.zero) : @group.fg.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_39938 (h0 : group (has_append (metric_space to_additive.value_type))) : is_cyclic (has_append (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_39939 (h0 : complete_lattice (has_union char)) : complete_lattice.is_Sup_finite_compact (has_union char) := sorry --non-trivial
lemma new_lemma_39940 (h0 : functor.add_const (ring (mul_zero_class num)) empty) : @rank_condition.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_39941 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_39942 (h0 : finset (linear_order (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_39943 (h0 : cancel_comm_monoid_with_zero (filter num)) : unique_factorization_monoid (filter num) := sorry --non-trivial
lemma new_lemma_39944 (h0 : ring (canonically_ordered_monoid linarith.comp)) : is_domain (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_39945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_39946 (h0 : complete_lattice (measurable_space (random_gen string_imp))) : is_compactly_generated (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_39947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39948 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39949 (h1 : add_group (nondiscrete_normed_field char)) : is_add_cyclic (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_39950 (h0 : topological_space (ring (has_to_string (finset linarith.comp)))) : discrete_topology (ring (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_39951 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_39952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39953 (h0 : topological_space (cancel_monoid (comm_group (comm_group (comm_group name))))) : discrete_topology (cancel_monoid (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_39954 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_39955 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_39956 (h0 : topological_space (denumerable (has_nnnorm fun_info))) (h1 : set (denumerable (has_nnnorm fun_info))) : is_open h1 := sorry --non-trivial
lemma new_lemma_39957 (h0 : list (linear_ordered_add_comm_group string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39958 (h0 : ring (plift (semiring num))) : rank_condition (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_39959 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_39960 (h0 : topological_space (comm_monoid (option empty))) : path_connected_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_39961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_39962 (h0 : topological_space (has_to_string (finset (finset pos)))) : loc_path_connected_space (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_39963 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39964 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_39965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_39966 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_39967 (h0 : add_monoid (has_to_string (has_nndist (has_nndist pos)))) : add_monoid.fg (has_to_string (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_39968 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_39969 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39970 (h0 : topological_space (comm_group name)) : topological_space.separable_space (comm_group name) := sorry --non-trivial
lemma new_lemma_39971 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39972 (h0 : uniform_space (measurable_space linarith.comp_source)) : separated_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_39973 (h0 : filter (with_zero (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39974 (h0 : function.extfun Type topological_space) : @t0_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_39975 (h0 : group (fintype (random_gen linarith.ineq))) : is_cyclic (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_39976 (h0 : topological_space (has_inv string_imp)) (h1 : function.extfun (has_inv string_imp) (fun (x : has_inv string_imp), Prop)) : is_preirreducible (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_39977 (h0 : list (plift (partial_order num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39978 (h0 : filter (encodable (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_39979 (h0 : semiring std_gen) (h1 : ideal std_gen) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_39980 (h0 : topological_space (cancel_monoid pos)) : t0_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_39981 (h0 : group (ordered_comm_ring (has_add name))) : is_cyclic (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_39982 (h0 : add_group (with_zero (has_nnnorm fun_info))) : is_add_cyclic (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_39983 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @preirreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_39984 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_39985 (h0 : list (has_inv linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39986 (h0 : list (comm_group (comm_group Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_39987 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_39988 (h0 : add_group (has_nndist (has_add Type))) : is_add_cyclic (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_39989 (h0 : functor.add_const (filter (semigroup Type)) (boolean_algebra Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39990 (h0 : ring (normed_group (has_norm fun_info))) : is_domain (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_39991 (h0 : measurable_space (has_append reducibility_hints)) (h1 : filter (has_append reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_39992 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_39993 (h0 : functor.add_const (group (semigroup name)) name) : @is_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_39994 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) pos) : @complete_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_39995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_39996 (h0 : functor.add_const (list (canonically_ordered_comm_semiring environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_39997 (h0 : uniform_space (semigroup (has_nndist (finset environment.implicit_infer_kind)))) : complete_space (semigroup (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_39998 (h0 : function.extfun Type group) : @group.fg.{0} (cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_39999 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
