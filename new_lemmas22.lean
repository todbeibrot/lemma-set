import imports
lemma new_lemma_176000 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) (comm_group name)) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_176001 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176002 (h0 : not (function.extfun Type topological_space -> false)) : @loc_path_connected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176003 (h0 : not (ring (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_176004 (h0 : topological_space (semigroup (has_neg (has_neg name)))) : regular_space (semigroup (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_176005 (h0 : function.extfun Type ring) : @is_domain.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_176006 (h0 : list (has_emptyc to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176007 (h0 : functor.add_const (list (complete_distrib_lattice name)) (finset Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_176009 (h0 : function.extfun Type monoid) : @monoid.fg.{0} empty (@function.extfun_app.{2 1} Type monoid.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_176010 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_176011 (h0 : filter (id (normed_group (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176012 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176013 (h0 : ring (normed_comm_ring (finset pos))) : is_domain (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_176014 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : totally_disconnected_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_176015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176016 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176017 (h0 : list (partial_order (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176019 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_176020 (h0 : functor.comp group complete_distrib_lattice name) : @is_simple_group.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_176021 (h0 : functor.comp topological_space boolean_algebra.core name) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_176022 (h0 : function.extfun (semiring num) (fun (x : semiring num), Prop)) : exists_unique (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_176023 (h0 : semiring (add_comm_monoid (has_pos_part pos))) : is_noetherian_ring (add_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_176024 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist num)) := sorry --non-trivial
lemma new_lemma_176025 (h0 : group (dlist (has_top fun_info))) : group.fg (dlist (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_176026 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176027 (h0 : group (has_to_string Type)) : is_cyclic (has_to_string Type) := sorry --non-trivial
lemma new_lemma_176028 (h0 : ring (has_inter (option num))) : rank_condition (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_176029 (h0 : functor.add_const (semiring (normed_comm_ring name)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_176031 (h0 : functor.add_const (topological_space (has_Sup empty)) num) : @preirreducible_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_176032 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176033 (h0 : functor.add_const (topological_space nnreal) (semiring (semiring num))) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_176034 (h0 : topological_space (linear_ordered_semiring num)) : totally_separated_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_176035 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc empty))) : @group.fg.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_176036 (h0 : group (canonically_ordered_comm_semiring (finset (mul_zero_class name)))) : group.fg (canonically_ordered_comm_semiring (finset (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_176037 (h0 : group (denumerable (random_gen char))) : is_cyclic (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_176038 (h0 : group (has_zero (has_add pos))) : is_simple_group (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_176039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_176040 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_176041 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) (has_add pos)) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176042 (h0 : topological_space (add_comm_monoid pos)) : loc_path_connected_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_176043 (h1 : add_group (with_one linarith.comp_source)) : is_add_cyclic (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_176044 (h0 : functor.add_const (add_monoid (ordered_comm_ring real)) (has_Inf name)) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} real)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_176045 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @locally_compact_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_176046 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_176047 (h0 h1 : multiset (semiring (random_gen num))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_176048 (h0 : uniform_space (with_one (has_nnnorm fun_info))) : complete_space (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_176049 (h0 : filter (has_sub num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176050 (h0 : complete_lattice (has_pos_part (has_neg name))) : is_compactly_generated (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_176051 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_176052 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : is_antisymm (generalized_boolean_algebra real) h0 := sorry --non-trivial
lemma new_lemma_176053 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : loc_path_connected_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_176054 (h0 : topological_space (with_one (semiring fun_info))) : totally_separated_space (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_176055 (h1 : group (with_bot congr_arg_kind)) : normalizer_condition (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176056 (h0 : topological_space (generalized_boolean_algebra real)) : totally_disconnected_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_176057 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string (has_to_string name))))) : preconnected_space (normed_comm_ring (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_176058 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_176059 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_176060 (h0 : ring (with_bot (random_gen (has_norm linarith.ineq)))) : rank_condition (with_bot (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_176061 (h0 : topological_space (has_add (finset (has_neg linarith.comp)))) : totally_separated_space (has_add (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_176062 (h0 : topological_space (boolean_algebra (has_add (has_add (comm_group unsigned))))) : discrete_topology (boolean_algebra (has_add (has_add (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_176063 (h0 : complete_lattice (partial_order num)) : is_compactly_generated (partial_order num) := sorry --non-trivial
lemma new_lemma_176064 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (ring (ring Type))) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176065 (h0 : functor.comp topological_space normed_comm_ring linarith.comp) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176066 (h0 : semiring (add_cancel_monoid (finset (finset (finset linarith.comp))))) : is_noetherian_ring (add_cancel_monoid (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_176067 (h0 : semiring (normed_comm_ring name)) : is_noetherian_ring (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_176068 (h0 : functor.add_const (monoid (add_comm_monoid pos)) (finset linarith.comp)) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176069 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_176070 (h1 : topological_space (topological_space (random_gen string_imp))) : path_connected_space (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_176071 (h0 : complete_lattice (has_norm (has_nnnorm to_additive.value_type))) : is_compactly_generated (has_norm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_176072 (h0 : not (function.extfun Type topological_space -> false)) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_176073 (h0 : complete_lattice (has_inv linarith.comp_source)) : is_compactly_generated (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_176074 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_176075 (h0 : topological_space congr_arg_kind) : discrete_topology congr_arg_kind := sorry --non-trivial
lemma new_lemma_176076 (h0 : cancel_comm_monoid_with_zero (has_nndist name)) : unique_factorization_monoid (has_nndist name) := sorry --non-trivial
lemma new_lemma_176077 (h0 : monoid (normed_group (random_gen num))) : monoid.fg (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_176078 (h0 : not (ring (denumerable fun_info) -> false)) : @rank_condition.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_176079 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_neg (has_add linarith.comp)))))) : locally_compact_space (normed_comm_ring (has_add (has_add (has_neg (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_176080 (h0 : not (topological_space (distrib reducibility_hints) -> false)) : @path_connected_space.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_176081 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176082 (h0 : complete_lattice (fintype fun_info)) : complete_lattice.is_Sup_finite_compact (fintype fun_info) := sorry --non-trivial
lemma new_lemma_176083 (h0 : functor.add_const (group (ring Type)) pos) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_176084 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.ineq)))) : t0_space (has_emptyc (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_176085 (h0 : functor.add_const (filter (semigroup pos)) (has_nndist Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176086 (h0 : functor.add_const Prop (has_to_string (has_add (has_add name)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_176087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176088 (h0 : ring (with_one (random_gen string_imp))) : is_domain (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_176089 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176090 (h0 : topological_space (plift (complete_linear_order unsigned))) : discrete_topology (plift (complete_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_176091 (h0 : functor.add_const (ring (ring Type)) linarith.comp) : @strong_rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176092 (h0 : topological_space (has_to_string unsigned)) : locally_compact_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_176093 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_176094 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176095 (h0 : has_pos_part (has_add real) -> has_pos_part (has_add real) -> Prop) : is_antisymm (has_pos_part (has_add real)) h0 := sorry --non-trivial
lemma new_lemma_176096 (h0 : functor.add_const (filter (add_comm_monoid name)) (option (option (option name)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176097 (h0 : add_group (partial_order (option (option (option (option congr_arg_kind)))))) : is_add_cyclic (partial_order (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_176098 (h0 : functor.add_const (uniform_space (add_left_cancel_monoid empty)) empty) : @complete_space.{0} (add_left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_176099 (h0 : monoid (add_comm_monoid (finset (finset Type)))) : monoid.fg (add_comm_monoid (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_176100 (h0 : topological_space (has_to_string (add_cancel_monoid environment.implicit_infer_kind))) : loc_path_connected_space (has_to_string (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176101 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_176102 (h0 : uniform_space (has_div (mul_one_class (mul_one_class (mul_one_class enat))))) : complete_space (has_div (mul_one_class (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_176103 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) pos) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_176104 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (group_with_zero empty)) := sorry --non-trivial
lemma new_lemma_176105 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring num))))) : irreducible_space (complete_linear_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_176106 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (has_neg linarith.comp)) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176107 (h0 : semiring (comm_group (ring Type))) : is_noetherian_ring (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_176108 (h0 : not (filter (topological_space linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_176109 (h0 : complete_lattice (random_gen (has_top linarith.comp_source))) : is_compactly_generated (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176110 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_176111 (h0 : ordered_comm_monoid (has_pos_part (has_nndist pos))) : has_exists_mul_of_le (has_pos_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_176112 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_176113 (h0 : topological_space (has_Inf (has_Inf (has_add (has_Inf linarith.comp))))) : locally_compact_space (has_Inf (has_Inf (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_176114 (h0 : add_monoid (has_neg (option (option pos)))) : add_monoid.fg (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_176115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176116 (h0 : ring (uniform_space reducibility_hints)) : rank_condition (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_176117 (h0 : topological_space (boolean_algebra.core (finset (finset (finset (finset pos)))))) : locally_compact_space (boolean_algebra.core (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_176118 (h0 : topological_space (add_cancel_monoid (has_add (has_add environment.implicit_infer_kind)))) : normal_space (add_cancel_monoid (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_176119 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_176120 (h0 : complete_lattice (has_to_string (option ennreal))) : is_compactly_generated (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_176121 (h0 : ring (with_bot reducibility_hints)) : rank_condition (with_bot reducibility_hints) := sorry --non-trivial
lemma new_lemma_176122 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176123 (h0 : topological_space (comm_group name)) : regular_space (comm_group name) := sorry --non-trivial
lemma new_lemma_176124 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_Inf (boolean_algebra.core Type)))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_Inf (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_176125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (linear_ordered_field num)) := sorry --non-trivial
lemma new_lemma_176126 (h0 : filter (monoid_with_zero (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176127 (h0 : topological_space (has_compl (has_nnnorm linarith.ineq))) (h1 : preorder (has_compl (has_nnnorm linarith.ineq))) : order_topology (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176128 (h0 : not (topological_space (ordered_ring unsigned) -> false)) : @t0_space.{0} (ordered_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176129 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_176130 (h0 : add_group (cancel_monoid (option (option unsigned))) -> Prop) (h1 : Exists (fun (x : add_group (cancel_monoid (option (option unsigned)))), h0 x)) : @is_add_cyclic.{0} (cancel_monoid.{0} (option.{0} (option.{0} unsigned))) (@classical.some.{1} (add_group.{0} (cancel_monoid.{0} (option.{0} (option.{0} unsigned)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_176131 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_176132 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_176133 (h0 : uniform_space (measurable_space (semiring linarith.comp))) : complete_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_176134 (h2 : complete_lattice (has_ssubset to_additive.value_type)) : is_compactly_generated (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176135 (h0 : finset (pseudo_emetric_space empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176136 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : topological_space.separable_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_176137 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176138 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) name) : @rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_176139 (h0 : ring (has_to_string (add_comm_monoid name))) : is_principal_ideal_ring (has_to_string (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_176140 (h0 : topological_space (has_add linarith.ineq)) : path_connected_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_176141 (h0 : topological_space (boolean_algebra unsigned)) : irreducible_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_176142 (h0 : uniform_space (add_left_cancel_monoid fun_info)) : complete_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_176143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_176144 (h0 : group (with_bot (has_top fun_info))) : is_cyclic (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_176145 (h0 : complete_lattice (has_neg empty)) : complete_lattice.is_Sup_finite_compact (has_neg empty) := sorry --non-trivial
lemma new_lemma_176146 (h0 : topological_space (has_neg_part (boolean_algebra.core environment.implicit_infer_kind))) : preirreducible_space (has_neg_part (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176147 (h0 : list (add_cancel_monoid (has_to_string name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176148 (h0 : ring (uniform_space (mul_one_class char))) : is_domain (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_176149 (h0 : semiring (comm_group (has_nndist linarith.comp))) : is_noetherian_ring (comm_group (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_176150 (h0 : topological_space (pseudo_metric_space (option empty))) : t0_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_176151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_176152 (h0 : topological_space (normed_field (random_gen (random_gen to_additive.value_type)))) : path_connected_space (normed_field (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_176153 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176154 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_176155 (h0 : topological_space (linear_ordered_comm_group_with_zero (has_ssubset reducibility_hints))) : t0_space (linear_ordered_comm_group_with_zero (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176156 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176157 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176158 (h0 : group (has_top (has_nnnorm (random_gen char)))) : group.fg (has_top (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_176159 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_176160 (h5 : complete_lattice (denumerable char)) : complete_lattice.is_Sup_finite_compact (denumerable char) := sorry --non-trivial
lemma new_lemma_176161 (h0 : group (has_star (semiring unsigned))) : group.fg (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_176162 (h0 : ring (comm_group (cancel_monoid Type))) : rank_condition (comm_group (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_176163 (h0 : group (fintype (has_ssubset fun_info))) : is_cyclic (fintype (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_176164 (h2 : has_coe linarith.ineq Prop) (h3 : linarith.ineq) : @coe_b.{1 1} linarith.ineq Prop h2 h3  := sorry --non-trivial
lemma new_lemma_176165 (h0 : topological_space (has_to_string (option (canonically_linear_ordered_monoid name)))) : sequential_space (has_to_string (option (canonically_linear_ordered_monoid name))) := sorry --non-trivial
lemma new_lemma_176166 (h0 : uniform_space (has_lt string.iterator_imp)) : complete_space (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_176167 (h0 : monoid (group_with_zero ennreal)) : monoid.fg (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_176168 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring empty)))) : discrete_topology (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_176169 (h0 : uniform_space (has_pos_part (has_neg (has_neg pos)))) : separated_space (has_pos_part (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_176170 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_176171 (h0 : list (topological_space reducibility_hints)) (h1 : nat) : @totally_disconnected_space.{0} reducibility_hints (@list.inth.{0} (topological_space.{0} reducibility_hints) (@inhabited_topological_space.{0} reducibility_hints) h0 h1)  := sorry --non-trivial
lemma new_lemma_176172 (h0 : functor.add_const (function.extfun Type complete_lattice) (finset Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (finset.{1} Type) h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_176173 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h1 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_176174 (h0 : ring (semi_normed_comm_ring (comm_ring char))) : rank_condition (semi_normed_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_176175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176176 (h0 : add_group (canonically_linear_ordered_monoid (option (option (option (option ennreal)))))) : is_add_cyclic (canonically_linear_ordered_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_176177 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_176178 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (uniform_space.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (uniform_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176179 (h0 : monoid (ring (has_add linarith.comp))) : monoid.fg (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_176180 (h1 : complete_lattice (semi_normed_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176181 (h0 : add_group (topological_space (has_nnnorm (comm_ring char)))) : is_add_cyclic (topological_space (has_nnnorm (comm_ring char))) := sorry --non-trivial
lemma new_lemma_176182 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176183 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176184 (h0 : ring (has_inter num)) : is_principal_ideal_ring (has_inter num) := sorry --non-trivial
lemma new_lemma_176185 (h0 : functor.add_const (add_group (left_cancel_monoid unsigned)) (semiring (semiring (semiring num)))) : @is_add_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_176186 (h0 : complete_lattice (has_add (has_to_string name))) : is_compactly_generated (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_176187 (h2 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} fun_info) h2)  := sorry --non-trivial
lemma new_lemma_176188 (h0 : complete_lattice (comm_group (comm_group unsigned))) : complete_lattice.is_Sup_finite_compact (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_176189 (h0 : functor.add_const (group (has_neg Type)) (has_neg linarith.comp)) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176190 (h2 : topological_space (comm_ring char)) : t0_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_176191 (h0 : filter (linear_ordered_add_comm_group (has_top to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176192 (h0 : monoid (has_emptyc (random_gen (random_gen num)))) : monoid.fg (has_emptyc (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_176193 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_176195 (h0 : topological_space (has_neg (finset unsigned))) : topological_space.separable_space (has_neg (finset unsigned)) := sorry --non-trivial
lemma new_lemma_176196 (h0 : list (has_top (with_bot (with_bot (with_bot to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176197 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (has_add.{1} (boolean_algebra.core.{1} Type)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} (boolean_algebra.core.{1} Type)))  := sorry --non-trivial
lemma new_lemma_176198 (h1 : topological_space (add_comm_semigroup char)) (h2 : set (add_comm_semigroup char)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_176199 (h0 : ring (metric_space (has_norm congr_arg_kind))) : is_domain (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176200 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_176201 (h0 : functor.add_const (ring (add_cancel_comm_monoid empty)) empty) : @is_domain.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_176202 (h0 : semiring (normed_group (semiring congr_arg_kind))) : is_noetherian_ring (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176203 (h0 : ring (measurable_space.dynkin_system unsigned)) : is_domain (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_176204 (h1 : ring (uniform_space (has_lt linarith.comp_source))) : is_domain (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176205 (h2 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen)))) -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_176206 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_176207 (h0 : topological_space (id (semiring unsigned))) : totally_separated_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_176208 (h0 : complete_lattice (has_zero (has_zero name))) : is_compactly_generated (has_zero (has_zero name)) := sorry --non-trivial
lemma new_lemma_176209 (h0 : group (with_one (random_gen (random_gen fun_info)))) : is_cyclic (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_176210 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_176211 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176212 (h0 : group (has_one (has_norm empty))) : group.fg (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_176213 (h0 h1 : option (filter (has_neg (has_neg_part Type)))) (h2 : filter (has_neg (has_neg_part Type))) : filter.ne_bot (option.get_or_else h0 (option.get_or_else h1 h2)) := sorry --non-trivial
lemma new_lemma_176214 (h0 : topological_space (has_nndist (finset linarith.comp))) : topological_space.separable_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_176215 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176216 (h0 : topological_space (with_one (random_gen fun_info))) : totally_separated_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_176217 (h0 : ring (has_le (mul_one_class char))) : is_domain (has_le (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_176218 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176219 (h0 : group (id (linear_ordered_semiring empty))) : normalizer_condition (id (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_176220 (h0 h1 : multiset (distrib char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_176221 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176222 (h0 : topological_space (ring (has_add linarith.comp))) : t1_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_176223 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_176224 (h0 : functor.add_const (filter (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176225 (h0 : ring (finset unsigned)) : is_domain (finset unsigned) := sorry --non-trivial
lemma new_lemma_176226 (h0 : topological_space (has_to_string (has_nndist linarith.comp))) : t1_space (has_to_string (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_176227 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_176228 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176229 (h1 : ring ereal) : rank_condition ereal := sorry --non-trivial
lemma new_lemma_176230 (h1 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_176231 (h0 : ring (filter congr_arg_kind)) : rank_condition (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176232 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_176233 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_176234 (h0 : complete_lattice (denumerable (random_gen char))) : is_compactly_generated (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_176235 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_176236 (h0 : list (has_neg_part (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176237 (h0 : topological_space (has_Sup (ordered_ring unsigned))) : normal_space (has_Sup (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_176238 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_176239 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_176240 (h0 : uniform_space (has_nnnorm (semigroup environment.projection_info))) : complete_space (has_nnnorm (semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_176241 (h0 : add_monoid (comm_group (boolean_algebra.core name))) : add_monoid.fg (comm_group (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_176242 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_176243 (h0 : not (complete_lattice (ordered_ring num) -> false)) : @is_atomistic.{0} (ordered_ring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (ordered_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_176244 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_176245 (h0 : functor.add_const (topological_space (mul_zero_class Type)) name) : @normal_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_176246 (h0 : add_group (non_assoc_semiring num)) : is_add_cyclic (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_176247 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid unsigned)) pos) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_176248 (h0 : topological_space (has_ssubset char)) : path_connected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_176249 (h0 : add_group (add_cancel_monoid (option (option unsigned)))) : is_add_cyclic (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_176250 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_176251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_176252 (h0 : ring (normed_comm_ring (ring (ring (ring environment.implicit_infer_kind))))) : strong_rank_condition (normed_comm_ring (ring (ring (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_176253 (h0 : topological_space (canonically_linear_ordered_monoid (finset name))) : discrete_topology (canonically_linear_ordered_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_176254 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176255 (h0 : topological_space (has_Sup (option unsigned))) : totally_disconnected_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_176256 (h0 : topological_space (add_comm_monoid (has_nndist name))) : loc_path_connected_space (add_comm_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_176257 (h0 : uniform_space (has_div linarith.ineq)) : complete_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_176258 (h0 : ring (boolean_algebra.core environment.implicit_infer_kind)) : strong_rank_condition (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_176259 (h0 : filter (has_inv (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176260 (h0 : topological_space to_additive.value_type) : irreducible_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_176261 (h0 : group (has_append string_imp)) : is_cyclic (has_append string_imp) := sorry --non-trivial
lemma new_lemma_176262 (h0 : uniform_space (has_top linarith.comp)) : separated_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_176263 (h0 : topological_space (has_union num)) : path_connected_space (has_union num) := sorry --non-trivial
lemma new_lemma_176264 (h0 : ring (boolean_algebra.core to_additive.value_type)) : is_domain (boolean_algebra.core to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176265 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176266 (h0 : list (complete_distrib_lattice (has_norm (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176267 (h0 : uniform_space (normed_comm_ring (has_add (normed_comm_ring (has_add Type))))) : separated_space (normed_comm_ring (has_add (normed_comm_ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_176268 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176269 (h0 : functor.add_const (finset (has_nndist unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176270 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_176271 (h1 : ring (non_unital_non_assoc_semiring (has_lt linarith.comp_source))) : is_domain (non_unital_non_assoc_semiring (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176272 (h0 : functor.add_const (ring (has_nndist pos)) environment.implicit_infer_kind) : @is_domain.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176273 (h0 : topological_space (ordered_comm_ring (has_nndist Type))) : preirreducible_space (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_176274 (h0 : group (has_to_string pos)) : group.fg (has_to_string pos) := sorry --non-trivial
lemma new_lemma_176275 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176276 (h0 : semiring (has_nndist name)) : is_noetherian_ring (has_nndist name) := sorry --non-trivial
lemma new_lemma_176277 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) linarith.comp) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176278 (h0 : topological_space (has_zero unsigned)) : t0_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_176279 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) : normal_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176280 (h0 : topological_space (left_cancel_monoid unsigned)) : t1_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_176281 (h0 : functor.add_const (add_group (semigroup pos)) linarith.comp) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176282 (h0 : functor.add_const (semiring (finset Type)) (has_neg linarith.comp)) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (finset.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176283 (h0 : ring (has_neg (ring (has_neg pos)))) : is_principal_ideal_ring (has_neg (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_176284 (h0 : topological_space (has_emptyc (random_gen fun_info))) : path_connected_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_176285 (h0 : ring (boolean_algebra (finset (boolean_algebra (has_add (has_add linarith.comp)))))) : rank_condition (boolean_algebra (finset (boolean_algebra (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_176286 (h0 : functor.add_const (group (has_to_string pos)) linarith.comp) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176287 (h1 : set (char -> add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_176288 (h0 : monoid (complete_linear_order num)) : monoid.fg (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_176289 (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_176290 (h0 : ring (normed_comm_ring (has_to_string pos))) : strong_rank_condition (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_176291 (h0 : complete_lattice (has_nnnorm (has_nnnorm string_imp))) : is_compactly_generated (has_nnnorm (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_176292 (h0 : group (canonically_ordered_monoid (has_add (has_add (has_add pos))))) : is_cyclic (canonically_ordered_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_176293 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_176294 (h0 : group (boolean_algebra.core (has_to_string num))) : is_simple_group (boolean_algebra.core (has_to_string num)) := sorry --non-trivial
lemma new_lemma_176295 (h2 : topological_space fun_info) : path_connected_space fun_info := sorry --non-trivial
lemma new_lemma_176296 (h0 : add_group (generalized_boolean_algebra (ordered_comm_monoid (has_Inf Type)))) : is_add_cyclic (generalized_boolean_algebra (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_176297 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset linarith.comp)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176298 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) Type) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_176299 (h0 : topological_space (ordered_comm_ring (finset name))) : topological_space.separable_space (ordered_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_176300 (h0 : group (has_top (semiring empty))) : is_cyclic (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_176301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_176302 (h0 : ordered_comm_monoid (has_to_string (has_to_string pos))) : has_exists_mul_of_le (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_176303 (h0 : topological_space (simple_graph (option num))) : totally_separated_space (simple_graph (option num)) := sorry --non-trivial
lemma new_lemma_176304 (h0 : topological_space (has_neg (has_add (has_pos_part (has_add pos))))) : normal_space (has_neg (has_add (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_176305 (h0 : topological_space (has_top (metric_space (id linarith.comp)))) : path_connected_space (has_top (metric_space (id linarith.comp))) := sorry --non-trivial
lemma new_lemma_176306 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_176307 (h0 : function.extfun Type topological_space) (h1 : set (distrib_lattice string_imp)) : @is_totally_separated.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} string_imp)) h1  := sorry --non-trivial
lemma new_lemma_176308 (h0 : topological_space (uniform_space (mul_one_class reducibility_hints))) (h1 : preorder (uniform_space (mul_one_class reducibility_hints))) : order_topology (uniform_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176309 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_176310 (h0 : finset (distrib to_additive.value_type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176311 (h0 : ring (has_append (semi_normed_ring (distrib to_additive.value_type)))) : is_domain (has_append (semi_normed_ring (distrib to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_176312 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176313 (h0 : topological_space (left_cancel_semigroup (semiring num))) : topological_space.separable_space (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_176314 (h0 : functor.add_const (monoid (ordered_comm_group empty)) empty) : @monoid.fg.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_176315 (h0 : complete_lattice (complete_distrib_lattice Type)) : is_atomistic (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_176316 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_176317 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_176318 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add real)))) : topological_space.separable_space (normed_lattice_add_comm_group (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_176319 (h1 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_176320 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_176321 (h0 : ennreal -> ennreal -> Prop) (h1 : set ennreal) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_176322 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @normal_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_176323 (h0 : not (topological_space (with_one num) -> false)) : @normal_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_176324 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_176325 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen string_imp))))) : path_connected_space (has_emptyc (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_176326 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_176327 (h0 : functor.add_const (topological_space (bin_tree empty)) empty) : @locally_compact_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_176328 (h0 : finset (add_comm_monoid name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176329 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_176331 (h0 : topological_space (canonically_ordered_monoid name)) : irreducible_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_176332 (h0 : topological_space (monoid ennreal)) : loc_path_connected_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_176333 (h0 : ring (ordered_comm_monoid (has_add real))) : is_principal_ideal_ring (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_176334 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176335 (h0 : functor.add_const (topological_space (free_add_monoid num)) empty) : @discrete_topology.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_176336 (h0 : function.extfun Type ring) : @is_domain.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_176337 (h0 : topological_space (has_bot (has_neg name))) : normal_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_176338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_176339 (h0 : topological_space (ordered_comm_ring (finset (finset Type)))) : t0_space (ordered_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_176340 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_176341 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176342 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup environment.projection_info))) : complete_space (add_comm_semigroup (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_176343 (h0 : topological_space (simple_graph (has_pos_part linarith.comp))) : t1_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_176344 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_176345 (h0 : not (uniform_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_176346 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176347 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_176348 (h0 : functor.add_const (uniform_space (has_pos_part pos)) pos) : @separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_176349 (h0 : topological_space (has_star (semiring (semiring (semiring (semiring num)))))) : totally_separated_space (has_star (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_176350 (h0 : ordered_add_comm_monoid (ring (option pos))) : archimedean (ring (option pos)) := sorry --non-trivial
lemma new_lemma_176351 (h0 : not (add_group (non_assoc_semiring unsigned) -> false)) : @is_add_cyclic.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176352 (h0 : ring (with_bot (has_top num))) : is_domain (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_176353 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 znum) := sorry --non-trivial
lemma new_lemma_176354 (h0 : topological_space (normed_linear_ordered_group unsigned)) : t0_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_176355 (h0 : topological_space (normed_group (has_top (has_norm (has_top fun_info))))) : totally_separated_space (normed_group (has_top (has_norm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_176356 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176357 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176358 (h0 : topological_space (random_gen (comm_ring linarith.comp_source))) : t0_space (random_gen (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176360 (h0 : complete_lattice (linear_ordered_field (option ennreal))) : is_atomistic (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_176361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_176362 (h0 : topological_space (measurable_space (has_top congr_arg_kind))) : preirreducible_space (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176363 (h0 : group (ring (has_add pos))) : is_cyclic (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_176364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_176365 (h0 : ring (monoid_with_zero unsigned)) : is_domain (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_176366 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176367 (h0 : functor.add_const (uniform_space (has_nndist pos)) Type) : @complete_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_176368 (h0 : list (ordered_comm_monoid (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176369 (h0 : group (has_dist num)) : normalizer_condition (has_dist num) := sorry --non-trivial
lemma new_lemma_176370 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176371 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176372 (h0 : not (complete_lattice (normed_group fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_176373 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra Type)) pos) : @archimedean.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_176374 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (finset.{1} (semigroup.{1} (has_add.{1} (has_add.{1} (normed_comm_ring.{1} Type))))) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (finset.{1} (semigroup.{1} (has_add.{1} (has_add.{1} (normed_comm_ring.{1} Type))))))  := sorry --non-trivial
lemma new_lemma_176375 (h0 : topological_space (add_cancel_monoid (ring (finset (finset linarith.comp))))) : regular_space (add_cancel_monoid (ring (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_176376 (h0 : complete_lattice (linear_ordered_semiring (has_top linarith.ineq))) : is_atomistic (linear_ordered_semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176377 (h0 : topological_space (has_to_string linarith.comp)) : locally_compact_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_176378 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_176379 (h0 : functor.add_const (add_group (has_Inf Type)) Type) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_176380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_176381 (h0 : topological_space reducibility_hints) : totally_disconnected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_176382 (h0 : topological_space (boolean_algebra (ring (finset environment.implicit_infer_kind)))) : irreducible_space (boolean_algebra (ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_176383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_176384 (h0 : uniform_space (with_bot (semiring linarith.comp))) : separated_space (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_176385 (h0 : function.extfun Type (functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)))) : @irreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176386 (h0 : ring char) (h1 : uniform_space (topological_space (ring_topology char))) : complete_space (topological_space (ring_topology char)) := sorry --non-trivial
lemma new_lemma_176387 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_176388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_176389 (h0 : topological_space (has_nndist (has_to_string linarith.comp))) : t1_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_176390 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176391 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_Inf pos))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_176392 (h1 : function.extfun (nat -> Prop) subtype) : pnat.prime (function.extfun_app h1 (fun (n : nat), has_lt.lt has_zero.zero n)) := sorry --non-trivial
lemma new_lemma_176393 (h0 : complete_lattice (has_append reducibility_hints)) : is_compactly_generated (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_176394 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : set (has_ssubset string.iterator_imp)) : is_open h1 := sorry --non-trivial
lemma new_lemma_176395 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : irreducible_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176396 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176397 (h0 : not (complete_lattice (has_top congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_176398 (h0 : topological_space (has_inter empty)) : discrete_topology (has_inter empty) := sorry --non-trivial
lemma new_lemma_176399 (h0 : uniform_space (has_neg (option (option pos)))) : separated_space (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_176400 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_176401 (h0 : filter (linear_ordered_semiring to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176402 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra pos)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_176403 (h0 : topological_space (boolean_algebra.core (option ennreal))) : irreducible_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_176404 (h0 : add_group (canonically_ordered_comm_semiring (boolean_algebra.core pos))) : is_add_cyclic (canonically_ordered_comm_semiring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_176405 (h0 : filter (distrib_lattice (random_gen (random_gen (has_nnnorm (denumerable (has_nnnorm linarith.ineq))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176406 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_176407 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_176408 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_176409 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176410 (h0 : function.extfun (Type 1) (functor.comp topological_space add_cancel_monoid)) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} add_cancel_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_176411 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_176412 (h0 : topological_space (linear_ordered_comm_group (option empty))) : locally_compact_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_176413 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @preconnected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176414 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_176415 (h0 : topological_space (finset (has_to_string linarith.comp))) : preconnected_space (finset (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_176416 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add (has_add pos))))) : t0_space (generalized_boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_176417 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : regular_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_176418 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_176419 (h0 : functor.add_const (function.extfun Type uniform_space) (ring Type)) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (ring.{1} Type) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176420 (h0 : complete_lattice (random_gen linarith.comp)) : is_atomistic (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_176421 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_176422 (h0 : complete_lattice (canonically_ordered_monoid name)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_176423 (h0 : add_monoid (has_star empty)) : add_monoid.fg (has_star empty) := sorry --non-trivial
lemma new_lemma_176424 (h0 : topological_space (measurable_space (random_gen (random_gen linarith.ineq)))) : locally_compact_space (measurable_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_176425 (h0 : complete_lattice (semi_normed_ring string_imp)) : is_compactly_generated (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_176426 (h0 : list (normed_group (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176427 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_176428 (h0 : filter (dlist (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176429 (h1 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen))) -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_176430 (h0 : group (complete_distrib_lattice (semigroup pos))) : normalizer_condition (complete_distrib_lattice (semigroup pos)) := sorry --non-trivial
lemma new_lemma_176431 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : regular_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_176432 (h0 : topological_space (plift (omega_complete_partial_order unsigned))) : normal_space (plift (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_176433 (h0 : functor.add_const (ordered_add_comm_monoid (option ennreal)) unsigned) : @archimedean.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (option.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176434 (h0 : topological_space (monoid (option (option (option unsigned))))) : loc_path_connected_space (monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_176435 (h0 : not (ring (fintype to_additive.value_type) -> false)) : @rank_condition.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_176436 (h1 : ring (id to_additive.value_type)) : rank_condition (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176437 (h0 : group (has_union (has_one (semiring (random_gen empty))))) : normalizer_condition (has_union (has_one (semiring (random_gen empty)))) := sorry --non-trivial
lemma new_lemma_176438 (h0 : ordered_comm_monoid (complete_distrib_lattice Type)) : has_exists_mul_of_le (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_176439 (h0 : functor.add_const (add_monoid (cancel_monoid pos)) Type) : @add_monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_176440 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_176441 (h0 : list (has_edist (semiring (semiring (semiring unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176442 (h0 : topological_space (has_bot (sub_neg_monoid (boolean_algebra real)))) : sequential_space (has_bot (sub_neg_monoid (boolean_algebra real))) := sorry --non-trivial
lemma new_lemma_176443 (h0 : not (topological_space (fintype char) -> false)) : @totally_disconnected_space.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_176444 (h0 : uniform_space (sub_neg_monoid (has_add linarith.comp))) : separated_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_176445 (h0 : function.extfun nat fin) : @irreducible_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_176446 (h0 : topological_space (non_assoc_semiring empty)) : topological_space.separable_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_176447 (h0 : functor.add_const (monoid (has_pos_part pos)) Type) : @monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_176448 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : loc_path_connected_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_176449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_176450 (h0 : topological_space (simple_graph string.iterator_imp)) (h1 : preorder (simple_graph string.iterator_imp)) : order_topology (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_176451 (h0 : topological_space (has_norm empty)) : preirreducible_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_176452 (h0 : group (topological_space (has_append reducibility_hints))) : is_cyclic (topological_space (has_append reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176453 (h0 : add_group (as_linear_order (option (option empty)))) : is_add_cyclic (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_176454 (h0 : functor.add_const (ring pos) Type) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 1} (ring.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_176455 (h0 : semiring (semigroup (mul_one_class Type))) : is_noetherian_ring (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_176456 (h0 : topological_space (has_pos_part pos)) : sequential_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_176457 (h0 : functor.add_const (list (partial_order congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176458 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} (has_norm.{0} (with_bot.{0} (with_bot.{0} (has_norm.{0} num))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} (has_norm.{0} (with_bot.{0} (with_bot.{0} (has_norm.{0} num))))))  := sorry --non-trivial
lemma new_lemma_176459 (h0 : ring (boolean_algebra (finset Type))) : rank_condition (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_176460 (h0 : functor.add_const (topological_space (partial_order num)) num) : @irreducible_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_176461 (h0 : add_monoid (complete_distrib_lattice empty)) : add_monoid.fg (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_176462 (h0 : group (normed_comm_ring (finset Type))) : is_simple_group (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_176463 (h0 : filter (with_bot (random_gen (random_gen (random_gen (random_gen fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176464 (h1 : topological_space (semi_normed_ring to_additive.value_type)) : path_connected_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176465 (h0 : uniform_space (semi_normed_ring (has_nnnorm linarith.ineq))) : complete_space (semi_normed_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176466 (h0 : group (ordered_comm_ring linarith.comp)) : normalizer_condition (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_176467 (h0 : ring (encodable (has_ssubset char))) : strong_rank_condition (encodable (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_176468 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Inf environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176469 (h0 : add_group (has_pos_part (ring Type))) : is_add_cyclic (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_176470 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176471 (h1 : complete_lattice (has_norm linarith.comp)) : is_compactly_generated (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_176472 (h0 : group (semigroup (has_neg Type))) : is_cyclic (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_176473 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176474 (h0 : ring (has_neg_part (normed_comm_ring name))) : is_domain (has_neg_part (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_176475 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_176476 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176477 (h0 : not (topological_space (has_one empty) -> false)) : @totally_disconnected_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_176478 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176479 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176480 (h0 : uniform_space (semiring unsigned)) : complete_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_176481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (fintype.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (fintype.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176482 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_176483 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_176484 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_176485 (h1 : topological_space nnreal) : path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_176486 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_176487 (h0 : topological_space (add_comm_monoid (comm_group unsigned))) : preirreducible_space (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_176488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176489 (h0 : functor.add_const (group (preorder num)) num) : @normalizer_condition.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_176490 (h0 : ring (has_star (semiring empty))) : is_principal_ideal_ring (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_176491 (h2 : uniform_space (id (with_bot congr_arg_kind))) : complete_space (id (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176492 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @preconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_176493 (h1 : ring (with_one (has_inv string_imp))) : rank_condition (with_one (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_176494 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring unsigned)))) : totally_disconnected_space (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_176495 (h0 : ring (has_emptyc (semiring (semiring congr_arg_kind)))) : strong_rank_condition (has_emptyc (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_176496 (h0 : semiring (ordered_comm_monoid (ring (ring (ring Type))))) : is_noetherian_ring (ordered_comm_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_176497 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : sequential_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_176498 (h0 : prod (complete_linear_order (semiring empty)) (complete_linear_order (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_176499 (h1 : has_lt (has_ssubset reducibility_hints)) : no_max_order (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_176500 (h1 : topological_space (with_bot to_additive.value_type)) : locally_compact_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176501 (h0 : functor.add_const (function.extfun Type list) (ordered_ring Type)) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_176502 (h0 : functor.add_const (topological_space (ring pos)) Type) : @sequential_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_176503 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_176504 (h1 : uniform_space (comm_ring (normed_group (encodable (semi_normed_comm_ring string_imp))))) : complete_space (comm_ring (normed_group (encodable (semi_normed_comm_ring string_imp)))) := sorry --non-trivial
lemma new_lemma_176505 (h0 : not (topological_space (normed_group empty) -> false)) : @path_connected_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_176506 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (boolean_algebra name)) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_176507 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @preirreducible_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_176508 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) pos) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_176509 (h0 : group (topological_space (mul_one_class (option char)))) : is_cyclic (topological_space (mul_one_class (option char))) := sorry --non-trivial
lemma new_lemma_176510 (h0 : functor.add_const (topological_space (add_cancel_monoid num)) empty) : @discrete_topology.{0} (add_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_176511 (h0 : ring (has_compl string.iterator_imp)) : is_domain (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_176512 (h0 : topological_space (finset (has_pos_part linarith.comp))) : normal_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_176513 (h0 : complete_lattice (add_monoid (fintype reducibility_hints))) : complete_lattice.is_Sup_finite_compact (add_monoid (fintype reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176514 (h0 : topological_space enat) (h1 : has_lt (topological_space.compacts enat)) : no_max_order (topological_space.compacts enat) := sorry --non-trivial
lemma new_lemma_176515 (h0 : ring (has_neg (has_add pos))) : strong_rank_condition (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_176516 (h0 : uniform_space (has_nndist (option (option (option (option unsigned)))))) : separated_space (has_nndist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_176517 (h0 : topological_space (add_group (has_norm (has_norm (semiring (has_norm unsigned)))))) : irreducible_space (add_group (has_norm (has_norm (semiring (has_norm unsigned))))) := sorry --non-trivial
lemma new_lemma_176518 (h0 : topological_space (ring (option num))) : t1_space (ring (option num)) := sorry --non-trivial
lemma new_lemma_176519 (h0 : ring (has_Inf (mul_zero_class linarith.comp))) : rank_condition (has_Inf (mul_zero_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_176520 (h0 : topological_space (has_bot (has_add Type))) : preconnected_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_176521 (h2 : monoid linarith.ineq) : monoid.fg linarith.ineq := sorry --non-trivial
lemma new_lemma_176522 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_176523 (h0 : prod (preorder empty) (preorder empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_176524 (h0 : topological_space (has_bot (has_Inf real))) : preirreducible_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_176525 (h0 : list (has_star (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176526 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (ring Type)) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_176527 (h3 : topological_space (comm_ring (random_gen char))) : t0_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_176528 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_176529 (h0 : filter (has_one (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176530 (h0 : ring (linear_ordered_add_comm_group (distrib_lattice char))) : strong_rank_condition (linear_ordered_add_comm_group (distrib_lattice char)) := sorry --non-trivial
lemma new_lemma_176531 (h0 : topological_space (has_union (has_norm unsigned))) : t0_space (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_176532 (h0 : not (ring (has_norm num) -> false)) : @is_principal_ideal_ring.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_176533 (h0 : functor.comp ordered_comm_monoid has_neg_part name) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_176534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176535 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_176536 (h0 : uniform_space (canonically_ordered_monoid (finset linarith.comp))) : complete_space (canonically_ordered_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_176537 (h1 : uniform_space (with_one to_additive.value_type)) : complete_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176538 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176539 (h0 : group (encodable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : is_cyclic (encodable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_176540 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_176541 (h0 : add_group (has_dist (mul_one_class string.iterator_imp))) : is_add_cyclic (has_dist (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_176542 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_176543 (h0 : fin has_zero.zero) : @separated_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_176544 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_176545 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_176546 (h1 : set (distrib (distrib linarith.comp_source))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_176547 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_176548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) empty)  := sorry --non-trivial
lemma new_lemma_176549 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176550 (h0 : monoid (random_gen (comm_ring (has_inv to_additive.value_type)))) : monoid.fg (random_gen (comm_ring (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_176551 (h0 : topological_space (has_ssubset (has_ssubset fun_info))) : locally_compact_space (has_ssubset (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_176552 (h0 : monoid (measure_theory.measure_space (semiring (semiring (semiring (semiring (semiring num))))))) : monoid.fg (measure_theory.measure_space (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_176553 (h0 : topological_space (semiring (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_176554 (h1 : topological_space (has_nnnorm string_imp)) : locally_compact_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_176555 (h0 : topological_space (has_div enat)) (h1 : preorder (has_div enat)) : order_closed_topology (has_div enat) := sorry --non-trivial
lemma new_lemma_176556 (h0 : group (finset (has_add real))) : is_cyclic (finset (has_add real)) := sorry --non-trivial
lemma new_lemma_176557 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring (semiring unsigned))))) : t1_space (normed_linear_ordered_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_176558 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_domain.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_176559 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) linarith.comp) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176560 (h1 : complete_lattice (has_ssubset reducibility_hints)) : is_compactly_generated (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_176561 (h0 : add_monoid linarith.ineq) (h1 : add_group (add_units linarith.ineq)) : is_add_cyclic (add_units linarith.ineq) := sorry --non-trivial
lemma new_lemma_176562 (h0 : cancel_comm_monoid_with_zero (option (semiring (semiring (semiring (semiring (semiring num))))))) : unique_factorization_monoid (option (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_176563 (h0 : functor.add_const (topological_space (simple_graph Type)) (finset pos)) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176564 (h0 : topological_space (boolean_algebra.core (finset linarith.comp))) : path_connected_space (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_176565 (h0 : not (add_group (has_compl linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_176566 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup char))) : totally_disconnected_space (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_176567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176568 (h0 : to_additive.value_type -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) to_additive.value_type h0  := sorry --non-trivial
lemma new_lemma_176569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} name (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) name)  := sorry --non-trivial
lemma new_lemma_176570 (h0 : topological_space (has_neg (option pos))) : path_connected_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_176571 (h0 : topological_space (simple_graph (semigroup (has_neg (ring linarith.comp))))) : sequential_space (simple_graph (semigroup (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_176572 (h0 : topological_space (ordered_comm_group (option (option (option (option (option empty))))))) : totally_disconnected_space (ordered_comm_group (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_176573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176574 (h0 : add_group (random_gen (with_bot string_imp))) : is_add_cyclic (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_176575 (h0 : complete_lattice (ordered_comm_ring (has_neg name))) : is_atomistic (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_176576 (h0 : uniform_space (has_neg_part (finset linarith.comp))) : separated_space (has_neg_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_176577 (h0 : group (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type))))) : normalizer_condition (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_176578 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_176579 (h0 : topological_space (boolean_algebra linarith.comp)) : topological_space.separable_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_176580 (h0 : ordered_add_comm_monoid (has_Inf (boolean_algebra.core (has_add name)))) : archimedean (has_Inf (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_176581 (h0 : topological_space (linear_ordered_add_comm_group (has_inv fun_info))) : totally_separated_space (linear_ordered_add_comm_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_176582 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_176583 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_zero pos)) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176584 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_176585 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_176586 (h0 : uniform_space (has_nnnorm (topological_space (has_nnnorm linarith.comp_source)))) : complete_space (has_nnnorm (topological_space (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_176587 (h0 : uniform_space (linear_order (option (option unsigned)))) : complete_space (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_176588 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_176589 (h0 : topological_space (option name)) : totally_disconnected_space (option name) := sorry --non-trivial
lemma new_lemma_176590 (h0 : group (uniform_space (random_gen reducibility_hints))) : is_cyclic (uniform_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176591 (h0 : function.extfun Type (functor.add_const (uniform_space (add_cancel_monoid empty)))) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_176592 (h0 : ring (generalized_boolean_algebra (ring linarith.comp))) : is_principal_ideal_ring (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_176593 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_176594 (h0 : ring (boolean_algebra (sub_neg_monoid real))) : rank_condition (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_176595 (h0 : ring (has_top char)) : rank_condition (has_top char) := sorry --non-trivial
lemma new_lemma_176596 (h0 : functor.add_const (ring (ring Type)) environment.implicit_infer_kind) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176597 (h0 : ring (linear_ordered_comm_ring unsigned)) : strong_rank_condition (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_176598 (h1 : group (linear_ordered_add_comm_group to_additive.value_type)) : is_cyclic (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176599 (h0 : finset (normed_linear_ordered_group congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176600 (h1 : uniform_space (measurable_space congr_arg_kind)) : complete_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176601 (h0 : preorder to_additive.value_type) (h1 : not (topological_space (omega_complete_partial_order.chain to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (@omega_complete_partial_order.chain.{0} to_additive.value_type h0) (@classical.by_contradiction'.{1} (topological_space.{0} (@omega_complete_partial_order.chain.{0} to_additive.value_type h0)) h1)  := sorry --non-trivial
lemma new_lemma_176602 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_176603 (h0 : topological_space (with_bot (has_norm linarith.comp))) : t0_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_176604 (h0 : add_monoid (comm_group (has_to_string (has_to_string (has_to_string (has_to_string Type)))))) : add_monoid.fg (comm_group (has_to_string (has_to_string (has_to_string (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_176605 (h0 : ordered_add_comm_monoid (mul_zero_class num)) : archimedean (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_176606 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} stieltjes_function (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) stieltjes_function)  := sorry --non-trivial
lemma new_lemma_176607 (h0 : topological_space (has_zero (ring environment.implicit_infer_kind))) : locally_compact_space (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176608 (h0 : topological_space (as_linear_order (option (option (option unsigned))))) : preirreducible_space (as_linear_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_176609 (h0 : function.extfun nat fin) : is_compactly_generated (filter unsigned) := sorry --non-trivial
lemma new_lemma_176610 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_176611 (h0 : ring (comm_ring (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : strong_rank_condition (comm_ring (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_176612 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176613 (h0 : functor.comp group ring Type) : @normalizer_condition.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_176614 (h0 : group (with_bot (has_inv linarith.ineq))) : is_cyclic (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176615 (h0 : metric_space (has_bot empty)) (h1 : set (has_bot empty)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_176616 (h0 : not (topological_space num -> false)) : @irreducible_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_176617 (h0 : complete_lattice (add_comm_monoid (has_add Type))) : is_compactly_generated (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_176618 (h0 : complete_lattice ennreal) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_176619 (h0 : topological_space (with_bot (has_top fun_info))) : path_connected_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_176620 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_176621 (h0 : set (std_gen -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_176622 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_176623 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : loc_path_connected_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176624 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176625 (h0 : functor.add_const Prop (has_nndist Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_176626 (h0 : not (topological_space (with_one linarith.comp) -> false)) : @t0_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_176627 (h0 : not (filter (has_inv to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_176628 (h0 : group (complete_semilattice_Sup (has_norm (has_norm linarith.comp_source)))) : is_cyclic (complete_semilattice_Sup (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_176629 (h0 : topological_space (complete_distrib_lattice (has_neg_part (has_add pos)))) : normal_space (complete_distrib_lattice (has_neg_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_176630 (h1 : semiring (add_comm_semigroup ereal)) (h2 : add_comm_semigroup ereal) : even h2 := sorry --non-trivial
lemma new_lemma_176631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_176632 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176633 (h0 : add_monoid (finset (ring (has_Inf Type)))) : add_monoid.fg (finset (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_176634 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176635 (h0 : cancel_comm_monoid_with_zero (has_neg (has_add name))) : unique_factorization_monoid (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_176636 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_176637 (h0 : topological_space (has_compl (mul_one_class reducibility_hints))) : t0_space (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176638 (h0 : functor.add_const (filter (boolean_algebra Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176639 (h0 : ordered_comm_monoid (has_pos_part (has_Inf Type))) : has_exists_mul_of_le (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_176640 (h0 : ordered_add_comm_monoid (has_zero (has_to_string (has_to_string Type)))) : archimedean (has_zero (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_176641 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_176642 (h0 : add_group (ordered_comm_ring (has_pos_part Type))) : is_add_cyclic (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_176643 (h0 : functor.comp complete_lattice mul_zero_class environment.implicit_infer_kind) : @is_atomistic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176644 (h0 : not (topological_space (semiring unsigned) -> false)) : @preirreducible_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176645 (h0 : not (ring (distrib (has_nnnorm fun_info)) -> false)) : @rank_condition.{0} (distrib.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_176646 (h0 : list (comm_ring (dlist (random_gen (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176647 (h0 : list (has_pos_part (has_Inf (has_add linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176648 (h0 : functor.comp cancel_comm_monoid_with_zero ring (normed_comm_ring environment.implicit_infer_kind)) : @unique_factorization_monoid.{0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_176649 (h0 : topological_space (has_norm (has_norm linarith.comp_source))) : totally_separated_space (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176650 (h0 : add_group (has_lt (has_nnnorm (mul_one_class string.iterator_imp))) -> Prop) (h1 : Exists (fun (x : add_group (has_lt (has_nnnorm (mul_one_class string.iterator_imp)))), h0 x)) : @is_add_cyclic.{0} (has_lt.{0} (has_nnnorm.{0} (mul_one_class.{0} string.iterator_imp))) (@classical.some.{1} (add_group.{0} (has_lt.{0} (has_nnnorm.{0} (mul_one_class.{0} string.iterator_imp)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_176651 (h0 : complete_lattice (normed_field reducibility_hints)) : is_compactly_generated (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_176652 (h0 : functor.add_const (monoid (has_zero pos)) linarith.comp) : @monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176653 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_176654 (h0 : topological_space (has_bot linarith.comp)) : normal_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_176655 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @t0_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176656 (h0 : topological_space (boolean_algebra (has_bot Type))) : totally_separated_space (boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_176657 (h0 : functor.comp topological_space has_add Type) : @path_connected_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_176658 (h0 : add_comm_semigroup string.iterator_imp -> Prop) (h2 : filter (add_comm_semigroup string.iterator_imp)) : filter.eventually h0 h2 := sorry --non-trivial
lemma new_lemma_176659 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_176660 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176661 (h0 : complete_lattice (normed_group (comm_ring to_additive.value_type))) : is_atomistic (normed_group (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_176662 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_176663 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_176664 (h1 : ereal -> Prop) : is_total ereal (fun (h0 : ereal), h1) := sorry --non-trivial
lemma new_lemma_176665 (h0 : add_group (has_inter (option (option (option (option unsigned)))))) : is_add_cyclic (has_inter (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_176666 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) linarith.comp) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176667 (h0 : topological_space (group_with_zero empty)) : preirreducible_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_176668 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_176669 (h0 : group (canonically_ordered_monoid (has_Inf Type))) : group.fg (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_176670 (h0 : functor.add_const (group (cancel_monoid unsigned)) name) : @group.fg.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_176671 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : preirreducible_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_176672 (h0 : filter (linear_ordered_comm_ring (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176673 (h0 : topological_space (complete_distrib_lattice (finset (finset pos)))) : locally_compact_space (complete_distrib_lattice (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_176674 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist empty)) unsigned) : @archimedean.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176675 (h0 : has_lt (has_le ereal)) : no_max_order (has_le ereal) := sorry --non-trivial
lemma new_lemma_176676 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : regular_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_176677 (h0 : complete_lattice (has_zero environment.implicit_infer_kind)) : is_compactly_generated (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_176678 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176679 (h0 : topological_space (add_cancel_monoid (has_Inf (has_pos_part linarith.comp)))) : totally_separated_space (add_cancel_monoid (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_176680 (h0 : finset (has_to_string (finset (finset (finset (has_add linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176681 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @sequential_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_176682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176683 (h0 : add_monoid (ordered_comm_monoid (boolean_algebra.core Type))) : add_monoid.fg (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_176684 (h0 : uniform_space (has_inter empty)) : separated_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_176685 (h0 : finset (add_left_cancel_semigroup congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176686 (h0 : topological_space (semigroup (has_neg (add_cancel_monoid environment.implicit_infer_kind)))) : discrete_topology (semigroup (has_neg (add_cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_176687 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176688 (h0 : complete_lattice (has_add (has_bot (sub_neg_monoid real)))) : is_atomistic (has_add (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_176689 (h0 : group (has_pos_part (has_neg (has_nndist pos)))) : group.fg (has_pos_part (has_neg (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_176690 (h0 : functor.add_const (complete_lattice (has_neg pos)) linarith.comp) : @is_compactly_generated.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176691 (h0 : functor.add_const (filter (has_nndist name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176692 (h0 : functor.add_const (ring (filter num)) empty) : @strong_rank_condition.{0} (filter.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (filter.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_176693 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_176694 (h0 : topological_space (has_inter empty)) : preirreducible_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_176695 (h0 : functor.add_const (uniform_space (plift num)) num) : @complete_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_176696 (h0 : topological_space (normed_group (semiring (semiring linarith.comp)))) : preirreducible_space (normed_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_176697 (h0 : add_group (add_left_cancel_monoid fun_info)) : is_add_cyclic (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_176698 (h0 : not (cancel_comm_monoid_with_zero (has_sub unsigned) -> false)) : @unique_factorization_monoid.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176699 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (id unsigned)) := sorry --non-trivial
lemma new_lemma_176700 (h1 : add_group (normed_field (mul_one_class reducibility_hints))) : is_add_cyclic (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176701 (h0 : ring (has_lt (mul_one_class fun_info))) : rank_condition (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_176702 (h0 : functor.add_const (topological_space (has_zero pos)) (comm_group pos)) : @regular_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176703 (h0 : topological_space (generalized_boolean_algebra real)) : path_connected_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_176704 (h0 : set (left_cancel_monoid fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_176705 (h0 : complete_lattice (has_norm (random_gen linarith.comp_source))) : is_compactly_generated (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176706 (h0 : topological_space (has_pos_part (boolean_algebra.core (ring (has_Inf linarith.comp))))) : irreducible_space (has_pos_part (boolean_algebra.core (ring (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_176707 (h0 : ring (has_zero (option name))) : strong_rank_condition (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_176708 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176709 (h0 : set (normed_field reducibility_hints -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_176710 (h0 : uniform_space (add_comm_monoid (has_to_string (boolean_algebra (ring pos))))) : separated_space (add_comm_monoid (has_to_string (boolean_algebra (ring pos)))) := sorry --non-trivial
lemma new_lemma_176711 (h0 : add_monoid (measure_theory.measure_space num)) : add_monoid.fg (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_176712 (h0 : filter (id (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176713 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_176714 (h0 : complete_lattice (has_Sup (add_right_cancel_monoid empty))) : complete_lattice.is_Sup_finite_compact (has_Sup (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_176715 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_176716 (h0 : functor.add_const (add_monoid (semigroup congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_176718 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176719 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_176720 (h0 : fin has_zero.zero) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_176721 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_176722 (h0 : topological_space (has_le reducibility_hints) -> environment.projection_info) (h1 : coe_sort (set.range h0)) : @path_connected_space.{0} (has_le.{0} reducibility_hints) (@set.range_splitting.{0 0} (topological_space.{0} (has_le.{0} reducibility_hints)) environment.projection_info h0 h1)  := sorry --non-trivial
lemma new_lemma_176723 (h0 : add_group (linear_ordered_semiring (has_top (semiring num)))) : is_add_cyclic (linear_ordered_semiring (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_176724 (h0 : uniform_space (random_gen (has_nnnorm char))) : complete_space (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_176725 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) (comm_group name)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_176726 (h0 : topological_space (has_neg_part (has_add unsigned))) : locally_compact_space (has_neg_part (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_176727 (h0 : ring (group_with_zero (option ennreal))) : rank_condition (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_176728 (h0 : Prop) : id h0 := sorry --non-trivial
lemma new_lemma_176729 (h0 : functor.add_const (topological_space (option unsigned)) empty) : @t1_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_176730 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) unsigned) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176731 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176732 (h0 : uniform_space (ordered_comm_ring (has_nndist Type))) : separated_space (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_176733 (h0 : list (ring (has_neg name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176734 (h0 : functor.add_const (list (has_to_string unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176735 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_176736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_176737 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176738 (h0 : filter (has_to_string pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_176739 (h0 : ordered_add_comm_monoid (ring (option (option num)))) : archimedean (ring (option (option num))) := sorry --non-trivial
lemma new_lemma_176740 (h1 : not (ring (distrib fun_info) -> false)) : @is_domain.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_176741 (h0 : list (normed_comm_ring (finset (boolean_algebra (finset Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176742 (h2 : filter (with_zero to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_176743 (h0 : topological_space (uniform_space (has_ssubset (uniform_space (mul_one_class char))))) : path_connected_space (uniform_space (has_ssubset (uniform_space (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_176744 (h0 : topological_space (has_nnnorm to_additive.value_type)) (h1 : add_group (has_nnnorm to_additive.value_type)) : topological_add_group (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176745 (h0 : list (has_add (boolean_algebra linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176746 (h2 : ring (add_cancel_comm_monoid to_additive.value_type)) : strong_rank_condition (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176747 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core Type))) : topological_space.separable_space (generalized_boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_176748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176749 (h0 : topological_space (mul_zero_class (finset (has_add (has_add (finset (finset pos))))))) : loc_path_connected_space (mul_zero_class (finset (has_add (has_add (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_176750 (h0 : group (has_zero (finset (ring Type)))) : group.fg (has_zero (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_176751 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176752 (h0 : monoid (with_bot (comm_ring (random_gen (random_gen (has_inv linarith.comp_source)))))) : monoid.fg (with_bot (comm_ring (random_gen (random_gen (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_176753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176754 (h3 : ring (has_emptyc linarith.ineq)) : is_domain (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_176755 (h0 : add_group (partial_order (conditionally_complete_linear_order (has_sub empty)))) (h1 : add_subgroup (partial_order (conditionally_complete_linear_order (has_sub empty)))) : add_subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_176756 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) real) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_176757 (h0 : function.extfun Type ring) : @is_domain.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176758 (h0 : functor.add_const Prop (has_neg (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_176759 (h0 : functor.add_const (add_group nnreal) (option (option (option empty)))) : @is_add_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (add_group.{0} nnreal) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_176760 (h0 : function.extfun Type (functor.add_const (list (preorder empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_176761 (h0 : topological_space (metric_space reducibility_hints)) : t0_space (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_176762 (h0 : uniform_space (has_to_string (finset (finset linarith.comp)))) : complete_space (has_to_string (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_176763 (h0 : functor.add_const (complete_lattice (monoid_with_zero ennreal)) (option (option unsigned))) : @is_compactly_generated.{0} (monoid_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid_with_zero.{0} ennreal)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_176764 (h1 : uniform_space (dlist (random_gen (has_inv (has_inv (has_inv linarith.ineq)))))) : complete_space (dlist (random_gen (has_inv (has_inv (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_176765 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176766 (h0 : topological_space (has_Inf (ring Type))) : loc_path_connected_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_176767 (h0 : ring (partial_order (semiring (semiring empty)))) : is_principal_ideal_ring (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_176768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176769 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_176770 (h0 : functor.add_const (ordered_add_comm_monoid unsigned) unsigned) : @archimedean.{0} unsigned (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} unsigned) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176771 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176772 (h0 : topological_space (has_zero (option pos))) : topological_space.separable_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_176773 (h1 : complete_lattice (distrib linarith.comp_source)) : is_compactly_generated (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_176774 (h0 : ordered_comm_monoid (has_nndist (has_neg environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_176775 (h0 : group (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : group.fg (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_176776 (h3 : uniform_space (topological_space to_additive.value_type)) : complete_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176777 (h0 : complete_lattice (random_gen (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_176778 (h0 : functor.add_const (topological_space (has_norm congr_arg_kind)) unsigned) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_norm.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176779 (h0 : topological_space (left_cancel_monoid (semiring empty))) : locally_compact_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_176780 (h0 : ordered_add_comm_monoid (add_comm_monoid num)) : archimedean (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_176781 (h0 : complete_lattice (has_inter (option (option (option unsigned))))) : is_compactly_generated (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_176782 (h0 : functor.add_const (semiring (is_R_or_C unsigned)) unsigned) : @is_noetherian_ring.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176783 (h0 : ring (comm_semigroup name)) : is_domain (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_176784 (h0 : topological_space (semi_normed_comm_ring (has_ssubset fun_info))) : locally_compact_space (semi_normed_comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_176785 (h4 : set (add_comm_semigroup linarith.ineq)) : set.finite h4 := sorry --non-trivial
lemma new_lemma_176786 (h0 : cancel_comm_monoid_with_zero (simple_graph (finset pos))) : unique_factorization_monoid (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_176787 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_176788 (h0 : topological_space (as_linear_order unsigned)) : discrete_topology (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_176789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176790 (h0 : group (normed_comm_ring (has_neg Type))) : normalizer_condition (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_176791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_176792 (h0 : ring (complete_distrib_lattice (has_nndist Type))) : rank_condition (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_176793 (h0 : add_group (normed_group (comm_ring linarith.ineq))) : is_add_cyclic (normed_group (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_176794 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_176795 (h0 : topological_space (semigroup (has_add (has_add environment.implicit_infer_kind)))) : regular_space (semigroup (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_176796 (h0 : group (add_comm_monoid (add_comm_monoid name))) : is_simple_group (add_comm_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_176797 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176798 (h0 : add_monoid (complete_semilattice_Sup (semiring (semiring empty)))) : add_monoid.fg (complete_semilattice_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_176799 (h0 : complete_lattice (has_nnnorm (mul_one_class enat))) : is_compactly_generated (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_176800 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_176801 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string Type)))) : regular_space (boolean_algebra (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_176802 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_176803 (h0 : add_group (semigroup (option name))) : is_add_cyclic (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_176804 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter linarith.comp_source h0) := sorry --non-trivial
lemma new_lemma_176805 (h0 : group (has_nndist (comm_group pos))) : group.fg (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_176806 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_176807 (h0 : monoid (boolean_algebra.core empty)) : monoid.fg (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_176808 (h0 : filter (non_assoc_semiring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176809 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_domain.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_176810 (h0 : complete_lattice (ordered_comm_semiring num)) : is_compactly_generated (ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_176811 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class (metric_space string_imp)))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class (metric_space string_imp))) := sorry --non-trivial
lemma new_lemma_176812 (h0 : filter (has_nndist (finset Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_176813 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176814 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_176815 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf linarith.comp))) : preconnected_space (canonically_linear_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_176816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_176817 (h0 : group (has_add (finset linarith.comp))) : normalizer_condition (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_176818 (h0 : group (canonically_ordered_comm_semiring (has_neg_part Type))) : is_cyclic (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_176819 (h0 : functor.comp list complete_distrib_lattice name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_176820 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_176821 (h0 : ring (distrib (has_ssubset to_additive.value_type))) : strong_rank_condition (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_176822 (h0 : not (ring (has_div enat) -> false)) : @rank_condition.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_176823 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_176824 (h0 : group (finset (has_add (boolean_algebra (has_Inf Type))))) : normalizer_condition (finset (has_add (boolean_algebra (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_176825 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_176826 (h0 : add_monoid (normed_group (has_top num))) : add_monoid.fg (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_176827 (h0 : not (complete_lattice (denumerable linarith.ineq) -> false)) : @is_compactly_generated.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_176828 (h0 : ring (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : is_domain (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_176829 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_176830 (h1 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm string_imp))))) : totally_disconnected_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm string_imp)))) := sorry --non-trivial
lemma new_lemma_176831 (h0 : topological_space (normed_comm_ring (finset ennreal))) : totally_disconnected_space (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_176832 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) ennreal) : @strong_rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_176833 (h0 : functor.add_const (add_monoid znum) unsigned) : @add_monoid.fg.{0} znum (@functor.add_const.run.{0 0} (add_monoid.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176834 (h0 : topological_space (has_neg_part (canonically_linear_ordered_monoid name))) : normal_space (has_neg_part (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_176835 (h0 : complete_lattice (complete_distrib_lattice (has_bot (has_bot (has_bot real))))) : is_atomistic (complete_distrib_lattice (has_bot (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_176836 (h0 : topological_space (measurable_space (random_gen fun_info))) : totally_disconnected_space (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_176837 (h0 : functor.add_const (ring (add_left_cancel_semigroup environment.implicit_infer_kind)) (has_neg_part linarith.comp)) : @strong_rank_condition.{0} (add_left_cancel_semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} environment.implicit_infer_kind)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_176838 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group unsigned)))) : @irreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_176839 (h0 : finset (boolean_algebra.core (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_176840 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_176841 (h0 : topological_space (has_bot congr_arg_kind)) : preconnected_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176842 (h0 : uniform_space (complete_distrib_lattice (has_Inf (has_Inf real)))) : separated_space (complete_distrib_lattice (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_176843 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176844 (h0 : ring (complete_linear_order empty)) : is_principal_ideal_ring (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_176845 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176846 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_176847 (h1 : uniform_space (distrib (has_nnnorm string_imp))) : complete_space (distrib (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_176848 (h0 : function.extfun Type (functor.add_const (add_monoid (semiring unsigned)))) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (semiring.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_176849 (h0 : topological_space (has_to_string (mul_one_class Type))) : sequential_space (has_to_string (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_176850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_176851 (h0 : add_monoid (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))))) : add_monoid.fg (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) := sorry --non-trivial
lemma new_lemma_176852 (h0 : functor.add_const Prop (normed_comm_ring (has_neg_part name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_176853 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176854 (h0 : functor.add_const Prop (finset (has_to_string pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_176855 (h0 : congr_arg_kind -> congr_arg_kind -> congr_arg_kind) : is_associative congr_arg_kind h0 := sorry --non-trivial
lemma new_lemma_176856 (h0 : functor.add_const (list (semigroup pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176857 (h0 : topological_space (has_Inf real)) : t0_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_176858 (h0 : topological_space (has_nndist (finset Type))) : regular_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_176859 (h0 : topological_space (normed_group congr_arg_kind)) : totally_disconnected_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176860 (h0 : topological_space (finset unsigned)) : preirreducible_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_176861 (h0 : complete_lattice (add_comm_monoid (comm_semigroup real))) : is_atomistic (add_comm_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_176862 (h1 : has_neg (has_nnnorm ereal)) (h2 : measurable_space (has_nnnorm ereal)) : has_measurable_neg (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_176863 (h1 : preorder linarith.comp) (h2 : topological_space linarith.comp) : Inf_convergence_class linarith.comp := sorry --non-trivial
lemma new_lemma_176864 (h0 : uniform_space (has_Inf (has_pos_part Type))) : complete_space (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_176865 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_176866 (h0 : topological_space (has_nndist (finset ennreal))) : totally_disconnected_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_176867 (h1 : simple_graph (topological_space (random_gen linarith.ineq))) (h2 : sym2 (topological_space (random_gen linarith.ineq))) : simple_graph.edge_set h1 h2 := sorry --non-trivial
lemma new_lemma_176868 (h0 : group (linear_ordered_add_comm_group (has_top linarith.comp_source))) : normalizer_condition (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176869 (h0 : function.extfun Type (functor.add_const (semiring (semigroup empty)))) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semigroup.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_176870 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @normalizer_condition.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_176871 (h0 : uniform_space (distrib_lattice (has_nnnorm fun_info))) : complete_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_176872 (h0 : filter (complete_distrib_lattice num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176873 (h0 : complete_lattice (mul_one_class linarith.comp_source)) : is_compactly_generated (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_176874 (h0 : group (add_cancel_monoid (comm_group linarith.comp))) : is_simple_group (add_cancel_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_176875 (h0 : uniform_space (has_star (semiring (semiring (semiring (semiring (semiring num))))))) : separated_space (has_star (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_176876 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_176877 (h0 : has_zero (option num) -> has_zero (option num) -> Prop) : is_symm (has_zero (option num)) h0 := sorry --non-trivial
lemma new_lemma_176878 (h0 : topological_space (normed_comm_ring (complete_distrib_lattice unsigned))) : loc_path_connected_space (normed_comm_ring (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_176879 (h0 : topological_space (has_neg_part (option unsigned))) : normal_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_176880 (h0 : topological_space (has_neg (has_to_string (has_to_string name)))) : sequential_space (has_neg (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_176881 (h0 : function.extfun Type add_group -> Prop) (h1 : Exists (fun (x : function.extfun Type add_group), h0 x)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.some.{2} (function.extfun.{2 1} Type add_group.{0}) h0 h1) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176882 (h0 : complete_lattice (random_gen (comm_ring (comm_ring linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (random_gen (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_176883 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : irreducible_space (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_176884 (h0 : complete_lattice (distrib enat) -> Prop) (h1 : Exists (fun (x : complete_lattice (distrib enat)), h0 x)) : @is_compactly_generated.{0} (distrib.{0} enat) (@classical.some.{1} (complete_lattice.{0} (distrib.{0} enat)) h0 h1)  := sorry --non-trivial
lemma new_lemma_176885 (h0 : ordered_add_comm_monoid (normed_comm_ring ennreal)) : archimedean (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_176886 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_176887 (h0 : ring (has_lt (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (has_lt (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_176888 (h0 : topological_space (has_pos_part (has_Inf pos))) : preconnected_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_176889 (h0 : functor.add_const (multiset (semigroup name)) name) (h1 : functor.comp multiset semigroup name) : multiset.subset (functor.add_const.run h0) (functor.comp.run h1) := sorry --non-trivial
lemma new_lemma_176890 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_176891 (h0 : fin has_zero.zero) : @preconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_176892 (h0 : ring (canonically_ordered_comm_semiring (comm_group name))) : is_domain (canonically_ordered_comm_semiring (comm_group name)) := sorry --non-trivial
lemma new_lemma_176893 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (has_add (has_add name)))) : unique_factorization_monoid (cancel_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_176894 (h0 : functor.add_const (finset (normed_lattice_add_comm_group unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176895 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_176896 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_176897 (h0 : topological_space (complete_distrib_lattice num)) : totally_separated_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_176898 (h0 : monoid (has_neg_part (has_neg (has_to_string Type)))) : monoid.fg (has_neg_part (has_neg (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_176899 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_176900 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_176901 (h0 : list (semigroup ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176902 (h0 : functor.add_const (add_monoid (preorder empty)) (option empty)) : @add_monoid.fg.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_176903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176904 (h0 : uniform_space (add_right_cancel_monoid unsigned)) : separated_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_176905 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_176906 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid linarith.comp)) (has_add unsigned)) : @archimedean.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_176907 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_176908 (h0 : functor.add_const (ring (has_dist empty)) congr_arg_kind) : @rank_condition.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_176909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_176910 (h0 : group (partial_order (semiring congr_arg_kind))) : is_cyclic (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176911 (h0 : functor.add_const (group (cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : @group.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176912 (h1 : semiring (add_comm_semigroup environment.projection_info)) (h2 : ideal (add_comm_semigroup environment.projection_info)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_176913 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (has_star num)) := sorry --non-trivial
lemma new_lemma_176914 (h2 : complete_lattice (random_gen to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176915 (h0 : ring (add_semigroup (option (option empty)))) : strong_rank_condition (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_176916 (h0 : functor.add_const (add_group (has_add linarith.comp)) pos) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_176917 (h0 : topological_space (with_one empty)) : irreducible_space (with_one empty) := sorry --non-trivial
lemma new_lemma_176918 (h0 : uniform_space (has_add (has_Inf linarith.comp))) : separated_space (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_176919 (h0 : ring (has_compl (nondiscrete_normed_field enat))) : strong_rank_condition (has_compl (nondiscrete_normed_field enat)) := sorry --non-trivial
lemma new_lemma_176920 (h0 : complete_lattice (has_union (has_norm (semiring (semiring (has_norm num)))))) : complete_lattice.is_Sup_finite_compact (has_union (has_norm (semiring (semiring (has_norm num))))) := sorry --non-trivial
lemma new_lemma_176921 (h0 : functor.add_const (functor.add_const (monoid linarith.comp) (has_pos_part pos)) pos) : @monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (monoid.{0} linarith.comp) (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} linarith.comp) (has_pos_part.{0} pos)) pos h0))  := sorry --non-trivial
lemma new_lemma_176922 (h1 : topological_space (id (random_gen congr_arg_kind))) : t0_space (id (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176923 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_176924 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_176925 (h0 : ring (left_cancel_monoid empty)) : strong_rank_condition (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_176926 (h0 : not (topological_space (with_bot to_additive.value_type) -> false)) : @locally_compact_space.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_176927 (h0 : complete_lattice (denumerable (random_gen linarith.comp_source))) : is_compactly_generated (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_176928 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_176929 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part (has_Inf (has_neg Type)))) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{1} (has_Inf.{1} (has_neg.{1} Type))) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_176930 (h0 : uniform_space (with_one (has_top (has_top (semiring fun_info))))) : separated_space (with_one (has_top (has_top (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_176931 (h1 : topological_space (add_comm_semigroup char)) (h2 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_176932 (h0 : complete_lattice (finset unsigned)) : is_atomistic (finset unsigned) := sorry --non-trivial
lemma new_lemma_176933 (h1 : topological_space (measurable_space linarith.comp)) : normal_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_176934 (h0 : not (topological_space (complete_semilattice_Sup char) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_176935 (h1 : add_group (has_ssubset (fintype char))) : is_add_cyclic (has_ssubset (fintype char)) := sorry --non-trivial
lemma new_lemma_176936 (h0 : fin has_zero.zero) : list.head (matrix.vec_empty (id (matrix.vec_empty (matrix.vec_empty (id h0))))) := sorry --non-trivial
lemma new_lemma_176937 (h0 : group (metric_space (has_norm (semiring empty)))) : is_cyclic (metric_space (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_176938 (h0 : complete_lattice (with_one (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_176939 (h0 : complete_lattice (with_one string_imp)) : is_compactly_generated (with_one string_imp) := sorry --non-trivial
lemma new_lemma_176940 (h0 : add_group (canonically_ordered_comm_semiring name)) : is_add_cyclic (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_176941 (h0 : ring (has_Sup num)) : is_domain (has_Sup num) := sorry --non-trivial
lemma new_lemma_176942 (h0 : set (random_gen (distrib char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_176943 (h0 : filter (has_inv (fintype linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_176944 (h0 : functor.add_const (filter (has_to_string pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_176945 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_176946 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_176947 (h0 : topological_space (metric_space (mul_one_class reducibility_hints))) : t0_space (metric_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_176948 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_176949 (h0 : uniform_space (boolean_algebra (ring (has_add unsigned)))) : separated_space (boolean_algebra (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_176950 (h4 : topological_space (semi_normed_ring (random_gen char))) : totally_disconnected_space (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_176951 (h2 : complete_lattice (has_compl fun_info)) : is_compactly_generated (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_176952 (h1 : topological_space (add_comm_semigroup char)) (h2 : add_group (add_comm_semigroup char)) : topological_add_group (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_176953 (h0 : topological_space (has_inv (has_inv (has_norm (has_norm (has_norm linarith.ineq)))))) : locally_compact_space (has_inv (has_inv (has_norm (has_norm (has_norm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_176954 (h0 : topological_space (group_with_zero (option (option congr_arg_kind)))) : totally_disconnected_space (group_with_zero (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_176955 (h0 : complete_lattice (normed_comm_ring (has_neg_part name))) : is_compactly_generated (normed_comm_ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_176956 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176957 (h0 : functor.add_const (topological_space (has_inner unsigned congr_arg_kind)) unsigned) : @t1_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inner.{0 0} unsigned congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_176958 (h0 : unsigned -> unsigned -> unsigned) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_176959 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_176960 (h0 : ordered_add_comm_monoid (boolean_algebra.core Type)) : archimedean (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_176961 (h0 : group (ring (option name))) : is_cyclic (ring (option name)) := sorry --non-trivial
lemma new_lemma_176962 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_176963 (h0 : topological_space char) : noncompact_space char := sorry --non-trivial
lemma new_lemma_176964 (h1 : group (has_inv char)) : is_cyclic (has_inv char) := sorry --non-trivial
lemma new_lemma_176965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_176966 (h0 : topological_space (normed_field (random_gen (random_gen string.iterator_imp)))) : t0_space (normed_field (random_gen (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_176967 (h0 : ordered_add_comm_monoid (complete_distrib_lattice unsigned)) : archimedean (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_176968 (h0 : functor.add_const (ring (has_zero name)) environment.implicit_infer_kind) : @is_domain.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_176969 (h0 : functor.comp topological_space add_cancel_monoid name) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_176970 (h0 : has_pos_part real -> has_pos_part real -> Prop) : is_refl (has_pos_part real) h0 := sorry --non-trivial
lemma new_lemma_176971 (h1 : topological_space (metric_space (random_gen linarith.comp))) : totally_separated_space (metric_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_176972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_176973 (h3 : complete_lattice (simple_graph to_additive.value_type)) : is_compactly_generated (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_176974 (h0 : monoid (canonically_ordered_monoid pos)) : monoid.fg (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_176975 (h1 : add_group (linear_ordered_comm_group_with_zero linarith.ineq)) : is_add_cyclic (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_176976 (h2 : topological_space (distrib_lattice fun_info)) : locally_compact_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_176977 (h0 : ring (linear_ordered_semiring num)) : is_domain (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_176978 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist num)) := sorry --non-trivial
lemma new_lemma_176979 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) (normed_comm_ring pos)) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176980 (h0 : functor.add_const (group (has_pos_part Type)) (ordered_ring pos)) : @is_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_pos_part.{1} Type)) (ordered_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_176981 (h0 : topological_space (has_norm (has_top (random_gen to_additive.value_type)))) : path_connected_space (has_norm (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_176982 (h0 : not (topological_space (semi_normed_comm_ring linarith.comp_source) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_176983 (h0 : list (ordered_comm_ring (boolean_algebra.core Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_176984 (h0 : list (mul_zero_class pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_176985 (h0 : ring (semigroup unsigned)) : rank_condition (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_176986 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_176987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_176988 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_176989 (h0 : topological_space (encodable (random_gen string_imp))) : locally_compact_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_176990 (h0 : ring (normed_comm_ring (option (option ennreal)))) : strong_rank_condition (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_176991 (h0 : add_group (canonically_ordered_monoid Type)) : is_add_cyclic (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_176992 (h0 : topological_space (has_neg (finset pos))) : preconnected_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_176993 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_176994 (h0 : topological_space (has_edist congr_arg_kind)) : locally_compact_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_176995 (h0 : add_monoid (add_group (semiring (semiring empty)))) : add_monoid.fg (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_176996 (h0 : group (comm_semigroup (sub_neg_monoid (sub_neg_monoid pos)))) : group.fg (comm_semigroup (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_176997 (h0 : functor.add_const (group (canonically_linear_ordered_monoid environment.implicit_infer_kind)) pos) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_176998 (h0 : ring (has_top (has_norm to_additive.value_type))) : rank_condition (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_176999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_177000 (h0 : heq (with_bot (with_bot linarith.comp_source)) (id to_additive.value_type)) (h1 : add_group (with_bot (with_bot linarith.comp_source))) : @is_add_cyclic.{0} (@id.{2} Type to_additive.value_type) (@heq.elim.{2 1} Type (with_bot.{0} (with_bot.{0} linarith.comp_source)) add_group.{0} (@id.{2} Type to_additive.value_type) h0 h1)  := sorry --non-trivial
lemma new_lemma_177001 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_Inf linarith.comp)) : @locally_compact_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_177002 (h0 : not (has_mem.mem (semiring num) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_177003 (h0 : functor.add_const (topological_space (has_pos_part name)) Type) : @preirreducible_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_177004 (h0 : functor.add_const (filter (canonically_ordered_add_monoid empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177005 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177006 (h0 : group (option (semiring (semiring (semiring (semiring unsigned)))))) : is_cyclic (option (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_177007 (h0 : add_group (measurable_space (random_gen (random_gen (has_inv to_additive.value_type))))) : is_add_cyclic (measurable_space (random_gen (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_177008 (h0 : topological_space (linear_ordered_add_comm_group char)) : totally_disconnected_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_177009 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177010 (h0 : has_mem.mem (metric_space empty) has_emptyc.emptyc) : @separated_space.{0} (metric_space.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (metric_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_177011 (h0 : group (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind))) : group.fg (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_177013 (h0 : topological_space (has_to_string (has_to_string pos))) : totally_disconnected_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_177014 (h0 : topological_space (linear_ordered_add_comm_group (has_norm (comm_ring linarith.ineq)))) : t0_space (linear_ordered_add_comm_group (has_norm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_177015 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen fun_info))))) : path_connected_space (has_norm (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_177016 (h0 : has_le (has_add (has_nnnorm fun_info))) (h1 : topological_space (bounded_order (has_add (has_nnnorm fun_info)))) : totally_disconnected_space (bounded_order (has_add (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_177017 (h0 : topological_space (complete_distrib_lattice ennreal)) : preconnected_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_177018 (h0 : uniform_space linarith.comp -> Prop) : @complete_space.{0} linarith.comp (@classical.epsilon.{1} (uniform_space.{0} linarith.comp) (@nonempty_of_inhabited.{1} (uniform_space.{0} linarith.comp) (@inhabited_uniform_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177019 (h0 : functor.add_const (group (has_neg_part name)) (has_add (has_add pos))) : @is_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_177020 (h0 : uniform_space (has_neg environment.implicit_infer_kind)) : separated_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_177021 (h0 : group (plift (semiring congr_arg_kind))) : normalizer_condition (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177022 (h0 : ring (add_right_cancel_monoid linarith.ineq)) : is_domain (add_right_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_177023 (h0 : list (comm_group (boolean_algebra.core name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177024 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_177025 (h1 : not (ring (simple_graph linarith.ineq) -> false)) : @is_domain.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_177026 (h0 : not (add_monoid (measurable_space.dynkin_system unsigned) -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_177027 (h0 : std_gen -> char) (h1 : set std_gen) (h2 : char) : set.kern_image h0 h1 h2 := sorry --non-trivial
lemma new_lemma_177028 (h1 : not (ring (semi_normed_ring char) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_177029 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @t1_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177030 (h0 : functor.add_const (ring (has_neg linarith.comp)) Type) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_177031 (h0 : group (semiring empty)) : normalizer_condition (semiring empty) := sorry --non-trivial
lemma new_lemma_177032 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177033 (h0 : not (uniform_space (comm_ring linarith.comp_source) -> false)) : @complete_space.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_177034 (h0 : topological_space (metric_space (semiring (has_norm linarith.comp)))) : irreducible_space (metric_space (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_177035 (h0 : complete_lattice (measurable_space.dynkin_system (semiring unsigned))) : is_atomistic (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177036 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf (has_Inf (has_pos_part Type)))))) : loc_path_connected_space (ordered_comm_monoid (has_add (has_Inf (has_Inf (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_177037 (h0 : not (group num -> false)) : @group.fg.{0} num (@classical.by_contradiction'.{1} (group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_177038 (h0 : topological_space (has_inter ennreal)) : totally_disconnected_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_177039 (h0 : uniform_space (has_bot congr_arg_kind)) : complete_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177040 (h0 : group (normed_group (random_gen linarith.ineq))) : is_cyclic (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177041 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) unsigned) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177042 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_177043 (h0 : functor.add_const (complete_lattice (ring pos)) (mul_one_class Type)) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} pos)) (mul_one_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177044 (h0 : group (denumerable (random_gen (random_gen fun_info)))) : group.fg (denumerable (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_177045 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_177046 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring empty)))) : normal_space (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_177047 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid real)) : unique_factorization_monoid (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_177048 (h0 : not (topological_space (metric_space (semiring unsigned)) -> false)) : @path_connected_space.{0} (metric_space.{0} (semiring.{0} unsigned)) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_177049 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) (semiring num)) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_177050 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177051 (h0 : has_mem.mem (encodable to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (encodable.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (encodable.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_177052 (h0 : topological_space (canonically_ordered_monoid (has_bot name))) : discrete_topology (canonically_ordered_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_177053 (h0 : not (uniform_space (uniform_space (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) -> false)) : @complete_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_177054 (h0 : complete_lattice (has_neg_part (has_add (comm_group (comm_group name))))) : is_compactly_generated (has_neg_part (has_add (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_177055 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @normalizer_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type group.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177056 (h0 : add_monoid (measurable_space (random_gen empty))) : add_monoid.fg (measurable_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_177057 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : preirreducible_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177058 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177059 (h0 : topological_space (linear_order congr_arg_kind)) : locally_compact_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177060 (h0 : ring (boolean_algebra (has_neg_part Type))) : is_domain (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_177061 (h0 : not (complete_lattice (has_nnnorm fun_info) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_177062 (h0 : topological_space (complete_distrib_lattice ennreal)) : totally_separated_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_177063 (h1 : topological_space (normed_group (random_gen (random_gen string_imp)))) : path_connected_space (normed_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_177064 (h0 : uniform_space (ring (boolean_algebra environment.implicit_infer_kind))) : separated_space (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177065 (h0 : topological_space (has_lt (mul_one_class (mul_one_class (mul_one_class fun_info))))) (h1 : add_group (has_lt (mul_one_class (mul_one_class (mul_one_class fun_info))))) : topological_add_group (has_lt (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_177066 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : t0_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177067 (h0 : ring (normed_field (has_nnnorm reducibility_hints))) : rank_condition (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177068 (h0 : not (topological_space (linear_ordered_semiring (has_top unsigned)) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} (has_top.{0} unsigned)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} (has_top.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_177069 (h0 : set (normed_field (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_177070 (h0 : simple_graph (semi_normed_comm_ring char)) : set.subsingleton (simple_graph.support (id h0)) := sorry --non-trivial
lemma new_lemma_177071 (h0 : functor.comp filter add_comm_monoid name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_177072 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177073 (h0 : functor.add_const (finset (option congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177074 (h0 : list (has_norm (has_nnnorm char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177075 (h0 : filter (has_zero name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177076 (h0 : ring (normed_comm_ring (finset unsigned))) : is_principal_ideal_ring (normed_comm_ring (finset unsigned)) := sorry --non-trivial
lemma new_lemma_177077 (h0 : has_le (has_nnnorm fun_info)) (h1 : has_nnnorm fun_info) : is_max h1 := sorry --non-trivial
lemma new_lemma_177078 (h0 : topological_space (has_ssubset (random_gen (dlist reducibility_hints)))) : totally_disconnected_space (has_ssubset (random_gen (dlist reducibility_hints))) := sorry --non-trivial
lemma new_lemma_177079 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp))) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_177080 (h0 : function.extfun (with_one congr_arg_kind) (fun (x : with_one congr_arg_kind), Prop)) : set.infinite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_177081 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_177082 (h0 : ordered_comm_monoid (has_zero (has_neg_part linarith.comp))) : has_exists_mul_of_le (has_zero (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_177083 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177084 (h0 : function.extfun Type (functor.add_const (semiring (add_cancel_comm_monoid empty)))) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_177085 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177086 (h0 : group (has_pos_part (has_Inf linarith.comp))) : is_simple_group (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_177087 (h0 : complete_lattice (has_emptyc (has_top (has_top (has_top (has_top num)))))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top (has_top (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_177088 (h0 : function.extfun Type (functor.add_const (topological_space (non_assoc_semiring empty)))) : @t0_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_177089 (h0 : functor.add_const (topological_space (preorder num)) (semiring num)) : @t1_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_177090 (h0 : ring (topological_space (denumerable (comm_ring to_additive.value_type)))) : rank_condition (topological_space (denumerable (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_177091 (h1 : prod char char) : set.diagonal char h1 := sorry --non-trivial
lemma new_lemma_177092 (h0 : group (has_top (has_norm congr_arg_kind))) : normalizer_condition (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177093 (h0 : functor.add_const (finset (semigroup linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177094 (h0 : functor.add_const (add_group (cancel_monoid empty)) num) : @is_add_cyclic.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_177095 (h0 : complete_lattice (generalized_boolean_algebra (ring pos))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_177096 (h0 : topological_space (has_neg (has_neg Type))) : loc_path_connected_space (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_177097 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_177098 (h0 : topological_space (finset (has_pos_part Type))) : loc_path_connected_space (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_177099 (h0 : group (has_top (random_gen (random_gen fun_info)))) : group.fg (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_177100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_177101 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_domain.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_177102 (h0 : functor.add_const (group pos) unsigned) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177103 (h0 : has_neg (has_div reducibility_hints)) (h1 : measurable_space (has_div reducibility_hints)) : has_measurable_neg (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_177104 (h0 : add_monoid (canonically_ordered_monoid (sub_neg_monoid (has_Inf real)))) : add_monoid.fg (canonically_ordered_monoid (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_177105 (h0 : not (ring (has_norm empty) -> false)) : @is_domain.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177106 (h0 : ring (generalized_boolean_algebra (has_neg Type))) : is_domain (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_177107 (h0 : topological_space (has_compl enat)) (h1 : add_group (has_compl enat)) : topological_add_group (has_compl enat) := sorry --non-trivial
lemma new_lemma_177108 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_177109 (h1 : complete_lattice (encodable to_additive.value_type)) : is_compactly_generated (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177110 (h0 : functor.add_const (ordered_add_comm_monoid (measurable_space.dynkin_system unsigned)) empty) : @archimedean.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_177111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_177112 (h0 : topological_space (has_pos_part (has_Inf Type))) : discrete_topology (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_177113 (h0 : functor.add_const (topological_space (has_bot pos)) (has_bot linarith.comp)) : @sequential_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) (has_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_177114 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} (option.{0} (option.{0} (option.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_177115 (h0 : ring (has_norm num)) : is_principal_ideal_ring (has_norm num) := sorry --non-trivial
lemma new_lemma_177116 (h0 : has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (complete_semilattice_Sup.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_177117 (h0 : not (group (partial_order unsigned) -> false)) : @normalizer_condition.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_177118 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_177119 (h0 : topological_space (simple_graph (has_add (has_add name)))) : path_connected_space (simple_graph (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_177120 (h0 : set (has_nnnorm (has_compl fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_177121 (h0 : function.extfun Type (functor.add_const (functor.add_const (finset nnreal) empty))) : finset.nonempty (functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty))) := sorry --non-trivial
lemma new_lemma_177122 (h0 : group (has_nndist (finset ennreal))) : is_cyclic (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_177123 (h0 : functor.comp topological_space cancel_monoid (complete_distrib_lattice pos)) : @topological_space.separable_space.{0} (cancel_monoid.{0} (complete_distrib_lattice.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} (complete_distrib_lattice.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_177124 (h1 : ring (mul_one_class environment.projection_info)) : rank_condition (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_177125 (h0 : ring (comm_group (comm_group Type))) : is_domain (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_177126 (h0 : list (cancel_monoid (semigroup name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177127 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_177128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_177129 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177130 (h0 : add_group (comm_semigroup (comm_semigroup Type))) : is_add_cyclic (comm_semigroup (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_177131 (h0 : add_monoid (random_gen (has_norm num))) : add_monoid.fg (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_177132 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @totally_disconnected_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_177133 (h0 : complete_lattice (has_bot (has_add (has_add (has_add pos))))) : is_compactly_generated (has_bot (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_177134 (h0 : add_group (measurable_space (random_gen linarith.comp_source))) : is_add_cyclic (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177135 (h0 : topological_space (semiring (has_top linarith.comp))) : t0_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_177136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177137 (h0 : list (ordered_comm_monoid real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177138 (h0 : topological_space (left_cancel_semigroup (option empty))) : totally_disconnected_space (left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_177139 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : t0_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177140 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_177141 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_177142 (h0 : topological_space (omega_complete_partial_order empty)) : irreducible_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_177143 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_177144 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177145 (h0 : topological_space (add_cancel_monoid (has_neg_part linarith.comp))) : totally_separated_space (add_cancel_monoid (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_177146 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177147 (h0 : topological_space (comm_semigroup pos)) : locally_compact_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_177148 (h0 : group (linear_order (option (option (option empty))))) : is_cyclic (linear_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_177149 (h0 : functor.add_const (function.extfun Type ring) empty) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) empty h0) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177150 (h1 : complete_lattice (has_top (random_gen string_imp))) : is_compactly_generated (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_177151 (h0 : complete_lattice (has_ssubset (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_177152 (h0 : prod (simple_graph unsigned) (simple_graph unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_177153 (h0 : functor.add_const (topological_space znum) (option empty)) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_177154 (h0 : functor.add_const (monoid (finset environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_177155 (h0 : uniform_space (has_dist (option congr_arg_kind))) : separated_space (has_dist (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177156 (h0 : functor.add_const (ring (has_nndist Type)) (has_add (has_add (has_add (has_add name))))) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_177157 (h0 : topological_space (bin_tree (semiring unsigned))) : totally_disconnected_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177158 (h0 : function.extfun Type (functor.add_const (group (mul_zero_class congr_arg_kind)))) : @normalizer_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (mul_zero_class.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_177159 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset name)) := sorry --non-trivial
lemma new_lemma_177160 (h0 : functor.add_const (topological_space znum) unsigned) : @preconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177161 (h1 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @discrete_topology.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_177162 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_177163 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : normal_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177164 (h0 : add_monoid (boolean_algebra.core (comm_group Type))) : add_monoid.fg (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_177165 (h0 : complete_lattice (has_le reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_177166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_177167 (h0 : group (has_nndist (has_add ennreal))) : normalizer_condition (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_177168 (h1 : group (complete_semilattice_Sup linarith.comp)) : group.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_177169 (h0 : topological_space (has_ssubset linarith.ineq)) : locally_compact_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_177170 (h0 : topological_space (has_nnnorm (random_gen (random_gen (has_inv to_additive.value_type))))) : locally_compact_space (has_nnnorm (random_gen (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_177171 (h0 : topological_space (has_lt string_imp)) : totally_disconnected_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_177172 (h0 : topological_space (has_add (option unsigned))) : loc_path_connected_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_177173 (h0 : topological_space (has_pos_part (has_add (has_Inf (has_Inf real))))) : locally_compact_space (has_pos_part (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_177174 (h0 : Prop) (h1 : option Prop) : option.lhoare h0 h1 := sorry --non-trivial
lemma new_lemma_177175 (h0 : has_mem.mem (has_to_string linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (has_to_string.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_to_string.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_177176 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177177 (h0 : topological_space (has_pos_part (finset pos))) : t1_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_177178 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177179 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) pos) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_177180 (h0 : list (cancel_monoid Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177181 (h0 : uniform_space (preorder (semiring (semiring num)))) : complete_space (preorder (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_177182 (h0 : ring (lex (has_inv linarith.comp_source))) : is_domain (lex (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177183 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @totally_separated_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_177185 (h0 : topological_space (complete_semilattice_Sup (semiring empty))) : irreducible_space (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_177186 (h0 : complete_lattice (simple_graph unsigned)) : is_atomistic (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_177187 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class string.iterator_imp)))) : totally_disconnected_space (has_ssubset (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_177188 (h0 : complete_lattice (normed_group (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177189 (h0 : complete_lattice (boolean_algebra (finset pos))) : is_compactly_generated (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_177190 (h0 : ring (boolean_algebra.core (option pos))) : is_principal_ideal_ring (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_177191 (h0 : complete_lattice (has_nnnorm (has_lt reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177192 (h0 : group (has_neg linarith.comp)) : is_cyclic (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_177193 (h0 : filter (non_assoc_semiring (option num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177194 (h0 : functor.add_const (uniform_space (has_nndist pos)) linarith.comp) : @separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177195 (h0 : finset (is_R_or_C unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_177196 (h0 : finset (has_Inf (has_neg (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_177197 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring pos))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring pos)) := sorry --non-trivial
lemma new_lemma_177198 (h0 : list (div_inv_monoid string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177199 (h0 : not (topological_space (with_bot unsigned) -> false)) : @discrete_topology.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_177200 (h0 : monoid (boolean_algebra (comm_semigroup real))) : monoid.fg (boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_177201 (h0 : not (function.extfun Type topological_space -> false)) : totally_disconnected_space ennreal := sorry --non-trivial
lemma new_lemma_177202 (h0 : add_group (ordered_comm_ring (ring (has_Inf (has_nndist (has_add pos)))))) : is_add_cyclic (ordered_comm_ring (ring (has_Inf (has_nndist (has_add pos))))) := sorry --non-trivial
lemma new_lemma_177203 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177204 (h0 : functor.add_const (topological_space (bin_tree unsigned)) empty) : @loc_path_connected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_177205 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_177206 (h0 : functor.add_const (add_monoid (ordered_ring empty)) congr_arg_kind) : @add_monoid.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177207 (h0 : uniform_space (semi_normed_comm_ring (random_gen fun_info))) : complete_space (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_177208 (h0 : list (partial_order empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177209 (h0 : topological_space (boolean_algebra.core (measurable_space.dynkin_system unsigned))) : totally_separated_space (boolean_algebra.core (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_177210 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_177211 (h0 : has_mem.mem num has_emptyc.emptyc) : @rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num h0)  := sorry --non-trivial
lemma new_lemma_177212 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177213 (h0 : uniform_space (has_Sup (option unsigned))) : separated_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_177214 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_177215 (h2 : complete_lattice (uniform_space to_additive.value_type)) : is_compactly_generated (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177216 (h0 : topological_space (has_nndist (option (option empty)))) : irreducible_space (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_177217 (h0 h1 : multiset (random_gen (mul_one_class linarith.ineq))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_177218 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177219 (h0 : not (topological_space (partial_order num) -> false)) : @irreducible_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_177220 (h0 : functor.add_const (group (simple_graph linarith.comp)) linarith.comp) : @is_simple_group.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177221 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : irreducible_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_177222 (h0 : topological_space (boolean_algebra (has_Inf (has_add (has_add linarith.comp))))) : loc_path_connected_space (boolean_algebra (has_Inf (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_177223 (h0 : functor.add_const (ring (add_group empty)) num) : @is_domain.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_177224 (h0 : group (add_cancel_monoid (ring (finset (has_Inf name))))) : is_cyclic (add_cancel_monoid (ring (finset (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_177225 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177226 (h0 : ring (boolean_algebra (has_Inf Type))) : strong_rank_condition (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_177227 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) (option (option (option unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_177228 (h0 : topological_space (boolean_algebra.core (ring Type))) : preirreducible_space (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_177229 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177230 (h0 : not (ring (with_one to_additive.value_type) -> false)) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_177231 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @preconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_177232 (h0 : semiring (linear_ordered_field num)) : is_noetherian_ring (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_177233 (h0 : ring (has_to_string (boolean_algebra.core unsigned))) : is_principal_ideal_ring (has_to_string (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_177234 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177235 (h0 : uniform_space (with_zero string_imp)) : complete_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_177236 (h0 : functor.add_const Prop (has_neg_part unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_177237 (h0 : ring (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid real)))) : rank_condition (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_177238 (h0 : functor.add_const (group (has_neg linarith.comp)) (has_neg Type)) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177239 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_177240 (h0 : occurrences -> Prop) (h1 : ordinal) (h2 : has_lt.lt h1 (ordinal.type well_ordering_rel)) : ordinal.bfamily_of_family h0 h1 h2 := sorry --non-trivial
lemma new_lemma_177241 (h0 : group (has_lt enat)) : is_cyclic (has_lt enat) := sorry --non-trivial
lemma new_lemma_177242 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_177243 (h0 : topological_space (uniform_space char)) (h1 : preorder (uniform_space char)) : order_topology (uniform_space char) := sorry --non-trivial
lemma new_lemma_177244 (h0 : functor.add_const (filter (has_neg_part name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177245 (h0 : topological_space (distrib_lattice (random_gen (has_inv linarith.comp_source)))) : t0_space (distrib_lattice (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177246 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_177247 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} num (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_177248 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @totally_separated_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_177249 (h0 : functor.add_const (ordered_add_comm_monoid (has_inter unsigned)) unsigned) : @archimedean.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_inter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177250 (h0 : add_group (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat))))) : is_add_cyclic (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_177251 (h0 : group (sub_neg_monoid (has_Inf (finset (finset linarith.comp))))) : is_simple_group (sub_neg_monoid (has_Inf (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_177252 (h0 : topological_space (cancel_monoid num)) : locally_compact_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_177253 (h0 : add_monoid (has_zero (ring Type))) : add_monoid.fg (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_177254 (h0 : filter (add_group (has_norm (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177255 (h0 : ring (has_norm (has_zero linarith.comp))) : strong_rank_condition (has_norm (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_177256 (h0 : topological_space (complete_distrib_lattice (finset (boolean_algebra environment.implicit_infer_kind)))) : normal_space (complete_distrib_lattice (finset (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_177257 (h0 : functor.add_const (group (has_Inf Type)) Type) : @is_simple_group.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_177258 (h0 : functor.add_const (add_monoid (ordered_comm_monoid pos)) (ring Type)) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_monoid.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177259 (h0 : group (has_nndist (has_add pos))) : is_simple_group (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_177260 (h0 : functor.add_const (group (has_neg_part name)) linarith.comp) : @is_simple_group.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177261 (h0 : function.extfun Type (functor.add_const (group (has_scalar empty num)))) : @is_cyclic.{0} (has_scalar.{0 0} empty num) (@functor.add_const.run.{0 0} (group.{0} (has_scalar.{0 0} empty num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_scalar.{0 0} empty num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_177262 (h0 : topological_space (with_bot (has_top linarith.ineq))) : totally_separated_space (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177263 (h0 : semiring (simple_graph congr_arg_kind)) : is_noetherian_ring (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177264 (h0 : topological_space (has_le char)) (h1 : set (has_le char)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_177265 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : preconnected_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177266 (h0 : group (has_add num)) : normalizer_condition (has_add num) := sorry --non-trivial
lemma new_lemma_177267 (h0 : option (topological_space (has_norm string_imp))) (h1 : coe_sort (option.is_some h0)) : @locally_compact_space.{0} (has_norm.{0} string_imp) (@option.get.{0} (topological_space.{0} (has_norm.{0} string_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_177268 (h0 : ring (with_bot unsigned)) : strong_rank_condition (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_177269 (h0 : add_group (distrib_lattice (random_gen linarith.ineq))) : is_add_cyclic (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177270 (h1 : monoid (denumerable string_imp)) : monoid.fg (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_177271 (h0 : finset (ordered_comm_monoid (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_177272 (h0 : topological_space (linear_ordered_add_comm_group (random_gen fun_info))) : irreducible_space (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_177273 (h0 : topological_space (semiring (has_norm (semiring (semiring unsigned))))) : t0_space (semiring (has_norm (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_177274 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_177275 (h0 : filter (has_neg_part (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_177276 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177277 (h0 : topological_space (boolean_algebra.core (has_add (has_add Type)))) : discrete_topology (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_177278 (h0 : monoid (boolean_algebra.core (has_neg_part pos))) : monoid.fg (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_177279 (h0 : functor.comp ring has_to_string name) : @is_domain.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_177280 (h2 : ring fun_info) : is_domain fun_info := sorry --non-trivial
lemma new_lemma_177281 (h0 : group (complete_linear_order (has_top empty))) : is_cyclic (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_177282 (h0 : topological_space (has_nndist (has_neg_part unsigned))) : regular_space (has_nndist (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_177283 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring name))) : unique_factorization_monoid (partial_order (semiring name)) := sorry --non-trivial
lemma new_lemma_177284 (h0 : topological_space (add_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (add_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177285 (h0 : functor.add_const (has_lt (has_Sup unsigned)) unsigned) : @no_min_order.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (has_lt.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177286 (h0 : functor.add_const (topological_space (cancel_monoid Type)) environment.implicit_infer_kind) : @t0_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177287 (h0 : ring (has_nndist (ring (ring (ring linarith.comp))))) : is_domain (has_nndist (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_177288 (h0 : topological_space (has_zero (finset pos))) : topological_space.separable_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_177289 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177290 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_177291 (h0 : functor.comp filter mul_zero_class pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_177292 (h0 : ring (random_gen (random_gen (random_gen to_additive.value_type)))) : is_domain (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_177293 (h0 : functor.add_const (add_cancel_monoid Type) Type) : list.nodup (list.ret (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_177294 (h0 : complete_lattice (normed_field (has_nnnorm char))) : is_compactly_generated (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_177295 (h0 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @t0_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_177296 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_inner.{0 0} unsigned unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned unsigned))  := sorry --non-trivial
lemma new_lemma_177297 (h0 : functor.add_const (group (has_neg linarith.comp)) (has_neg Type)) : @is_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177298 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177299 (h0 : ring (measurable_space (random_gen (random_gen linarith.comp_source)))) : rank_condition (measurable_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_177301 (h0 : not (ring (with_one fun_info) -> false)) : @strong_rank_condition.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_177302 (h0 : add_monoid (semiring congr_arg_kind)) : add_monoid.fg (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177303 (h1 : not (topological_space (add_monoid char) -> false)) : @path_connected_space.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_177304 (h0 : ring (denumerable (has_lt (random_gen (has_nnnorm (has_lt fun_info)))))) : is_domain (denumerable (has_lt (random_gen (has_nnnorm (has_lt fun_info))))) := sorry --non-trivial
lemma new_lemma_177305 (h0 : topological_space (has_neg_part ennreal)) : t0_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_177306 (h0 : topological_space unsigned) : locally_compact_space unsigned := sorry --non-trivial
lemma new_lemma_177307 (h0 : topological_space (canonically_ordered_comm_semiring (ring name))) : discrete_topology (canonically_ordered_comm_semiring (ring name)) := sorry --non-trivial
lemma new_lemma_177308 (h0 : function.extfun Type (functor.add_const (list (non_assoc_semiring empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_177309 (h0 : group (has_norm (has_nnnorm (has_nnnorm char)))) : is_cyclic (has_norm (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_177310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177311 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177312 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @regular_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_177313 (h1 : topological_space (has_compl linarith.comp_source)) : path_connected_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177314 (h0 : ring (random_gen (has_nnnorm reducibility_hints))) : strong_rank_condition (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177315 (h0 : topological_space (measurable_space.dynkin_system pos)) : t0_space (measurable_space.dynkin_system pos) := sorry --non-trivial
lemma new_lemma_177316 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177317 : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@filter.coclosed_compact.{0} Prop sierpinski_space)  := sorry --non-trivial
lemma new_lemma_177318 (h0 : topological_space (nondiscrete_normed_field fun_info)) : topological_space.first_countable_topology (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_177319 (h0 : function.extfun Type group) : @is_simple_group.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177320 (h0 : complete_lattice (semi_normed_ring ereal)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring ereal) := sorry --non-trivial
lemma new_lemma_177321 (h0 : group (comm_ring string.iterator_imp)) : is_cyclic (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_177322 (h0 : ring (left_cancel_monoid num)) : is_principal_ideal_ring (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_177323 (h0 : ring (has_top (has_norm (has_norm linarith.comp_source)))) : is_domain (has_top (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177324 (h0 : not (semiring (bin_tree congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_177325 (h0 : topological_space (has_nndist (option ennreal))) : preirreducible_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_177326 (h0 : ring (linear_ordered_comm_group (option (option (option empty))))) : is_principal_ideal_ring (linear_ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_177327 (h0 : functor.add_const (ring linarith.comp) Type) : @is_principal_ideal_ring.{0} linarith.comp (@functor.add_const.run.{0 1} (ring.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_177328 (h0 : group (boolean_algebra (finset (has_Inf pos)))) : is_simple_group (boolean_algebra (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_177329 (h0 : uniform_space (semi_normed_ring (has_ssubset linarith.ineq))) : complete_space (semi_normed_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177330 (h0 : not (complete_lattice (has_star empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177331 (h0 : functor.add_const (ring (partial_order num)) num) : @strong_rank_condition.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_177332 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @separated_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177333 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_177334 (h0 : uniform_space znum) : separated_space znum := sorry --non-trivial
lemma new_lemma_177335 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177336 (h0 : not (group (option num) -> false)) : @normalizer_condition.{0} (option.{0} num) (@classical.by_contradiction'.{1} (group.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_177337 (h0 : ring (has_pos_part (has_neg Type))) : strong_rank_condition (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_177338 (h1 : ring (has_nnnorm string_imp)) : rank_condition (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_177339 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))  := sorry --non-trivial
lemma new_lemma_177341 (h0 : ring (metric_space char)) : rank_condition (metric_space char) := sorry --non-trivial
lemma new_lemma_177342 (h0 : topological_space (mul_one_class (add_comm_semigroup fun_info))) (h1 : set (mul_one_class (add_comm_semigroup fun_info))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_177343 (h0 : function.extfun Type preorder) (h1 : topological_space rat -> Prop) : Inf_convergence_class rat := sorry --non-trivial
lemma new_lemma_177344 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_177345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_177346 (h0 : topological_space (comm_semigroup (ordered_comm_monoid real))) : topological_space.separable_space (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_177347 (h0 : complete_lattice (random_gen to_additive.value_type)) : is_atomistic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177348 (h0 : complete_lattice (normed_group (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_177349 (h0 : set (add_comm_semigroup (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_177350 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_177351 (h0 : topological_space (has_Inf linarith.comp)) : normal_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_177352 (h0 : ring string.iterator_imp) : rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_177353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177354 (h0 : semiring (linear_ordered_comm_monoid_with_zero (semiring empty))) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_177355 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177356 (h1 : preorder enat) (h3 : Prop) : set.is_pwo (id (fun (h2 : enat), h3)) := sorry --non-trivial
lemma new_lemma_177357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177358 (h0 : topological_space (ring (add_comm_monoid Type))) : path_connected_space (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_177359 (h0 : not (add_group (partial_order congr_arg_kind) -> false)) : @is_add_cyclic.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_177360 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177361 (h0 : functor.add_const (group (has_add linarith.comp)) pos) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_177362 (h0 : add_group (has_to_string (ring Type))) : is_add_cyclic (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_177363 (h0 : group (finset (has_add linarith.comp))) : is_simple_group (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_177364 (h0 : has_mem.mem linarith.ineq has_emptyc.emptyc) : @is_cyclic.{0} linarith.ineq (@finset.pi.empty.{1 0} Type group.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_177365 (h1 : not (group linarith.comp -> false)) : @normalizer_condition.{0} linarith.comp (@classical.by_contradiction'.{1} (group.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_177366 (h0 : group (div_inv_monoid to_additive.value_type)) : is_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177367 (h0 : topological_space (has_neg (mul_zero_class (option ennreal)))) : t1_space (has_neg (mul_zero_class (option ennreal))) := sorry --non-trivial
lemma new_lemma_177368 (h1 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @discrete_topology.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_177369 (h0 : ring (with_bot (has_norm num))) : rank_condition (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_177370 (h0 : functor.add_const (list (canonically_linear_ordered_monoid pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177371 (h0 : topological_space (sub_neg_monoid (has_Inf (finset pos)))) : locally_compact_space (sub_neg_monoid (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_177372 (h0 : not (filter (fintype (fintype linarith.comp_source)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_177373 (h0 : topological_space (semiring (has_norm empty))) : irreducible_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_177374 (h1 : topological_space (denumerable (has_ssubset (has_ssubset linarith.comp_source)))) : path_connected_space (denumerable (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177375 (h0 : topological_space (add_comm_monoid (pseudo_metric_space ennreal))) : totally_separated_space (add_comm_monoid (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_177376 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_177377 (h1 : ring (normed_field string_imp)) : strong_rank_condition (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_177378 (h1 : complete_lattice (nondiscrete_normed_field fun_info)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_177379 (h0 : add_group (has_inv fun_info)) : is_add_cyclic (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_177380 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) name) : @t1_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_177381 (h0 : ring (plift (semiring congr_arg_kind))) : rank_condition (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177382 (h0 : topological_space (has_norm (semiring fun_info))) : totally_separated_space (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_177383 (h0 : uniform_space real) : complete_space real := sorry --non-trivial
lemma new_lemma_177384 (h0 : topological_space (finset unsigned)) : t0_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_177385 (h0 : topological_space (has_bot (option (option unsigned)))) : totally_separated_space (has_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_177386 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_177387 (h0 : uniform_space (topological_space (random_gen char))) : complete_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_177388 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @totally_separated_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_177390 (h0 : topological_space (has_neg (finset (has_add (has_add pos))))) : totally_separated_space (has_neg (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_177391 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_177392 (h0 : functor.add_const (ring (boolean_algebra.core ennreal)) unsigned) : @rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177393 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177394 (h0 : function.extfun nat fin) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_177395 (h0 : topological_space (complete_distrib_lattice (has_nndist Type))) : topological_space.separable_space (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_177396 (h0 : topological_space (encodable (has_nnnorm (random_gen (random_gen linarith.ineq))))) : irreducible_space (encodable (has_nnnorm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_177397 (h0 : topological_space (add_cancel_monoid (ring (has_add linarith.comp)))) : preirreducible_space (add_cancel_monoid (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_177398 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177399 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup pos)) Type) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_177400 (h0 : functor.add_const (topological_space (has_star num)) (semiring (semiring empty))) : @t0_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177401 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_177402 (h0 : not (ring (linear_ordered_add_comm_group fun_info) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_177403 (h0 : measurable_space (add_cancel_monoid empty)) (h1 : has_mul (add_cancel_monoid empty)) : has_measurable_mul₂ (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_177404 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} (has_to_string.{0} (has_to_string.{0} (has_to_string.{0} (has_to_string.{0} pos))))) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} (has_to_string.{0} (has_to_string.{0} (has_to_string.{0} (has_to_string.{0} pos))))))  := sorry --non-trivial
lemma new_lemma_177405 (h0 : add_group (generalized_boolean_algebra (has_add name))) : is_add_cyclic (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_177406 (h0 : complete_lattice (has_norm (semiring (semiring (semiring (semiring num)))))) : is_compactly_generated (has_norm (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_177407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_177408 (h0 : not (topological_space (plift empty) -> false)) : @discrete_topology.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177409 (h0 : to_additive.value_type -> fun_info -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_177410 (h0 : not (topological_space (random_gen to_additive.value_type) -> false)) : @locally_compact_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_177411 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177412 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_177413 (h0 : topological_space (has_neg (ring (has_add (has_to_string name))))) : path_connected_space (has_neg (ring (has_add (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_177414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177415 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177416 (h1 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @rank_condition.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_177417 (h0 : function.extfun nat fin) : @archimedean.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_177418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_177419 (h0 : semiring (option (option pos))) : is_noetherian_ring (option (option pos)) := sorry --non-trivial
lemma new_lemma_177420 (h0 : topological_space (finset (has_neg (has_Inf Type)))) : irreducible_space (finset (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_177421 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177422 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177423 (h0 : list (boolean_algebra (finset (finset (finset Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177424 (h0 : topological_space (option pos)) : totally_disconnected_space (option pos) := sorry --non-trivial
lemma new_lemma_177425 (h0 : functor.add_const (monoid (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177426 (h0 : not (topological_space (has_star empty) -> false)) : @topological_space.separable_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177427 (h0 : functor.add_const (topological_space (has_neg_part name)) (option pos)) : @irreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_177428 (h0 : complete_lattice (has_sdiff to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_sdiff to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177429 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @normal_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177430 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @topological_space.separable_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_177431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_group.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_177432 (h0 : add_group (mul_one_class (simple_graph reducibility_hints))) : is_add_cyclic (mul_one_class (simple_graph reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177434 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177435 (h0 : semigroup (option ennreal) -> semigroup (option ennreal) -> Prop) : is_symm (semigroup (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_177436 (h0 : topological_space (semigroup Type)) : topological_space.separable_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_177437 (h0 : functor.add_const (group (ring pos)) pos) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177438 (h0 : ring (ordered_cancel_add_comm_monoid (has_to_string (has_to_string num)))) : strong_rank_condition (ordered_cancel_add_comm_monoid (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_177439 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177440 (h0 : ring (normed_comm_ring (comm_group ennreal))) : is_principal_ideal_ring (normed_comm_ring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_177441 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177442 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_177443 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_177444 (h1 : group (has_nnnorm linarith.ineq)) : is_cyclic (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_177445 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177446 (h0 : ring (generalized_boolean_algebra (has_neg (has_neg (has_neg name))))) : rank_condition (generalized_boolean_algebra (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_177447 (h0 : set (has_ssubset string.iterator -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_177448 (h0 : functor.add_const (group (add_comm_monoid pos)) (finset (ring linarith.comp))) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (finset.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177449 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : regular_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177450 (h0 : multiset (semi_normed_comm_ring string_imp)) (h1 : not (multiset (semi_normed_comm_ring string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_177451 (h1 : ring (div_inv_monoid linarith.comp_source)) : is_domain (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177452 (h0 : add_group (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) : is_add_cyclic (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_177453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_177454 (h0 : add_monoid (finset name)) : add_monoid.fg (finset name) := sorry --non-trivial
lemma new_lemma_177455 (h0 : topological_space (cancel_monoid (comm_group (semigroup Type)))) : preirreducible_space (cancel_monoid (comm_group (semigroup Type))) := sorry --non-trivial
lemma new_lemma_177456 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177457 (h0 : complete_lattice (simple_graph ereal)) : complete_lattice.is_Sup_finite_compact (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_177458 (h0 : ring (complete_distrib_lattice (has_add Type))) : strong_rank_condition (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_177459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_177460 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid (has_bot real))) : unique_factorization_monoid (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_177461 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) linarith.comp) pos) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_177462 (h0 : complete_lattice (has_add name)) : complete_lattice.is_Sup_finite_compact (has_add name) := sorry --non-trivial
lemma new_lemma_177463 (h0 : functor.add_const (list (left_cancel_semigroup empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177464 (h0 : topological_space (add_cancel_comm_monoid empty)) : preirreducible_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_177465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177466 (h0 : function.extfun Type (functor.comp finset has_nndist)) : finset.nonempty (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_177467 (h0 : topological_space (has_nndist (finset (boolean_algebra environment.implicit_infer_kind)))) : totally_disconnected_space (has_nndist (finset (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_177468 (h0 : ring (simple_graph (finset Type))) : strong_rank_condition (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_177469 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : discrete_topology real := sorry --non-trivial
lemma new_lemma_177470 (h0 : complete_lattice fun_info) : is_compactly_generated fun_info := sorry --non-trivial
lemma new_lemma_177471 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) pos) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_177472 (h0 : topological_space (ordered_comm_ring (has_pos_part real))) : t1_space (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_177473 (h0 : filter (has_one (has_norm (has_norm (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177474 (h0 : ring (has_nnnorm string_imp)) : strong_rank_condition (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_177475 (h0 : topological_space (random_gen linarith.comp_source)) : irreducible_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177476 (h0 : complete_lattice (has_nnnorm (has_ssubset reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177477 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_177478 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177479 (h0 : functor.add_const (group (plift empty)) empty) : @normalizer_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_177480 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : discrete_topology (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177481 (h0 : topological_space (random_gen (has_top congr_arg_kind))) : locally_compact_space (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177482 (h2 : topological_space string.iterator_imp) : totally_disconnected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_177483 (h0 : topological_space (pseudo_metric_space (has_nndist (finset pos)))) : totally_separated_space (pseudo_metric_space (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_177484 (h0 : functor.add_const (monoid (has_zero name)) pos) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_177485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177486 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @t0_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_177487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_177488 (h0 : topological_space (add_comm_monoid (option (option (option ennreal))))) : normal_space (add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_177489 (h0 : topological_space (mul_zero_class unsigned)) : locally_compact_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_177490 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177491 (h0 : uniform_space (preorder (semiring (semiring empty)))) : separated_space (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_177492 (h1 : complete_lattice num) : is_atomistic num := sorry --non-trivial
lemma new_lemma_177493 (h0 : semiring (linear_ordered_cancel_comm_monoid (option (option empty)))) : is_noetherian_ring (linear_ordered_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_177494 (h0 : function.extfun nat fin) : @t0_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_177495 (h0 : ring (bin_tree (semiring empty))) : rank_condition (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_177496 (h0 : topological_space (has_to_string (has_add (has_add (has_add (has_add (has_add Type))))))) : regular_space (has_to_string (has_add (has_add (has_add (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_177497 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @t0_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177498 (h0 : function.extfun (ordered_ring unsigned) (fun (x : ordered_ring unsigned), Prop)) (h1 : ordered_ring unsigned -> ordered_ring unsigned -> Prop) : set.partially_well_ordered_on (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_177499 (h0 : has_add Type) : set.add_center Type enat := sorry --non-trivial
lemma new_lemma_177500 (h0 : functor.add_const (uniform_space (boolean_algebra unsigned)) linarith.comp) : @separated_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177501 (h0 : uniform_space (pseudo_metric_space (option (option unsigned)))) : separated_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_177502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177503 (h0 : functor.add_const (complete_lattice (comm_group environment.implicit_infer_kind)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_177504 (h0 : ring (uniform_space fun_info)) : is_domain (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_177505 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_177506 (h0 : has_to_string (has_inter ennreal) -> has_to_string (has_inter ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_177507 (h0 : topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) : t0_space (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177508 (h0 : functor.add_const (functor.add_const (topological_space (measurable_space.dynkin_system empty)) num) num) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num) num h0))  := sorry --non-trivial
lemma new_lemma_177509 (h0 : finset (finset (has_Inf (has_Inf linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_177510 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (sub_neg_monoid Type))) : archimedean (canonically_linear_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_177511 (h0 : group (normed_field (has_nnnorm (has_nnnorm string.iterator_imp)))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_177512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_177513 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177514 (h0 : topological_space (has_zero (has_neg_part unsigned))) : preconnected_space (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_177515 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_177516 (h0 : topological_space (free_add_monoid (semiring empty))) : t1_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_177517 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : preirreducible_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177518 (h0 : complete_lattice (pseudo_metric_space (finset (finset ennreal)))) : is_compactly_generated (pseudo_metric_space (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_177519 (h0 : topological_space (complete_distrib_lattice (generalized_boolean_algebra pos))) : sequential_space (complete_distrib_lattice (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_177520 (h0 : functor.add_const (uniform_space (has_neg pos)) Type) : @complete_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_177521 (h0 : functor.add_const (semiring (generalized_boolean_algebra Type)) linarith.comp) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177522 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_177523 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset (finset Type))) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} (finset.{1} Type)) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_177524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_177525 (h1 : group (fintype string_imp)) : is_cyclic (fintype string_imp) := sorry --non-trivial
lemma new_lemma_177526 (h0 : ring (normed_comm_ring pos)) : rank_condition (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_177527 (h0 : not (function.extfun (Type 1) complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_177528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} (has_neg_part.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} (has_neg_part.{0} pos)))  := sorry --non-trivial
lemma new_lemma_177529 (h0 : add_group (ring linarith.comp)) : is_add_cyclic (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_177530 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_177531 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_nndist name))) : unique_factorization_monoid (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_177532 (h0 : topological_space (semiring (has_norm linarith.comp))) : locally_compact_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_177533 (h0 : ring (option (semiring unsigned))) : rank_condition (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177534 (h0 : group (measurable_space (has_top (random_gen (random_gen to_additive.value_type))))) : normalizer_condition (measurable_space (has_top (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_177535 (h0 : not (topological_space (has_sub empty) -> false)) : @preirreducible_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177536 (h0 : finset (canonically_ordered_comm_semiring (mul_zero_class name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_177537 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_177538 (h0 : topological_space (filter empty)) : preirreducible_space (filter empty) := sorry --non-trivial
lemma new_lemma_177539 (h0 : fin has_zero.zero) : @discrete_topology.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_177540 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) congr_arg_kind) : @preirreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177541 (h0 : ring (has_neg (has_add (finset (finset (finset name)))))) : rank_condition (has_neg (has_add (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_177542 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177543 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid empty)))) : @irreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_177544 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_177545 (h0 : topological_space (normed_comm_ring (has_Inf environment.implicit_infer_kind))) : irreducible_space (normed_comm_ring (has_Inf environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177546 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177547 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_177548 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_177549 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option ennreal)) := sorry --non-trivial
lemma new_lemma_177550 (h0 : complete_lattice (has_Sup (option (option (option (option unsigned)))))) : is_compactly_generated (has_Sup (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_177551 (h0 : topological_space (has_star empty)) : loc_path_connected_space (has_star empty) := sorry --non-trivial
lemma new_lemma_177552 (h0 : ring (ring (option (has_to_string congr_arg_kind)))) : is_principal_ideal_ring (ring (option (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_177553 (h0 : list (ring (add_comm_monoid pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177554 (h0 : complete_lattice (has_norm (semiring empty))) : is_atomistic (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_177555 (h0 : add_monoid (ordered_cancel_add_comm_monoid unsigned)) : add_monoid.fg (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_177556 (h0 : functor.add_const (topological_space (has_edist empty)) (option (option empty))) : @preirreducible_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177557 (h0 : functor.add_const (finset (boolean_algebra.core pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177558 (h0 : functor.add_const (list (canonically_ordered_comm_semiring unsigned)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177559 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @complete_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177560 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177561 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field name)) := sorry --non-trivial
lemma new_lemma_177562 (h0 : functor.add_const (topological_space (has_neg name)) name) : @path_connected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_177563 (h0 : not (topological_space (id linarith.comp) -> false)) : @path_connected_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177564 (h1 : uniform_space (has_inv linarith.ineq)) : complete_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_177565 (h0 : monoid (semigroup (has_neg_part pos))) : monoid.fg (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_177566 (h0 : preorder (id empty)) (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (@locally_finite_order.{0} (@id.{2} Type empty) h0) (@function.extfun_app.{2 1} Type add_group.{0} h1 (@locally_finite_order.{0} (@id.{2} Type empty) h0))  := sorry --non-trivial
lemma new_lemma_177567 (h0 : complete_lattice (with_one (has_top linarith.comp_source))) : is_atomistic (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177568 (h0 : add_group (has_nnnorm (has_nnnorm to_additive.value_type))) : is_add_cyclic (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177569 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring pos)) (comm_group pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177570 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_177571 (h0 : add_group (with_one linarith.comp)) : is_simple_add_group (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_177572 (h0 : group (semiring (semiring congr_arg_kind))) : is_cyclic (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177573 (h0 : group (ordered_comm_group num)) : group.fg (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_177574 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_177575 (h0 : add_group (has_emptyc (has_norm fun_info))) : is_add_cyclic (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_177576 (h3 : add_group (has_div reducibility_hints)) : is_add_cyclic (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_177577 (h0 : has_nndist (ring empty) -> has_nndist (ring empty) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_177578 (h1 : ring (has_append (random_gen (has_nnnorm char)))) : strong_rank_condition (has_append (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_177579 (h0 : functor.add_const (add_monoid (semigroup Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177580 (h0 : add_group (has_ssubset (random_gen (comm_group (random_gen (comm_ring linarith.comp_source)))))) : is_add_cyclic (has_ssubset (random_gen (comm_group (random_gen (comm_ring linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_177581 (h0 : list (has_sub string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177582 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_177583 (h0 : add_group (has_one (semiring (semiring (semiring num))))) : is_add_cyclic (has_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_177584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177585 (h0 : topological_space (has_neg (has_add linarith.comp))) : normal_space (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_177586 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra pos))) : loc_path_connected_space (canonically_ordered_comm_semiring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_177587 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177588 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) (ring (ring (ring Type)))) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) (ring.{1} (ring.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_177589 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177590 (h0 : not (topological_space (normed_group unsigned) -> false)) : @t0_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_177591 (h0 : functor.add_const (monoid (boolean_algebra.core linarith.comp)) linarith.comp) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177592 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_group num)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_group.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_177593 (h0 : topological_space (add_group (semiring (semiring linarith.comp)))) : preirreducible_space (add_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_177594 (h0 : ring (non_unital_non_assoc_semiring string_imp)) : is_domain (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_177595 (h1 : ring (has_ssubset char)) : rank_condition (has_ssubset char) := sorry --non-trivial
lemma new_lemma_177596 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : locally_compact_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_177597 (h0 : topological_space (partial_order (semiring empty))) : t1_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_177598 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core Type)) environment.implicit_infer_kind) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177599 (h0 : monoid (has_neg (has_add (has_add linarith.comp)))) : monoid.fg (has_neg (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_177600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_177601 (h0 : uniform_space (linear_ordered_semiring (has_top to_additive.value_type))) : complete_space (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177602 (h0 : functor.add_const (list (complete_distrib_lattice Type)) (has_add Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177604 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core name))) : regular_space (ordered_comm_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_177605 (h1 : set (has_ssubset linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_177606 (h1 : ring (distrib_lattice linarith.ineq)) : is_domain (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_177607 (h0 : topological_space (has_bot (option unsigned))) : totally_disconnected_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_177608 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ring ennreal)) := sorry --non-trivial
lemma new_lemma_177610 (h1 : ring (random_gen (has_nnnorm fun_info))) : rank_condition (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_177611 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177612 (h0 : complete_lattice (has_Inf linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_177613 (h0 : function.extfun Type ring) : @is_domain.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_177614 (h0 : topological_space (with_bot empty)) : discrete_topology (with_bot empty) := sorry --non-trivial
lemma new_lemma_177615 (h0 : filter (add_comm_monoid (has_neg pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_177616 (h0 : complete_lattice (has_one (has_top num))) : is_atomistic (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_177617 (h0 : semiring (normed_comm_ring (boolean_algebra (has_neg name)))) : is_noetherian_ring (normed_comm_ring (boolean_algebra (has_neg name))) := sorry --non-trivial
lemma new_lemma_177618 (h0 : uniform_space (with_bot (has_sdiff num))) : separated_space (with_bot (has_sdiff num)) := sorry --non-trivial
lemma new_lemma_177619 (h0 : not (prod unsigned unsigned -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_177620 (h0 : functor.add_const (add_group (has_add linarith.comp)) (has_add (boolean_algebra.core linarith.comp))) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} linarith.comp)) (has_add.{0} (boolean_algebra.core.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177621 (h0 : complete_lattice (encodable to_additive.value_type)) : is_compactly_generated (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177622 (h0 : uniform_space (has_lt char)) : complete_space (has_lt char) := sorry --non-trivial
lemma new_lemma_177623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (preorder.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (preorder.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177624 (h0 : function.extfun Type group) : @group.fg.{0} (group_with_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_177625 (h1 : topological_space (has_ssubset string.iterator_imp)) : t0_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_177626 (h0 : group (has_zero (has_zero ennreal))) : normalizer_condition (has_zero (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_177627 (h0 : topological_space (has_zero num)) : locally_compact_space (has_zero num) := sorry --non-trivial
lemma new_lemma_177628 (h0 : uniform_space (has_neg (boolean_algebra name))) : separated_space (has_neg (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_177629 (h0 : topological_space (ordered_comm_ring Type)) : sequential_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_177630 (h0 : filter (id empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177631 (h0 : topological_space (has_neg (add_comm_monoid environment.implicit_infer_kind))) : topological_space.separable_space (has_neg (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177632 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_177633 (h0 : uniform_space (simple_graph Type)) : separated_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_177634 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_177635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177636 (h0 : topological_space (has_pos_part (sub_neg_monoid (ordered_comm_monoid name)))) : discrete_topology (has_pos_part (sub_neg_monoid (ordered_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_177637 (h0 : uniform_space (has_neg (has_neg Type))) : separated_space (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_177638 (h0 : topological_space (linear_ordered_field (option pos))) : preconnected_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_177639 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_177640 (h0 : topological_space (has_neg (has_to_string (has_neg_part pos)))) : preirreducible_space (has_neg (has_to_string (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_177641 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177642 (h0 : functor.add_const (topological_space (has_pos_part real)) Type) : @regular_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_177643 (h0 : topological_space (bin_tree (semiring (semiring empty)))) : t1_space (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_177644 (h0 : topological_space (semigroup (option (add_left_cancel_semigroup (option unsigned))))) : t1_space (semigroup (option (add_left_cancel_semigroup (option unsigned)))) := sorry --non-trivial
lemma new_lemma_177645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177646 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177647 (h0 : functor.add_const (function.extfun Type list) (has_add pos)) : list.nodup (function.extfun_app (functor.add_const.run h0) unsigned) := sorry --non-trivial
lemma new_lemma_177648 (h0 : topological_space (has_neg (has_add (finset ennreal)))) : normal_space (has_neg (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_177649 (h0 : group (normed_field reducibility_hints)) : is_cyclic (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_177650 (h0 : uniform_space (linear_order (option congr_arg_kind))) : separated_space (linear_order (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177652 (h0 : ring (has_compl (has_compl to_additive.value_type))) : rank_condition (has_compl (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177653 (h0 : ring (add_semigroup unsigned)) : strong_rank_condition (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_177654 (h0 : functor.add_const (uniform_space (semigroup pos)) pos) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177655 (h0 : topological_space (finset (option (option ennreal)))) : normal_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_177656 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @regular_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_177657 (h0 : functor.add_const (function.extfun Type list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_177658 (h0 : functor.add_const (topological_space ennreal) num) : t1_space ennreal := sorry --non-trivial
lemma new_lemma_177659 (h0 : topological_space (normed_lattice_add_comm_group real)) : sequential_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_177660 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_177661 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra name)))) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_177662 (h0 : topological_space (semigroup (finset (finset ennreal)))) : topological_space.separable_space (semigroup (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_177663 (h0 : uniform_space (normed_linear_ordered_group congr_arg_kind)) : complete_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177664 (h0 : functor.comp cancel_comm_monoid_with_zero has_add pos) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_177665 (h0 : topological_space (complete_distrib_lattice (has_pos_part pos))) : t1_space (complete_distrib_lattice (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_177666 (h0 : complete_lattice (has_add char)) : is_compactly_generated (has_add char) := sorry --non-trivial
lemma new_lemma_177667 (h0 : has_neg fun_info) (h1 : has_mem.mem fun_info has_emptyc.emptyc) : @has_measurable_neg.{0} fun_info h0 (@finset.pi.empty.{1 0} Type measurable_space.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_177668 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) (has_Inf linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177669 (h0 : topological_space (add_cancel_monoid (semigroup unsigned))) : locally_compact_space (add_cancel_monoid (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_177670 (h0 : group (complete_distrib_lattice (sub_neg_monoid (has_Inf real)))) : group.fg (complete_distrib_lattice (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_177671 (h0 : functor.add_const (add_monoid (boolean_algebra.core pos)) pos) : @add_monoid.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177672 (h0 : topological_space (plift (left_cancel_semigroup unsigned))) : totally_disconnected_space (plift (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_177673 (h0 : ring (has_zero (has_nndist ennreal))) : is_principal_ideal_ring (has_zero (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_177674 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_177675 (h0 : complete_lattice (random_gen (has_inv to_additive.value_type))) : is_atomistic (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177676 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177677 (h0 : filter (has_nnnorm (random_gen (has_inv (random_gen (random_gen to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_177679 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_177680 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177681 (h0 : ring (ordered_comm_ring (has_neg real))) : is_domain (ordered_comm_ring (has_neg real)) := sorry --non-trivial
lemma new_lemma_177682 (h0 : group (cancel_monoid (comm_group name))) : group.fg (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_177683 (h0 : add_group (random_gen (comm_ring char))) : is_add_cyclic (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_177684 (h0 : topological_space (generalized_boolean_algebra string_imp)) : t0_space (generalized_boolean_algebra string_imp) := sorry --non-trivial
lemma new_lemma_177685 (h0 : topological_space (linear_ordered_add_comm_group (has_norm num))) : path_connected_space (linear_ordered_add_comm_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_177686 (h0 : ring (linear_ordered_comm_group (option ennreal))) : is_domain (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_177687 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177688 (h0 : topological_space (has_to_string Type)) : sequential_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_177689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_177690 (h0 : not (uniform_space (with_one (random_gen (random_gen (random_gen num)))) -> false)) : @separated_space.{0} (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) h0)  := sorry --non-trivial
lemma new_lemma_177691 (h0 : ordered_comm_monoid (ordered_comm_ring (finset linarith.comp))) : has_exists_mul_of_le (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_177692 (h0 : function.extfun (finset Type) (has_mem.mem (with_one to_additive.value_type))) : @strong_rank_condition.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_177693 (h0 : ring (has_lt to_additive.value_type)) : strong_rank_condition (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177694 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177695 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177696 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_177697 (h0 : ring (pseudo_metric_space (cancel_monoid name))) : strong_rank_condition (pseudo_metric_space (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_177698 (h0 : not (ordered_add_comm_monoid (has_compl fun_info) -> false)) : @archimedean.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (ordered_add_comm_monoid.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_177699 (h0 : has_mem.mem (finset name) has_zero.zero) : finset.nonempty (multiset.pi.empty finset (finset name) h0) := sorry --non-trivial
lemma new_lemma_177700 (h0 : uniform_space (has_one (semiring unsigned))) : separated_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177701 (h0 : topological_space (comm_group Type)) : normal_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_177702 (h0 : add_group (mul_zero_class unsigned)) : add_group.fg (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_177703 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_177704 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) unsigned) : @is_simple_group.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177705 (h0 : functor.add_const (complete_lattice (ring name)) name) : @is_atomistic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_177706 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_neg_part (has_zero unsigned))) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_neg_part.{0} (has_zero.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_177707 (h0 : group (has_to_string (has_add Type))) : group.fg (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_177708 (h0 : topological_space (with_bot (random_gen (random_gen linarith.ineq)))) : totally_separated_space (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_177709 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring environment.implicit_infer_kind)) pos) : @unique_factorization_monoid.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_177710 (h0 : topological_space (measure_theory.measure_space unsigned)) : irreducible_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_177711 (h0 : complete_lattice (fintype (fintype (random_gen char)))) : complete_lattice.is_Sup_finite_compact (fintype (fintype (random_gen char))) := sorry --non-trivial
lemma new_lemma_177712 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177713 (h0 : functor.add_const (topological_space (plift empty)) congr_arg_kind) : @totally_disconnected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177714 (h0 : ordered_comm_monoid (ring (option (complete_distrib_lattice (option pos))))) : has_exists_mul_of_le (ring (option (complete_distrib_lattice (option pos)))) := sorry --non-trivial
lemma new_lemma_177715 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177716 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177717 (h0 : group (option empty)) : group.fg (option empty) := sorry --non-trivial
lemma new_lemma_177718 (h0 : ring (add_group (semiring unsigned))) : rank_condition (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177719 (h1 : has_mem.mem num has_emptyc.emptyc) : @is_compactly_generated.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num h1)  := sorry --non-trivial
lemma new_lemma_177720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177721 (h0 : function.extfun (Type 1) (functor.add_const (monoid (ring linarith.comp)))) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (ring.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (monoid.{0} (ring.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_177722 (h0 : list (has_to_string (option (measurable_space.dynkin_system unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177723 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_177724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_177725 (h0 : topological_space (plift (bin_tree num))) : totally_disconnected_space (plift (bin_tree num)) := sorry --non-trivial
lemma new_lemma_177726 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part Type)) (has_add Type)) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177727 (h0 : functor.add_const (finset (semigroup linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177728 (h0 : topological_space (id congr_arg_kind)) : path_connected_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177729 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_177730 (h0 : not (group unsigned -> false)) : @group.fg.{0} unsigned (@classical.by_contradiction'.{1} (group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_177731 (h1 : ring (has_ssubset ereal)) : rank_condition (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_177732 (h2 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : is_compactly_generated (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177733 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_177734 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177735 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_177736 (h0 : list (distrib_lattice linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177737 (h0 : function.extfun Type topological_space) : @normal_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177738 (h0 : function.extfun (fun_info -> Type) (function.extfun fun_info)) : Exists (function.extfun_app (function.extfun_app h0 (fun (x : fun_info), Prop))) := sorry --non-trivial
lemma new_lemma_177739 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177740 (h0 : add_monoid (boolean_algebra (has_Inf real))) : add_monoid.fg (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_177741 (h0 : not (uniform_space (semi_normed_ring reducibility_hints) -> false)) : @complete_space.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_177742 (h0 : topological_space (add_cancel_monoid linarith.comp)) : normal_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_177743 (h0 : functor.add_const (filter (add_cancel_monoid name)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177744 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_177745 (h0 : ring (has_nndist (option empty))) : rank_condition (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_177746 (h1 : not (ring (linear_ordered_comm_group_with_zero string_imp) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_177747 (h0 : ring (has_add (has_add name))) : is_principal_ideal_ring (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_177748 (h0 : topological_space (has_bot linarith.comp)) : locally_compact_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_177749 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177750 (h0 : add_monoid (has_Inf linarith.comp)) : add_monoid.fg (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_177751 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177752 (h0 : topological_space (has_add (has_pos_part environment.implicit_infer_kind))) : sequential_space (has_add (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177753 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} real.angle (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_177754 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid (has_Inf name))))) : rank_condition (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_177755 (h3 : comm_monoid_with_zero char) : wf_dvd_monoid char := sorry --non-trivial
lemma new_lemma_177756 (h0 : add_group (complete_linear_order (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (complete_linear_order (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_177757 (h0 : filter (with_one (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177758 (h0 : ring (finset (ring linarith.comp))) : is_domain (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_177759 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177760 (h0 : topological_space (add_cancel_monoid (has_nndist num))) : normal_space (add_cancel_monoid (has_nndist num)) := sorry --non-trivial
lemma new_lemma_177761 (h0 : ring (complete_semilattice_Sup congr_arg_kind)) : rank_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177762 (h0 : ring (has_sub (semiring (semiring (semiring congr_arg_kind))))) : strong_rank_condition (has_sub (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_177763 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid empty)) empty) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_177764 (h0 : topological_space (has_star (has_top congr_arg_kind))) : totally_separated_space (has_star (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177765 (h0 : functor.comp topological_space complete_distrib_lattice pos) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_177766 (h0 : ring (add_cancel_comm_monoid empty)) : is_domain (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_177767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_177768 (h0 : prod (has_nnnorm linarith.comp_source) (has_nnnorm linarith.comp_source)) : set.diagonal (has_nnnorm linarith.comp_source) h0 := sorry --non-trivial
lemma new_lemma_177769 (h0 : ordered_add_comm_monoid (group_with_zero ennreal)) : archimedean (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_177770 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.ineq) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_177771 (h0 : topological_space (ordered_comm_ring name)) : t1_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_177772 (h0 : ring (has_ssubset (has_nnnorm linarith.comp_source))) : strong_rank_condition (has_ssubset (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177773 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_177774 (h0 : ring (has_Sup (option (option (option (option (option (option unsigned)))))))) : is_principal_ideal_ring (has_Sup (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_177775 (h0 : topological_space (simple_graph real)) : discrete_topology (simple_graph real) := sorry --non-trivial
lemma new_lemma_177776 (h1 : add_group (semiring (has_norm fun_info))) : is_add_cyclic (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_177777 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_177778 (h0 : group (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_Inf Type))))) : normalizer_condition (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_177779 (h0 : functor.add_const (group (ring pos)) name) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_177780 (h0 : function.extfun Type (prod (add_comm_monoid pos))) : id_rel (function.extfun_app h0 (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_177781 (h0 : uniform_space (has_to_string (boolean_algebra.core name))) : separated_space (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_177782 (h0 : semiring (boolean_algebra (finset (finset (finset (finset (finset pos))))))) : is_noetherian_ring (boolean_algebra (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_177783 (h0 : functor.add_const (functor.add_const (ring Type) name) name) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) name) name h0))  := sorry --non-trivial
lemma new_lemma_177784 (h0 : group (has_pos_part (has_add real))) : normalizer_condition (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_177785 (h1 : topological_space (nondiscrete_normed_field reducibility_hints)) : t0_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_177786 (h0 : functor.add_const (topological_space (ring pos)) pos) : @preirreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177787 (h0 : list (complete_semilattice_Sup unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177788 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_177789 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) congr_arg_kind) : @totally_disconnected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177790 (h0 : functor.add_const (group (partial_order num)) num) : @is_cyclic.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_177791 (h0 : topological_space (id (with_bot num))) : irreducible_space (id (with_bot num)) := sorry --non-trivial
lemma new_lemma_177792 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_177793 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177794 (h0 : ring (has_to_string Type)) : rank_condition (has_to_string Type) := sorry --non-trivial
lemma new_lemma_177795 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_177796 (h0 : group (has_emptyc (has_top (random_gen linarith.ineq)))) : normalizer_condition (has_emptyc (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_177797 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @loc_path_connected_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_177798 (h0 : not (topological_space linarith.comp_source -> false)) : @path_connected_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_177799 (h0 : list (add_monoid fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177800 (h0 : ring (monoid (option (option (option (option ennreal)))))) : is_principal_ideal_ring (monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_177801 (h3 : topological_space (normed_field linarith.comp_source)) : totally_disconnected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177802 (h0 : ring (simple_graph reducibility_hints)) : strong_rank_condition (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_177803 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @discrete_topology.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_177804 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_177805 (h0 : functor.add_const (add_monoid (has_star congr_arg_kind)) empty) : @add_monoid.fg.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_177806 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : path_connected_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_177807 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_bot pos)))) : t0_space (comm_semigroup (sub_neg_monoid (has_bot pos))) := sorry --non-trivial
lemma new_lemma_177808 (h0 : functor.add_const (filter (boolean_algebra.core pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177809 (h0 : measurable_space (has_dist string_imp)) (h1 : filter (has_dist string_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_177810 (h2 : ring (normed_field (random_gen to_additive.value_type))) : rank_condition (normed_field (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177811 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @sequential_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177812 (h0 : filter (has_nndist (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_177813 (h0 : topological_space (with_zero (has_inv linarith.ineq))) : t0_space (with_zero (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177814 (h0 : function.extfun Type group) : @group.fg.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_177815 (h0 : semiring (semi_normed_comm_ring string.iterator_imp)) (h1 : ideal (semi_normed_comm_ring string.iterator_imp)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_177816 (h0 h1 : set real) (h2 : complex) : set.re_prod_im (is_greatest h0) h1 h2 := sorry --non-trivial
lemma new_lemma_177817 (h0 : list (has_add (cancel_monoid (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177818 (h0 : not (complete_lattice (mul_zero_class num) -> false)) : @is_compactly_generated.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_177819 (h0 : ring (normed_group (has_norm linarith.comp))) : is_domain (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_177820 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_177821 (h0 : functor.add_const (uniform_space name) num) : @separated_space.{0} name (@functor.add_const.run.{0 0} (uniform_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_177822 (h0 : monoid (has_bot Type)) : monoid.fg (has_bot Type) := sorry --non-trivial
lemma new_lemma_177823 (h0 : list (dlist (has_nnnorm (random_gen (has_nnnorm linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_177824 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option unsigned))) : irreducible_space (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_177825 (h0 : uniform_space (generalized_boolean_algebra (has_neg name))) : complete_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_177826 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177827 (h0 : functor.add_const (monoid (has_neg_part environment.implicit_infer_kind)) (has_add pos)) : @monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_177828 (h0 : has_lt (has_lt linarith.comp_source)) : no_max_order (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177829 (h0 : functor.add_const (topological_space (simple_graph name)) (finset (finset linarith.comp))) : @t0_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_177830 (h0 : topological_space (has_norm num)) : irreducible_space (has_norm num) := sorry --non-trivial
lemma new_lemma_177831 (h0 : has_bot linarith.comp -> has_bot linarith.comp -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_177832 (h0 : ring (distrib (comm_ring (comm_ring linarith.ineq)))) : strong_rank_condition (distrib (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_177833 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177834 (h0 : add_group (encodable (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_add_cyclic (encodable (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_177835 (h0 : not (topological_space congr_arg_kind -> false)) : @irreducible_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (topological_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_177836 (h0 : topological_space (topological_space string_imp)) : path_connected_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_177837 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : rank_condition (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_177838 (h0 : fin has_zero.zero) : @normal_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_177839 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177840 (h0 : functor.add_const (uniform_space (has_to_string name)) (has_neg environment.implicit_infer_kind)) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_177841 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) pos) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_177842 (h0 : function.extfun Type group) : @is_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177843 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @t1_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177844 (h0 : group (generalized_boolean_algebra linarith.comp)) : group.fg (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_177845 (h0 : ring (add_comm_monoid unsigned)) : strong_rank_condition (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_177846 (h0 : functor.add_const (uniform_space (finset pos)) linarith.comp) : @separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177847 (h0 : topological_space (has_bot (option empty))) : loc_path_connected_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_177848 (h0 : topological_space (comm_ring (random_gen char))) : path_connected_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_177849 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_177850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177851 (h0 : topological_space (semigroup ennreal)) : t1_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_177852 (h0 : complete_lattice (has_zero (has_add Type))) : complete_lattice.is_Sup_finite_compact (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_177853 (h0 : not (add_group (distrib (has_nnnorm linarith.ineq)) -> false)) : @is_add_cyclic.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_177854 (h0 : topological_space (with_bot congr_arg_kind)) : t0_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177855 (h0 : ring (denumerable string_imp)) : rank_condition (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_177856 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @t0_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_177857 (h0 : add_group (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_177858 (h0 : cancel_comm_monoid_with_zero (add_group linarith.comp)) : unique_factorization_monoid (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_177859 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177860 (h1 : topological_space (has_inv to_additive.value_type)) : t0_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177861 (h0 : not (complete_lattice (has_compl (has_lt char)) -> false)) : @is_compactly_generated.{0} (has_compl.{0} (has_lt.{0} char)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} (has_lt.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_177862 (h0 : complete_lattice (measure_theory.measure_space num)) : is_atomistic (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_177863 (h0 : not (uniform_space (semi_normed_ring to_additive.value_type) -> false)) : @complete_space.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_177864 (h0 : complete_lattice (option (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177865 (h0 : not (topological_space (topological_space char) -> false)) : @path_connected_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_177866 (h0 : ring (encodable (random_gen linarith.ineq))) : is_domain (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177867 (h0 : uniform_space (has_to_string (has_add (has_add linarith.comp)))) : separated_space (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_177868 (h0 : group (has_add (has_Inf Type))) : group.fg (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_177869 (h0 : topological_space (dlist (random_gen string_imp))) : totally_disconnected_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_177870 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid pos)) pos) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_177871 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177872 (h0 : filter (has_neg_part (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_177873 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177874 (h0 : functor.add_const (filter (has_nndist linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177875 (h0 : list (add_comm_monoid (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177876 (h0 : topological_space (finset (boolean_algebra.core (ring Type)))) : preirreducible_space (finset (boolean_algebra.core (ring Type))) := sorry --non-trivial
lemma new_lemma_177877 (h0 : uniform_space (linear_ordered_field num)) : complete_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_177878 (h1 : set environment.projection_info) : set.finite h1 := sorry --non-trivial
lemma new_lemma_177879 (h0 : topological_space (normed_comm_ring num)) : irreducible_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_177880 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_177881 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177882 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_177883 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid unsigned)) unsigned) : @irreducible_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177884 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero (has_bot congr_arg_kind))) : unique_factorization_monoid (linear_ordered_comm_monoid_with_zero (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177885 (h0 : filter (has_norm (has_norm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177886 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_177887 (h0 : functor.add_const (ring (add_cancel_monoid Type)) linarith.comp) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177888 (h0 : add_group (with_one congr_arg_kind)) : is_add_cyclic (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177889 (h0 : set (non_unital_non_assoc_semiring std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_177890 (h3 : prod enat enat) : set.diagonal enat h3 := sorry --non-trivial
lemma new_lemma_177891 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_177892 (h0 : functor.add_const (monoid (boolean_algebra.core pos)) name) : @monoid.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_177893 (h0 : functor.add_const (filter Prop) num) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@functor.add_const.run.{0 0} (filter.{0} Prop) num h0)  := sorry --non-trivial
lemma new_lemma_177894 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_177895 (h0 : ring (simple_graph (has_add pos))) : is_principal_ideal_ring (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_177896 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177897 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (mul_one_class (add_comm_semigroup char))))) : t0_space (add_comm_semigroup (add_comm_semigroup (mul_one_class (add_comm_semigroup char)))) := sorry --non-trivial
lemma new_lemma_177898 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_177899 (h0 : topological_space (has_add (mul_one_class environment.implicit_infer_kind))) : preconnected_space (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_177900 (h0 : not (topological_space (has_norm fun_info) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_177901 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177902 (h0 : topological_space (normed_comm_ring (has_add pos))) : regular_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_177903 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) (ring linarith.comp)) : @group.fg.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_177904 (h0 : complete_lattice (canonically_ordered_monoid (has_add (has_Inf (has_add (has_add pos)))))) : is_atomistic (canonically_ordered_monoid (has_add (has_Inf (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_177905 (h0 : functor.add_const (ring (has_zero Type)) Type) : @strong_rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_177906 (h0 h1 : multiset (mul_one_class std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_177907 (h0 : topological_space (semi_normed_ring (has_compl reducibility_hints))) : t0_space (semi_normed_ring (has_compl reducibility_hints)) := sorry --non-trivial
lemma new_lemma_177908 (h0 : topological_space (add_comm_monoid (ring (finset (finset linarith.comp))))) : loc_path_connected_space (add_comm_monoid (ring (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_177909 (h0 : not (semiring (normed_group empty) -> false)) : @is_noetherian_ring.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177910 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @irreducible_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_177911 (h0 : list (omega_complete_partial_order (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_177912 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_nndist Type)) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177913 (h1 : topological_space (mul_one_class linarith.ineq)) (h2 : preorder (mul_one_class linarith.ineq)) : order_closed_topology (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_177914 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177915 (h1 : ring (complete_semilattice_Sup congr_arg_kind)) : is_domain (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177916 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : totally_disconnected_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_177917 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid linarith.comp) name) linarith.comp) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} linarith.comp) name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_177918 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_177919 (h0 : functor.add_const (complete_lattice (as_linear_order unsigned)) unsigned) : @is_atomistic.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177920 (h0 : complete_lattice (comm_semigroup (has_add (has_add (has_add (has_add pos)))))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (has_add (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_177921 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_177922 (h0 : ring (boolean_algebra.core (simple_graph (has_add (ring (finset Type)))))) : rank_condition (boolean_algebra.core (simple_graph (has_add (ring (finset Type))))) := sorry --non-trivial
lemma new_lemma_177923 (h0 : not (ring (add_left_cancel_monoid linarith.ineq) -> false)) : @rank_condition.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_177924 (h0 : ring (non_assoc_semiring congr_arg_kind)) : is_domain (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_177925 (h0 : topological_space environment.projection_info) : topological_space.first_countable_topology environment.projection_info := sorry --non-trivial
lemma new_lemma_177926 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : path_connected_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_177927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_177928 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177929 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177930 (h0 : functor.add_const (add_monoid (boolean_algebra.core linarith.comp)) (has_nndist linarith.comp)) : @add_monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_177931 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_177932 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_177933 (h0 : functor.add_const (group (normed_comm_ring Type)) unsigned) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_177934 (h0 : ring (uniform_space (mul_one_class linarith.comp_source))) : rank_condition (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_177935 (h1 : uniform_space (has_append to_additive.value_type)) : complete_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177936 (h0 : ring (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_domain (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_177937 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177938 (h0 : ring (monoid_with_zero (has_to_string (has_to_string environment.implicit_infer_kind)))) : rank_condition (monoid_with_zero (has_to_string (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_177939 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177940 (h0 : topological_space linarith.comp_source) (h1 : linarith.comp_source) (h2 : set (topological_space.open_nhds_of h1)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_177941 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177942 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_177943 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_177944 (h0 : ring (ring (option (option (option pos))))) : strong_rank_condition (ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_177945 (h0 : measurable_space char) (h1 : topological_space char) (h2 : measure_theory.measure char) : measure_theory.measure.outer_regular h2 := sorry --non-trivial
lemma new_lemma_177946 (h0 : functor.add_const (finset (add_cancel_monoid unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177947 (h0 : functor.add_const (ring (semigroup unsigned)) pos) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_177948 (h1 : topological_space congr_arg_kind) : path_connected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_177949 (h0 : function.extfun nat fin) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_177950 (h0 : complete_lattice (add_left_cancel_monoid (has_inv (has_nnnorm fun_info)))) : is_compactly_generated (add_left_cancel_monoid (has_inv (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_177951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_177952 (h0 : ring (encodable (has_nnnorm linarith.ineq))) : rank_condition (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_177953 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_177954 (h0 : function.extfun Type group) : @group.fg.{0} (comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_177955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_177956 (h0 : ordered_comm_monoid (boolean_algebra.core (boolean_algebra.core pos))) : has_exists_mul_of_le (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_177957 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) (finset Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177958 (h0 : topological_space (ordered_comm_group (option empty))) : totally_disconnected_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_177959 (h0 : ring (generalized_boolean_algebra (has_pos_part linarith.comp))) : rank_condition (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_177960 (h0 : functor.add_const (add_group (semigroup unsigned)) (ring (ring pos))) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_177961 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) Type) : @group.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_177962 (h0 : complete_lattice (bin_tree (semiring unsigned))) : is_compactly_generated (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_177963 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_177964 (h0 : topological_space (boolean_algebra (has_add pos))) : regular_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_177965 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_177966 (h0 : add_group (add_group (semiring (semiring linarith.comp)))) : is_add_cyclic (add_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_177967 (h0 : complete_lattice (simple_graph (option unsigned))) : is_compactly_generated (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_177968 (h1 : not (topological_space (add_cancel_comm_monoid string_imp) -> false)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_177969 (h0 : functor.add_const (ordered_comm_monoid (ring unsigned)) (has_neg_part Type)) : @has_exists_mul_of_le.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} unsigned)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_177970 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_177971 (h0 : topological_space (add_group (semiring (non_unital_non_assoc_semiring empty)))) : topological_space.separable_space (add_group (semiring (non_unital_non_assoc_semiring empty))) := sorry --non-trivial
lemma new_lemma_177972 (h1 : topological_space string) : path_connected_space string := sorry --non-trivial
lemma new_lemma_177973 (h0 : not (group (has_star empty) -> false)) : @is_cyclic.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177974 (h0 : topological_space (has_top (semiring (semiring (semiring (semiring (semiring linarith.comp))))))) : locally_compact_space (has_top (semiring (semiring (semiring (semiring (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_177975 (h1 : ring (has_compl to_additive.value_type)) : rank_condition (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177976 (h0 : topological_space (has_zero (comm_group Type))) : t1_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_177977 (h0 : ring (simple_graph linarith.comp)) : strong_rank_condition (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_177978 (h0 : not (add_group (has_star empty) -> false)) : @is_add_cyclic.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_177979 (h0 : topological_space (canonically_linear_ordered_monoid (has_add pos))) : irreducible_space (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_177980 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) (semigroup (semigroup name))) : @irreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (semigroup.{0} (semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_177981 (h1 : group (linear_ordered_add_comm_group to_additive.value_type)) : group.fg (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_177982 (h0 : functor.add_const (group (simple_graph linarith.comp)) Type) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_177983 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) (semigroup (comm_group Type))) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) (semigroup.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_177984 (h0 : functor.add_const (filter (ring Type)) (has_add Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_177985 (h0 : group (has_norm empty)) : normalizer_condition (has_norm empty) := sorry --non-trivial
lemma new_lemma_177986 (h0 : topological_space (has_union linarith.comp)) : locally_compact_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_177987 (h0 : topological_space (mul_one_class linarith.comp_source)) (h1 : preorder (mul_one_class linarith.comp_source)) : order_topology (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_177988 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_177989 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : t0_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_177990 (h1 : topological_space (has_compl (random_gen (random_gen string_imp)))) : locally_compact_space (has_compl (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_177991 (h0 : filter (has_zero (option (option (complete_distrib_lattice (option pos)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_177992 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : path_connected_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_177993 (h0 : topological_space (ring (complete_distrib_lattice Type))) : irreducible_space (ring (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_177994 (h0 : complete_lattice (has_lt (add_cancel_comm_monoid char))) : is_compactly_generated (has_lt (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_177995 (h1 : topological_space (has_emptyc fun_info)) : discrete_topology (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_177996 (h0 : uniform_space (random_gen (semiring congr_arg_kind))) : separated_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_177997 (h0 : ring (comm_ring (metric_space to_additive.value_type))) : strong_rank_condition (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_177998 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_177999 (h1 : ring (distrib (has_ssubset (random_gen char)))) : rank_condition (distrib (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_178000 (h0 : cancel_comm_monoid_with_zero (simple_graph Type)) : unique_factorization_monoid (simple_graph Type) := sorry --non-trivial
lemma new_lemma_178001 (h0 : add_group (topological_space to_additive.value_type)) : is_add_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178002 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178004 (h0 : topological_space (has_one (has_norm (has_top linarith.comp)))) : preirreducible_space (has_one (has_norm (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_178005 (h0 : function.extfun Type group) : @group.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_178006 (h0 : topological_space (has_one (semiring (has_top empty)))) : totally_disconnected_space (has_one (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_178007 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178008 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178009 (h0 : topological_space (random_gen (random_gen (random_gen linarith.ineq)))) : locally_compact_space (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_178010 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @locally_compact_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178011 (h0 : topological_space (ring (ring pos))) : discrete_topology (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_178012 (h1 : uniform_space (div_inv_monoid (has_inv to_additive.value_type))) : complete_space (div_inv_monoid (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178013 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_178014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_178015 (h0 : topological_space (has_nnnorm linarith.ineq)) : locally_compact_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_178016 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178017 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178018 (h0 : monoid (has_to_string (has_add (comm_group unsigned)))) : monoid.fg (has_to_string (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_178019 (h0 : group (has_neg unsigned)) : normalizer_condition (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_178020 (h4 : uniform_space linarith.comp_source) : complete_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_178021 (h0 : not (topological_space (distrib_lattice linarith.ineq) -> false)) : @path_connected_space.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_178022 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178023 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178024 (h0 : function.extfun Type (functor.add_const (ring (has_star empty)))) : @rank_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_star.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_178025 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_178026 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_178027 (h0 : uniform_space (normed_field (metric_space to_additive.value_type))) : complete_space (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178028 (h0 : topological_space (measurable_space (linear_ordered_semiring (semiring empty)))) : totally_separated_space (measurable_space (linear_ordered_semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_178029 (h0 : add_group (add_cancel_monoid (comm_group Type))) : is_add_cyclic (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_178030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_178031 (h0 : topological_space (has_neg (finset (finset pos)))) : discrete_topology (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_178032 (h0 : group (normed_field (has_nnnorm linarith.comp_source))) : is_cyclic (normed_field (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178033 (h0 : topological_space (option num)) : locally_compact_space (option num) := sorry --non-trivial
lemma new_lemma_178034 (h0 : functor.add_const (ring (semigroup pos)) (has_neg (boolean_algebra linarith.comp))) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) (has_neg.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_178035 (h0 : group (id string_imp)) : normalizer_condition (id string_imp) := sorry --non-trivial
lemma new_lemma_178036 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178037 (h0 : topological_space (left_cancel_monoid (semiring (semiring num)))) : preirreducible_space (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_178038 (h0 : ring (has_zero (comm_group (cancel_monoid (has_neg_part unsigned))))) : is_domain (has_zero (comm_group (cancel_monoid (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_178039 (h0 : functor.add_const (function.extfun Type finset) unsigned) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_178040 (h0 : functor.add_const (functor.comp topological_space semigroup linarith.comp) linarith.comp) : @normal_space.{0} (semigroup.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} linarith.comp (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} semigroup.{0} linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_178041 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @irreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_178042 (h0 : not (group (has_norm linarith.ineq) -> false)) : @group.fg.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_178043 (h1 : topological_space (with_bot linarith.comp_source)) : totally_separated_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178044 (h0 : functor.add_const (monoid (left_cancel_monoid empty)) empty) : @monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_178045 (h0 : set (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_178046 (h0 : uniform_space (ring (mul_zero_class (option name)))) : complete_space (ring (mul_zero_class (option name))) := sorry --non-trivial
lemma new_lemma_178047 (h0 : topological_space (comm_group (option name))) : preconnected_space (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_178048 (h2 : ring (dlist linarith.comp_source)) : is_domain (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178049 (h0 h1 : multiset (has_nnnorm reducibility_hints)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_178050 (h0 : semiring (complete_semilattice_Sup (semiring empty))) : is_noetherian_ring (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_178051 (h0 : uniform_space (distrib_lattice (random_gen fun_info))) : complete_space (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_178052 (h0 : add_group (denumerable linarith.ineq)) : is_add_cyclic (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_178053 (h0 : ordered_comm_monoid (add_cancel_monoid unsigned)) : has_exists_mul_of_le (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_178054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_178055 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_178056 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178057 (h0 : fin has_zero.zero) : @t0_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_178058 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @path_connected_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178059 (h0 : functor.add_const (complete_lattice (semiring congr_arg_kind)) num) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_178060 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @sequential_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_178061 (h0 : topological_space (semi_normed_ring linarith.ineq)) (h1 : preorder (semi_normed_ring linarith.ineq)) : order_topology (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_178062 (h0 : topological_space unsigned) : irreducible_space unsigned := sorry --non-trivial
lemma new_lemma_178063 (h0 : topological_space (uniform_space char)) : t0_space (uniform_space char) := sorry --non-trivial
lemma new_lemma_178064 (h0 : group (has_nndist (finset Type))) : group.fg (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_178065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178066 (h0 : topological_space (left_cancel_semigroup (ordered_cancel_comm_monoid num))) : topological_space.separable_space (left_cancel_semigroup (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_178067 (h0 : add_group (boolean_algebra (has_add Type))) : is_add_cyclic (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_178068 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178069 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_field.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_178071 (h0 : ordered_add_comm_monoid (omega_complete_partial_order empty)) : archimedean (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_178072 (h2 : topological_space (fintype to_additive.value_type)) : path_connected_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178073 (h0 : topological_space (has_top (has_norm fun_info))) : irreducible_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_178074 (h0 : functor.add_const (uniform_space (has_Inf Type)) Type) : @complete_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_178075 (h1 : group (comm_ring (has_nnnorm to_additive.value_type))) : is_cyclic (comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178076 (h0 : ring (add_monoid linarith.comp_source)) : is_domain (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178077 (h0 : list (add_cancel_monoid (comm_group unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178078 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : sequential_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_178079 (h1 : measurable_space (nondiscrete_normed_field environment.projection_info)) (h2 : filter (nondiscrete_normed_field environment.projection_info)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_178080 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @normal_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178081 (h0 : finset (cancel_monoid (option (option (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178082 (h0 : not (topological_space (cancel_comm_monoid_with_zero (metric_space reducibility_hints)) -> false)) : @t0_space.{0} (cancel_comm_monoid_with_zero.{0} (metric_space.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (cancel_comm_monoid_with_zero.{0} (metric_space.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_178083 (h0 : add_group (with_one (semiring (semiring (semiring unsigned))))) : is_add_cyclic (with_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_178084 (h0 : ring (add_comm_semigroup enat)) : is_domain (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_178085 (h0 : complete_lattice (topological_space (random_gen linarith.comp_source))) : is_compactly_generated (topological_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178086 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_178087 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_178088 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178089 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} char) (@matrix.vec_empty.{0} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_178090 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178091 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_178092 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp))) : @is_domain.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178093 (h0 : topological_space (has_Inf (has_zero (has_add Type)))) : loc_path_connected_space (has_Inf (has_zero (has_add Type))) := sorry --non-trivial
lemma new_lemma_178094 (h0 : ordered_comm_monoid (has_nndist (has_to_string Type))) : has_exists_mul_of_le (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_178095 (h0 : functor.add_const (monoid (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_178096 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (generalized_boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178097 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178098 (h0 : not (add_group (has_top congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178099 (h0 : functor.add_const (topological_space (ordered_ring empty)) congr_arg_kind) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_178100 (h0 : not (topological_space (non_assoc_semiring unsigned) -> false)) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178101 (h0 : complete_lattice (comm_group (comm_group name))) : is_atomistic (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_178102 (h0 : cancel_comm_monoid_with_zero (has_neg (has_neg_part (has_to_string Type)))) : unique_factorization_monoid (has_neg (has_neg_part (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_178103 (h0 : ring (is_R_or_C (semiring empty))) : is_domain (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_178104 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178105 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_178106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} name))  := sorry --non-trivial
lemma new_lemma_178107 (h0 : functor.add_const (topological_space (has_pos_part Type)) (ring Type)) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_178108 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) (ring (ring linarith.comp))) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_178109 (h0 : monoid (complete_semilattice_Sup (semiring congr_arg_kind))) : monoid.fg (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178110 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) linarith.comp) : @is_compactly_generated.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178111 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice environment.implicit_infer_kind)) : unique_factorization_monoid (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_178112 (h1 : ring (add_monoid fun_info)) : rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_178113 (h0 : has_mem.mem (add_group linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (add_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (add_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178114 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178115 (h0 : ring (complete_semilattice_Sup (semiring unsigned))) : strong_rank_condition (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_178116 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_178117 (h0 : group (left_cancel_monoid (option (option (option empty))))) : normalizer_condition (left_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_178118 (h1 : complete_lattice (measurable_space linarith.comp_source)) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178119 (h0 : functor.add_const (group (has_bot empty)) empty) : @is_cyclic.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_178120 (h0 : ordered_add_comm_monoid (option (option pos))) : archimedean (option (option pos)) := sorry --non-trivial
lemma new_lemma_178121 (h0 : complete_lattice (comm_ring (normed_field (normed_field string.iterator_imp)))) : complete_lattice.is_Sup_finite_compact (comm_ring (normed_field (normed_field string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_178122 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : t0_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_178123 (h0 : ring (as_linear_order (option unsigned))) : is_principal_ideal_ring (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_178124 (h1 : topological_space (has_append to_additive.value_type)) : path_connected_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178125 (h0 : functor.add_const (finset (ring linarith.comp)) (boolean_algebra linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178126 (h0 : group (semigroup (ring Type))) : is_cyclic (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_178127 (h0 : topological_space (has_top (has_top (has_inv (random_gen (has_norm string_imp)))))) : t0_space (has_top (has_top (has_inv (random_gen (has_norm string_imp))))) := sorry --non-trivial
lemma new_lemma_178128 (h0 : topological_space (boolean_algebra (has_zero (has_zero linarith.comp)))) : irreducible_space (boolean_algebra (has_zero (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_178129 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178130 (h0 : topological_space (linear_ordered_add_comm_group num)) : path_connected_space (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_178131 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_178132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_178133 (h0 : complete_lattice (non_unital_non_assoc_semiring enat)) : is_compactly_generated (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_178134 (h0 : add_group (add_comm_semigroup (add_comm_semigroup environment.projection_info))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_178135 (h0 : complete_lattice (random_gen (has_norm empty))) : is_atomistic (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_178136 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_178137 (h0 : ring (random_gen empty)) : strong_rank_condition (random_gen empty) := sorry --non-trivial
lemma new_lemma_178138 (h0 : finset (omega_complete_partial_order num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178139 (h0 : has_lt (has_compl (has_compl (has_compl reducibility_hints)))) : no_max_order (has_compl (has_compl (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_178140 (h0 : functor.add_const (topological_space (option empty)) unsigned) : @topological_space.separable_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178141 (h0 h1 : multiset (mul_one_class (add_comm_semigroup char))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_178142 (h0 : list (has_neg (option congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178143 (h0 : ring (has_nnnorm ereal)) : strong_rank_condition (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_178144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_178145 (h0 : preorder (add_comm_semigroup (mul_one_class ereal))) (h1 : set (add_comm_semigroup (mul_one_class ereal))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_178146 (h0 : topological_space (has_add linarith.comp)) : preconnected_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_178147 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178148 (h0 : complete_lattice (boolean_algebra.core (option num))) : is_atomistic (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_178149 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : loc_path_connected_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_178150 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178151 (h0 : not (uniform_space (has_star unsigned) -> false)) : @separated_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178152 (h0 : topological_space (has_append (semi_normed_ring char))) : t0_space (has_append (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_178153 (h0 : uniform_space (with_bot (semiring num))) : separated_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_178154 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_178155 (h0 : function.extfun (Type 1) (functor.comp topological_space has_zero)) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_zero.{1}) h0 Type)))  := sorry --non-trivial
lemma new_lemma_178156 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg linarith.comp)) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178157 (h1 : ring (with_one fun_info)) : strong_rank_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_178158 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : t1_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_178159 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178160 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf (finset (has_neg linarith.comp))))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_178161 (h0 : ring (has_norm (has_norm unsigned))) : rank_condition (has_norm (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_178162 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178163 (h0 : fin has_zero.zero) : @separated_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_178164 (h0 : topological_space (boolean_algebra (has_zero (boolean_algebra (has_add subsingleton_info))))) : discrete_topology (boolean_algebra (has_zero (boolean_algebra (has_add subsingleton_info)))) := sorry --non-trivial
lemma new_lemma_178165 (h0 : functor.add_const (group (boolean_algebra name)) (has_neg Type)) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_178166 (h0 : add_monoid (simple_graph (ordered_comm_monoid Type))) : add_monoid.fg (simple_graph (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_178167 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_178168 (h0 : topological_space (ring (option (option (option (mul_zero_class name)))))) : t1_space (ring (option (option (option (mul_zero_class name))))) := sorry --non-trivial
lemma new_lemma_178169 (h0 : functor.add_const (functor.comp topological_space has_neg_part unsigned) ennreal) : @discrete_topology.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned) ennreal h0))  := sorry --non-trivial
lemma new_lemma_178170 (h0 : functor.add_const (filter (has_Inf Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178171 (h0 : filter (topological_space (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178172 (h0 : complete_lattice (preorder unsigned)) : is_compactly_generated (preorder unsigned) := sorry --non-trivial
lemma new_lemma_178173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178174 (h0 : functor.add_const (ring (has_star unsigned)) (semiring empty)) : @rank_condition.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_178175 (h0 : measurable_space fun_info) (h1 : monoid fun_info) (h2 : mul_action fun_info fun_info) : measurable_set (mul_action.fixed_points fun_info fun_info) := sorry --non-trivial
lemma new_lemma_178176 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_Inf real)) : @preconnected_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_178177 (h0 : ring (pseudo_metric_space (pseudo_metric_space num))) : rank_condition (pseudo_metric_space (pseudo_metric_space num)) := sorry --non-trivial
lemma new_lemma_178178 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_178179 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) (canonically_ordered_comm_semiring pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) (canonically_ordered_comm_semiring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_178180 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @is_domain.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178181 (h0 : semiring (has_pos_part (ring (has_pos_part Type)))) : is_noetherian_ring (has_pos_part (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_178182 (h2 : group (complete_semilattice_Sup linarith.comp)) : group.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_178183 (h0 : filter (complete_distrib_lattice Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178184 (h0 : topological_space (has_neg (has_Inf pos))) : normal_space (has_neg (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_178185 (h0 : not (group (with_zero to_additive.value_type) -> false)) : @is_cyclic.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_178186 (h0 : topological_space (non_unital_non_assoc_semiring (semi_normed_ring reducibility_hints))) : totally_disconnected_space (non_unital_non_assoc_semiring (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_178187 (h0 : topological_space (has_top (random_gen string_imp))) : totally_separated_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_178188 (h0 : group (has_zero (finset (has_add name)))) : is_simple_group (has_zero (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_178189 (h2 : add_group (fintype (has_nnnorm fun_info))) : is_add_cyclic (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_178190 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178191 (h0 : functor.add_const (complete_lattice (cancel_monoid ennreal)) (option ennreal)) : @is_compactly_generated.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_178192 (h0 : topological_space (semigroup (has_add Type))) : locally_compact_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_178193 (h0 : ring (add_comm_monoid (option ennreal))) : invariant_basis_number (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_178194 (h0 : not (prod (linear_ordered_semiring unsigned) (linear_ordered_semiring unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_178195 (h0 : functor.add_const (topological_space Type) linarith.comp) : @preirreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178196 (h0 : topological_space (complete_distrib_lattice (has_add (add_comm_monoid (semigroup pos))))) : totally_separated_space (complete_distrib_lattice (has_add (add_comm_monoid (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_178197 (h1 : add_group (has_neg to_additive.value_type)) : is_add_cyclic (has_neg to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178198 (h0 : topological_space (canonically_linear_ordered_monoid (has_zero num))) : irreducible_space (canonically_linear_ordered_monoid (has_zero num)) := sorry --non-trivial
lemma new_lemma_178199 (h0 : topological_space (random_gen (has_norm fun_info))) : path_connected_space (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_178200 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178201 (h0 : group (add_cancel_monoid (finset environment.implicit_infer_kind))) : group.fg (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178202 (h0 : functor.add_const (group (has_nndist name)) Type) : @is_simple_group.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_178203 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add (has_add (comm_group unsigned))))) : is_compactly_generated (canonically_ordered_comm_semiring (has_add (has_add (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_178204 (h0 : topological_space (uniform_space (has_compl char))) : t0_space (uniform_space (has_compl char)) := sorry --non-trivial
lemma new_lemma_178205 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178206 (h0 : monoid (has_bot (sub_neg_monoid pos))) : monoid.fg (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_178207 (h0 : ordered_add_comm_monoid (has_pos_part (sub_neg_monoid real))) : archimedean (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_178208 (h0 : complete_lattice auto.case_option) : complete_lattice.is_Sup_finite_compact auto.case_option := sorry --non-trivial
lemma new_lemma_178209 (h0 : uniform_space (ordered_comm_monoid (has_nnnorm (has_nnnorm char)))) : complete_space (ordered_comm_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_178210 (h1 : ring (has_append (has_ssubset char))) : strong_rank_condition (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_178211 (h0 : functor.add_const (topological_space Type) pos) : @t1_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_178212 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_178213 (h0 : function.extfun nat fin) : @is_atomistic.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178214 (h0 : functor.add_const Prop (add_cancel_monoid linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_178215 (h0 : functor.add_const (uniform_space (add_cancel_monoid name)) name) : @separated_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_178216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178217 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_monoid.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_178218 (h0 : topological_space (boolean_algebra (has_add (boolean_algebra (ordered_ring Type))))) : totally_separated_space (boolean_algebra (has_add (boolean_algebra (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_178219 (h0 : ordered_add_comm_monoid (has_to_string (option empty))) : archimedean (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_178220 (h0 : complete_lattice (fintype (random_gen to_additive.value_type))) : is_compactly_generated (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178221 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178222 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178223 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) (finset linarith.comp)) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178224 (h0 : ordered_comm_monoid (has_neg_part (ring (boolean_algebra name)))) : has_exists_mul_of_le (has_neg_part (ring (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_178225 (h0 : add_monoid (has_sub num)) : add_monoid.fg (has_sub num) := sorry --non-trivial
lemma new_lemma_178226 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_178227 (h0 : ring (normed_field char)) : strong_rank_condition (normed_field char) := sorry --non-trivial
lemma new_lemma_178228 (h3 : has_coe char Prop) (h4 : char) : @coe_b.{1 1} char Prop h3 h4  := sorry --non-trivial
lemma new_lemma_178229 (h0 : ring (linear_ordered_comm_ring (semiring (semiring empty)))) : is_principal_ideal_ring (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_178230 (h0 : add_monoid (bin_tree (option empty))) : add_monoid.fg (bin_tree (option empty)) := sorry --non-trivial
lemma new_lemma_178231 (h0 : functor.add_const (filter (finset name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178232 (h0 : complete_lattice (semiring linarith.comp_source)) : is_atomistic (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178233 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178234 (h8 : not (topological_space (denumerable char) -> false)) : @t0_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h8)  := sorry --non-trivial
lemma new_lemma_178235 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178236 (h1 : complete_lattice (comm_ring linarith.ineq)) : is_compactly_generated (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_178237 (h0 : topological_space (with_bot (semiring unsigned))) : discrete_topology (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_178238 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : @complete_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_one.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_178239 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_178240 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_178241 (h0 : topological_space (has_zero linarith.comp)) : normal_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_178242 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178243 (h0 : functor.add_const (add_monoid (ordered_comm_monoid pos)) name) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_178244 (h0 : topological_space (with_one (has_top linarith.comp_source))) : irreducible_space (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178245 (h0 : topological_space (has_Sup (semiring num))) : locally_compact_space (has_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_178246 (h0 : topological_space (add_cancel_monoid pos)) : sequential_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_178247 (h0 : ring (boolean_algebra (comm_group Type))) : strong_rank_condition (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_178248 (h0 : uniform_space (fintype linarith.comp_source)) : complete_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178249 (h0 : complete_lattice (has_add (finset (finset (finset pos))))) : is_compactly_generated (has_add (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_178250 (h0 : uniform_space (linear_ordered_field (option (option ennreal)))) : separated_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_178251 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_178252 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) linarith.comp) : @separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178253 (h0 : functor.add_const (topological_space (boolean_algebra real)) (has_Inf Type)) : @regular_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_178254 (h0 : functor.add_const (filter (measure_theory.measure_space empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178255 (h0 : set (non_unital_non_assoc_semiring fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_178256 (h0 : list (finset (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178257 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_178258 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} (has_inv.{0} (has_inv.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} (has_inv.{0} (has_inv.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_178259 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_178260 (h0 : ordered_add_comm_monoid (has_bot (has_add (has_Inf name)))) : archimedean (has_bot (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_178261 (h0 : group (has_compl (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_cyclic (has_compl (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_178262 (h1 : topological_space (complete_semilattice_Sup (has_top fun_info))) : path_connected_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_178263 (h0 : add_monoid (free_add_monoid (semiring num))) : add_monoid.fg (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_178264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178265 (h0 : topological_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty)))) : totally_separated_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_178266 (h2 : topological_space (denumerable char)) : totally_disconnected_space (denumerable char) := sorry --non-trivial
lemma new_lemma_178267 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_178268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178269 (h0 : functor.add_const (finset (has_nndist Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178270 (h0 : topological_space (normed_comm_ring (boolean_algebra (has_add unsigned)))) : totally_separated_space (normed_comm_ring (boolean_algebra (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_178271 (h0 : group (comm_ring (random_gen (has_top to_additive.value_type)))) : group.fg (comm_ring (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_178272 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178273 (h0 : ring (linear_ordered_comm_group (option empty))) : is_principal_ideal_ring (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_178274 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178275 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_178276 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : preconnected_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_178277 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_178278 (h0 : topological_space (has_Inf (has_add pos))) : normal_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_178279 (h0 : functor.add_const (functor.add_const (add_monoid Type) linarith.comp) linarith.comp) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (add_monoid.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_178280 (h0 : functor.add_const (ring (ordered_comm_monoid pos)) linarith.comp) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178281 (h0 : topological_space (complete_distrib_lattice (comm_group environment.implicit_infer_kind))) : locally_compact_space (complete_distrib_lattice (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178282 (h0 : topological_space (semigroup (has_add unsigned))) : regular_space (semigroup (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_178283 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_178284 (h0 : topological_space (has_to_string (comm_group (comm_group unsigned)))) : irreducible_space (has_to_string (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_178285 (h4 : ring (nondiscrete_normed_field linarith.ineq)) : strong_rank_condition (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_178286 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178287 (h0 : function.extfun Type group) : @is_cyclic.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_178288 (h0 : topological_space (has_one (linear_ordered_semiring (semiring unsigned)))) : t0_space (has_one (linear_ordered_semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_178289 (h0 : topological_space (random_gen (semiring empty))) : path_connected_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_178290 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178291 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_neg real)))) : discrete_topology (canonically_linear_ordered_monoid (has_Inf (has_neg real))) := sorry --non-trivial
lemma new_lemma_178292 (h0 : finset (is_R_or_C empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178293 (h0 : topological_space (normed_comm_ring (comm_group (comm_group (comm_group unsigned))))) : t0_space (normed_comm_ring (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_178294 (h1 : topological_space (with_bot linarith.comp_source)) : path_connected_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178295 (h0 : topological_space (ring (option (option (option (option empty)))))) : normal_space (ring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_178296 (h0 : ring (distrib (denumerable linarith.ineq))) : is_domain (distrib (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178297 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178298 (h0 : function.extfun nat fin) : @is_atomistic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178299 (h0 : ring (canonically_linear_ordered_monoid congr_arg_kind)) : rank_condition (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178300 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} (ring.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (ring.{0} name)))  := sorry --non-trivial
lemma new_lemma_178301 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part Type))) : preconnected_space (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_178302 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space name)) : unique_factorization_monoid (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_178303 (h0 : complete_lattice (ordered_comm_monoid linarith.comp)) : is_atomistic (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_178304 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178305 (h0 : topological_space (ring (has_zero (ring Type)))) : regular_space (ring (has_zero (ring Type))) := sorry --non-trivial
lemma new_lemma_178306 (h0 : uniform_space (with_one (has_norm (random_gen fun_info)))) : complete_space (with_one (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_178307 (h0 : topological_space (finset (ring (has_to_string linarith.comp)))) : sequential_space (finset (ring (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_178308 (h1 : topological_space (with_bot string_imp)) : totally_disconnected_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_178309 (h0 : group (complete_semilattice_Sup (has_top (has_top (has_top linarith.ineq))))) : group.fg (complete_semilattice_Sup (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_178310 (h0 : topological_space (ordered_ring congr_arg_kind)) : discrete_topology (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178311 (h1 : topological_space (normed_field (has_nnnorm linarith.comp_source))) : t0_space (normed_field (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178312 (h0 : add_group (ordered_comm_monoid linarith.comp)) : is_add_cyclic (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_178313 (h0 : uniform_space (topological_space string_imp)) : complete_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_178314 (h0 : group (add_cancel_monoid (finset (comm_group name)))) : normalizer_condition (add_cancel_monoid (finset (comm_group name))) := sorry --non-trivial
lemma new_lemma_178315 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) unsigned) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178316 (h0 : topological_space (has_nndist (finset (finset (finset (finset linarith.comp)))))) : totally_disconnected_space (has_nndist (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_178317 (h0 : ring (complete_distrib_lattice (finset name))) : rank_condition (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_178318 (h0 : functor.add_const (monoid (has_nndist name)) (has_nndist Type)) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} name)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_178319 (h0 : topological_space (simple_graph (has_le environment.projection_info))) (h1 : preorder (simple_graph (has_le environment.projection_info))) : order_closed_topology (simple_graph (has_le environment.projection_info)) := sorry --non-trivial
lemma new_lemma_178320 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_178321 (h0 : add_group (add_cancel_comm_monoid (option unsigned))) : is_add_cyclic (add_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_178322 (h0 : filter (normed_comm_ring (add_left_cancel_monoid (has_add linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_178323 (h1 : not (ring (uniform_space to_additive.value_type) -> false)) : @is_domain.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_178324 (h0 : functor.add_const (filter (has_edist empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178325 (h0 : functor.comp ordered_add_comm_monoid mul_zero_class pos) : @archimedean.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_178326 (h0 : functor.add_const Prop (has_add (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_178327 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_178328 (h0 : ring (has_top (semiring linarith.comp))) : is_domain (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_178329 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_178330 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178331 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_178332 (h0 : topological_space (monoid_with_zero (option ennreal))) : t1_space (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_178333 (h0 : semiring (boolean_algebra.core (option ennreal))) : is_noetherian_ring (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_178334 (h0 : topological_space (has_neg_part pos)) : t0_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_178335 (h0 : function.extfun (Type 1) (prod (plift (semiring (semiring (semiring (semiring (semiring empty)))))))) : id_rel (function.extfun_app h0 (plift (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_178336 (h2 : ring (uniform_space to_additive.value_type)) : rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178337 (h1 : not (ring (has_compl (denumerable linarith.comp_source)) -> false)) : @rank_condition.{0} (has_compl.{0} (denumerable.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (denumerable.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_178338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : set.diagonal fun_info (function.extfun_app (function.extfun_app h0 (prod fun_info)) fun_info) := sorry --non-trivial
lemma new_lemma_178339 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf real))))) : discrete_topology (ordered_comm_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_178340 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178341 (h0 : topological_space (simple_graph (has_lt to_additive.value_type))) : t0_space (simple_graph (has_lt to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178342 (h0 : group (has_nndist Type)) : is_cyclic (has_nndist Type) := sorry --non-trivial
lemma new_lemma_178343 (h0 : topological_space (random_gen (has_norm (has_top (has_top (has_top num)))))) : irreducible_space (random_gen (has_norm (has_top (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_178344 (h0 : group (random_gen (has_top (has_top (has_top linarith.ineq))))) : group.fg (random_gen (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_178345 (h0 : topological_space (has_append (mul_one_class (mul_one_class fun_info)))) : t0_space (has_append (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_178346 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_178347 (h0 : group (add_group (has_norm (has_norm (has_norm linarith.comp))))) : is_cyclic (add_group (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_178348 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_178349 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid Type))) : irreducible_space (ordered_comm_ring (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_178350 (h4 : topological_space (add_comm_semigroup linarith.ineq)) : path_connected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_178351 (h1 : ring (has_ssubset std_gen)) : strong_rank_condition (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_178352 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_178353 (h0 : functor.add_const (uniform_space (has_Inf name)) Type) : @separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_178354 (h0 : functor.add_const (finset (ring Type)) (finset Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178355 (h1 : complete_lattice (with_one (with_bot congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (with_one (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178356 (h0 : functor.add_const (list environment.implicit_infer_kind) (finset linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178357 (h0 : list (distrib_lattice (has_inv (has_inv (has_inv linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178358 (h0 : function.extfun Type group) : @group.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178359 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid pos))) : sequential_space (complete_distrib_lattice (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_178360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_178361 (h0 : ring (ordered_cancel_add_comm_monoid (option (option pos)))) : is_domain (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_178362 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178363 (h0 : filter (semigroup (finset (finset (has_nndist (finset (finset pos))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178364 (h1 : complete_lattice (add_monoid (has_nnnorm to_additive.value_type))) : is_compactly_generated (add_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178365 (h0 : functor.add_const (complete_lattice (has_add name)) (has_add name)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_178366 (h0 : not (topological_space (id num) -> false)) : @t0_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_178367 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_178368 (h0 : topological_space (denumerable to_additive.value_type)) : irreducible_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178369 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_178370 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_178371 (h0 : ring (encodable char)) : rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_178372 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_178373 (h0 : add_monoid (boolean_algebra.core name)) : add_monoid.fg (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_178374 (h0 : not (list (denumerable string_imp) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_178375 (h0 : add_group (metric_space (semiring (semiring (semiring (has_top num)))))) : is_add_cyclic (metric_space (semiring (semiring (semiring (has_top num))))) := sorry --non-trivial
lemma new_lemma_178376 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) linarith.comp) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) (comm_group name)) := sorry --non-trivial
lemma new_lemma_178377 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178378 (h1 : group (has_top (has_top to_additive.value_type))) : is_cyclic (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178379 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178380 (h0 : topological_space (semigroup (has_neg_part (has_neg_part Type)))) : loc_path_connected_space (semigroup (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_178381 (h0 : topological_space (has_Sup congr_arg_kind)) : irreducible_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178382 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178384 (h0 : ring (linear_ordered_comm_group_with_zero fun_info)) : rank_condition (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_178385 (h0 : functor.comp topological_space has_neg Type) : @sequential_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_178386 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) num) : @discrete_topology.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_178387 (h0 : not (topological_space (with_one empty) -> false)) : @irreducible_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178388 (h0 : group (has_nnnorm (random_gen char))) : is_cyclic (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_178389 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @preconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_178390 (h0 : topological_space (has_zero (option (option (option pos))))) : preconnected_space (has_zero (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_178391 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring unsigned)) (option (option unsigned))) : @archimedean.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178392 (h0 : topological_space (has_neg_part (has_add (has_add Type)))) : topological_space.separable_space (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_178393 (h0 : fin has_zero.zero) : list.head (empty.elim (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_178394 (h0 : preorder (has_dist unsigned)) (h1 : set (has_dist unsigned)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_178395 (h0 : not (complete_lattice (normed_group to_additive.value_type) -> false)) : @is_atomistic.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_178396 (h0 : topological_space (semiring (random_gen congr_arg_kind))) : locally_compact_space (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178397 (h0 : topological_space (has_Inf (has_Inf (generalized_boolean_algebra pos)))) : discrete_topology (has_Inf (has_Inf (generalized_boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_178398 (h0 : topological_space (linear_order (option (option (option (option (option unsigned))))))) : totally_separated_space (linear_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_178399 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178400 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178401 (h0 : functor.add_const (topological_space (ring Type)) (has_neg Type)) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_178402 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178403 (h0 : topological_space (has_to_string linarith.comp)) : normal_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_178404 (h0 : topological_space (has_union (semiring (has_norm (semiring linarith.comp))))) : preirreducible_space (has_union (semiring (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_178405 (h0 : ring (semi_normed_ring reducibility_hints)) : rank_condition (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_178406 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_pos_part pos)) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_178407 (h1 : ring (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_178408 (h0 : ring (add_cancel_monoid (comm_group linarith.comp))) : rank_condition (add_cancel_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_178409 (h0 : group (plift linarith.ineq)) : is_cyclic (plift linarith.ineq) := sorry --non-trivial
lemma new_lemma_178410 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_178411 (h0 : functor.add_const Prop znum) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_178412 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178413 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_178414 (h0 : topological_space (monoid_with_zero pos)) : t0_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_178415 (h0 : group (filter empty)) : group.fg (filter empty) := sorry --non-trivial
lemma new_lemma_178416 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_178417 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_178418 (h0 : topological_space (boolean_algebra (boolean_algebra (has_Inf (has_Inf (has_Inf pos)))))) : t0_space (boolean_algebra (boolean_algebra (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_178419 (h0 : topological_space (add_comm_monoid (comm_group (comm_group Type)))) : preirreducible_space (add_comm_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_178420 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_178422 (h0 : topological_space (ordered_comm_ring (has_Inf (has_bot real)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_178423 (h0 : functor.add_const (complete_lattice (has_to_string Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_178424 (h0 : functor.add_const (uniform_space (has_pos_part pos)) linarith.comp) : @complete_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178425 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178426 (h1 : topological_space (has_emptyc (random_gen congr_arg_kind))) : locally_compact_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178427 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_178428 (h0 : uniform_space (has_add congr_arg_kind)) : complete_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178429 (h1 : measurable_space std_gen) (h2 : measure_theory.measure std_gen) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_178430 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @normal_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178431 (h0 : functor.add_const (group (canonically_ordered_add_monoid unsigned)) congr_arg_kind) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_178432 (h3 : complete_lattice (has_lt char)) : complete_lattice.is_Sup_finite_compact (has_lt char) := sorry --non-trivial
lemma new_lemma_178433 (h0 : list (has_top (dlist fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178434 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (measure_theory.measure_space empty)) := sorry --non-trivial
lemma new_lemma_178435 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf Type)))) : loc_path_connected_space (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_178436 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_178437 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : irreducible_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_178438 (h0 : fin has_zero.zero) : @is_atomistic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_178439 (h0 : not (topological_space (has_top unsigned) -> false)) : @t1_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178440 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178441 (h0 : ring (has_neg_part (option name))) : is_domain (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_178442 (h1 : topological_space (add_cancel_comm_monoid (metric_space to_additive.value_type))) : t0_space (add_cancel_comm_monoid (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178443 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @locally_compact_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178444 (h0 : measurable_space (has_dist (has_edist empty))) (h1 : has_add (has_dist (has_edist empty))) : has_measurable_add (has_dist (has_edist empty)) := sorry --non-trivial
lemma new_lemma_178445 (h1 : topological_space (uniform_space (has_lt to_additive.value_type))) : totally_disconnected_space (uniform_space (has_lt to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178446 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_178447 (h0 : ring (semiring congr_arg_kind)) : is_domain (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178448 (h1 : group (id string_imp)) : normalizer_condition (id string_imp) := sorry --non-trivial
lemma new_lemma_178449 (h0 : topological_space (has_add (has_neg (has_neg (has_neg (add_cancel_monoid Type)))))) : discrete_topology (has_add (has_neg (has_neg (has_neg (add_cancel_monoid Type))))) := sorry --non-trivial
lemma new_lemma_178450 (h0 : function.extfun to_additive.value_type (fun (x : to_additive.value_type), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) to_additive.value_type (@function.extfun_app.{1 1} to_additive.value_type (λ (x : to_additive.value_type), Prop) h0)  := sorry --non-trivial
lemma new_lemma_178451 (h0 : ring (complete_semilattice_Sup (has_norm linarith.comp_source))) : is_domain (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178452 (h0 : group (add_cancel_monoid (has_add (has_add Type)))) : is_simple_group (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_178453 (h0 : finset (normed_linear_ordered_group (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178454 (h0 : topological_space (has_Inf (has_Inf (has_Inf real)))) : t0_space (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_178455 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @t0_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_178456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_178457 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (ordered_comm_monoid Type)))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_Inf (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_178458 (h0 : functor.add_const (complete_lattice (linear_ordered_field unsigned)) (option unsigned)) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_field.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_178459 (h0 : complete_lattice (has_to_string (finset ennreal))) : is_compactly_generated (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_178460 (h0 : prod (partial_order (semiring unsigned)) (partial_order (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_178461 (h0 : topological_space (distrib (random_gen char))) : path_connected_space (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_178462 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178463 (h0 : add_group (has_top (with_bot to_additive.value_type))) : is_add_cyclic (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178464 (h0 : uniform_space (normed_group (random_gen linarith.ineq))) : complete_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178465 (h0 : function.extfun Type group) : @normalizer_condition.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_178466 (h0 : not (group (normed_field ennreal) -> false)) : @is_cyclic.{0} (normed_field.{0} ennreal) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_178467 (h0 : topological_space (semigroup (has_add (finset pos)))) : t1_space (semigroup (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_178468 (h0 : topological_space (has_nndist (has_add (finset environment.implicit_infer_kind)))) : regular_space (has_nndist (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_178469 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf pos)))) : locally_compact_space (boolean_algebra (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_178470 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_178471 (h1 : set (linear_ordered_comm_group_with_zero environment.projection_info)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_178472 (h0 : topological_space (has_neg_part (cancel_monoid (has_nndist ennreal)))) : preirreducible_space (has_neg_part (cancel_monoid (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_178473 (h0 : has_mem.mem (function.extfun Type) has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@multiset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_178474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_178475 (h1 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h1) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178476 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_178477 (h0 : fin has_zero.zero) : @archimedean.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_178478 (h0 : functor.add_const (topological_space (add_group unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_178479 (h0 : canonically_ordered_monoid real -> canonically_ordered_monoid real -> Prop) : is_antisymm (canonically_ordered_monoid real) h0 := sorry --non-trivial
lemma new_lemma_178480 (h1 : topological_space (non_unital_non_assoc_semiring string_imp)) (h2 : preorder (non_unital_non_assoc_semiring string_imp)) : order_topology (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_178481 (h0 : filter (with_bot (has_norm (has_norm empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_178483 (h0 : group (canonically_ordered_monoid (has_bot (has_bot (has_Inf real))))) : is_cyclic (canonically_ordered_monoid (has_bot (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_178484 (h0 : monoid (add_comm_monoid (has_neg linarith.comp))) : monoid.fg (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_178485 (h0 : ring (has_norm (random_gen (random_gen num)))) : is_domain (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_178486 (h0 : uniform_space (has_to_string (ring (add_comm_monoid environment.implicit_infer_kind)))) : complete_space (has_to_string (ring (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_178487 (h0 : ring (simple_graph (option (option empty)))) : is_domain (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_178488 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_add real))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_178489 (h2 : ring (comm_ring (has_nnnorm (comm_ring fun_info)))) : rank_condition (comm_ring (has_nnnorm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_178490 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @normal_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178491 (h0 : ordered_add_comm_monoid (has_pos_part (has_neg (ring Type)))) : archimedean (has_pos_part (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_178492 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_add linarith.comp)) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178493 (h0 : ring (ring (has_pos_part linarith.comp))) : is_domain (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_178494 (h0 : topological_space (has_top linarith.ineq)) : totally_disconnected_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_178495 (h2 : ring (has_append (random_gen char))) : strong_rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_178496 (h1 : filter (encodable (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_178497 (h0 : functor.add_const (topological_space (has_neg_part pos)) (option pos)) : @t1_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_178498 (h0 : group (has_norm (random_gen (has_top (has_top (has_top linarith.ineq)))))) : normalizer_condition (has_norm (random_gen (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_178499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178500 (h0 : group (add_cancel_comm_monoid (has_nnnorm (random_gen string.iterator_imp)))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_178501 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_178502 (h0 : functor.add_const (filter (add_comm_monoid pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178503 (h1 : ring (uniform_space string_imp)) : rank_condition (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_178504 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_178505 (h0 : topological_space (finset (option unsigned))) : loc_path_connected_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_178506 (h0 : group (topological_space (topological_space (comm_ring reducibility_hints)))) : is_cyclic (topological_space (topological_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_178507 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg environment.implicit_infer_kind)) : @sequential_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_178508 (h1 : topological_space (dlist char)) : irreducible_space (dlist char) := sorry --non-trivial
lemma new_lemma_178509 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178510 (h0 : group (has_ssubset (has_inv linarith.ineq))) : is_cyclic (has_ssubset (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178511 (h0 : functor.add_const (list (has_add linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178512 (h2 : set ereal) : set.finite h2 := sorry --non-trivial
lemma new_lemma_178513 (h0 : group (normed_comm_ring environment.implicit_infer_kind)) : group.fg (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_178514 (h0 : topological_space (semigroup (has_add (has_neg_part Type)))) : topological_space.separable_space (semigroup (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_178515 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178516 (h0 : group (complete_distrib_lattice (has_to_string (has_neg_part pos)))) : is_cyclic (complete_distrib_lattice (has_to_string (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_178517 (h4 : uniform_space (uniform_space linarith.comp_source)) : complete_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178518 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp)  := sorry --non-trivial
lemma new_lemma_178519 (h0 : uniform_space (ordered_comm_group unsigned)) : complete_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_178520 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178521 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178522 (h0 : prod (canonically_ordered_comm_semiring unsigned) (canonically_ordered_comm_semiring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_178523 (h0 : topological_space (has_ssubset (has_ssubset linarith.ineq))) : path_connected_space (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178524 (h0 : topological_space (mul_zero_class (left_cancel_monoid pos))) : sequential_space (mul_zero_class (left_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_178525 (h0 : topological_space (has_one unsigned)) : totally_separated_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_178526 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core linarith.comp)) (has_add linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178527 (h0 : topological_space (measurable_space (has_top (has_top fun_info)))) : totally_separated_space (measurable_space (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_178528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_178529 (h0 : topological_space (option (semiring (semiring unsigned)))) : normal_space (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_178530 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_178531 (h0 : topological_space (pseudo_metric_space (has_neg_part (has_neg_part (has_neg_part pos))))) : totally_disconnected_space (pseudo_metric_space (has_neg_part (has_neg_part (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_178532 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @totally_separated_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_178533 (h0 : uniform_space (group_with_zero num)) : separated_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_178534 (h0 : complete_lattice (has_norm (semiring (semiring (semiring empty))))) : complete_lattice.is_Sup_finite_compact (has_norm (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_178535 (h0 : functor.add_const (topological_space (has_dist empty)) empty) : @irreducible_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_178536 (h0 : not (topological_space (has_sub unsigned) -> false)) : @totally_separated_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_178538 (h0 : functor.add_const (add_group (preorder congr_arg_kind)) unsigned) : @is_add_cyclic.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178539 (h0 : group (complete_semilattice_Sup (has_norm congr_arg_kind))) : is_cyclic (complete_semilattice_Sup (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178540 (h0 : topological_space (has_norm linarith.comp_source)) : irreducible_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178541 (h0 : has_coe (has_ssubset linarith.ineq) Prop) (h2 : has_ssubset linarith.ineq) : @coe_b.{1 1} (has_ssubset.{0} linarith.ineq) Prop h0 h2  := sorry --non-trivial
lemma new_lemma_178542 (h0 : complete_lattice (simple_graph environment.projection_info)) : is_compactly_generated (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_178543 (h0 : ring (with_bot (has_union linarith.comp))) : is_domain (with_bot (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_178544 (h0 : add_group (semiring (has_top (has_norm fun_info)))) : is_add_cyclic (semiring (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_178545 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178546 (h0 : topological_space (add_comm_monoid (finset environment.implicit_infer_kind))) : totally_disconnected_space (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178547 (h0 : topological_space (add_comm_semigroup (set.set_semiring fun_info))) : t0_space (add_comm_semigroup (set.set_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_178548 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @separated_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178549 (h0 : add_group (boolean_algebra.core (has_add Type))) : is_add_cyclic (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_178550 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_178551 (h1 : add_group (with_one to_additive.value_type)) : is_add_cyclic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178552 (h0 : complete_lattice (boolean_algebra.core (has_neg environment.implicit_infer_kind))) : is_atomistic (boolean_algebra.core (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178553 (h1 : complete_lattice (with_one (has_append linarith.ineq))) : complete_lattice.is_Sup_finite_compact (with_one (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178554 (h0 : topological_space (has_inter (option empty))) : normal_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_178555 (h0 : not (complete_lattice (with_zero linarith.comp_source) -> false)) : @is_compactly_generated.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_178556 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_178557 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178558 (h0 : group (random_gen (has_ssubset linarith.comp_source))) : group.fg (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178559 (h0 : group (has_bot (has_bot real))) : is_simple_group (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_178560 (h0 : semiring (option empty) -> semiring (option empty) -> Prop) : is_trans (semiring (option empty)) h0 := sorry --non-trivial
lemma new_lemma_178561 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_178562 (h3 : ring string.iterator_imp) : is_domain string.iterator_imp := sorry --non-trivial
lemma new_lemma_178563 (h0 : topological_space (has_nndist (has_to_string num))) : t0_space (has_nndist (has_to_string num)) := sorry --non-trivial
lemma new_lemma_178564 (h2 : uniform_space (semi_normed_comm_ring char)) : complete_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_178565 (h0 : topological_space (id (random_gen linarith.comp_source))) : totally_separated_space (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178566 (h0 : topological_space (boolean_algebra (has_add (normed_comm_ring (normed_comm_ring Type))))) : totally_disconnected_space (boolean_algebra (has_add (normed_comm_ring (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_178567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_178568 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_178569 (h0 : topological_space (has_Inf (has_pos_part real))) : discrete_topology (has_Inf (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_178570 (h1 : Type -> Type -> Prop) (h2 : Pi (x : Type), (Pi (y : Type), h1 y x -> complete_lattice y) -> complete_lattice x) (h3 : acc h1 char) : @complete_lattice.is_Sup_finite_compact.{0} char (@well_founded.fix_F.{2 1} Type h1 complete_lattice.{0} h2 char h3)  := sorry --non-trivial
lemma new_lemma_178571 (h0 : complete_lattice (pseudo_metric_space (has_add pos))) : is_compactly_generated (pseudo_metric_space (has_add pos)) := sorry --non-trivial
lemma new_lemma_178572 (h0 : ring (lex (semiring (semiring (semiring (semiring (semiring unsigned))))))) : strong_rank_condition (lex (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_178573 (h0 : fin has_zero.zero) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_178574 (h0 : group (canonically_ordered_monoid (has_neg real))) : is_simple_group (canonically_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_178575 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_178576 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_178577 (h0 : functor.add_const (topological_space (has_sub pos)) (has_neg environment.implicit_infer_kind)) : @sequential_space.{0} (has_sub.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_sub.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_178578 (h0 : topological_space (semigroup (has_Inf (has_Inf (has_pos_part pos))))) : irreducible_space (semigroup (has_Inf (has_Inf (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_178579 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @regular_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_178580 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_neg linarith.comp)) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178581 (h0 : add_group (has_nnnorm (mul_one_class reducibility_hints))) : is_add_cyclic (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_178582 (h0 : topological_space (with_bot (has_norm linarith.ineq))) : totally_disconnected_space (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178583 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_178584 (h0 : prod (has_add ennreal) (has_add ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_178585 (h0 : topological_space (ring (has_add (ring (has_add Type))))) : sequential_space (ring (has_add (ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_178586 (h0 : topological_space (with_zero linarith.ineq)) (h1 : has_sub (with_zero linarith.ineq)) : has_continuous_sub (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_178587 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_178588 (h0 : semiring (has_zero (finset (finset name)))) : is_noetherian_ring (has_zero (finset (finset name))) := sorry --non-trivial
lemma new_lemma_178589 (h0 : uniform_space (add_cancel_monoid (has_add (has_add Type)))) : complete_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_178590 (h0 : topological_space (fintype to_additive.value_type)) : t0_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178591 (h0 : list (pseudo_metric_space (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178592 (h0 : functor.add_const (cancel_comm_monoid_with_zero (option ennreal)) pos) : @unique_factorization_monoid.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (option.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_178593 (h0 : group (add_comm_monoid (option unsigned))) : is_simple_group (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_178594 (h0 : ring (has_to_string (mul_one_class linarith.comp))) : rank_condition (has_to_string (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_178595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_178596 (h1 : complete_lattice to_additive.value_type) : is_compactly_generated to_additive.value_type := sorry --non-trivial
lemma new_lemma_178597 (h4 : add_group (uniform_space to_additive.value_type)) : is_add_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_178598 (h0 : list (has_add (has_neg (has_neg linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178599 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class environment.projection_info)))) (h1 : preorder (has_nnnorm (mul_one_class (mul_one_class environment.projection_info)))) : order_closed_topology (has_nnnorm (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_178600 (h0 : group (id (has_norm congr_arg_kind))) : is_cyclic (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178601 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg name))) : separated_space (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_178602 (h0 : topological_space (normed_lattice_add_comm_group pos)) : preirreducible_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_178603 (h2 : has_lt (has_nnnorm reducibility_hints)) : no_max_order (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_178604 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @normalizer_condition.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178605 (h0 : add_group (boolean_algebra.core name)) : is_add_cyclic (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_178606 (h0 : filter (has_one empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178607 (h0 : ring (fintype (has_ssubset linarith.comp_source))) : strong_rank_condition (fintype (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178608 (h0 : topological_space (boolean_algebra.core ennreal)) : regular_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_178609 (h1 : topological_space (has_compl string.iterator_imp)) : t0_space (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_178610 (h0 : topological_space environment.projection_info) (h1 : pfun string.iterator_imp (preorder environment.projection_info)) (h2 : coe_sort (pfun.dom h1)) : @order_topology.{0} environment.projection_info h0 (@pfun.as_subtype.{0 0} string.iterator_imp (preorder.{0} environment.projection_info) h1 h2)  := sorry --non-trivial
lemma new_lemma_178611 (h0 : not (group (has_nnnorm char) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_178612 (h0 : complete_lattice (normed_group (has_top (has_top fun_info)))) : is_compactly_generated (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_178613 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup num))) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_178614 (h0 : ring (has_Inf unsigned)) : strong_rank_condition (has_Inf unsigned) := sorry --non-trivial
lemma new_lemma_178615 (h0 : monoid (is_R_or_C (semiring (semiring empty)))) : monoid.fg (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_178616 (h0 : topological_space (has_neg ennreal)) : t1_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_178617 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : totally_disconnected_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_178618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_Sup.{0} (ordered_ring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} (ordered_ring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_178619 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178620 (h0 : list (with_one (with_bot string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178621 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @locally_compact_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178622 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} (has_ssubset.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} (has_ssubset.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_178623 (h0 : ring (with_bot (comm_ring fun_info))) : rank_condition (with_bot (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_178624 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178625 (h0 : topological_space (cancel_monoid (comm_monoid (option unsigned)))) : discrete_topology (cancel_monoid (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_178626 (h0 : function.extfun Type (functor.add_const (topological_space unsigned))) : @normal_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} unsigned)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_178627 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178628 (h0 : functor.add_const (ring (left_cancel_monoid empty)) empty) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_178629 (h0 : group (semiring linarith.ineq)) : is_cyclic (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_178630 (h2 : not (ring (comm_ring to_additive.value_type) -> false)) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_178631 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_178632 (h0 : not (add_monoid (measurable_space.dynkin_system congr_arg_kind) -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178633 (h0 : ring (has_lt reducibility_hints)) : strong_rank_condition (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_178634 (h0 : topological_space (has_union fun_info)) : locally_compact_space (has_union fun_info) := sorry --non-trivial
lemma new_lemma_178635 (h0 : normed_group empty -> normed_group empty -> Prop) : is_symm (normed_group empty) h0 := sorry --non-trivial
lemma new_lemma_178636 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_178637 (h0 : ordered_add_comm_monoid (has_inner empty num)) : archimedean (has_inner empty num) := sorry --non-trivial
lemma new_lemma_178638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178639 (h0 : group (add_comm_monoid (has_add Type))) : group.fg (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_178640 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : t0_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_178641 (h0 : topological_space (has_inter empty)) : normal_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_178642 (h0 : fin has_zero.zero) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_178643 (h0 : not (filter (add_cancel_comm_monoid fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_178644 (h0 : topological_space (has_to_string (has_Inf (has_add (finset pos))))) : locally_compact_space (has_to_string (has_Inf (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_178645 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_178646 (h0 : ring (mul_zero_class name)) : is_principal_ideal_ring (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_178647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178648 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178649 (h0 : set (prod (semiring empty) (semiring empty))) (h1 : function.extfun Type (prod (semiring empty))) : symmetrize_rel h0 (function.extfun_app h1 (semiring empty)) := sorry --non-trivial
lemma new_lemma_178650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178651 (h0 : ring (has_compl (random_gen linarith.ineq))) : strong_rank_condition (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178652 (h0 : functor.add_const (prod (measurable_space.dynkin_system empty) (measurable_space.dynkin_system empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178653 (h0 : semiring (ordered_ring num)) : is_noetherian_ring (ordered_ring num) := sorry --non-trivial
lemma new_lemma_178654 (h0 : group (ring Type)) : normalizer_condition (ring Type) := sorry --non-trivial
lemma new_lemma_178655 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178656 (h0 : ring (has_div fun_info)) : rank_condition (has_div fun_info) := sorry --non-trivial
lemma new_lemma_178657 (h0 : functor.add_const (function.extfun Type list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_178658 (h0 : ring (has_norm (has_top fun_info))) : strong_rank_condition (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_178659 (h0 : topological_space (distrib (mul_one_class fun_info))) : totally_disconnected_space (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_178660 (h0 : function.extfun (ring (add_monoid fun_info) -> false) (fun (x : ring (add_monoid fun_info) -> false), false)) : @rank_condition.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) (@function.extfun_app.{0 0} (ring.{0} (add_monoid.{0} fun_info) → false) (λ (x : ring.{0} (add_monoid.{0} fun_info) → false), false) h0))  := sorry --non-trivial
lemma new_lemma_178661 (h0 : set (linarith.ineq -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_178662 (h0 : functor.add_const (group (semigroup name)) Type) : @normalizer_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_178663 (h0 : list (linear_ordered_field (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178664 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_178665 (h0 : topological_space (normed_comm_ring (add_group unsigned))) : discrete_topology (normed_comm_ring (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_178666 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @discrete_topology.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_178667 (h0 : ring (linear_ordered_add_comm_group (measurable_space to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178668 (h0 : topological_space (simple_graph (ring (has_add pos)))) : totally_disconnected_space (simple_graph (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_178669 (h0 : uniform_space (left_cancel_semigroup (semiring (semiring unsigned)))) : complete_space (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_178670 (h0 : topological_space (has_nndist (cancel_monoid ennreal))) : sequential_space (has_nndist (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_178671 (h0 : ring (has_inv (has_inv linarith.ineq))) : is_domain (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178672 (h0 : complete_lattice (distrib (mul_one_class (mul_one_class (distrib fun_info))))) : is_compactly_generated (distrib (mul_one_class (mul_one_class (distrib fun_info)))) := sorry --non-trivial
lemma new_lemma_178673 (h0 : functor.add_const (semiring (simple_graph pos)) Type) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_178674 (h0 : semiring (boolean_algebra (has_pos_part (has_bot (has_bot pos))))) : is_noetherian_ring (boolean_algebra (has_pos_part (has_bot (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_178675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_178676 (h0 : topological_space (has_Sup unsigned)) : irreducible_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_178677 (h0 : comm_ring fun_info -> comm_ring fun_info -> comm_ring fun_info) (h1 : comm_ring fun_info) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_178678 (h0 : functor.add_const (list (measurable_space.dynkin_system unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178679 (h0 : group (encodable (has_top (random_gen linarith.comp_source)))) : group.fg (encodable (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178680 (h0 : topological_space (add_comm_monoid ennreal)) : totally_disconnected_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_178681 (h0 : filter (normed_comm_ring (boolean_algebra.core name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_178682 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178683 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178684 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group empty)) empty) : @archimedean.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_178685 (h0 : topological_space (normed_comm_ring (ring (option pos)))) : sequential_space (normed_comm_ring (ring (option pos))) := sorry --non-trivial
lemma new_lemma_178686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178687 (h0 : topological_space (complete_semilattice_Sup linarith.comp_source)) : t0_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_178688 (h0 : complete_lattice (linear_order unsigned)) : complete_lattice.is_Sup_finite_compact (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_178689 (h0 : functor.add_const (list (boolean_algebra.core pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178691 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178692 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : normal_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_178693 (h0 : topological_space (has_add (has_add (has_pos_part linarith.comp)))) : discrete_topology (has_add (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_178694 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preirreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178695 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178696 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_178697 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : normal_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_178698 (h1 : set (to_additive.value_type -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_178699 (h0 : add_group (denumerable (random_gen (random_gen char)))) : is_add_cyclic (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_178700 (h0 : topological_space (random_gen (has_top (has_top linarith.comp_source)))) : totally_separated_space (random_gen (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178701 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @normal_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_178702 (h3 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))))) (h4 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))))) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_178703 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178704 (h0 : semiring (has_inter congr_arg_kind)) : is_noetherian_ring (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178705 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_178706 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178707 (h0 : functor.add_const (topological_space (has_neg unsigned)) Type) : @path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_178708 (h0 : ordered_add_comm_monoid (finset (has_pos_part (has_Inf linarith.comp)))) : archimedean (finset (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_178709 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_zero.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_178710 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_cancel_comm_monoid empty)))) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_178711 (h0 : topological_space (has_zero ennreal)) : regular_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_178712 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero pos)) (has_neg_part name)) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} pos)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_178713 (h0 : not (add_monoid (linear_ordered_semiring congr_arg_kind) -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178714 (h0 : topological_space (option (semiring unsigned))) : t1_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_178715 (h0 : ring (canonically_linear_ordered_monoid (has_neg real))) : rank_condition (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_178716 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_neg linarith.comp))) : archimedean (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_178717 (h0 : functor.add_const (add_monoid (complete_distrib_lattice name)) pos) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_178718 (h0 : group (has_bot name)) : is_cyclic (has_bot name) := sorry --non-trivial
lemma new_lemma_178719 (h0 : complete_lattice (has_pos_part (has_neg (has_add (canonically_linear_ordered_monoid real))))) : is_compactly_generated (has_pos_part (has_neg (has_add (canonically_linear_ordered_monoid real)))) := sorry --non-trivial
lemma new_lemma_178720 (h0 : ring (boolean_algebra (has_neg_part Type))) : rank_condition (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_178721 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_178722 (h0 : complete_lattice (measurable_space (random_gen (has_norm fun_info)))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_178723 (h0 : functor.add_const (finset (left_cancel_semigroup num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178724 (h0 : topological_space (has_pos_part Type)) : path_connected_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_178725 (h0 : topological_space (simple_graph (has_pos_part (finset (has_Inf (finset linarith.comp)))))) : regular_space (simple_graph (has_pos_part (finset (has_Inf (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_178726 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid linarith.comp)))) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_178727 (h0 : group (add_semigroup unsigned)) : is_cyclic (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_178728 (h0 : topological_space (has_nndist unsigned)) : locally_compact_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_178729 (h0 : add_group (with_bot (has_inv linarith.comp_source))) : is_add_cyclic (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178730 (h0 : prod (semigroup name) (semigroup name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_178731 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178732 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178733 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_178734 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178735 (h0 : functor.add_const (list (monoid empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178736 (h0 : complete_lattice (has_to_string (has_neg_part Type))) : is_atomistic (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_178737 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178738 (h0 : complete_lattice (has_nndist (has_neg environment.implicit_infer_kind))) : is_compactly_generated (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_178740 (h0 : filter (complete_semilattice_Sup (has_ssubset to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178741 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_178742 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178743 (h0 : group (encodable linarith.ineq)) : group.fg (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_178744 (h0 : function.extfun Type (functor.add_const (list (normed_linear_ordered_group empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_178745 (h0 : topological_space (add_cancel_monoid (ring name))) : totally_disconnected_space (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_178746 (h0 : group (has_top (random_gen string_imp))) : is_cyclic (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_178747 (h0 : topological_space (finset (has_Inf Type))) : loc_path_connected_space (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_178748 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : topological_space.separable_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_178749 (h0 : ring (boolean_algebra.core linarith.comp)) : is_principal_ideal_ring (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_178750 (h0 : has_neg (has_compl (mul_one_class (mul_one_class environment.projection_info)))) (h1 : measurable_space (has_compl (mul_one_class (mul_one_class environment.projection_info)))) : has_measurable_neg (has_compl (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_178751 (h0 : semiring (has_add congr_arg_kind)) : is_noetherian_ring (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_178752 (h0 : functor.add_const (finset (measurable_space.dynkin_system num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178753 (h0 : complete_lattice (has_lt (mul_one_class (mul_one_class linarith.ineq)))) : is_compactly_generated (has_lt (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_178754 (h0 : not (add_monoid (add_group unsigned) -> false)) : @add_monoid.fg.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_178755 (h0 : unsigned -> semiring (semiring (semiring congr_arg_kind)) -> semiring (semiring (semiring congr_arg_kind))) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_178756 (h0 : topological_space (boolean_algebra.core Type)) : topological_space.separable_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_178757 (h0 : ordered_comm_monoid (has_nndist (has_add (has_add name)))) : has_exists_mul_of_le (has_nndist (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_178758 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) unsigned) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178759 (h0 : group (has_one (linear_ordered_semiring empty))) : group.fg (has_one (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_178760 (h0 : pnat) (h1 : Prop) (h2 : not h1) (h3 : h1) : pnat.coprime h0 (matrix.vec_empty (ulower.up (not.elim h2 h3))) := sorry --trivial
lemma new_lemma_178761 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_178762 (h0 : ring (has_add (finset (ring (has_to_string (ring (has_add Type))))))) : rank_condition (has_add (finset (ring (has_to_string (ring (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_178763 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_178764 (h0 : list (group_with_zero num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178765 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : irreducible_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178766 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_178767 (h0 : filter (canonically_linear_ordered_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178768 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : loc_path_connected_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_178769 (h0 : functor.add_const (function.extfun Type topological_space) name) : @regular_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178770 (h0 : monoid (bin_tree (semiring (semiring num)))) : monoid.fg (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_178771 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_178772 (h0 : filter (measurable_space linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178773 (h1 : uniform_space (semi_normed_comm_ring std_gen)) : complete_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_178774 (h0 : add_monoid (add_comm_monoid (option num))) : add_monoid.fg (add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_178775 (h0 : topological_space (has_norm (random_gen (has_top linarith.comp_source)))) : path_connected_space (has_norm (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178776 (h0 : ring (with_bot (has_norm unsigned))) : strong_rank_condition (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_178777 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_178778 (h0 : topological_space (has_to_string (finset pos))) : normal_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_178779 (h0 : functor.add_const (group (semigroup linarith.comp)) name) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_178780 (h0 : functor.add_const (complete_lattice (is_R_or_C empty)) unsigned) : @is_compactly_generated.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178781 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_178782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178783 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_178784 (h0 : monoid (finset environment.implicit_infer_kind)) : monoid.fg (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_178785 (h0 : functor.comp uniform_space ring name) : @separated_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_178786 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_178787 (h0 : topological_space (add_cancel_monoid (has_add Type))) : t1_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_178788 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_178789 (h0 : group (generalized_boolean_algebra (ring (has_Inf pos)))) : group.fg (generalized_boolean_algebra (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_178790 (h0 : list (ring (ordered_ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178791 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : archimedean (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_178792 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178793 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : sequential_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_178794 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178795 (h0 : topological_space (has_neg (option (option (option unsigned))))) : path_connected_space (has_neg (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_178796 (h0 : group (with_one unsigned)) : normalizer_condition (with_one unsigned) := sorry --non-trivial
lemma new_lemma_178797 (h0 : topological_space (has_norm (has_norm (has_top linarith.comp_source)))) : irreducible_space (has_norm (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178798 (h0 : function.extfun Type (functor.add_const (semiring (linear_order empty)))) : @is_noetherian_ring.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (linear_order.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (linear_order.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_178799 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_178800 (h0 : ring (with_one string_imp)) : strong_rank_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_178801 (h0 : not (topological_space (semi_normed_comm_ring to_additive.value_type) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_178802 (h0 : measurable_space (add_comm_semigroup reducibility_hints)) (h1 : measure_theory.measure (add_comm_semigroup reducibility_hints)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_178803 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_178804 (h0 : functor.add_const (topological_space (as_linear_order empty)) num) : @totally_separated_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_178805 (h0 : ordered_comm_monoid (comm_group (has_to_string Type))) : has_exists_mul_of_le (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_178806 (h0 : topological_space (semigroup (has_pos_part Type))) : preconnected_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_178807 (h0 : functor.add_const (monoid (semigroup linarith.comp)) linarith.comp) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178808 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} pos (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) pos)  := sorry --non-trivial
lemma new_lemma_178809 (h1 : complete_lattice (has_nnnorm char)) : is_compactly_generated (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_178810 (h0 : ring (has_inv (random_gen linarith.comp_source))) : strong_rank_condition (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178811 (h0 : topological_space (has_add (has_neg environment.implicit_infer_kind))) : regular_space (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_178812 (h0 : ring (add_left_cancel_semigroup unsigned)) : is_principal_ideal_ring (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_178813 (h0 : group (measurable_space (has_inv linarith.comp_source))) : normalizer_condition (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178814 (h0 : ring (boolean_algebra (comm_group (comm_group (comm_group pos))))) : strong_rank_condition (boolean_algebra (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_178815 (h0 : ring (has_nndist (has_norm (random_gen unsigned)))) : rank_condition (has_nndist (has_norm (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_178816 (h0 : function.extfun (Type 1) (functor.add_const (list (ring pos)))) : list.nodup (functor.add_const.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_178817 (h0 : ring (partial_order (semiring unsigned))) : is_principal_ideal_ring (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_178818 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_178820 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178821 (h2 : topological_space linarith.comp_source) : totally_disconnected_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_178822 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} (has_add.{0} (comm_group.{0} (comm_group.{0} (comm_group.{0} name))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (has_add.{0} (comm_group.{0} (comm_group.{0} (comm_group.{0} name))))))  := sorry --non-trivial
lemma new_lemma_178823 (h0 : ring (has_add (has_neg name))) : strong_rank_condition (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_178824 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add name)))) : locally_compact_space (generalized_boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_178825 (h0 : semiring (has_bot unsigned)) : is_noetherian_ring (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_178826 (h0 : topological_space (finset empty)) : totally_disconnected_space (finset empty) := sorry --non-trivial
lemma new_lemma_178827 (h0 : group (is_R_or_C num)) : group.fg (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_178828 (h0 : functor.add_const (complete_lattice (bin_tree congr_arg_kind)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_178829 (h0 : complete_lattice (has_inter empty)) : is_atomistic (has_inter empty) := sorry --non-trivial
lemma new_lemma_178830 (h0 : semiring (has_add (has_pos_part linarith.comp))) : is_noetherian_ring (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_178831 (h1 : uniform_space (distrib (non_unital_non_assoc_semiring string_imp))) : complete_space (distrib (non_unital_non_assoc_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_178832 (h0 : group (denumerable (has_top fun_info))) : group.fg (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_178833 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_178834 (h0 : topological_space (semigroup num)) : loc_path_connected_space (semigroup num) := sorry --non-trivial
lemma new_lemma_178835 (h0 : multiset (has_dist string_imp)) (h1 : not (multiset (has_dist string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_178836 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_178837 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_compl.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_178838 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_178839 (h0 : functor.add_const (finset (bin_tree empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178840 (h0 : uniform_space (semigroup linarith.comp)) : separated_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_178841 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core Type))) : t0_space (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_178842 (h0 : ring (has_norm (has_norm (has_norm congr_arg_kind)))) : rank_condition (has_norm (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_178843 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_178844 (h0 : functor.add_const (add_group (has_to_string pos)) (has_neg_part pos)) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_178845 (h0 : topological_space (has_lt ereal)) : path_connected_space (has_lt ereal) := sorry --non-trivial
lemma new_lemma_178846 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_178847 (h0 : group (boolean_algebra.core (option (option (option empty))))) : normalizer_condition (boolean_algebra.core (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_178848 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_178849 (h0 : ring (semiring (has_top (has_top linarith.comp_source)))) : strong_rank_condition (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178850 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @t1_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_178851 (h0 : functor.add_const (list (has_Inf environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178852 (h0 : uniform_space (canonically_ordered_monoid (has_add pos))) : separated_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_178853 (h0 : monoid (has_top (measurable_space num))) : monoid.fg (has_top (measurable_space num)) := sorry --non-trivial
lemma new_lemma_178854 (h0 : fin has_zero.zero) : @separated_space.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_178855 (h0 : group (add_comm_monoid (comm_group Type))) : is_simple_group (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_178856 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_178857 (h0 : functor.add_const (ring (complete_distrib_lattice name)) name) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_178858 (h2 : set (set num)) : is_countably_spanning h2 := sorry --non-trivial
lemma new_lemma_178859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_178860 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_178861 (h0 : ring real) : rank_condition real := sorry --non-trivial
lemma new_lemma_178862 (h0 : not (ring (linear_ordered_add_comm_group linarith.ineq) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_178863 (h0 : functor.add_const (add_group (semigroup linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_178864 (h3 : topological_space (has_nnnorm (mul_one_class char))) : t0_space (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_178865 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178866 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) unsigned) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) unsigned h0) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178867 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_178868 (h0 : list (pseudo_metric_space (finset (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178869 (h0 : monoid (ordered_comm_ring Type)) : monoid.fg (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_178870 (h0 : group (has_zero (has_neg (normed_comm_ring Type)))) : is_cyclic (has_zero (has_neg (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_178871 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : path_connected_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_178872 (h0 : topological_space (distrib (comm_ring fun_info))) : path_connected_space (distrib (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_178873 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178874 (h0 : group (has_neg_part (finset name))) : is_simple_group (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_178875 (h0 : topological_space (has_nnnorm (non_unital_non_assoc_semiring enat))) : path_connected_space (has_nnnorm (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_178876 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_178877 (h0 : cancel_comm_monoid_with_zero (has_pos_part (comm_semigroup (sub_neg_monoid (has_Inf real))))) : unique_factorization_monoid (has_pos_part (comm_semigroup (sub_neg_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_178878 (h0 : not (topological_space (linear_ordered_semiring to_additive.value_type) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_178879 (h0 : topological_space (nondiscrete_normed_field ereal)) : path_connected_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_178880 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_178881 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_178882 (h0 : topological_space (add_comm_monoid (has_add pos))) : loc_path_connected_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_178883 (h0 : not (group (has_nnnorm (has_nnnorm linarith.comp_source)) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_178884 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @preirreducible_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178885 (h0 : topological_space auto.case_option) : discrete_topology auto.case_option := sorry --non-trivial
lemma new_lemma_178886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_178887 (h0 : group (simple_graph (has_add linarith.comp))) : group.fg (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_178888 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : totally_separated_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_178889 (h0 : add_group (has_le (normed_field (simple_graph reducibility_hints)))) : is_add_cyclic (has_le (normed_field (simple_graph reducibility_hints))) := sorry --non-trivial
lemma new_lemma_178890 (h0 : finset (has_add (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178891 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178892 (h0 : group (add_cancel_comm_monoid unsigned)) : normalizer_condition (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_178893 (h0 : functor.add_const Prop (comm_group name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_178894 (h0 : add_group (normed_lattice_add_comm_group (has_Inf Type))) : is_add_cyclic (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_178895 (h0 : ring (ordered_comm_ring (canonically_ordered_comm_semiring Type))) : is_principal_ideal_ring (ordered_comm_ring (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_178896 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid pos))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_178897 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_178898 (h0 : group (normed_lattice_add_comm_group (has_Inf linarith.comp))) : group.fg (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_178899 (h0 : topological_space (linear_ordered_field ennreal)) : path_connected_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_178900 (h0 : complete_lattice (has_pos_part linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_178901 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (finset.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_178902 (h7 : ring (has_ssubset (preorder linarith.ineq))) : is_domain (has_ssubset (preorder linarith.ineq)) := sorry --non-trivial
lemma new_lemma_178903 (h1 : complete_lattice (non_unital_non_assoc_semiring string_imp)) : is_compactly_generated (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_178904 (h0 : add_monoid (canonically_ordered_comm_semiring (finset Type))) : add_monoid.fg (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_178905 (h0 : group (comm_group name)) : is_cyclic (comm_group name) := sorry --non-trivial
lemma new_lemma_178906 (h0 : functor.add_const (ring environment.implicit_infer_kind) name) : @rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_178907 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) pos) : @add_monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_178908 (h0 : complete_lattice (dlist (has_nnnorm (has_nnnorm char)))) : is_compactly_generated (dlist (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_178909 (h0 : topological_space (has_zero (cancel_monoid pos))) : preconnected_space (has_zero (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_178910 (h1 : ring (has_compl (mul_one_class string.iterator_imp))) : strong_rank_condition (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_178911 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_178912 (h0 : filter (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178913 (h0 : uniform_space (semigroup (finset (finset pos)))) : separated_space (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_178914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_178915 (h0 : topological_space (add_group (semiring (semiring unsigned)))) : totally_disconnected_space (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_178916 (h0 : filter (id (add_group (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178917 (h0 : monoid (normed_comm_ring (comm_group (comm_group name)))) : monoid.fg (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_178918 (h1 : ring (topological_space (has_nnnorm string_imp))) : is_domain (topological_space (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_178919 (h0 : add_group (has_Inf (has_Inf (has_Inf Type)))) : is_add_cyclic (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_178920 (h0 : not (filter (has_inv fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_178921 (h1 : set (mul_one_class (add_comm_semigroup enat))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_178922 (h1 : topological_space (add_comm_semigroup string.iterator_imp)) : path_connected_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_178923 (h0 : group (complete_distrib_lattice empty)) : group.fg (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_178924 (h0 : complete_lattice (has_neg_part (has_nndist ennreal))) : is_compactly_generated (has_neg_part (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_178925 (h0 : functor.add_const (functor.add_const (complete_lattice (has_nndist linarith.comp)) Type) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_178926 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_178927 (h0 : list (comm_group (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_178928 (h0 : not (uniform_space (with_one linarith.comp_source) -> false)) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_178929 (h0 : ring (comm_group (finset (finset name)))) : is_principal_ideal_ring (comm_group (finset (finset name))) := sorry --non-trivial
lemma new_lemma_178930 (h0 : functor.add_const (complete_lattice ennreal) num) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_178931 (h0 : group (comm_semigroup (sub_neg_monoid Type))) : is_simple_group (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_178932 (h0 : topological_space (with_one (random_gen (has_nnnorm fun_info)))) : path_connected_space (with_one (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_178933 (h0 : topological_space (with_one (semiring (has_norm linarith.comp_source)))) : path_connected_space (with_one (semiring (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178934 (h1 : add_group (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_178935 (h0 : uniform_space (sub_neg_monoid real)) : complete_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_178936 (h0 : not (topological_space (measurable_space num) -> false)) : @irreducible_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_178937 (h0 : ring (semigroup (add_comm_monoid Type))) : is_principal_ideal_ring (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_178938 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178939 (h0 : functor.add_const (complete_lattice (semigroup congr_arg_kind)) unsigned) : @is_compactly_generated.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_178940 (h1 : uniform_space (linear_ordered_comm_group_with_zero string_imp)) : complete_space (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_178941 (h0 : complete_lattice (canonically_ordered_monoid (has_add (has_add pos)))) : is_compactly_generated (canonically_ordered_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_178942 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_178943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_178944 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_add name)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_178945 (h0 : topological_space (has_nndist (has_add name))) : locally_compact_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_178946 (h0 : group (has_norm (semiring congr_arg_kind))) : group.fg (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_178947 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_178948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178949 (h0 : monoid (has_to_string (comm_group (add_left_cancel_semigroup Type)))) : monoid.fg (has_to_string (comm_group (add_left_cancel_semigroup Type))) := sorry --non-trivial
lemma new_lemma_178950 (h0 : finset (cancel_monoid (has_add (has_add (boolean_algebra environment.implicit_infer_kind))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_178951 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178952 (h0 : add_group (semiring linarith.ineq)) : is_add_cyclic (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_178953 (h0 : group (normed_lattice_add_comm_group pos)) : is_simple_group (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_178954 (h0 : monoid (complete_semilattice_Sup fun_info)) : monoid.fg (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_178955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178956 (h0 : complete_lattice (plift (plift (complete_linear_order (semiring num))))) : complete_lattice.is_Sup_finite_compact (plift (plift (complete_linear_order (semiring num)))) := sorry --non-trivial
lemma new_lemma_178957 (h0 : not (complete_lattice (normed_comm_ring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_178958 (h0 : uniform_space (measurable_space.dynkin_system (metric_space (with_bot unsigned)))) : complete_space (measurable_space.dynkin_system (metric_space (with_bot unsigned))) := sorry --non-trivial
lemma new_lemma_178959 (h0 : linarith.ineq -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_178960 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid linarith.comp)) (ring (has_add name))) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_178961 (h0 : filter (linear_ordered_semiring (complete_semilattice_Sup (measurable_space linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_178962 (h0 : ring (boolean_algebra.core (comm_group pos))) : strong_rank_condition (boolean_algebra.core (comm_group pos)) := sorry --non-trivial
lemma new_lemma_178963 (h0 : functor.add_const (ring (add_comm_monoid name)) pos) : @rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_178964 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_178965 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (finset linarith.comp)) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_178966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_178967 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_178968 (h0 : ring (simple_graph linarith.ineq)) : is_domain (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_178969 (h0 : topological_space (monoid_with_zero (option pos))) : irreducible_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_178970 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring linarith.comp))) : preconnected_space (complete_distrib_lattice (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_178971 (h0 : uniform_space (has_union (semiring (semiring (has_one (semiring linarith.comp)))))) : complete_space (has_union (semiring (semiring (has_one (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_178972 (h0 : uniform_space (has_Inf (has_pos_part pos))) : complete_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_178973 (h0 : list (linear_ordered_add_comm_group (has_norm (comm_ring (dlist to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_178974 (h0 : not (ring (measure_theory.measure_space empty) -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178975 (h0 : semiring (preorder (semiring num))) : is_noetherian_ring (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_178976 (h0 : topological_space (id (semiring (semiring (semiring unsigned))))) : discrete_topology (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_178977 (h0 : functor.add_const (topological_space (semigroup Type)) ennreal) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_178978 (h0 : not (has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_178979 (h0 : uniform_space (boolean_algebra (has_add Type))) : complete_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_178980 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @preirreducible_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_178981 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (ordered_comm_ring linarith.comp)))) : @locally_compact_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_178982 (h0 : (topological_space (random_gen linarith.ineq) -> false) -> false) (h1 : topological_space (random_gen linarith.ineq) -> false) (h2 : not (false -> false)) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) (@function.update.{0 0} (topological_space.{0} (random_gen.{0} linarith.ineq) → false) (λ (a : topological_space.{0} (random_gen.{0} linarith.ineq) → false), false) (λ (a b : topological_space.{0} (random_gen.{0} linarith.ineq) → false), @decidable_eq_of_subsingleton.{0} (topological_space.{0} (random_gen.{0} linarith.ineq) → false) (@pi.subsingleton.{1 0} (topological_space.{0} (random_gen.{0} linarith.ineq)) (λ (ᾰ : topological_space.{0} (random_gen.{0} linarith.ineq)), false) (λ (a : topological_space.{0} (random_gen.{0} linarith.ineq)), subsingleton_prop false)) a b) h0 h1 (@classical.by_contradiction'.{0} false h2)))  := sorry --trivial
lemma new_lemma_178983 (h0 : topological_space (has_nnnorm (random_gen fun_info))) : path_connected_space (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_178984 (h0 : topological_space (encodable (random_gen (with_one (has_top (random_gen string_imp)))))) : irreducible_space (encodable (random_gen (with_one (has_top (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_178985 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_178986 (h0 : not (complete_lattice (dlist linarith.comp_source) -> false)) : @is_compactly_generated.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_178987 (h0 : ring (has_top (mul_one_class linarith.comp_source))) : is_domain (has_top (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_178988 (h0 : complete_lattice (has_add (complete_distrib_lattice (comm_semigroup real)))) : is_compactly_generated (has_add (complete_distrib_lattice (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_178989 (h0 : complete_lattice (has_one linarith.comp)) : is_atomistic (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_178990 (h0 : functor.comp topological_space add_cancel_monoid Type) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_178991 (h0 : not (topological_space (left_cancel_monoid empty) -> false)) : @totally_separated_space.{0} (left_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178992 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen (has_inv linarith.comp_source)))) : complete_space (linear_ordered_add_comm_group (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_178993 (h0 : not (complete_lattice (measurable_space.dynkin_system empty) -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_178994 (h0 : topological_space (finset (option (option empty)))) : irreducible_space (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_178995 (h0 : monoid (plift empty)) : monoid.fg (plift empty) := sorry --non-trivial
lemma new_lemma_178996 (h0 : ring (bin_tree (option (option unsigned)))) : rank_condition (bin_tree (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_178997 (h0 : functor.add_const (list (semigroup name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_178998 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_178999 (h0 : not (monoid (id num) -> false)) : @monoid.fg.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (monoid.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_179000 (h3 : group (has_top (random_gen (random_gen linarith.comp_source)))) : normalizer_condition (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_179001 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string Type)) (finset (ring (has_neg (ring linarith.comp))))) : @archimedean.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_to_string.{1} Type)) (finset.{0} (ring.{0} (has_neg.{0} (ring.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_179002 (h2 : ring (mul_one_class (add_comm_semigroup enat))) : strong_rank_condition (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_179003 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_179004 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179005 (h0 : group (has_nndist (ring Type))) : normalizer_condition (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_179006 (h0 : not (ring (simple_graph to_additive.value_type) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_179007 (h2 : topological_space (has_top num)) : irreducible_space (has_top num) := sorry --non-trivial
lemma new_lemma_179008 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @discrete_topology.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_179009 (h0 : functor.add_const (list (simple_graph Type)) (has_neg name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179010 (h0 : topological_space (normed_field (mul_one_class fun_info))) : path_connected_space (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_179011 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_179012 (h0 : functor.add_const (topological_space (has_Inf Type)) (finset Type)) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179013 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : totally_disconnected_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_179014 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_179015 (h0 : topological_space (add_cancel_monoid (has_to_string name))) : preconnected_space (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_179016 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179017 (h1 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_179018 (h0 : not (ring (id empty) -> false)) : @rank_condition.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_179019 (h0 : group (div_inv_monoid (has_nnnorm linarith.comp_source))) : is_cyclic (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_179020 (h0 : functor.add_const (uniform_space (add_cancel_monoid unsigned)) name) : @separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_179021 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_179022 (h0 : group (has_Inf (ring Type))) : normalizer_condition (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_179023 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : irreducible_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179024 (h0 : group (linear_ordered_comm_ring (semiring (semiring empty)))) : group.fg (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_179025 (h0 : function.extfun (finset (Type 1 -> Type 1)) (has_mem.mem topological_space)) : @totally_disconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) topological_space.{1} (@function.extfun_app.{3 0} (finset.{2} (Type 1 → Type 1)) (@has_mem.mem.{2 2} (Type 1 → Type 1) (finset.{2} (Type 1 → Type 1)) (@finset.has_mem.{2} (Type 1 → Type 1)) topological_space.{1}) h0 (@has_emptyc.emptyc.{2} (finset.{2} (Type 1 → Type 1)) (@finset.has_emptyc.{2} (Type 1 → Type 1))))) Type)  := sorry --non-trivial
lemma new_lemma_179026 (h1 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char)))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_179027 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179028 (h0 : functor.add_const (complete_lattice (option pos)) unsigned) : @is_compactly_generated.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_179030 (h0 : add_group (boolean_algebra.core (ring Type))) : is_add_cyclic (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_179031 (h0 : group (pseudo_metric_space congr_arg_kind)) : is_cyclic (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179032 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179033 (h0 : not (add_monoid (has_star empty) -> false)) : @add_monoid.fg.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_179034 (h0 : topological_space (comm_group (monoid (has_neg_part (has_neg_part unsigned))))) : preirreducible_space (comm_group (monoid (has_neg_part (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_179035 (h0 : filter (has_to_string num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179036 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179037 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_179038 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_179039 (h0 : topological_space (finset empty)) : loc_path_connected_space (finset empty) := sorry --non-trivial
lemma new_lemma_179040 (h0 : complete_lattice (has_inter (option pos))) : complete_lattice.is_Sup_finite_compact (has_inter (option pos)) := sorry --non-trivial
lemma new_lemma_179041 (h0 : group (ring (has_add (boolean_algebra Type)))) : normalizer_condition (ring (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_179042 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_179043 (h0 : function.extfun Type monoid) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_179044 (h0 : functor.add_const (group (cancel_monoid name)) environment.implicit_infer_kind) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179045 (h0 : functor.add_const (topological_space (boolean_algebra.core empty)) (option empty)) : @t0_space.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179046 (h0 : uniform_space (complete_distrib_lattice (has_neg pos))) : separated_space (complete_distrib_lattice (has_neg pos)) := sorry --non-trivial
lemma new_lemma_179047 (h0 : functor.add_const (group (has_add pos)) (has_add Type)) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179048 (h0 : topological_space (has_zero (comm_group (has_to_string unsigned)))) : normal_space (has_zero (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_179049 (h0 : functor.add_const (topological_space (finset unsigned)) num) : @totally_disconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_179050 (h0 : topological_space (boolean_algebra.core (has_add pos))) : preirreducible_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_179051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179052 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : irreducible_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_179053 (h0 : function.extfun Type (functor.add_const (group (is_R_or_C empty)))) : @group.fg.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_179054 (h0 : topological_space (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : irreducible_space (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179055 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid unsigned)) unsigned) : @archimedean.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179056 (h1 : topological_space (normed_group (random_gen to_additive.value_type))) : irreducible_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_179057 (h0 : topological_space (cancel_monoid congr_arg_kind)) : totally_disconnected_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_179059 (h0 : group (id unsigned)) : is_cyclic (id unsigned) := sorry --non-trivial
lemma new_lemma_179060 (h0 : filter (measurable_space.dynkin_system congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179061 (h0 : functor.add_const (group (linear_ordered_comm_ring empty)) unsigned) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179062 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179063 (h0 : filter (boolean_algebra unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179064 (h0 : topological_space (id (has_norm (has_norm (has_norm linarith.comp))))) : discrete_topology (id (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179065 (h0 : complete_lattice (generalized_boolean_algebra name)) : is_atomistic (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_179066 (h0 h1 : list (add_comm_semigroup char)) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_179067 (h0 : ring (distrib string.iterator_imp)) : is_domain (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_179068 (h0 : add_group (mul_zero_class (semiring congr_arg_kind))) : is_add_cyclic (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179069 (h0 : monoid (has_to_string (normed_comm_ring Type))) : monoid.fg (has_to_string (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_179070 (h0 : functor.add_const (topological_space (has_add pos)) (finset (has_pos_part linarith.comp))) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (finset.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_179071 (h0 : filter (canonically_ordered_comm_semiring (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179072 (h0 : uniform_space (non_assoc_semiring (semiring (semiring unsigned)))) : separated_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_179073 (h0 : ring (partial_order num)) : is_domain (partial_order num) := sorry --non-trivial
lemma new_lemma_179074 (h0 : add_group (has_to_string (normed_comm_ring (finset environment.implicit_infer_kind)))) : is_add_cyclic (has_to_string (normed_comm_ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_179075 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_179076 (h0 : list (has_ssubset (random_gen (has_top (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179077 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_179078 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179079 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @discrete_topology.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_179080 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) (finset Type)) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179081 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) (has_add Type)) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179082 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179083 (h0 : group (has_neg (finset (finset Type)))) : is_simple_group (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_179084 (h0 : filter (add_cancel_monoid (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179085 (h0 : group (has_add (finset (ring (has_neg (finset pos)))))) : is_cyclic (has_add (finset (ring (has_neg (finset pos))))) := sorry --non-trivial
lemma new_lemma_179086 (h0 : functor.add_const (functor.add_const (finset linarith.comp) pos) linarith.comp) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_179087 (h0 : set (normed_field (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_179088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_179089 (h0 : fin has_zero.zero) : @group.fg.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_179090 (h0 : fin has_zero.zero) : @archimedean.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_179091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179092 (h0 : topological_space (mul_zero_class (mul_zero_class pos))) : t1_space (mul_zero_class (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_179093 (h0 : monoid (has_inter (comm_monoid unsigned))) : monoid.fg (has_inter (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_179094 (h0 : functor.add_const (semiring (has_to_string unsigned)) name) : @is_noetherian_ring.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_179095 (h0 : functor.comp ring boolean_algebra.core name) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_179096 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_pos_part pos))) : unique_factorization_monoid (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_179097 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_179098 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179099 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_179100 (h0 : topological_space (add_left_cancel_monoid (add_zero_class (has_ssubset linarith.comp_source)))) : path_connected_space (add_left_cancel_monoid (add_zero_class (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_179101 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179102 (h0 : uniform_space (monoid empty)) : separated_space (monoid empty) := sorry --non-trivial
lemma new_lemma_179103 (h0 : topological_space (finset empty)) : t1_space (finset empty) := sorry --non-trivial
lemma new_lemma_179104 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_179105 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) ennreal) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_179106 (h0 : topological_space (semi_normed_comm_ring (mul_one_class (mul_one_class string.iterator_imp)))) : t0_space (semi_normed_comm_ring (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_179107 (h0 : not (has_mem.mem (normed_group to_additive.value_type) has_emptyc.emptyc -> false)) : @rank_condition.{0} (normed_group.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_179108 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : complete_space (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_179109 (h0 : topological_space (has_norm (has_norm empty))) : t0_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_179110 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_179111 (h0 : list (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179112 (h0 : functor.comp ordered_comm_monoid add_comm_monoid Type) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} ordered_comm_monoid.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_179113 (h0 : ring (fintype string_imp)) : rank_condition (fintype string_imp) := sorry --non-trivial
lemma new_lemma_179114 (h0 : monoid bool) : monoid.fg bool := sorry --non-trivial
lemma new_lemma_179115 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179116 (h0 h1 : multiset (has_compl char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_179117 (h0 : topological_space (simple_graph environment.projection_info)) : path_connected_space (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_179118 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_neg name))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_179119 (h1 : uniform_space (linear_ordered_add_comm_group char)) : complete_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_179120 (h1 : topological_space (has_add char)) : path_connected_space (has_add char) := sorry --non-trivial
lemma new_lemma_179121 (h0 : topological_space (with_zero char)) : t0_space (with_zero char) := sorry --non-trivial
lemma new_lemma_179122 (h0 : has_lt (has_ssubset ereal)) : no_max_order (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_179123 (h0 : topological_space (sub_neg_monoid (has_Inf (canonically_linear_ordered_monoid pos)))) : topological_space.separable_space (sub_neg_monoid (has_Inf (canonically_linear_ordered_monoid pos))) := sorry --non-trivial
lemma new_lemma_179124 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_neg (has_Inf name)))) : archimedean (canonically_ordered_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_179125 (h0 : not (filter (partial_order empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_179126 (h0 : finset (comm_group (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_179127 (h0 : ring (comm_group pos)) : strong_rank_condition (comm_group pos) := sorry --non-trivial
lemma new_lemma_179128 (h0 : functor.add_const (list (semigroup linarith.comp)) (ring environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179129 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179130 (h0 : ring (has_top (has_top num))) : rank_condition (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_179131 (h0 : ordered_comm_monoid (pseudo_metric_space (option unsigned))) : has_exists_mul_of_le (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_179132 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_179133 (h0 : ring (ordered_comm_ring (finset (finset (has_pos_part Type))))) : is_principal_ideal_ring (ordered_comm_ring (finset (finset (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_179134 (h0 : topological_space (has_neg (has_add (has_neg_part Type)))) : t0_space (has_neg (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_179135 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset pos)) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_179136 (h0 : topological_space (has_to_string (has_add (has_add Type)))) : t1_space (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_179137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_179138 (h1 : ring (normed_field to_additive.value_type)) : rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179139 (h0 : group (cancel_monoid (has_nndist name))) : normalizer_condition (cancel_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_179140 (h0 : functor.add_const (semiring (has_edist empty)) num) : @is_noetherian_ring.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_edist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179141 (h0 : functor.comp uniform_space ring name) : @complete_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} name (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} name h0))  := sorry --non-trivial
lemma new_lemma_179142 (h0 : topological_space (has_to_string (has_nndist Type))) : locally_compact_space (has_to_string (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_179143 (h0 : topological_space (non_unital_non_assoc_semiring (uniform_space string.iterator_imp))) : totally_disconnected_space (non_unital_non_assoc_semiring (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_179144 (h0 : add_group (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_179145 (h0 : ring (preorder (semiring (semiring num)))) : strong_rank_condition (preorder (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_179146 (h0 : functor.add_const (group (has_Sup empty)) empty) : @group.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_179147 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_179148 (h0 : functor.add_const (group (comm_group name)) linarith.comp) : @is_simple_group.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179149 (h0 : not (group (distrib reducibility_hints) -> false)) : @is_cyclic.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_179150 (h0 : functor.comp group finset name) : @group.fg.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} group.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_179151 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_179152 (h2 : topological_space (has_nnnorm linarith.ineq)) (h3 : preorder (has_nnnorm linarith.ineq)) : order_topology (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_179153 (h0 : functor.add_const (monoid (normed_comm_ring Type)) name) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_179154 (h0 : topological_space (has_neg (has_to_string pos))) : preconnected_space (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_179155 (h0 : ring (with_bot (has_norm congr_arg_kind))) : is_domain (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179156 (h0 : ring (has_neg (finset Type))) : is_domain (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_179157 (h0 : ordered_comm_monoid (has_neg_part pos)) : has_exists_mul_of_le (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_179158 (h0 : topological_space (complete_distrib_lattice (option empty))) : totally_separated_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_179159 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_179161 (h0 : topological_space (has_append string_imp) -> string_imp) (h1 : coe_sort (set.range h0)) : @t0_space.{0} (has_append.{0} string_imp) (@set.range_splitting.{0 0} (topological_space.{0} (has_append.{0} string_imp)) string_imp h0 h1)  := sorry --non-trivial
lemma new_lemma_179162 (h0 : uniform_space (has_add (has_Inf (has_neg name)))) : complete_space (has_add (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_179163 (h0 : list (monoid (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179164 (h0 : topological_space (has_neg (has_nndist environment.implicit_infer_kind))) : discrete_topology (has_neg (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179165 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @locally_compact_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_179166 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) (has_neg Type)) : @t1_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179167 (h0 : complete_lattice (simple_graph to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179168 (h0 : ring (has_Inf (has_add (has_Inf (has_Inf real))))) : strong_rank_condition (has_Inf (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_179169 (h0 : ring (canonically_ordered_comm_semiring (has_to_string pos))) : is_domain (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_179170 (h0 : functor.add_const (group (has_neg_part ennreal)) unsigned) : @is_simple_group.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179171 (h0 : functor.add_const (ring (boolean_algebra Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179172 (h0 : function.extfun Type (functor.comp group add_comm_monoid)) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} add_comm_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} add_comm_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_179173 (h0 : functor.add_const (monoid (comm_group linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_179175 (h0 : filter (has_add (option (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179176 (h0 : functor.add_const (monoid (comm_group linarith.comp)) (has_neg pos)) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_179177 (h0 : has_lt string_imp) : no_max_order string_imp := sorry --non-trivial
lemma new_lemma_179178 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group num)) : unique_factorization_monoid (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_179179 (h0 : ring (monoid (option unsigned))) : is_principal_ideal_ring (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_179180 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (ring (has_add (finset linarith.comp))))) : unique_factorization_monoid (add_cancel_monoid (ring (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179181 (h0 : uniform_space (has_neg (mul_zero_class (mul_zero_class (mul_zero_class name))))) : complete_space (has_neg (mul_zero_class (mul_zero_class (mul_zero_class name)))) := sorry --non-trivial
lemma new_lemma_179182 (h0 : not (topological_space (has_union empty) -> false)) : @t0_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_179183 (h0 : functor.add_const (monoid (has_neg Type)) (comm_group Type)) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_neg.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179184 (h0 : list (finset (semigroup (semigroup (comm_group (partial_order unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179185 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179186 (h0 : topological_space (canonically_ordered_comm_semiring (option (option ennreal)))) : regular_space (canonically_ordered_comm_semiring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_179187 (h0 : ring (has_nndist (option unsigned))) : rank_condition (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_179188 (h0 : functor.comp group has_neg environment.implicit_infer_kind) : @normalizer_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179189 (h0 : add_group (has_emptyc (has_norm linarith.comp_source))) : is_add_cyclic (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_179190 (h2 : topological_space to_additive.value_type) : path_connected_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_179191 (h0 : ring (ring (finset pos))) : is_domain (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_179192 (h0 : not (ring (has_top unsigned) -> false)) : @strong_rank_condition.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_179193 (h0 : topological_space (random_gen linarith.comp_source)) : path_connected_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179194 (h1 : ring (normed_group (has_compl (random_gen string_imp)))) : strong_rank_condition (normed_group (has_compl (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_179195 (h0 : topological_space (has_zero (normed_comm_ring linarith.comp))) : loc_path_connected_space (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_179196 (h0 : topological_space (add_cancel_monoid (has_to_string unsigned))) : totally_separated_space (add_cancel_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_179197 (h0 : list (has_zero (semigroup unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179198 (h0 : group (normed_field (comm_ring reducibility_hints))) : is_cyclic (normed_field (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_179199 (h1 : topological_space (non_unital_non_assoc_semiring (distrib (mul_one_class linarith.comp_source)))) : path_connected_space (non_unital_non_assoc_semiring (distrib (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_179200 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : sequential_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_179201 (h0 : functor.add_const (topological_space (cancel_monoid empty)) num) : @t1_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179202 (h0 : monoid (has_nndist (add_comm_monoid pos))) : monoid.fg (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_179203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179204 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_edist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_179205 (h0 : ring (with_bot (has_norm congr_arg_kind))) : rank_condition (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179206 (h1 : ring (has_add fun_info)) : strong_rank_condition (has_add fun_info) := sorry --non-trivial
lemma new_lemma_179207 (h0 : group (has_Inf linarith.comp)) : is_cyclic (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_179208 (h0 : topological_space (canonically_ordered_add_monoid empty)) : t0_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_179209 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_179210 (h0 : functor.add_const (function.extfun Type ring) (has_to_string (semigroup Type))) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (has_to_string.{1} (semigroup.{1} Type)) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_179211 (h0 : ring (has_neg_part environment.implicit_infer_kind)) : strong_rank_condition (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_179212 (h0 : functor.add_const (group (has_zero pos)) linarith.comp) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179213 (h0 : uniform_space (add_comm_semigroup linarith.ineq)) : separated_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_179214 (h0 : group (ring (has_pos_part Type))) : is_cyclic (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_179215 (h0 : not (add_group (normed_field fun_info) -> false)) : @is_add_cyclic.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_179216 (h0 : functor.add_const (fin has_zero.zero) Type) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_179217 (h0 : semiring (has_add (has_to_string Type))) : is_noetherian_ring (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_179218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_179219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_179220 (h0 : not (topological_space (option empty) -> false)) : @irreducible_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_179221 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_ring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_ring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_179222 (h0 : group (cancel_monoid (has_add Type))) : is_cyclic (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_179223 (h0 : complete_lattice (measurable_space (random_gen (random_gen (random_gen to_additive.value_type))))) : is_atomistic (measurable_space (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_179224 (h0 : functor.add_const (add_monoid (add_group congr_arg_kind)) empty) : @add_monoid.fg.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_179225 (h0 : topological_space (boolean_algebra (comm_group name))) : normal_space (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_179226 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179227 (h0 : set (has_ssubset (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_179228 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179229 (h0 : topological_space (has_neg (ring (ring (has_add (ring Type)))))) : t0_space (has_neg (ring (ring (has_add (ring Type))))) := sorry --non-trivial
lemma new_lemma_179230 (h0 : list (has_zero pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179231 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid linarith.comp)) : unique_factorization_monoid (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_179232 (h0 : add_monoid (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_add real))))) : add_monoid.fg (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_179233 (h0 : functor.add_const (functor.add_const (list linarith.comp) pos) Type) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_179234 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_179236 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_179237 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_179238 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_add (ring pos))) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_add.{0} (ring.{0} pos)) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_179239 (h0 : topological_space (has_neg (comm_group (comm_group Type)))) : sequential_space (has_neg (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_179240 (h0 : uniform_space (has_add (add_left_cancel_monoid linarith.comp))) : separated_space (has_add (add_left_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_179241 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_179242 (h2 : ring string_imp) : is_domain string_imp := sorry --non-trivial
lemma new_lemma_179243 (h0 : functor.add_const (topological_space (finset unsigned)) (comm_group (has_to_string Type))) : @normal_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) (comm_group.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_179244 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_Inf (ring (has_Inf (has_Inf pos))))) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{0} (ring.{0} (has_Inf.{0} (has_Inf.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_179245 (h0 : not (group (has_nnnorm linarith.ineq) -> false)) : @group.fg.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_179246 (h0 : add_monoid (cancel_monoid pos)) : add_monoid.fg (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_179247 (h0 : functor.add_const (complete_lattice (comm_group Type)) (comm_group (comm_group pos))) : @is_atomistic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) (comm_group.{0} (comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_179248 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @totally_separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179249 (h0 : filter (normed_group (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179250 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_179251 (h0 : complete_lattice (has_add congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179252 (h1 : measurable_space string.iterator_imp) (h2 : measure_theory.measure string.iterator_imp) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_179253 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179254 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist name)) (add_comm_monoid (has_neg unsigned))) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} name)) (add_comm_monoid.{0} (has_neg.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_179255 (h0 : ring (has_pos_part (has_add (ring linarith.comp)))) : is_principal_ideal_ring (has_pos_part (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_179256 (h0 : ring (with_bot (semiring congr_arg_kind))) : is_domain (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179257 (h0 : functor.add_const (list (linear_order empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179258 (h0 : topological_space (ring (has_add pos))) : totally_separated_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_179259 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179260 (h0 : topological_space (sub_neg_monoid real)) : t0_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_179261 (h0 : topological_space (complete_distrib_lattice (has_add (has_neg_part pos)))) : normal_space (complete_distrib_lattice (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_179262 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179263 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_179264 (h0 : functor.add_const (topological_space (plift num)) num) : @t1_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_179265 (h0 : uniform_space (distrib_lattice (with_bot (random_gen (random_gen to_additive.value_type))))) : complete_space (distrib_lattice (with_bot (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_179266 (h0 : ring (linear_ordered_comm_ring (semiring (semiring unsigned)))) : is_domain (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_179267 (h0 : ring (has_compl (mul_one_class linarith.ineq))) : rank_condition (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179268 (h0 : pnat) (h1 : list pnat) (h2 : thunk pnat) : pnat.coprime (@list.ilast'.{0} pnat h0 h1) (@trace_call_stack.{0} pnat h2)  := sorry --non-trivial
lemma new_lemma_179269 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_Inf pos)) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_179270 (h2 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179271 (h0 : function.extfun Type group) : @normalizer_condition.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179272 (h0 : ring (ring (has_neg name))) : rank_condition (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_179273 (h1 : prod (add_comm_semigroup fun_info) (add_comm_semigroup fun_info)) : set.diagonal (add_comm_semigroup fun_info) h1 := sorry --non-trivial
lemma new_lemma_179274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} (has_inv.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_179275 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_179276 (h0 : add_monoid (has_union (linear_ordered_semiring (linear_ordered_semiring (semiring unsigned))))) : add_monoid.fg (has_union (linear_ordered_semiring (linear_ordered_semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_179277 (h0 : topological_space (ordered_comm_monoid (ring name))) : loc_path_connected_space (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_179278 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_add (has_neg Type)))))) : preconnected_space (has_Inf (has_Inf (has_Inf (has_add (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_179279 (h1 : ring (semiring linarith.comp)) : strong_rank_condition (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_179280 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_179281 (h0 : topological_space (has_zero (has_neg environment.implicit_infer_kind))) : totally_disconnected_space (has_zero (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179282 (h0 : list (group_with_zero ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179283 (h1 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_179284 (h0 : functor.add_const (ring (cancel_monoid name)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179285 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179286 (h0 : topological_space (with_one (has_norm linarith.comp_source))) : totally_separated_space (with_one (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_179287 (h0 : topological_space (ordered_comm_ring linarith.comp)) : totally_separated_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_179288 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf real)))))) : preconnected_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_179289 (h0 : topological_space (filter (option unsigned))) : irreducible_space (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_179290 (h0 : topological_space (has_norm (has_top (has_top fun_info)))) : discrete_topology (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_179291 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_179292 (h0 : functor.add_const (topological_space (option empty)) num) : @discrete_topology.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179293 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_179294 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179295 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_179296 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179297 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : preconnected_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_179298 (h0 : topological_space (has_to_string fun_info)) : totally_disconnected_space (has_to_string fun_info) := sorry --non-trivial
lemma new_lemma_179299 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_179300 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : regular_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_179301 (h0 : functor.add_const (topological_space (ring Type)) (ring environment.implicit_infer_kind)) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_179302 (h0 : filter (linear_ordered_add_comm_group (normed_field linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179303 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) pos) : @sequential_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_179304 (h0 : ring (with_one to_additive.value_type)) : strong_rank_condition (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179305 (h0 : topological_space (mul_one_class (add_comm_semigroup ereal))) (h1 : set (mul_one_class (add_comm_semigroup ereal))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_179306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg num)) := sorry --non-trivial
lemma new_lemma_179307 (h0 : ring (linear_ordered_field (has_nnnorm string_imp))) : is_domain (linear_ordered_field (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_179308 (h0 : function.extfun Type (functor.add_const (list (add_right_cancel_monoid empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_179309 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179310 (h0 : filter (has_dist empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179311 (h1 : ring (has_div std_gen)) : rank_condition (has_div std_gen) := sorry --non-trivial
lemma new_lemma_179312 (h0 : topological_space (simple_graph (has_to_string pos))) : locally_compact_space (simple_graph (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_179313 (h0 : semiring (measurable_space (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (measurable_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_179314 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : totally_separated_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_179315 (h0 : ordered_add_comm_monoid (preorder unsigned)) : archimedean (preorder unsigned) := sorry --non-trivial
lemma new_lemma_179316 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179317 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) name) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_179318 (h0 : topological_space (has_neg (has_add (has_add environment.implicit_infer_kind)))) : locally_compact_space (has_neg (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_179319 (h0 : not (uniform_space (measurable_space.dynkin_system num) -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_179320 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring unsigned))))) : t1_space (non_assoc_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_179321 (h0 : prod linarith.ineq linarith.ineq) : id_rel h0 := sorry --non-trivial
lemma new_lemma_179322 (h0 : semiring linarith.ineq) (h1 : linarith.ineq) : odd h1 := sorry --non-trivial
lemma new_lemma_179323 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup std_gen))) (h2 : preorder (add_comm_semigroup (add_comm_semigroup std_gen))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_179324 (h0 : ordered_comm_monoid (has_neg (has_nndist Type))) : has_exists_mul_of_le (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_179325 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179326 (h0 : topological_space (has_Inf (ordered_ring Type))) : t1_space (has_Inf (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_179327 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_179328 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_179329 (h0 : functor.add_const (ring (left_cancel_monoid empty)) (semiring empty)) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179330 (h0 : topological_space (complete_distrib_lattice linarith.comp_source)) : t0_space (complete_distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179331 (h0 : functor.add_const Prop num) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_179332 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_179333 (h0 : topological_space (has_nndist (finset (has_add (finset name))))) : sequential_space (has_nndist (finset (has_add (finset name)))) := sorry --non-trivial
lemma new_lemma_179334 (h1 : uniform_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm char))))) : complete_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_179335 (h1 : complete_lattice (simple_graph string_imp)) : complete_lattice.is_Sup_finite_compact (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_179336 (h0 : group (has_zero (finset (finset (finset (finset name)))))) : is_simple_group (has_zero (finset (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_179337 (h1 : group (comm_ring fun_info)) : is_cyclic (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_179338 (h0 : ring (canonically_ordered_comm_semiring (finset unsigned))) : strong_rank_condition (canonically_ordered_comm_semiring (finset unsigned)) := sorry --non-trivial
lemma new_lemma_179339 (h0 : functor.comp topological_space mul_zero_class pos) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_179340 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179341 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_179342 (h0 : uniform_space (has_norm (random_gen (has_norm congr_arg_kind)))) : separated_space (has_norm (random_gen (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_179343 (h0 : ring (has_add (has_inv char))) : is_domain (has_add (has_inv char)) := sorry --non-trivial
lemma new_lemma_179344 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179345 (h1 : uniform_space (measurable_space (has_norm empty))) : separated_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_179346 (h0 : group (add_left_cancel_semigroup unsigned)) : group.fg (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_179347 (h0 : add_monoid (has_Inf (ring Type))) : add_monoid.fg (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_179348 (h0 : ring (linear_ordered_semiring (semiring congr_arg_kind))) : rank_condition (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179349 (h2 : ring (distrib char)) : is_domain (distrib char) := sorry --non-trivial
lemma new_lemma_179350 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @group.fg.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_179351 (h0 : topological_space (normed_field linarith.ineq)) (h1 : preorder (normed_field linarith.ineq)) : order_closed_topology (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_179352 (h0 : functor.add_const (uniform_space (has_zero Type)) (boolean_algebra Type)) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_zero.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179353 (h0 : topological_space (simple_graph (boolean_algebra.core linarith.comp))) : regular_space (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_179354 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) (has_to_string linarith.comp)) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_179355 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_179356 (h0 : topological_space (ring num)) : discrete_topology (ring num) := sorry --non-trivial
lemma new_lemma_179357 (h0 : semiring (linear_ordered_comm_group (option ennreal))) : is_noetherian_ring (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_179358 (h0 : topological_space (ordered_comm_monoid name)) : discrete_topology (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_179359 (h0 : topological_space (has_norm (semiring (semiring (semiring unsigned))))) : discrete_topology (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_179360 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_179361 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (left_cancel_monoid pos))) : unique_factorization_monoid (boolean_algebra.core (left_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_179362 (h0 : group (add_comm_monoid (has_neg pos))) : is_simple_group (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_179363 (h1 : uniform_space (has_emptyc linarith.ineq)) : complete_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_179364 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid unsigned)) : archimedean (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_179365 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179366 (h0 : not (ring (dlist linarith.ineq) -> false)) : @rank_condition.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_179367 (h4 : topological_space reducibility_hints) : path_connected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_179368 (h0 : filter (preorder (has_bot unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179369 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_179370 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid unsigned)) (semiring (semiring empty))) : @unique_factorization_monoid.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_179371 (h0 : topological_space (option (option num))) : totally_separated_space (option (option num)) := sorry --non-trivial
lemma new_lemma_179372 (h0 : ring (has_to_string (has_add pos))) : is_principal_ideal_ring (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_179373 (h0 : filter (pseudo_metric_space (cancel_monoid ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179375 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @irreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_179376 (h0 : ring (has_scalar name (normed_comm_ring ennreal))) : strong_rank_condition (has_scalar name (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_179377 (h0 : functor.add_const (prod (add_group empty) (add_group empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179378 (h0 : group (has_norm (has_nnnorm to_additive.value_type))) : is_cyclic (has_norm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_179379 (h0 : complete_lattice (has_to_string (option num))) : complete_lattice.is_Sup_finite_compact (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_179380 (h0 : group (has_pos_part name)) : normalizer_condition (has_pos_part name) := sorry --non-trivial
lemma new_lemma_179381 (h0 : topological_space (has_dist (option (option unsigned)))) : preirreducible_space (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_179382 (h0 : multiset (uniform_space string_imp)) (h1 : not (multiset (uniform_space string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_179383 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) (has_neg Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179384 (h0 : topological_space (normed_linear_ordered_group unsigned)) : loc_path_connected_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_179385 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) Type) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_179386 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_179387 (h0 : has_mem.mem empty has_emptyc.emptyc) : @monoid.fg.{0} empty (@finset.pi.empty.{1 0} Type monoid.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_179388 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_179389 (h0 : pnat) (h1 : thunk (fin has_zero.zero)) : pnat.coprime h0 (@matrix.vec_empty.{0} pnat (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h1)))  := sorry --non-trivial
lemma new_lemma_179390 (h0 : functor.add_const (ring (has_nndist name)) unsigned) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179392 (h0 : topological_space (has_Inf (has_add (has_pos_part (finset pos))))) : preconnected_space (has_Inf (has_add (has_pos_part (finset pos)))) := sorry --non-trivial
lemma new_lemma_179393 (h0 : linarith.comp_source) (h1 : add_monoid string_imp) (h2 : add_action string_imp linarith.comp_source) : set.finite (add_action.orbit string_imp h0) := sorry --non-trivial
lemma new_lemma_179394 (h0 : topological_space (simple_graph (ring pos))) : topological_space.separable_space (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_179395 (h0 : topological_space (measurable_space.dynkin_system linarith.comp_source)) (h1 : preorder (measurable_space.dynkin_system linarith.comp_source)) : order_topology (measurable_space.dynkin_system linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179396 (h0 : complete_lattice (random_gen fun_info)) : is_atomistic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_179397 (h0 : function.extfun nat fin) : @t0_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_179398 (h0 : topological_space (has_to_string (option pos))) : locally_compact_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_179399 (h0 : list znum) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179400 (h0 : functor.add_const (function.extfun Type topological_space) (has_add environment.implicit_infer_kind)) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} environment.implicit_infer_kind) h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179402 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info)))) : is_domain (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_179403 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part Type)) pos) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_179404 (h0 : topological_space (has_nnnorm (mul_one_class linarith.comp_source))) : totally_disconnected_space (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_179405 (h0 : topological_space (has_nndist pos)) : preirreducible_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_179406 (h0 : function.extfun Type pseudo_metric_space) (h1 : function.extfun Type add_monoid) : @has_lipschitz_add.{0} linarith.comp_source (@function.extfun_app.{2 1} Type pseudo_metric_space.{0} h0 linarith.comp_source) (@function.extfun_app.{2 1} Type add_monoid.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_179407 (h0 : topological_space (preorder (semiring num))) : discrete_topology (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_179408 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_179409 (h0 : functor.add_const (group (ring name)) name) : @is_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_179410 (h0 : topological_space (boolean_algebra (has_Inf Type))) : preirreducible_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_179411 (h0 : functor.add_const (uniform_space (has_Sup empty)) num) : @separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179412 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : totally_disconnected_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_179413 (h0 : topological_space linarith.comp_source) : locally_compact_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_179414 (h0 : not (ring (add_right_cancel_monoid congr_arg_kind) -> false)) : @rank_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_179415 (h0 : option (topological_space (normed_comm_ring pos))) (h1 : topological_space (normed_comm_ring pos)) : normal_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_179416 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_179417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (ring pos)) := sorry --non-trivial
lemma new_lemma_179418 (h0 : functor.comp add_group complete_distrib_lattice name) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} complete_distrib_lattice.{0} name (@functor.comp.run.{0 0 0} add_group.{0} complete_distrib_lattice.{0} name h0))  := sorry --non-trivial
lemma new_lemma_179419 (h0 : fin has_zero.zero) : @group.fg.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_179420 (h0 : group (with_one unsigned)) : group.fg (with_one unsigned) := sorry --non-trivial
lemma new_lemma_179421 (h0 : not (group (add_left_cancel_monoid fun_info) -> false)) : @is_cyclic.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_179422 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) Type) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_179423 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_179424 (h0 : topological_space (has_zero (ring Type))) : topological_space.separable_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_179425 (h0 : ring (normed_comm_ring (finset pos))) : is_principal_ideal_ring (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_179426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179427 (h0 : functor.add_const (topological_space (semigroup pos)) (finset Type)) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179428 (h0 : nat) (h1 : option nat) (h2 : decidable (nat.min_sq_fac_prop (id h0) h1)) : as_true (nat.min_sq_fac_prop (id h0) h1) := sorry --non-trivial
lemma new_lemma_179429 (h1 : topological_space ordering -> Prop) (h2 : quot (fun (h0 : topological_space ordering), h1)) : @totally_disconnected_space.{0} ordering (@quot.out.{1} (topological_space.{0} ordering) (λ (h0 : topological_space.{0} ordering), h1) h2)  := sorry --non-trivial
lemma new_lemma_179430 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @totally_separated_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_179431 (h0 : ring (has_add (random_gen linarith.ineq))) : is_domain (has_add (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179432 (h0 : topological_space (has_nndist (comm_group (has_neg_part Type)))) : irreducible_space (has_nndist (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_179433 (h0 : filter (has_neg_part (mul_zero_class (option (has_to_string (has_to_string pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179434 (h1 : ring linarith.comp) : rank_condition linarith.comp := sorry --non-trivial
lemma new_lemma_179435 (h0 : group (measurable_space (random_gen (random_gen string_imp)))) : is_cyclic (measurable_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_179436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179437 (h0 : topological_space (add_cancel_monoid (has_neg (generalized_boolean_algebra (has_neg Type))))) : locally_compact_space (add_cancel_monoid (has_neg (generalized_boolean_algebra (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_179438 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) name) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_179439 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179440 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179441 (h0 : uniform_space (cancel_monoid (option ennreal))) : separated_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_179442 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_179443 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) (h1 : topological_space linarith.comp) (h2 : pfun (has_pos_part Type) linarith.comp) : @pcontinuous.{1 0} (has_pos_part.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0) h1 h2  := sorry --non-trivial
lemma new_lemma_179444 (h0 : functor.add_const (group num) num) : @normalizer_condition.{0} num (@functor.add_const.run.{0 0} (group.{0} num) num h0)  := sorry --non-trivial
lemma new_lemma_179445 (h0 : not (complete_lattice (has_top linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_179446 (h0 : uniform_space (measurable_space (measurable_space congr_arg_kind))) : complete_space (measurable_space (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179447 (h0 : finset (normed_comm_ring (boolean_algebra linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_179448 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) unsigned) : @normal_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179449 (h1 : list (random_gen fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_179450 (h1 h2 : linarith.comp_source -> linarith.comp_source) : function.commute h1 h2 := sorry --non-trivial
lemma new_lemma_179451 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179452 (h1 : topological_space (with_zero char)) : totally_disconnected_space (with_zero char) := sorry --non-trivial
lemma new_lemma_179453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179454 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (ordered_comm_ring.{0} (has_neg.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ordered_comm_ring.{0} (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_179455 (h0 : ring (has_compl (random_gen (has_nnnorm (random_gen (random_gen char)))))) : is_domain (has_compl (random_gen (has_nnnorm (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_179456 (h0 : functor.add_const (group (ring pos)) name) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_179457 (h0 : monoid (normed_comm_ring (finset (has_neg environment.implicit_infer_kind)))) : monoid.fg (normed_comm_ring (finset (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_179458 (h0 : topological_space (has_edist (option unsigned))) : irreducible_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_179459 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179460 (h0 : ring (add_cancel_monoid unsigned)) : rank_condition (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_179461 (h0 : group (linear_order (option (option (option (option unsigned)))))) : group.fg (linear_order (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_179462 (h0 : functor.add_const (topological_space (monoid empty)) empty) : @path_connected_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_179463 (h0 : ordered_comm_monoid (has_nndist (has_nndist (finset (finset Type))))) : has_exists_mul_of_le (has_nndist (has_nndist (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_179464 (h0 : functor.add_const (topological_space (cancel_monoid empty)) empty) : @discrete_topology.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_179465 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add pos))))) : discrete_topology (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_179466 (h1 : topological_space (non_unital_non_assoc_semiring string_imp)) : totally_disconnected_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_179467 (h0 : ring (finset (has_to_string environment.implicit_infer_kind))) : rank_condition (finset (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179468 (h0 : not (uniform_space (semiring congr_arg_kind) -> false)) : @complete_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_179469 (h1 : has_le (id string_imp)) (h2 : function.extfun Type id) : is_bot (function.extfun_app h2 string_imp) := sorry --non-trivial
lemma new_lemma_179470 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179471 (h0 : complete_lattice (finset pos)) : is_atomistic (finset pos) := sorry --non-trivial
lemma new_lemma_179472 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_179473 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_179474 (h0 : add_monoid (ordered_comm_monoid (has_Inf name))) : add_monoid.fg (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_179475 (h0 : semiring (semiring (semiring linarith.comp))) : is_noetherian_ring (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_179476 (h0 : prod (simple_graph congr_arg_kind) (simple_graph congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_179477 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @path_connected_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_179478 (h0 : function.extfun Type (functor.comp add_group has_zero)) : @is_add_cyclic.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_group.{0} has_zero.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} has_zero.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179480 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_179481 (h0 : topological_space (semi_normed_comm_ring (random_gen linarith.ineq))) : path_connected_space (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179482 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf (has_Inf environment.implicit_infer_kind))) : @regular_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} (has_Inf.{0} environment.implicit_infer_kind)) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_179483 (h0 : ordered_add_comm_monoid (add_cancel_monoid unsigned)) : archimedean (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_179484 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_179485 (h0 : uniform_space (has_sub (option unsigned))) : separated_space (has_sub (option unsigned)) := sorry --non-trivial
lemma new_lemma_179486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179487 (h0 : ring (finset (has_Inf (has_Inf linarith.comp)))) : is_domain (finset (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_179488 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type add_monoid.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_179489 (h0 : uniform_space (omega_complete_partial_order (semiring empty))) : separated_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_179490 (h0 : group (complete_distrib_lattice (finset pos))) : group.fg (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_179491 (h0 : semiring (finset (has_to_string ennreal))) : is_noetherian_ring (finset (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_179492 (h0 : functor.add_const (topological_space (semiring unsigned)) unsigned) : @totally_separated_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179493 (h0 : has_neg (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) (h1 : measurable_space (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_179494 (h2 : topological_space ereal) : path_connected_space ereal := sorry --non-trivial
lemma new_lemma_179495 (h0 : not (complete_lattice (with_bot fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_179496 (h0 : functor.add_const Prop (has_to_string (has_to_string num))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_179497 (h0 h1 : Prop) : nonempty (and h0 h1) := sorry --non-trivial
lemma new_lemma_179498 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_179499 (h0 : ring (has_append (mul_one_class (random_gen (has_nnnorm char))))) : rank_condition (has_append (mul_one_class (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_179500 (h0 : list (topological_space (complete_distrib_lattice (has_neg linarith.comp)))) : @locally_compact_space.{0} (complete_distrib_lattice.{0} (has_neg.{0} linarith.comp)) (@list.head.{0} (topological_space.{0} (complete_distrib_lattice.{0} (has_neg.{0} linarith.comp))) (@inhabited_topological_space.{0} (complete_distrib_lattice.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_179501 (h0 : uniform_space (comm_group (has_add (has_add pos)))) : complete_space (comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_179502 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179503 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg Type)) linarith.comp) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179504 (h0 : complete_lattice (has_top (semiring (semiring (semiring empty))))) : is_atomistic (has_top (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_179505 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @t1_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179506 (h0 : list (semigroup (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179507 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179508 (h0 : topological_space (mul_zero_class ennreal)) : t0_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_179509 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179510 (h0 : topological_space (denumerable (mul_one_class char))) : t0_space (denumerable (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_179511 (h0 : ordered_comm_monoid (semigroup (has_add name))) : has_exists_mul_of_le (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_179512 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179513 (h0 : topological_space (has_le char)) (h1 : add_group (has_le char)) : topological_add_group (has_le char) := sorry --non-trivial
lemma new_lemma_179514 (h0 : finset (finset (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_179515 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_add (has_add (has_add linarith.comp))))) : unique_factorization_monoid (has_Inf (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179516 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_179517 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : path_connected_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_179518 (h0 : topological_space (bin_tree (semiring (semiring empty)))) : discrete_topology (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_179519 (h0 : ring (normed_comm_ring (option (option name)))) : is_domain (normed_comm_ring (option (option name))) := sorry --non-trivial
lemma new_lemma_179520 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179521 (h0 : complete_lattice (has_emptyc (semiring congr_arg_kind))) : is_atomistic (has_emptyc (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179522 (h0 : functor.comp ring semigroup ennreal) : @strong_rank_condition.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_179523 (h0 : semiring (pseudo_metric_space (option unsigned))) : is_noetherian_ring (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_179524 (h1 : topological_space (semi_normed_ring (random_gen linarith.ineq))) : totally_disconnected_space (semi_normed_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179525 (h2 : ring (has_lt to_additive.value_type)) : is_domain (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179526 (h0 : topological_space (has_Inf (ring (has_add Type)))) : sequential_space (has_Inf (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_179527 (h0 : complete_lattice (random_gen (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_179528 (h0 : functor.add_const (ring (bin_tree congr_arg_kind)) unsigned) : @is_domain.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179529 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_179530 (h0 : not (ring (add_left_cancel_monoid char) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_179531 (h0 : group (has_to_string Type)) : normalizer_condition (has_to_string Type) := sorry --non-trivial
lemma new_lemma_179532 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_179533 (h0 : topological_space (group_with_zero (option empty))) : preconnected_space (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_179534 (h0 : group (semiring (has_norm empty))) : group.fg (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_179535 (h1 : uniform_space string.iterator) : complete_space string.iterator := sorry --non-trivial
lemma new_lemma_179536 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_179537 (h0 : ring (canonically_linear_ordered_monoid ennreal)) : strong_rank_condition (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_179538 (h0 : fin has_zero.zero) : @t0_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_179539 (h0 : filter (has_to_string (has_neg (ring environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179540 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_nndist name)) : @locally_compact_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_179541 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_179542 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_179544 (h0 : list (add_cancel_monoid (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179545 (h0 : group (ring (finset (finset (finset environment.implicit_infer_kind))))) : is_simple_group (ring (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_179546 (h0 : topological_space (measurable_space (has_norm linarith.ineq))) : totally_separated_space (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179547 (h0 : topological_space (has_top (random_gen congr_arg_kind))) : t0_space (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179548 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_179549 (h0 : ring (finset (has_neg Type))) : is_principal_ideal_ring (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_179550 (h0 : function.extfun Type (functor.add_const (group (normed_linear_ordered_group num)))) : @group.fg.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (normed_linear_ordered_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_179551 (h0 : cancel_comm_monoid_with_zero znum) : unique_factorization_monoid znum := sorry --non-trivial
lemma new_lemma_179552 (h0 : topological_space (ring (ring pos))) : locally_compact_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_179553 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @complete_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_179554 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) (option (option name))) : @topological_space.separable_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) (option.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_179555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179556 (h0 : list (semigroup (finset (has_neg environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179557 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_179558 (h0 : not (ring (div_inv_monoid char) -> false)) : @strong_rank_condition.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_179559 (h0 : ring (uniform_space (random_gen (metric_space char)))) : strong_rank_condition (uniform_space (random_gen (metric_space char))) := sorry --non-trivial
lemma new_lemma_179560 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_179561 (h0 : functor.add_const (topological_space (has_edist num)) empty) : @t1_space.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_179562 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : t0_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179563 (h0 : topological_space (has_emptyc (semiring (has_emptyc congr_arg_kind)))) : t0_space (has_emptyc (semiring (has_emptyc congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_179564 (h0 : group (metric_space (has_top (semiring linarith.comp)))) : group.fg (metric_space (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_179565 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179566 (h0 : ring (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : strong_rank_condition (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_179567 (h0 : group (add_cancel_monoid (has_add (has_add (has_add linarith.comp))))) : is_cyclic (add_cancel_monoid (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179568 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_179569 (h0 : ring (has_neg (has_to_string name))) : strong_rank_condition (has_neg (has_to_string name)) := sorry --non-trivial
lemma new_lemma_179570 (h0 : functor.add_const (add_group (boolean_algebra.core Type)) pos) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_179571 (h0 : functor.add_const (group Type) (boolean_algebra.core Type)) : @is_cyclic.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179572 (h0 : functor.add_const (list (ordered_comm_monoid pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179573 (h0 : functor.add_const (ring (has_nndist name)) Type) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_179574 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (ring Type)) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179575 (h0 : filter (has_to_string ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179576 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_179577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_179578 (h0 : ring (non_unital_non_assoc_semiring std_gen)) : rank_condition (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_179579 (h0 : fin has_zero.zero) : @separated_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_179580 (h0 : not (ring (linear_ordered_comm_ring num) -> false)) : @invariant_basis_number.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_179581 (h0 : functor.add_const (topological_space (has_neg ennreal)) (finset environment.implicit_infer_kind)) : @topological_space.separable_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_179582 (h0 : add_group (complete_semilattice_Sup (semiring congr_arg_kind))) : is_add_cyclic (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179583 (h0 : topological_space (has_neg (has_add (has_add (has_add (has_add Type)))))) : totally_disconnected_space (has_neg (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_179584 (h0 : complete_lattice (denumerable (random_gen (random_gen (random_gen linarith.ineq))))) : is_compactly_generated (denumerable (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_179585 (h0 : list (semigroup (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179586 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179587 (h0 : monoid ereal) (h1 : mul_action ereal Prop) : classical.epsilon (mul_action.fixed_points ereal Prop) := sorry --non-trivial
lemma new_lemma_179588 (h0 : ordered_comm_monoid (has_neg num)) : has_exists_mul_of_le (has_neg num) := sorry --non-trivial
lemma new_lemma_179589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} znum (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) znum)  := sorry --non-trivial
lemma new_lemma_179590 (h0 : topological_space (ring (has_add Type))) : preirreducible_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_179591 (h0 : ring (has_Inf (has_Inf (has_Inf (has_Inf Type))))) : strong_rank_condition (has_Inf (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_179592 (h0 : complete_lattice (div_inv_monoid (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_179593 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : t0_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179594 (h0 : add_group (has_to_string (option (option (option num))))) : is_add_cyclic (has_to_string (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_179595 (h0 : list (encodable (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179596 (h0 : uniform_space (random_gen (comm_ring (comm_ring char)))) : complete_space (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_179597 (h0 : ring (boolean_algebra (ring (has_add (has_neg (has_add pos)))))) : strong_rank_condition (boolean_algebra (ring (has_add (has_neg (has_add pos))))) := sorry --non-trivial
lemma new_lemma_179598 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_179599 (h0 : complete_lattice (metric_space num)) : is_atomistic (metric_space num) := sorry --non-trivial
lemma new_lemma_179600 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_179601 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_179602 (h5 : topological_space (with_one num)) : t0_space (with_one num) := sorry --non-trivial
lemma new_lemma_179603 (h0 : measurable_space fun_info) (h1 : has_sub fun_info) : has_measurable_sub₂ fun_info := sorry --non-trivial
lemma new_lemma_179604 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) : t0_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_179605 (h0 : ring (has_bot (has_Inf linarith.comp))) : strong_rank_condition (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_179606 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_179607 (h0 : ring (has_Sup (semiring (semiring empty)))) : is_principal_ideal_ring (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_179608 (h0 : functor.add_const (group (cancel_monoid name)) Type) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_179609 (h0 : topological_space (normed_group unsigned)) : preirreducible_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_179610 (h1 : topological_space (add_comm_semigroup ereal)) : topological_space.first_countable_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_179611 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_179612 (h0 : function.extfun Type (functor.add_const (semiring (normed_linear_ordered_group unsigned)))) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_179613 (h0 : list (linear_order (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179614 (h0 : fin has_zero.zero) : @sequential_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_179615 (h0 : measurable_space (linear_ordered_comm_group_with_zero reducibility_hints)) (h1 : filter (linear_ordered_comm_group_with_zero reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_179616 (h0 : ring (add_comm_semigroup (mul_one_class (left_cancel_monoid string.iterator_imp)))) : strong_rank_condition (add_comm_semigroup (mul_one_class (left_cancel_monoid string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_179617 (h0 : ring (canonically_linear_ordered_monoid Type)) : is_principal_ideal_ring (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_179618 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_179619 (h0 : ring (has_inv (has_norm (has_norm to_additive.value_type)))) : rank_condition (has_inv (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_179620 (h0 : topological_space (normed_group (has_norm (random_gen (has_top fun_info))))) : path_connected_space (normed_group (has_norm (random_gen (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_179621 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char)))) (h5 : preorder (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char)))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_179622 (h0 : topological_space (has_append (comm_ring to_additive.value_type))) : t0_space (has_append (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_179623 (h0 : functor.add_const (topological_space (finset Type)) (finset pos)) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_179624 (h0 : cancel_comm_monoid_with_zero (comm_semigroup pos)) : unique_factorization_monoid (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_179625 (h0 : topological_space (comm_group (add_cancel_monoid (add_cancel_monoid name)))) : t0_space (comm_group (add_cancel_monoid (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_179626 (h0 : group (has_one (id num))) : group.fg (has_one (id num)) := sorry --non-trivial
lemma new_lemma_179627 (h0 : functor.add_const (group (add_right_cancel_monoid congr_arg_kind)) unsigned) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179628 (h0 : functor.add_const (filter (complete_distrib_lattice environment.implicit_infer_kind)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179629 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_179630 (h0 : function.extfun nat fin) : @is_simple_group.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_179631 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_179632 (h0 : functor.add_const (semiring (non_assoc_semiring unsigned)) unsigned) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179633 (h0 : ring (has_compl (random_gen (random_gen to_additive.value_type)))) : strong_rank_condition (has_compl (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_179634 (h0 : group (random_gen (has_norm linarith.comp))) : group.fg (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_179635 (h0 : topological_space (has_neg (boolean_algebra (has_add name)))) : sequential_space (has_neg (boolean_algebra (has_add name))) := sorry --non-trivial
lemma new_lemma_179636 (h0 : add_group (add_comm_monoid linarith.comp)) : is_add_cyclic (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_179637 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179638 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_179639 (h0 : set (non_unital_non_assoc_semiring (has_lt char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_179640 (h0 : group (semigroup ennreal)) : normalizer_condition (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_179641 (h0 : finset linarith.comp) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_179642 (h0 : monoid (with_zero name)) : monoid.fg (with_zero name) := sorry --non-trivial
lemma new_lemma_179643 (h0 : ring (canonically_linear_ordered_monoid (option (option ennreal)))) : rank_condition (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_179644 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) (comm_group ennreal)) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} pos)) (comm_group.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_179645 (h0 : list (has_to_string (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179646 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_179647 (h0 : ring (linear_ordered_semiring unsigned)) : rank_condition (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_179648 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179649 (h0 : topological_space (normed_group fun_info)) : discrete_topology (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_179650 (h0 : uniform_space (has_Sup (semiring (semiring (semiring (semiring num)))))) : complete_space (has_Sup (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_179651 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_179652 (h0 : functor.add_const (filter (has_zero Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179653 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : is_compactly_generated (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_179654 (h0 : topological_space (monoid_with_zero unsigned)) : totally_separated_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_179655 (h0 : has_lt std_gen -> std_gen) (h1 : coe_sort (set.range h0)) : @no_max_order.{0} std_gen (@set.range_splitting.{0 0} (has_lt.{0} std_gen) std_gen h0 h1)  := sorry --non-trivial
lemma new_lemma_179656 (h0 : uniform_space (normed_comm_ring (has_Inf (has_Inf (finset environment.implicit_infer_kind))))) : separated_space (normed_comm_ring (has_Inf (has_Inf (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_179657 (h0 : functor.add_const (group (preorder empty)) num) : @is_cyclic.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_179658 (h0 : uniform_space (has_neg_part (add_comm_monoid environment.implicit_infer_kind))) : complete_space (has_neg_part (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179660 (h0 : add_monoid (generalized_boolean_algebra (finset pos))) : add_monoid.fg (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_179661 (h0 : uniform_space (has_nndist (finset name))) : separated_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_179662 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_179663 (h0 : has_zero (linear_ordered_field ennreal) -> has_zero (linear_ordered_field ennreal) -> Prop) : is_symm (has_zero (linear_ordered_field ennreal)) h0 := sorry --non-trivial
lemma new_lemma_179664 (h0 : has_lt (has_div linarith.ineq)) : no_max_order (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_179665 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) (semiring empty)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179667 (h0 : ordered_add_comm_monoid (add_cancel_comm_monoid empty)) : archimedean (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_179668 (h0 : topological_space (has_to_string (finset (ring (finset linarith.comp))))) : totally_disconnected_space (has_to_string (finset (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179669 (h0 : topological_space string.iterator_imp) : totally_disconnected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_179670 (h0 : functor.comp topological_space normed_comm_ring pos) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_179671 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_179672 (h0 : functor.add_const (monoid (add_comm_monoid environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_179673 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) name) : @regular_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_179674 (h0 : group (denumerable (random_gen (has_nnnorm (random_gen to_additive.value_type))))) : is_cyclic (denumerable (random_gen (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_179675 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) linarith.comp) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179676 (h0 : topological_space (ring (ring (has_nndist (ordered_ring Type))))) : totally_separated_space (ring (ring (has_nndist (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_179677 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_179678 (h0 : functor.comp topological_space add_comm_monoid (finset (ring pos))) : @preconnected_space.{0} (add_comm_monoid.{0} (finset.{0} (ring.{0} pos))) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} (finset.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_179679 (h0 : topological_space (has_le fun_info)) (h1 : add_group (has_le fun_info)) : topological_add_group (has_le fun_info) := sorry --non-trivial
lemma new_lemma_179680 (h2 : set (semi_normed_ring linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_179681 (h1 : topological_space (with_zero (has_nnnorm linarith.ineq))) : totally_disconnected_space (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179682 (h0 : topological_space (has_nndist ennreal)) : loc_path_connected_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_179683 (h1 : topological_space (id fun_info)) : locally_compact_space (id fun_info) := sorry --non-trivial
lemma new_lemma_179684 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_add (has_Inf pos)))) : unique_factorization_monoid (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_179685 (h0 : complete_lattice (left_cancel_monoid (option (option (option unsigned))))) : is_atomistic (left_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_179686 (h0 : topological_space (finset (mul_one_class linarith.comp))) : preconnected_space (finset (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_179687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179688 (h0 : semiring (cancel_monoid empty)) : is_noetherian_ring (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_179689 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_179690 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) (ring linarith.comp)) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_179691 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179692 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_179693 (h0 : ring (semiring (semiring congr_arg_kind))) : strong_rank_condition (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179694 (h1 : ring (add_left_cancel_monoid (has_nnnorm string_imp))) : strong_rank_condition (add_left_cancel_monoid (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_179695 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_179696 (h0 : list (normed_group (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_179698 (h0 : functor.comp topological_space mul_zero_class Type) : @t1_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_179699 (h0 : functor.add_const (add_monoid (complete_distrib_lattice pos)) pos) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_179700 (h0 : not (semiring (add_group congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_179701 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (has_Inf real))))) : irreducible_space (boolean_algebra (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_179702 (h0 : uniform_space (has_compl (has_ssubset (has_ssubset to_additive.value_type)))) : complete_space (has_compl (has_ssubset (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_179703 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_179704 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_179705 (h0 : functor.add_const (uniform_space (non_assoc_semiring congr_arg_kind)) congr_arg_kind) : @complete_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_179706 (h0 : group (id (has_inv (random_gen (has_inv linarith.ineq))))) : normalizer_condition (id (has_inv (random_gen (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_179707 (h0 : group (comm_group (has_neg (comm_group (semigroup linarith.comp))))) : group.fg (comm_group (has_neg (comm_group (semigroup linarith.comp)))) := sorry --non-trivial
lemma new_lemma_179708 (h1 : topological_space (simple_graph (normed_field reducibility_hints))) : path_connected_space (simple_graph (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_179709 (h0 : topological_space (has_pos_part (finset pos))) : totally_separated_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_179710 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_179711 (h0 : topological_space (has_bot (option (option unsigned)))) : t1_space (has_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_179712 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : totally_disconnected_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179713 (h0 : uniform_space (nondiscrete_normed_field string.iterator_imp)) : complete_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_179714 (h0 : complete_lattice (has_div linarith.comp_source)) : is_compactly_generated (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179715 (h0 : topological_space (complete_lattice empty)) : totally_disconnected_space (complete_lattice empty) := sorry --non-trivial
lemma new_lemma_179716 (h0 : topological_space (finset num)) : sequential_space (finset num) := sorry --non-trivial
lemma new_lemma_179717 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field num)) := sorry --non-trivial
lemma new_lemma_179718 (h0 : ring (add_left_cancel_semigroup congr_arg_kind)) : is_domain (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179719 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_179720 (h0 : list (has_top (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_179721 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_179722 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_179723 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179724 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179725 (h0 : not (uniform_space (has_append (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (comm_ring fun_info)))))) -> false)) : @complete_space.{0} (has_append.{0} (comm_ring.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (comm_ring.{0} fun_info)))))) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} (comm_ring.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (comm_ring.{0} fun_info))))))) h0)  := sorry --non-trivial
lemma new_lemma_179726 (h0 : functor.add_const (group (cancel_monoid pos)) Type) : @is_simple_group.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_179727 (h0 : topological_space (normed_comm_ring (has_add (has_to_string (has_to_string name))))) : topological_space.separable_space (normed_comm_ring (has_add (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_179728 (h0 : not (topological_space (semi_normed_ring linarith.ineq) -> false)) : @t0_space.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_179729 (h0 : functor.add_const (function.extfun Type topological_space) (has_nndist pos)) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_nndist.{0} pos) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_179730 (h0 : ordered_add_comm_monoid (has_add (has_nndist pos))) : archimedean (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_179731 (h0 : set (distrib fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_179732 (h0 : add_group (normed_comm_ring (option unsigned))) : is_add_cyclic (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_179733 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179735 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179736 (h0 : functor.comp ordered_comm_monoid has_neg name) : @has_exists_mul_of_le.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_179737 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179738 (h0 : not (ring to_additive.value_type -> false)) : @strong_rank_condition.{0} to_additive.value_type (@classical.by_contradiction'.{1} (ring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_179739 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_179740 (h0 : uniform_space (has_nndist Type)) : separated_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_179741 (h0 : thunk pnat) (h1 : pnat) : pnat.coprime (@trace_call_stack.{0} pnat h0) h1  := sorry --non-trivial
lemma new_lemma_179742 (h0 : ring (random_gen (random_gen string_imp))) : is_domain (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_179743 (h0 : topological_space (group_with_zero (option empty))) : locally_compact_space (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_179744 (h0 : monoid (with_bot (random_gen (has_inv to_additive.value_type)))) : monoid.fg (with_bot (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_179745 (h0 : functor.comp ring canonically_ordered_comm_semiring Type) : @strong_rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_179746 (h0 : functor.add_const (uniform_space (has_Inf Type)) pos) : @complete_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_179747 (h0 : group (add_cancel_monoid (boolean_algebra linarith.comp))) : is_simple_group (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_179748 (h0 : ring (normed_group (has_norm num))) : strong_rank_condition (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_179749 (h0 : pfun linarith.comp_source linarith.comp_source) (h1 : linarith.comp_source) : pfun.ran h0 h1 := sorry --non-trivial
lemma new_lemma_179750 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @irreducible_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_179751 (h0 : functor.add_const (topological_space Type) linarith.comp) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179752 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : path_connected_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_179753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_179754 (h0 : add_monoid (ordered_comm_group empty)) : add_monoid.fg (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_179755 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_179756 (h1 : uniform_space (topological_space to_additive.value_type)) : complete_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179757 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (add_cancel_monoid.{0} empty) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_179758 (h1 : ring (has_ssubset string.iterator_imp)) : strong_rank_condition (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_179759 (h0 : add_group (has_le (normed_field (mul_one_class reducibility_hints)))) : is_add_cyclic (has_le (normed_field (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_179760 (h0 : topological_space (random_gen (semiring unsigned))) : totally_separated_space (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_179761 (h0 : group (mul_zero_class (has_top (has_top (has_top (has_top empty)))))) : is_cyclic (mul_zero_class (has_top (has_top (has_top (has_top empty))))) := sorry --non-trivial
lemma new_lemma_179762 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179763 (h0 : functor.add_const Prop (boolean_algebra.core (has_neg pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_179764 (h0 : functor.add_const (topological_space (has_neg name)) (has_neg (has_neg (has_neg linarith.comp)))) : @totally_disconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) (has_neg.{0} (has_neg.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_179765 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_179766 (h0 : functor.add_const (ring (semigroup unsigned)) name) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_179767 (h0 : fin has_zero.zero) : @preconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_179768 (h0 : topological_space (has_norm (comm_ring linarith.ineq))) : irreducible_space (has_norm (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179769 (h1 : function.extfun Type add_group) : @is_simple_add_group.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179770 (h0 : uniform_space (has_norm (semiring (semiring empty)))) : separated_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_179771 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : locally_compact_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_179772 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} string_imp)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} string_imp)))))))  := sorry --non-trivial
lemma new_lemma_179773 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179774 (h0 : ring (encodable (random_gen char))) : strong_rank_condition (encodable (random_gen char)) := sorry --non-trivial
lemma new_lemma_179775 (h0 : ring (comm_group (has_neg_part (has_neg_part (add_comm_monoid Type))))) : rank_condition (comm_group (has_neg_part (has_neg_part (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_179776 (h0 : complete_lattice (id (has_top empty))) : is_atomistic (id (has_top empty)) := sorry --non-trivial
lemma new_lemma_179777 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_179778 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) (finset linarith.comp)) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_add.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_179779 (h0 : monoid (has_zero (measurable_space.dynkin_system name))) : monoid.fg (has_zero (measurable_space.dynkin_system name)) := sorry --non-trivial
lemma new_lemma_179780 (h0 : functor.add_const (list (semigroup name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179781 (h0 : functor.add_const Prop (has_add (boolean_algebra.core environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_179782 (h0 : add_group (random_gen (has_inv linarith.ineq))) : is_add_cyclic (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179783 (h0 : fin has_zero.zero) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_179784 (h0 : uniform_space (normed_lattice_add_comm_group Type)) : separated_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_179785 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_179786 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_179787 (h0 : topological_space (distrib (mul_one_class (mul_one_class linarith.ineq)))) : path_connected_space (distrib (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_179788 (h1 : monoid (normed_group linarith.comp_source)) : monoid.fg (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179789 (h0 : group (with_bot (random_gen num))) : is_cyclic (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_179790 (h1 : has_add fun_info) (h2 : topological_space (add_con fun_info)) : totally_disconnected_space (add_con fun_info) := sorry --non-trivial
lemma new_lemma_179791 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp)))))  := sorry --non-trivial
lemma new_lemma_179792 (h0 : monoid (has_zero (has_neg_part (comm_group Type)))) : monoid.fg (has_zero (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_179793 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179794 (h0 : functor.comp topological_space has_to_string linarith.comp) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179795 (h1 : set (normed_field linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_179796 (h0 : ring (has_add (ring (has_Inf pos)))) : rank_condition (has_add (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_179797 (h0 : functor.add_const (monoid (add_cancel_monoid unsigned)) (option (option (option (option (option num)))))) : @monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} unsigned)) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} num))))) h0)  := sorry --non-trivial
lemma new_lemma_179798 (h0 : topological_space (omega_complete_partial_order (option (option empty)))) : normal_space (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_179799 (h0 : not (list (has_emptyc (has_norm linarith.comp_source)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_179800 (h1 : group (comm_ring char)) : is_cyclic (comm_ring char) := sorry --non-trivial
lemma new_lemma_179801 (h0 : group (has_inter (option ennreal))) : is_simple_group (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_179802 (h0 : complete_lattice (normed_group (has_norm (semiring unsigned)))) : is_compactly_generated (normed_group (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_179803 (h0 : functor.comp finset canonically_ordered_comm_semiring pos) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_179804 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) (semiring empty)) : @normal_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179805 (h0 : group (metric_space (linear_ordered_semiring (semiring num)))) : group.fg (metric_space (linear_ordered_semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_179806 (h0 : functor.add_const (group (has_sub empty)) (semiring empty)) : @group.fg.{0} (has_sub.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_sub.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_179807 (h0 : not (ring (semi_normed_ring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_179808 (h0 : functor.add_const (add_monoid (left_cancel_monoid congr_arg_kind)) empty) : @add_monoid.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_179809 (h0 h1 : multiset (simple_graph fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_179810 (h0 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class (mul_one_class char))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_179811 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) name) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_179812 (h1 : add_group (add_comm_semigroup linarith.ineq)) : is_add_cyclic (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_179813 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179814 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_179816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_179817 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group unsigned)) unsigned) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179818 (h0 : add_group (boolean_algebra (has_bot real))) : is_add_cyclic (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_179819 (h0 : functor.comp (functor.comp monoid has_nndist) with_top nnreal) : @monoid.fg.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} monoid.{0} has_nndist.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} monoid.{0} has_nndist.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_179820 (h0 : function.extfun Type (functor.add_const (uniform_space (mul_zero_class empty)))) : @complete_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179821 (h0 : functor.add_const (ring (boolean_algebra.core pos)) linarith.comp) : @rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179822 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_179823 (h0 : not (topological_space (id num) -> false)) : @discrete_topology.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_179824 (h0 : topological_space (ordered_comm_ring (has_add (finset Type)))) : locally_compact_space (ordered_comm_ring (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_179825 (h0 : functor.comp topological_space boolean_algebra.core Type) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_179826 (h0 : topological_space (has_zero (has_add name))) : normal_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_179827 (h0 : add_monoid (cancel_monoid (option (has_to_string (has_add name))))) : add_monoid.fg (cancel_monoid (option (has_to_string (has_add name)))) := sorry --non-trivial
lemma new_lemma_179828 (h2 : add_group (encodable (has_nnnorm char))) : is_add_cyclic (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_179829 (h1 : complete_lattice (encodable (linear_ordered_add_comm_group string_imp))) : complete_lattice.is_Sup_finite_compact (encodable (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_179830 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_atomistic.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_179831 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_179832 (h0 : topological_space (ring (has_neg Type))) : topological_space.separable_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_179833 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179834 (h0 : topological_space (has_norm (random_gen num))) : irreducible_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_179835 (h0 : finset (has_top (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_179836 (h1 : add_group (has_lt linarith.comp_source)) : is_add_cyclic (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_179837 (h0 : add_group (id reducibility_hints)) : is_add_cyclic (id reducibility_hints) := sorry --non-trivial
lemma new_lemma_179838 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_179839 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179840 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (finset pos)) : @archimedean.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (finset.{0} pos) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_179841 (h0 : function.extfun nat fin) : @separated_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_179842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_179843 (h0 : ordered_comm_monoid (has_bot (has_Inf real))) : has_exists_mul_of_le (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_179844 (h0 : topological_space (has_one real)) : locally_compact_space (has_one real) := sorry --non-trivial
lemma new_lemma_179845 (h0 : topological_space (has_nndist (cancel_monoid name))) : normal_space (has_nndist (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_179846 (h0 : functor.add_const (ring (add_comm_monoid environment.implicit_infer_kind)) pos) : @is_domain.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_179847 (h0 : topological_space (normed_comm_ring unsigned)) : loc_path_connected_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_179848 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_179849 (h2 : group (linear_ordered_semiring num)) : normalizer_condition (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_179850 (h0 : complete_lattice (with_one (semiring empty))) : is_atomistic (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_179851 (h0 : ordered_comm_monoid (complete_distrib_lattice ennreal)) : has_exists_mul_of_le (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_179852 (h0 : topological_space (comm_group (comm_group Type))) : topological_space.separable_space (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_179853 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_179854 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_179855 (h0 : add_monoid (has_to_string (has_add linarith.comp))) : add_monoid.fg (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_179856 (h0 : has_zero (has_add unsigned) -> has_zero (has_add unsigned) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_179857 (h1 : not (topological_space (id linarith.comp) -> false)) : @normal_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_179858 (h0 : functor.comp topological_space mul_zero_class pos) : @irreducible_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_179859 (h0 : topological_space (with_one (semiring unsigned))) : irreducible_space (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_179860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_179861 (h0 : measurable_space (normed_field environment.projection_info)) (h1 : filter (normed_field environment.projection_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_179862 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_179863 (h0 : functor.add_const (monoid (monoid ennreal)) congr_arg_kind) : @monoid.fg.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (monoid.{0} ennreal)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_179864 (h0 : add_group (has_add Type)) : is_add_cyclic (has_add Type) := sorry --non-trivial
lemma new_lemma_179865 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_179866 (h1 : uniform_space (id (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : complete_space (id (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_179867 (h0 : list (group (partial_order empty))) (h1 : ne h0 list.nil) : @normalizer_condition.{0} (partial_order.{0} empty) (@list.last.{0} (group.{0} (partial_order.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_179868 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @loc_path_connected_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_179869 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_179870 (h0 : functor.add_const (complete_lattice (comm_group pos)) name) : @is_atomistic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_179871 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_179872 (h0 : functor.comp add_monoid boolean_algebra.core Type) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} add_monoid.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_179873 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (order_dual.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (order_dual.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_179874 (h0 : functor.add_const (ring (cancel_monoid unsigned)) name) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_179875 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_179876 (h0 : functor.add_const (complete_lattice (preorder num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_179877 (h0 : complete_lattice (has_emptyc (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_179878 (h4 : ring (has_ssubset linarith.ineq)) : is_domain (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_179879 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) pos) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_179880 (h0 : group (has_add num)) : is_cyclic (has_add num) := sorry --non-trivial
lemma new_lemma_179881 (h0 : functor.add_const (add_monoid (non_assoc_semiring num)) num) : @add_monoid.fg.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_179882 (h0 : topological_space (comm_group (comm_group (has_neg_part (option ennreal))))) : regular_space (comm_group (comm_group (has_neg_part (option ennreal)))) := sorry --non-trivial
lemma new_lemma_179883 (h1 : topological_space (has_emptyc (random_gen (random_gen to_additive.value_type)))) : path_connected_space (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_179884 (h0 : functor.add_const (complete_lattice (has_add Type)) linarith.comp) : @is_compactly_generated.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179885 (h0 : add_group (has_le std_gen)) : is_add_cyclic (has_le std_gen) := sorry --non-trivial
lemma new_lemma_179886 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_179887 (h0 : functor.add_const (list (semigroup linarith.comp)) (normed_comm_ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179888 (h0 : not (add_group (denumerable (denumerable (has_nnnorm linarith.ineq))) -> false)) : @is_add_cyclic.{0} (denumerable.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_179889 (h0 : ring (id linarith.ineq)) : rank_condition (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_179890 (h3 : set (std_gen -> fun_info)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_179891 (h0 : topological_space (non_unital_non_assoc_semiring (semigroup_with_zero string.iterator_imp))) : t0_space (non_unital_non_assoc_semiring (semigroup_with_zero string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_179892 (h0 : monoid (has_inv (random_gen string_imp))) : monoid.fg (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_179893 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) pos) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_179894 (h0 : group (canonically_linear_ordered_monoid pos)) : is_cyclic (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_179895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @local_ring.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type comm_ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 comm_ring.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_179896 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_179897 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : totally_disconnected_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_179898 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_179899 (h3 : uniform_space (has_lt to_additive.value_type)) : complete_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179900 (h0 : cancel_comm_monoid_with_zero (has_edist congr_arg_kind)) : unique_factorization_monoid (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_179901 (h0 : topological_space (id (random_gen (random_gen linarith.ineq)))) : t0_space (id (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_179902 (h0 : function.extfun Type ring) : @is_domain.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_179904 (h0 : group (topological_space (has_nnnorm fun_info))) : is_cyclic (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_179905 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : loc_path_connected_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_179906 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) num) : @strong_rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_179907 (h0 : function.extfun Type (functor.comp list finset)) : list.nodup (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_179908 (h0 : functor.add_const (ring (finset linarith.comp)) pos) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_179909 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179910 (h0 : functor.add_const (ring (ordered_comm_group congr_arg_kind)) congr_arg_kind) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_179911 (h0 : topological_space (encodable linarith.ineq)) : t0_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_179912 (h0 : set (set (option (option (has_to_string ennreal))))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_179913 (h0 : filter (has_bot unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_179914 (h0 : ring (add_comm_monoid (has_add pos))) : is_domain (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_179915 (h0 : functor.add_const (topological_space (has_to_string ennreal)) num) : @preirreducible_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_179916 (h0 : topological_space (normed_group (has_inv (has_inv (has_inv (has_inv fun_info)))))) : t0_space (normed_group (has_inv (has_inv (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_179917 (h0 : topological_space (has_Inf (has_neg real))) : path_connected_space (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_179918 (h0 : topological_space (has_neg_part (option unsigned))) : discrete_topology (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_179919 (h0 : complete_lattice (ring (ring Type))) : complete_lattice.is_Sup_finite_compact (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_179920 (h0 : topological_space (complete_distrib_lattice (has_bot real))) : discrete_topology (complete_distrib_lattice (has_bot real)) := sorry --non-trivial
lemma new_lemma_179921 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) pos) : @group.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_179922 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring linarith.comp)) (ring linarith.comp)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_179923 (h0 : ring (add_monoid (random_gen (has_nnnorm linarith.comp_source)))) : is_domain (add_monoid (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_179924 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_179925 (h0 : topological_space (left_cancel_semigroup num)) : totally_disconnected_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_179926 (h0 : list (non_assoc_semiring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179927 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 : topological_space (fintype (quot h0))) : t0_space (fintype (quot h0)) := sorry --non-trivial
lemma new_lemma_179928 (h0 : complete_lattice (has_pos_part (has_Inf (has_add pos)))) : is_atomistic (has_pos_part (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_179929 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_179930 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_comm_monoid.{0} (add_cancel_monoid.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} (add_cancel_monoid.{0} empty)))  := sorry --non-trivial
lemma new_lemma_179931 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179932 (h0 : group (dlist fun_info)) : group.fg (dlist fun_info) := sorry --non-trivial
lemma new_lemma_179933 (h0 : has_pos_part (sub_neg_monoid linarith.comp) -> has_pos_part (sub_neg_monoid linarith.comp) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_179934 (h0 : monoid (has_neg (comm_group name))) : monoid.fg (has_neg (comm_group name)) := sorry --non-trivial
lemma new_lemma_179935 (h0 : topological_space (mul_one_class ereal)) : totally_disconnected_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_179936 (h0 : topological_space (normed_group to_additive.value_type)) : irreducible_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_179938 (h0 : topological_space (comm_group (cancel_monoid unsigned))) : totally_disconnected_space (comm_group (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_179939 (h0 : filter (has_neg (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179940 (h0 : topological_space (monoid unsigned)) : totally_disconnected_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_179941 (h0 : filter (has_neg (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179942 (h0 : group (semigroup (ring pos))) : group.fg (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_179943 (h0 : functor.add_const (function.extfun Type group) name) : @is_simple_group.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_179944 (h0 : functor.add_const (filter (has_neg Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_179945 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_179946 (h0 : monoid (has_to_string (has_add (finset linarith.comp)))) : monoid.fg (has_to_string (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_179947 (h0 : ordered_comm_monoid (has_nndist (linear_ordered_comm_group name))) : has_exists_mul_of_le (has_nndist (linear_ordered_comm_group name)) := sorry --non-trivial
lemma new_lemma_179948 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_179949 (h0 : uniform_space (has_bot (has_Inf pos))) : complete_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_179950 (h0 : complete_lattice (dlist (has_nnnorm char))) : is_compactly_generated (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_179951 (h0 : list (measurable_space (random_gen (random_gen (random_gen to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_179952 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_179953 (h0 : topological_space (comm_group (has_add linarith.comp))) : preconnected_space (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_179954 (h0 : not (ring (measurable_space num) -> false)) : @is_domain.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_179955 (h0 : function.extfun nat fin) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos (@matrix.vec_empty.{0} (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_179956 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_add name)) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_179957 (h0 : uniform_space (topological_space (denumerable char))) : complete_space (topological_space (denumerable char)) := sorry --non-trivial
lemma new_lemma_179958 (h0 : topological_space (has_to_string (has_add (has_add Type)))) : irreducible_space (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_179959 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_179960 (h0 : group (order_dual empty)) : normalizer_condition (order_dual empty) := sorry --non-trivial
lemma new_lemma_179961 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) unsigned) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_179963 (h2 : group (random_gen (comm_ring char))) : is_cyclic (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_179964 (h0 : topological_space (has_zero pos)) : t0_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_179965 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_179966 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (ordered_comm_ring.{0} (has_neg.{0} pos)) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (ordered_comm_ring.{0} (has_neg.{0} pos)))  := sorry --non-trivial
lemma new_lemma_179967 (h0 : cancel_comm_monoid_with_zero (partial_order empty)) : unique_factorization_monoid (partial_order empty) := sorry --non-trivial
lemma new_lemma_179968 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop empty))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_179969 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_179970 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_179971 (h0 : has_zero (has_to_string pos) -> has_zero (has_to_string pos) -> Prop) : is_symm (has_zero (has_to_string pos)) h0 := sorry --non-trivial
lemma new_lemma_179972 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} environment.implicit_infer_kind))))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} environment.implicit_infer_kind))))))  := sorry --non-trivial
lemma new_lemma_179973 (h0 : uniform_space (comm_semigroup (comm_semigroup real))) : complete_space (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_179974 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (has_Inf Type)) : @irreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_179975 (h0 : uniform_space (linear_ordered_add_comm_group (fintype linarith.ineq))) : complete_space (linear_ordered_add_comm_group (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_179976 (h0 : topological_space (semigroup (has_pos_part pos))) : preirreducible_space (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_179977 (h0 : cancel_comm_monoid_with_zero (plift (semiring unsigned))) : unique_factorization_monoid (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_179978 (h0 : uniform_space (semiring (random_gen (semiring unsigned)))) : separated_space (semiring (random_gen (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_179979 (h0 : not (multiset (measurable_space empty) -> false)) : multiset.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_179980 (h0 : filter (group_with_zero congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_179981 (h0 : group (distrib_lattice (has_inv (has_inv linarith.comp_source)))) : group.fg (distrib_lattice (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_179982 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_179983 (h1 : topological_space (random_gen (metric_space (comm_ring reducibility_hints)))) : t0_space (random_gen (metric_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_179984 (h0 : monoid (id (random_gen linarith.comp))) : monoid.fg (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_179985 (h0 : topological_space (has_Inf (has_neg name))) : sequential_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_179986 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group (comm_group name))))) : topological_space.separable_space (add_cancel_monoid (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_179987 (h1 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_179988 (h0 : add_group (with_one to_additive.value_type)) : is_add_cyclic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_179989 (h0 : functor.add_const (group (has_zero name)) pos) : @group.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_179990 (h0 : ring (boolean_algebra.core num)) : is_principal_ideal_ring (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_179991 (h2 : preorder ereal) (h3 : set ereal) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_179992 (h0 : topological_space (with_bot (linear_ordered_add_comm_group congr_arg_kind))) : irreducible_space (with_bot (linear_ordered_add_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_179993 (h0 : complete_lattice (linear_ordered_field (has_to_string unsigned))) : is_atomistic (linear_ordered_field (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_179994 (h0 : functor.add_const (add_group (option congr_arg_kind)) unsigned) : @is_add_cyclic.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_179995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_179996 (h0 : topological_space (measurable_space (random_gen to_additive.value_type))) : irreducible_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_179997 (h0 : ring (has_nndist (has_add (has_add pos)))) : rank_condition (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_179998 (h0 : complete_lattice (boolean_algebra.core (option empty))) : is_atomistic (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_179999 (h0 : list (add_cancel_monoid (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180000 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180001 (h3 : complete_lattice (has_inv fun_info)) : complete_lattice.is_Sup_finite_compact (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_180002 (h0 : ring (has_inter reducibility_hints)) : is_domain (has_inter reducibility_hints) := sorry --non-trivial
lemma new_lemma_180003 (h0 : measurable_space std_gen) (h1 : filter std_gen) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_180004 (h0 : ring (has_dist (option (option empty)))) : is_domain (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_180005 (h0 : ring (simple_graph (has_neg name))) : is_principal_ideal_ring (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_180006 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_180007 (h0 : not (complete_lattice (has_ssubset reducibility_hints) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_180008 (h0 : cancel_comm_monoid_with_zero (has_neg_part (option pos))) : unique_factorization_monoid (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_180009 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180010 (h0 : functor.add_const (ring (add_cancel_monoid name)) unsigned) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180011 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : sequential_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_180012 (h1 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} (with_bot.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} (with_bot.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_180013 (h1 : complete_lattice (complete_semilattice_Sup (linear_ordered_semiring string_imp))) : is_compactly_generated (complete_semilattice_Sup (linear_ordered_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_180014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180015 (h0 : topological_space (has_star (semiring (semiring num)))) : normal_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_180016 (h1 h2 : multiset (has_lt to_additive.value_type)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_180017 (h1 : complete_lattice (complete_semilattice_Sup linarith.ineq)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_180018 (h0 : not (ring (partial_order congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_180019 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180020 (h0 : topological_space (add_group (has_union linarith.comp))) : irreducible_space (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_180021 (h0 : monoid (linear_ordered_comm_monoid_with_zero num)) : monoid.fg (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_180022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_180023 (h0 : prod (mul_zero_class unsigned) (mul_zero_class unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_180024 (h5 : set (nondiscrete_normed_field environment.projection_info)) : set.finite h5 := sorry --non-trivial
lemma new_lemma_180025 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_order empty)) := sorry --non-trivial
lemma new_lemma_180026 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @preconnected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180027 (h0 : not (order_hom nat Prop -> false) -> order_hom nat Prop) (h1 : nonempty (order_hom nat Prop)) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@classical.choice_of_by_contradiction'.{1} (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_180028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180029 (h0 : filter (has_add (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_180030 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180031 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (left_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180032 (h1 : ring (normed_group fun_info)) : is_domain (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_180033 (h0 : group (has_zero (comm_group ennreal))) : normalizer_condition (has_zero (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_180034 (h0 : topological_space (normed_comm_ring (has_add Type))) : totally_disconnected_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_180035 (h0 : function.extfun Type (functor.add_const (list (ordered_ring congr_arg_kind)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_180036 (h0 : functor.add_const (ring (pseudo_metric_space unsigned)) empty) : @rank_condition.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_180037 (h0 : ring (has_nnnorm (has_nnnorm linarith.ineq))) : rank_condition (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180038 (h0 : group (simple_graph (has_Inf pos))) : group.fg (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_180039 (h2 : uniform_space (has_nnnorm char)) : complete_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_180040 (h0 : function.extfun Type group) : @group.fg.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_180041 (h0 : ring (generalized_boolean_algebra name)) : is_domain (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_180042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_180043 (h0 : group (has_edist empty)) : group.fg (has_edist empty) := sorry --non-trivial
lemma new_lemma_180044 (h0 : functor.add_const (semiring (has_zero name)) unsigned) : @is_noetherian_ring.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180045 (h0 : topological_space (pseudo_metric_space (option unsigned))) : totally_separated_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_180046 (h0 : prod (boolean_algebra.core (semigroup Type)) (boolean_algebra.core (semigroup Type))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_180047 (h0 : functor.add_const (ring (boolean_algebra unsigned)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180048 (h0 : filter (random_gen to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180049 (h0 : topological_space (has_to_string (option unsigned))) : discrete_topology (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_180050 (h0 : functor.add_const (filter (has_Inf (has_add linarith.comp))) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180051 (h0 : group (random_gen (random_gen char))) : is_cyclic (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_180052 (h0 : topological_space (simple_graph (finset pos))) : sequential_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_180053 (h0 : topological_space (has_add (has_pos_part (add_left_cancel_semigroup Type)))) : totally_disconnected_space (has_add (has_pos_part (add_left_cancel_semigroup Type))) := sorry --non-trivial
lemma new_lemma_180054 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @totally_separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180055 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_180056 (h0 : ring (distrib (denumerable (comm_ring linarith.comp_source)))) : is_domain (distrib (denumerable (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_180057 (h0 : functor.add_const (topological_space (finset name)) (has_to_string Type)) : @preirreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180058 (h2 : ring (add_monoid to_additive.value_type)) : is_domain (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180059 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_180060 (h0 : group (id (has_inv linarith.ineq))) : is_cyclic (id (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180061 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180062 (h0 : complete_lattice (bin_tree congr_arg_kind)) : is_atomistic (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180063 (h0 : filter (semi_normed_comm_ring (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180064 (h0 : ring (has_compl (has_inv linarith.comp_source))) : is_domain (has_compl (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180065 (h0 : topological_space (has_nndist pos)) : discrete_topology (has_nndist pos) := sorry --non-trivial
lemma new_lemma_180066 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (group_with_zero num)) := sorry --non-trivial
lemma new_lemma_180067 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_180068 (h3 : ring (semi_normed_ring char)) : rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_180069 (h0 : group (has_Inf (ring (has_add (has_Inf pos))))) : is_cyclic (has_Inf (ring (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_180070 (h0 : function.extfun Type group) : @group.fg.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180071 (h0 : topological_space (boolean_algebra.core (has_neg environment.implicit_infer_kind))) : sequential_space (boolean_algebra.core (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180072 (h0 : function.extfun (set fun_info -> Type) (function.extfun (set fun_info))) : is_countably_spanning (function.extfun_app (function.extfun_app h0 (fun (x : set fun_info), Prop))) := sorry --non-trivial
lemma new_lemma_180073 (h0 : topological_space (has_ssubset (has_inv (random_gen linarith.ineq)))) : path_connected_space (has_ssubset (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180074 (h0 : topological_space (boolean_algebra (has_Inf (has_neg linarith.comp)))) : path_connected_space (boolean_algebra (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_180075 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @locally_compact_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180076 (h0 : not (ring (has_emptyc num) -> false)) : @rank_condition.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180077 (h1 : topological_space (complete_semilattice_Sup string_imp)) : t0_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_180078 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_inter num)) num) : @unique_factorization_monoid.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_inter.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_180079 (h0 : filter (encodable char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180080 (h0 : functor.add_const (filter (generalized_boolean_algebra linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180081 (h0 : topological_space (has_norm (semiring (semiring unsigned)))) : preirreducible_space (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180082 (h0 : ereal -> ereal -> Prop) : nonempty (is_directed ereal h0) := sorry --non-trivial
lemma new_lemma_180083 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) linarith.comp) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180084 (h0 : partial_order congr_arg_kind -> partial_order congr_arg_kind -> Prop) : is_strict_order (partial_order congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_180085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180086 (h0 : list (boolean_algebra (semigroup environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180087 (h0 : add_group (linear_ordered_semiring (semiring linarith.comp))) : is_add_cyclic (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_180088 (h1 : ring (add_monoid linarith.ineq)) : is_domain (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_180089 (h0 : monoid (normed_group (random_gen string_imp))) : monoid.fg (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_180090 (h0 : not (uniform_space (has_union empty) -> false)) : @separated_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_180091 (h0 : functor.add_const (topological_space (free_add_monoid empty)) unsigned) : @t0_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180092 (h0 : group (comm_ring (has_inv (denumerable string_imp)))) : group.fg (comm_ring (has_inv (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_180093 (h0 : complete_lattice (normed_comm_ring unsigned)) : is_compactly_generated (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_180094 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_180095 (h0 : not (uniform_space (with_bot linarith.ineq) -> false)) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_180096 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) unsigned) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180097 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_180098 (h0 : add_group (cancel_monoid environment.implicit_infer_kind)) : is_add_cyclic (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_180099 (h0 : add_group (has_div to_additive.value_type)) : is_add_cyclic (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180100 (h0 : has_lt (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char)))) : no_max_order (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_180101 (h0 : not (complete_lattice (linear_ordered_comm_ring empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_180102 (h1 : ring (semi_normed_comm_ring reducibility_hints)) : strong_rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_180103 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) num) : @preirreducible_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_180104 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180105 (h0 : filter (has_top (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180106 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_180107 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180108 (h1 : function.extfun Type has_le) (h2 : linarith.comp_source) : @is_max.{0} linarith.comp_source (@function.extfun_app.{2 1} Type has_le.{0} h1 linarith.comp_source) h2  := sorry --non-trivial
lemma new_lemma_180109 (h0 : uniform_space (finset (comm_group (add_cancel_monoid pos)))) : complete_space (finset (comm_group (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_180110 (h0 : ring (has_pos_part linarith.comp)) : rank_condition (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_180111 (h0 : fin has_zero.zero) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_180112 (h0 : functor.add_const (finset (measurable_space.dynkin_system unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180113 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) num) : @locally_compact_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_180114 (h0 : functor.add_const (filter (comm_group ennreal)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180115 (h0 : topological_space (left_cancel_semigroup unsigned)) : discrete_topology (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_180116 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_180117 (h0 : topological_space (has_inter (option (option (option empty))))) : path_connected_space (has_inter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_180118 (h0 : topological_space (has_top (semiring (has_norm (has_norm linarith.comp))))) : irreducible_space (has_top (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_180119 (h0 : add_monoid (comm_semigroup (has_bot (has_Inf (comm_semigroup (sub_neg_monoid (has_bot Type))))))) : add_monoid.fg (comm_semigroup (has_bot (has_Inf (comm_semigroup (sub_neg_monoid (has_bot Type)))))) := sorry --non-trivial
lemma new_lemma_180120 (h0 : uniform_space (has_pos_part (has_Inf linarith.comp))) : complete_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_180121 (h0 : functor.add_const (ring (boolean_algebra.core name)) name) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180122 (h1 : topological_space (id string_imp)) : locally_compact_space (id string_imp) := sorry --non-trivial
lemma new_lemma_180123 (h0 : group (has_norm (semiring num))) : normalizer_condition (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_180124 (h1 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_180125 (h0 : functor.add_const (group (finset pos)) (ring pos)) : @is_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_180126 (h0 : topological_space (add_cancel_monoid (has_Inf (has_neg (finset Type))))) : normal_space (add_cancel_monoid (has_Inf (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_180127 (h1 : set (char -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_180128 (h1 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h1) empty)  := sorry --non-trivial
lemma new_lemma_180129 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180130 (h0 : functor.add_const (filter (as_linear_order empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180131 (h0 : topological_space (ring (has_to_string environment.implicit_infer_kind))) : path_connected_space (ring (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180132 (h0 : function.extfun Type (functor.add_const (function.extfun Type ordered_comm_monoid))) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0})) h0 environment.implicit_infer_kind)) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_180133 (h0 : filter (semigroup (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180134 (h0 : topological_space (boolean_algebra (boolean_algebra.core pos))) : locally_compact_space (boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_180135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_180136 (h0 : topological_space (add_comm_monoid (option unsigned))) : t1_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_180137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180138 (h0 : not (group (non_assoc_semiring (semiring (semiring (semiring (semiring empty))))) -> false)) : @group.fg.{0} (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_180139 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180140 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180141 (h0 : ordered_comm_monoid (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_Inf (has_Inf real)))))) : has_exists_mul_of_le (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_180142 (h0 : functor.add_const (add_monoid (add_comm_monoid environment.implicit_infer_kind)) unsigned) : @add_monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180143 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) pos) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_180144 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180145 (h0 : functor.add_const (topological_space (finset pos)) (finset Type)) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180146 (h0 : add_group (linear_ordered_cancel_comm_monoid (option empty))) : is_add_cyclic (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_180147 (h0 : group (normed_field linarith.ineq)) : is_cyclic (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_180148 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg_part.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_180149 (h0 : function.extfun Type (prod (has_inter empty))) : id_rel (function.extfun_app h0 (has_inter empty)) := sorry --non-trivial
lemma new_lemma_180150 (h0 : finset (ring (has_pos_part pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180151 (h1 : ring (complete_distrib_lattice string_imp)) : rank_condition (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_180152 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_180153 (h0 : not (ring (has_inv linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_180154 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@id.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_180155 (h0 : functor.add_const (list (ring pos)) (has_nndist (has_neg_part pos))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180156 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) name) : @discrete_topology.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_180157 (h0 : group (with_bot (has_top unsigned))) : is_cyclic (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_180158 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @discrete_topology.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_180159 (h0 : not (group (add_right_cancel_monoid unsigned) -> false)) : @is_cyclic.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180160 (h1 : uniform_space (has_emptyc string_imp)) : complete_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_180161 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180162 (h0 : topological_space (has_nndist (has_add (has_add name)))) : preirreducible_space (has_nndist (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_180163 (h0 : group (metric_space (metric_space (comm_ring reducibility_hints)))) : is_cyclic (metric_space (metric_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_180164 (h0 : topological_space (comm_group (has_add Type))) : discrete_topology (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_180165 (h0 : ring (has_norm (has_top num))) : is_domain (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_180166 (h0 : add_monoid (mul_zero_class (semiring (semiring congr_arg_kind)))) : add_monoid.fg (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_180167 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_180168 (h0 : functor.add_const (semiring (preorder empty)) (semiring num)) : @is_noetherian_ring.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_180169 (h0 : filter (linear_ordered_comm_ring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_180171 (h0 : uniform_space (measurable_space.dynkin_system (linear_ordered_semiring (semiring unsigned)))) : separated_space (measurable_space.dynkin_system (linear_ordered_semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180172 (h0 : finset (semigroup (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180173 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180174 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180175 (h0 : complete_lattice (generalized_boolean_algebra (has_neg pos))) : is_compactly_generated (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_180176 (h0 : not (cancel_comm_monoid_with_zero (measurable_space.dynkin_system congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_180177 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) (semiring empty)) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_180178 (h0 : has_lt (linear_ordered_add_comm_group string_imp)) : no_min_order (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_180179 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_180180 (h0 : functor.add_const (group (has_add linarith.comp)) Type) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_180181 (h0 : ring (random_gen (with_bot (measurable_space (with_bot (random_gen string_imp)))))) : is_domain (random_gen (with_bot (measurable_space (with_bot (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_180182 (h0 : ring (non_assoc_semiring (option unsigned))) : is_domain (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_180183 (h0 : functor.add_const (add_group (boolean_algebra.core unsigned)) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180184 (h0 : group (has_star (semiring (semiring (semiring num))))) : normalizer_condition (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_180185 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_180186 (h0 : topological_space (ordered_comm_group empty)) : t1_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_180187 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_180188 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind)))) : has_exists_mul_of_le (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_180189 (h0 : ring (canonically_ordered_comm_semiring (finset (has_add (has_nndist name))))) : strong_rank_condition (canonically_ordered_comm_semiring (finset (has_add (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_180190 (h0 : ring (has_norm (semiring (semiring unsigned)))) : is_domain (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180191 (h1 : complete_lattice (has_nnnorm (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_180192 (h0 : functor.add_const (ring (has_Inf pos)) pos) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_180193 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_180194 (h0 : add_group (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : is_add_cyclic (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_180195 (h0 : not (function.extfun Type topological_space -> false)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_180196 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180197 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_180198 (h0 : complete_lattice (has_to_string (comm_group (comm_group name)))) : is_atomistic (has_to_string (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_180199 (h0 : ring (has_to_string (comm_group name))) : is_principal_ideal_ring (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_180200 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180201 (h0 : ring (plift num)) : rank_condition (plift num) := sorry --non-trivial
lemma new_lemma_180202 (h1 : uniform_space (semi_normed_comm_ring string_imp)) : complete_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_180203 (h0 : topological_space (with_one (has_norm linarith.comp_source))) : irreducible_space (with_one (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180204 (h0 : topological_space (has_zero (finset Type))) : discrete_topology (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_180205 (h0 : topological_space (has_Inf (ring (ordered_ring linarith.comp)))) : sequential_space (has_Inf (ring (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_180206 (h0 : set (linarith.ineq -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_180207 (h0 : topological_space (has_div reducibility_hints)) : totally_disconnected_space (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_180208 (h0 : finset Type -> finset Type -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_180209 (h0 : finset (complete_distrib_lattice pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180210 (h0 : topological_space (complete_distrib_lattice (mul_zero_class pos))) : regular_space (complete_distrib_lattice (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_180211 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group empty)))) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_180212 (h0 : ordered_add_comm_monoid (left_cancel_monoid (comm_monoid (option name)))) : archimedean (left_cancel_monoid (comm_monoid (option name))) := sorry --non-trivial
lemma new_lemma_180213 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180214 (h0 : fin has_zero.zero) : sequential_space real := sorry --non-trivial
lemma new_lemma_180215 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (has_zero linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_180216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_180217 (h0 : group (measurable_space (random_gen num))) : is_cyclic (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_180218 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180219 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_add real)))) : group.fg (normed_lattice_add_comm_group (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_180220 (h0 : topological_space (add_comm_monoid empty)) : normal_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_180221 (h0 : function.extfun Type (functor.add_const (ring (partial_order unsigned)))) : @rank_condition.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_180222 (h0 : functor.add_const (finset (has_inter empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180223 (h0 : finset (has_add (mul_one_class linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180224 (h0 : not (prod (add_right_cancel_monoid unsigned) (add_right_cancel_monoid unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_180225 (h0 : functor.add_const (group (has_zero pos)) pos) : @is_simple_group.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_180226 (h0 : ring (has_lt string_imp)) : strong_rank_condition (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_180227 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_180228 (h0 : functor.add_const (add_group (has_to_string Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_180230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_180231 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @loc_path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_180232 (h0 : topological_space (has_compl (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : t0_space (has_compl (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_180233 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid boolean_algebra.core)) : @archimedean.{0} (boolean_algebra.core.{0} (has_add.{0} unsigned)) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} boolean_algebra.core.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} boolean_algebra.core.{0}) h0 (has_add.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_180234 (h1 : complete_lattice (has_compl (has_nnnorm (has_inv fun_info)))) : complete_lattice.is_Sup_finite_compact (has_compl (has_nnnorm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_180235 (h0 : uniform_space (ordered_comm_ring (has_neg pos))) : complete_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_180236 (h0 : topological_space (linear_ordered_field (has_add (has_nndist name)))) : irreducible_space (linear_ordered_field (has_add (has_nndist name))) := sorry --non-trivial
lemma new_lemma_180237 (h3 : add_group enat) : is_add_cyclic enat := sorry --non-trivial
lemma new_lemma_180238 (h0 : uniform_space (linear_ordered_comm_group (option pos))) : complete_space (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_180239 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_180240 (h0 : ring (preorder unsigned)) : is_domain (preorder unsigned) := sorry --non-trivial
lemma new_lemma_180241 (h1 h2 : multiset (mul_one_class (mul_one_class fun_info))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_180242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_180243 (h0 : topological_space (has_to_string (finset pos))) : t1_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_180244 (h0 : topological_space (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_180245 (h0 : topological_space (has_Inf (has_add Type))) : totally_disconnected_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_180246 (h0 : topological_space (id linarith.ineq)) : totally_disconnected_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_180247 (h0 : list (complete_distrib_lattice (option num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180248 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : discrete_topology (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180249 (h0 : topological_space (has_neg (option (option (option num))))) : preconnected_space (has_neg (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_180250 (h0 : not (ring (has_add linarith.ineq) -> false)) : @rank_condition.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_180251 (h0 : monoid (omega_complete_partial_order empty)) : monoid.fg (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_180252 (h0 : monoid (ring (boolean_algebra pos))) : monoid.fg (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_180253 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180254 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180255 (h0 : ring (with_one (has_norm num))) : rank_condition (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_180256 (h0 : uniform_space (ordered_ring congr_arg_kind)) : separated_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180257 (h0 : topological_space (with_one (random_gen string_imp))) : locally_compact_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_180258 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) Type) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180259 (h0 : complete_lattice (with_one to_additive.value_type)) : is_atomistic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180260 (h0 : topological_space (ring (has_neg linarith.comp))) : topological_space.separable_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_180261 (h1 : has_compl (semi_normed_ring linarith.comp_source) -> std_gen) : function.has_right_inverse h1 := sorry --non-trivial
lemma new_lemma_180262 (h0 : functor.comp topological_space boolean_algebra name) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_180263 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_180264 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_180265 (h1 : filter (has_compl char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_180266 (h0 : filter (has_nnnorm (random_gen (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180267 (h0 : functor.add_const (monoid (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180268 (h0 : ring (has_div (mul_one_class char))) : strong_rank_condition (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_180269 (h0 : functor.add_const (function.extfun Type group) (ring linarith.comp)) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} linarith.comp) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_180270 (h0 : topological_space (simple_graph empty)) : t1_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_180271 (h0 : not (group (id unsigned) -> false)) : @normalizer_condition.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180272 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_180273 (h0 : function.extfun (finset Type) (has_mem.mem to_additive.value_type)) : @is_cyclic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type group.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_180274 (h0 : complete_lattice (has_emptyc (has_top (has_top to_additive.value_type)))) : is_atomistic (has_emptyc (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_180275 (h0 : not (topological_space (semiring (random_gen linarith.comp_source)) -> false)) : @locally_compact_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_180276 (h0 : topological_space (add_cancel_monoid (finset Type))) : regular_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_180277 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : path_connected_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180278 (h0 : ring (complete_distrib_lattice (finset (ring (ring Type))))) : strong_rank_condition (complete_distrib_lattice (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_180279 (h0 : not (filter (with_bot unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_180280 (h0 : ring (has_nndist (has_nndist name))) : rank_condition (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_180281 (h0 : list (has_nndist (has_nndist pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_180282 (h0 : add_group (has_compl (normed_group char))) : is_add_cyclic (has_compl (normed_group char)) := sorry --non-trivial
lemma new_lemma_180283 (h0 : function.extfun Type (functor.comp topological_space ring)) : @t1_space.{0} (ring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_180284 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring (semiring num)))))) : discrete_topology (left_cancel_monoid (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_180285 (h0 : topological_space (with_bot (has_norm linarith.comp))) : locally_compact_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_180286 (h0 : complete_lattice (normed_group (has_top (random_gen (has_ssubset char))))) : is_compactly_generated (normed_group (has_top (random_gen (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_180287 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) (ring (has_neg Type))) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_180288 (h0 : not (has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_180289 (h0 : group (generalized_boolean_algebra real)) : group.fg (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_180290 (h0 : topological_space (monoid (option ennreal))) : normal_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_180291 (h0 : group (left_cancel_semigroup num)) : group.fg (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_180292 (h0 : topological_space ereal) (h1 : set ereal) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_180293 (h0 : functor.add_const (list (has_Inf linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180294 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid num)) := sorry --non-trivial
lemma new_lemma_180295 (h0 : functor.add_const (topological_space (finset Type)) pos) : @regular_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_180296 (h0 : topological_space (boolean_algebra (has_to_string (has_neg_part (has_add unsigned))))) : totally_separated_space (boolean_algebra (has_to_string (has_neg_part (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_180297 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : @locally_compact_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_180298 (h0 : group (has_zero linarith.comp)) : is_cyclic (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_180299 (h0 : group (normed_comm_ring (finset Type))) : group.fg (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_180300 (h0 : complete_lattice (has_neg_part (cancel_monoid (option ennreal)))) : is_compactly_generated (has_neg_part (cancel_monoid (option ennreal))) := sorry --non-trivial
lemma new_lemma_180301 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_180302 (h0 : topological_space (has_nnnorm to_additive.value_type)) : path_connected_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180303 (h0 : list (boolean_algebra (finset (has_neg Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180304 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : path_connected_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180305 (h0 : functor.add_const (semiring (complete_distrib_lattice pos)) (has_add pos)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_180306 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_180307 (h0 : complete_lattice (has_nnnorm (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_compactly_generated (has_nnnorm (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_180308 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} znum (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) znum)  := sorry --non-trivial
lemma new_lemma_180310 (h0 : topological_space (simple_graph (has_add (has_add name)))) : locally_compact_space (simple_graph (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_180311 (h0 : functor.add_const (complete_lattice (has_nndist pos)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_180312 (h0 : list (with_bot (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180313 (h1 : ring (non_unital_non_assoc_semiring reducibility_hints)) : strong_rank_condition (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_180314 (h0 : uniform_space (linear_ordered_add_comm_group char)) : complete_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_180315 (h0 : ring (normed_field (has_nnnorm string.iterator_imp))) : rank_condition (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_180316 (h0 : group (boolean_algebra (has_add (ring linarith.comp)))) : normalizer_condition (boolean_algebra (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_180317 (h0 : topological_space (has_one congr_arg_kind)) : totally_separated_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180318 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf pos))) : is_atomistic (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_180319 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180320 (h0 : semiring (has_neg (option (option (has_neg pos))))) : is_noetherian_ring (has_neg (option (option (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_180321 (h0 : functor.add_const (uniform_space (has_neg Type)) pos) : @separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_180322 (h0 : functor.add_const (add_monoid (semigroup pos)) Type) : @add_monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180323 (h3 : ring (has_append reducibility_hints)) : strong_rank_condition (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_180324 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_180325 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180326 (h0 : group (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : group.fg (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180327 (h1 : topological_space (has_compl (has_inv (has_nnnorm string_imp)))) : totally_disconnected_space (has_compl (has_inv (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_180328 (h0 : uniform_space (with_one (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : complete_space (with_one (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_180329 (h0 : add_group (has_one num)) : is_add_cyclic (has_one num) := sorry --non-trivial
lemma new_lemma_180330 (h0 : ring (canonically_ordered_comm_semiring num)) : strong_rank_condition (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_180331 (h0 : list (has_neg (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_180332 (h0 : ring (add_right_cancel_monoid (semiring empty))) : is_domain (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_180333 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180334 (h0 : has_neg (has_le environment.projection_info)) (h1 : measurable_space (has_le environment.projection_info)) : has_measurable_neg (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_180335 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : totally_disconnected_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180336 (h0 : ring (normed_comm_ring (boolean_algebra environment.implicit_infer_kind))) : strong_rank_condition (normed_comm_ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180337 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_180338 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen string_imp))))) : path_connected_space (has_ssubset (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_180339 (h0 : group (comm_group (finset (finset (finset (finset pos)))))) : is_cyclic (comm_group (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_180340 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_180341 (h0 : not (ring (add_group empty) -> false)) : @strong_rank_condition.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_180342 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (dlist (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180343 (h0 : topological_space (linear_ordered_semiring linarith.ineq)) : path_connected_space (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_180344 (h0 : group (generalized_boolean_algebra (has_pos_part Type))) : normalizer_condition (generalized_boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_180345 (h0 : functor.add_const (topological_space (has_add Type)) (add_cancel_monoid name)) : @preirreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_180346 (h0 : topological_space (random_gen (has_top to_additive.value_type))) : path_connected_space (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_180347 (h0 : functor.add_const (filter pos) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180348 (h0 : ordered_add_comm_monoid (simple_graph (ring linarith.comp))) : archimedean (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_180349 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@id.{2} (function.extfun.{2 1} Type topological_space.{0}) (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0)) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180350 (h0 : not (add_group char -> false)) : @is_add_cyclic.{0} char (@classical.by_contradiction'.{1} (add_group.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_180351 (h0 : complete_lattice (has_bot (option empty))) : complete_lattice.is_Sup_finite_compact (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_180352 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_180353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_180354 (h2 : add_group (semi_normed_comm_ring string_imp)) : is_add_cyclic (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_180355 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_180356 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_180357 (h1 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h1) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_180358 (h0 : group (add_comm_monoid (has_neg (ring (comm_group Type))))) : normalizer_condition (add_comm_monoid (has_neg (ring (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_180359 (h0 : ring (ring ennreal)) : is_domain (ring ennreal) := sorry --non-trivial
lemma new_lemma_180360 (h0 : uniform_space (ring (has_add (has_add linarith.comp)))) : complete_space (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_180361 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_180362 (h0 : add_monoid (has_to_string linarith.comp)) : add_monoid.fg (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_180363 (h0 : complete_lattice (with_bot (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180364 (h1 : ring (metric_space (random_gen string_imp))) : strong_rank_condition (metric_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_180365 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @totally_separated_space.{0} (comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (option.{0} unsigned) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 (option.{0} unsigned))) (comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_180366 (h0 : topological_space (add_group (linear_ordered_semiring linarith.comp))) : t0_space (add_group (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_180367 (h0 : group (with_one (semiring congr_arg_kind))) : is_cyclic (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180368 (h0 : monoid (semiring fun_info)) : monoid.fg (semiring fun_info) := sorry --non-trivial
lemma new_lemma_180369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180370 (h1 : monoid (measurable_space linarith.comp_source)) : monoid.fg (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180371 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (comm_group unsigned))) : unique_factorization_monoid (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_180372 (h0 : not (ring (semiring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_180373 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_180374 (h3 : not (topological_space (has_norm num) -> false)) : @totally_separated_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h3)  := sorry --non-trivial
lemma new_lemma_180375 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @normalizer_condition.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_180376 (h0 : functor.add_const (add_group (add_comm_monoid pos)) (cancel_monoid pos)) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} pos)) (cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_180377 (h0 : functor.add_const (group (linear_order unsigned)) empty) : @group.fg.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_180378 (h0 : complete_lattice (has_emptyc (has_norm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180379 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180380 (h0 : uniform_space (add_comm_semigroup linarith.ineq)) : complete_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_180381 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_180382 (h0 : topological_space (has_Inf (has_bot (has_bot (has_bot (has_Inf linarith.comp)))))) : totally_separated_space (has_Inf (has_bot (has_bot (has_bot (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_180383 (h0 : topological_space (semi_normed_ring (mul_one_class (free_add_monoid linarith.ineq)))) : t0_space (semi_normed_ring (mul_one_class (free_add_monoid linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180384 (h0 : topological_space (has_bot congr_arg_kind)) : loc_path_connected_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180385 (h0 : function.extfun nat fin) : @rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@matrix.vec_empty.{1} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) ring.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180386 (h4 : group (has_lt to_additive.value_type)) : is_cyclic (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180387 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180388 (h0 : topological_space (has_to_string (has_neg_part Type))) : normal_space (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_180389 (h0 : functor.add_const (list (has_to_string pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180390 (h0 : filter (has_pos_part (finset (finset (finset (finset linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_180391 (h0 : functor.add_const (topological_space (has_to_string ennreal)) unsigned) : @irreducible_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180392 (h0 : uniform_space (has_one (semiring (semiring congr_arg_kind)))) : separated_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_180393 (h0 : topological_space (has_ssubset std_gen)) : totally_disconnected_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_180394 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_180395 (h2 : set (uniform_space (mul_one_class string.iterator_imp))) : set.finite h2 := sorry --non-trivial
lemma new_lemma_180396 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : discrete_topology (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_180397 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string name)) Type) : @archimedean.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_180398 (h0 : fin has_zero.zero) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_180399 (h1 : uniform_space (has_add char)) : complete_space (has_add char) := sorry --non-trivial
lemma new_lemma_180400 (h0 : functor.add_const (finset (has_pos_part pos)) (has_pos_part linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180401 (h0 : topological_space (normed_comm_ring (comm_group name))) : locally_compact_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_180402 (h0 : ring (normed_group (has_inv (has_ssubset (random_gen to_additive.value_type))))) : is_domain (normed_group (has_inv (has_ssubset (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_180403 (h0 : complete_lattice (add_comm_monoid pos)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_180404 (h0 : topological_space (has_norm string_imp)) : t0_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_180405 (h0 : topological_space (semigroup (has_to_string (comm_group pos)))) : t1_space (semigroup (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_180406 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_180407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_180408 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180409 (h0 : topological_space (comm_group ennreal)) : irreducible_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_180410 (h0 : ring (add_group empty)) : strong_rank_condition (add_group empty) := sorry --non-trivial
lemma new_lemma_180411 (h0 : not (ring (has_compl to_additive.value_type) -> false)) : @is_domain.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_180412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_180413 (h0 : functor.add_const (monoid (has_zero pos)) Type) : @monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180414 (h0 : functor.add_const (filter (has_bot unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180415 (h0 : topological_space (canonically_ordered_monoid (has_neg pos))) : totally_separated_space (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_180416 (h0 : semiring (canonically_ordered_comm_semiring (has_neg name))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_180417 (h1 : topological_space (id (random_gen (random_gen (random_gen (random_gen string_imp)))))) : t0_space (id (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_180418 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid real)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_180419 (h0 : add_group (has_Inf linarith.comp)) : is_add_cyclic (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_180420 (h0 : semiring (ordered_comm_ring (has_add name))) : is_noetherian_ring (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_180421 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_180422 (h0 : topological_space (with_bot (random_gen string_imp))) : path_connected_space (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_180423 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_180424 (h0 : topological_space (has_nndist (boolean_algebra (has_add linarith.comp)))) : locally_compact_space (has_nndist (boolean_algebra (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_180425 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_180426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_180427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180428 (h0 : topological_space (semigroup linarith.comp)) : t1_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_180429 (h0 : has_to_string linarith.comp -> has_to_string linarith.comp -> has_to_string linarith.comp) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_180430 (h1 : complete_lattice num) : is_compactly_generated num := sorry --non-trivial
lemma new_lemma_180431 (h0 : group (has_to_string (has_neg_part Type))) : is_cyclic (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_180432 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180433 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : totally_disconnected_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_180434 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_180435 (h0 : topological_space (complete_distrib_lattice (finset pos))) : discrete_topology (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_180436 (h0 : complete_lattice (measurable_space (with_bot (with_bot string_imp)))) : complete_lattice.is_Sup_finite_compact (measurable_space (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_180437 (h0 : topological_space (has_compl char)) : totally_disconnected_space (has_compl char) := sorry --non-trivial
lemma new_lemma_180438 (h0 : complete_lattice (has_neg_part (has_add pos))) : is_atomistic (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_180439 (h0 : ring (mul_zero_class (has_add Type))) : strong_rank_condition (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_180440 (h0 : topological_space (has_star (option empty))) : topological_space.separable_space (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_180441 (h0 : topological_space (distrib (has_nnnorm (random_gen linarith.ineq)))) : path_connected_space (distrib (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180442 (h0 : add_group (has_dist num)) : is_add_cyclic (has_dist num) := sorry --non-trivial
lemma new_lemma_180443 (h0 : group (add_cancel_monoid empty)) : is_cyclic (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_180444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180445 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_180446 (h0 : group (has_one (linear_ordered_semiring unsigned))) : group.fg (has_one (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_180447 (h0 : functor.add_const (group (semigroup Type)) linarith.comp) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180448 (h1 : ring (normed_field (mul_one_class char))) : strong_rank_condition (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_180449 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180450 (h0 : topological_space (linear_ordered_semiring (has_top fun_info))) : path_connected_space (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_180451 (h0 : semiring (has_add (sub_neg_monoid real))) : is_noetherian_ring (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_180452 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_180453 (h0 : functor.add_const (add_monoid (has_Sup empty)) empty) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_180454 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_180455 (h0 : topological_space (canonically_linear_ordered_monoid empty)) : loc_path_connected_space (canonically_linear_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_180456 (h0 : not (uniform_space reducibility_hints -> false)) : set.finite (is_compl (classical.by_contradiction' h0)) := sorry --non-trivial
lemma new_lemma_180457 (h0 : filter (normed_comm_ring Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_180458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180459 (h0 : functor.add_const (ring (comm_group Type)) Type) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_180460 (h0 : monoid (ordered_comm_ring (has_Inf linarith.comp))) : monoid.fg (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_180461 (h0 : topological_space (sub_neg_monoid real)) : t1_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_180462 (h0 : ordered_add_comm_monoid (linear_order congr_arg_kind)) : archimedean (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180463 (h0 : group (has_norm string_imp)) : normalizer_condition (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_180464 (h0 : group (comm_ring (random_gen (random_gen (comm_ring linarith.comp_source))))) : is_cyclic (comm_ring (random_gen (random_gen (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_180465 (h0 : not (complete_lattice (simple_graph char) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_180466 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add (has_pos_part pos)))))) : irreducible_space (boolean_algebra (has_add (has_add (has_add (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_180467 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_180468 (h0 : monoid (has_neg ennreal)) : monoid.fg (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_180469 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : path_connected_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_180470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180471 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180472 (h0 : group (non_assoc_semiring (has_norm congr_arg_kind))) : normalizer_condition (non_assoc_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180473 (h0 : functor.add_const (add_monoid (comm_group linarith.comp)) (has_neg name)) : @add_monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_180474 (h0 : monoid (linear_ordered_comm_group (option (option ennreal)))) : monoid.fg (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_180475 (h0 : ring (has_union (has_top (has_top num)))) : is_principal_ideal_ring (has_union (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_180476 (h0 : topological_space (add_cancel_monoid name)) : preconnected_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_180477 (h1 : topological_space (complete_semilattice_Sup linarith.comp)) : discrete_topology (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_180478 (h0 : topological_space (omega_complete_partial_order unsigned)) : discrete_topology (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_180479 (h0 : topological_space (add_cancel_monoid (has_to_string (has_add (has_neg pos))))) : path_connected_space (add_cancel_monoid (has_to_string (has_add (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_180480 (h0 : monoid (has_to_string (has_add (has_add pos)))) : monoid.fg (has_to_string (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_180481 (h0 : has_coe (mul_one_class (add_comm_semigroup (add_comm_semigroup fun_info))) Prop) (h1 : mul_one_class (add_comm_semigroup (add_comm_semigroup fun_info))) : @coe_b.{1 1} (mul_one_class.{0} (add_comm_semigroup.{0} (add_comm_semigroup.{0} fun_info))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_180482 (h0 : not (complete_lattice (add_monoid fun_info) -> false)) : @is_compactly_generated.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_180483 (h1 : group (with_one (random_gen to_additive.value_type))) : group.fg (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_180484 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_180485 (h0 : functor.add_const (ordered_comm_monoid (has_Inf Type)) (has_add name)) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_Inf.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_180486 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180487 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180488 (h0 : ring (comm_ring to_additive.value_type)) : is_domain (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180489 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_180490 (h0 : not (ring (topological_space linarith.comp_source) -> false)) : @is_domain.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_180491 (h0 : filter (add_monoid linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180492 (h0 : filter congr_arg_kind) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180493 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_180494 (h0 : set (add_comm_semigroup (normed_field char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_180495 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_180496 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_180497 (h0 : topological_space (has_top (has_norm (has_norm linarith.ineq)))) : t0_space (has_top (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180498 (h0 : add_group (has_Sup (option (semiring (option empty))))) : is_add_cyclic (has_Sup (option (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_180499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_180500 (h0 : semiring (canonically_linear_ordered_monoid (has_add linarith.comp))) : is_noetherian_ring (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_180501 (h0 : functor.add_const (list (ring Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180502 (h0 : ring (canonically_linear_ordered_monoid real)) : rank_condition (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_180503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_180504 (h0 : topological_space (has_neg_part (comm_group unsigned))) : totally_disconnected_space (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_180505 (h0 : topological_space (finset ennreal)) : preirreducible_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_180506 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_180507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_180508 (h0 : topological_space (boolean_algebra real)) : locally_compact_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_180509 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_add Type))) : unique_factorization_monoid (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_180510 (h0 : semiring (mul_zero_class unsigned)) : is_noetherian_ring (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_180511 (h0 : set (boolean_algebra.core string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_180512 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @t1_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180513 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_180514 (h0 : functor.comp list ring name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_180515 (h0 : functor.add_const (ring (bin_tree empty)) empty) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_180516 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180517 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180518 (h0 : topological_space (add_cancel_monoid (has_add name))) : locally_compact_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_180519 (h1 : topological_space (has_append char)) : t0_space (has_append char) := sorry --non-trivial
lemma new_lemma_180520 (h0 : functor.add_const (group (comm_group name)) name) : @group.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180521 (h0 : functor.add_const (ring (add_cancel_monoid Type)) pos) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_180522 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180523 (h0 : functor.comp topological_space has_zero name) : @totally_disconnected_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_180524 (h0 : list (ring pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_180525 (h0 : semiring (ordered_comm_monoid (finset pos))) : is_noetherian_ring (ordered_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_180526 (h0 : not (has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc -> false)) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_180527 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180528 (h0 : functor.add_const (finset (ordered_ring unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180529 (h0 : ring (canonically_ordered_monoid pos)) : rank_condition (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_180530 (h0 : topological_space (semi_normed_ring to_additive.value_type)) : t0_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180531 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180532 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @preirreducible_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_180533 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180534 (h0 : add_group (add_group num)) : is_add_cyclic (add_group num) := sorry --non-trivial
lemma new_lemma_180535 (h1 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_180536 (h0 : nat) (h1 : vector Prop h0) (h2 : fin h0) : vector.nth h1 h2 := sorry --non-trivial
lemma new_lemma_180537 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (canonically_linear_ordered_monoid linarith.comp)))) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_180538 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180539 (h0 : ring (has_nndist (finset (has_nndist environment.implicit_infer_kind)))) : is_domain (has_nndist (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_180540 (h0 : topological_space (has_zero (boolean_algebra (boolean_algebra.core linarith.comp)))) : irreducible_space (has_zero (boolean_algebra (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_180541 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180542 (h0 : functor.comp list mul_zero_class Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_180543 (h0 : not (uniform_space (semiring linarith.comp) -> false)) : @complete_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_180544 (h0 : finset (canonically_ordered_comm_semiring (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180545 (h0 : functor.add_const (function.extfun Type finset) unsigned) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (as_linear_order empty)) := sorry --non-trivial
lemma new_lemma_180546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_180547 (h0 : topological_space (has_bot name)) : t0_space (has_bot name) := sorry --non-trivial
lemma new_lemma_180548 (h0 : group (semiring (has_top congr_arg_kind))) : is_cyclic (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180549 (h0 : uniform_space (semigroup (ring (has_add linarith.comp)))) : separated_space (semigroup (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_180550 (h0 : complete_lattice (has_norm (has_top linarith.comp_source))) : is_atomistic (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180551 (h0 : functor.comp group has_to_string environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} group.{0} has_to_string.{0} environment.implicit_infer_kind) Type (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} environment.implicit_infer_kind h0)))  := sorry --non-trivial
lemma new_lemma_180552 (h1 : ring (topological_space (has_lt linarith.ineq))) : rank_condition (topological_space (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180553 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_180554 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @strong_rank_condition.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_180555 (h0 : functor.add_const (ring (ring pos)) pos) : @strong_rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_180556 (h0 : function.extfun Type ring) : @is_domain.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180557 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_180558 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_180559 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_180560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_180561 (h0 : not (topological_space (uniform_space (mul_one_class enat)) -> false)) : @t0_space.{0} (uniform_space.{0} (mul_one_class.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_180562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180563 (h0 : uniform_space (has_Inf (has_Inf (has_Inf Type)))) : separated_space (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_180564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_comm_group pos)) := sorry --non-trivial
lemma new_lemma_180565 (h0 : not (topological_space (with_one linarith.ineq) -> false)) : @irreducible_space.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_180566 (h0 : group (random_gen (has_nnnorm (has_lt char)))) : is_cyclic (random_gen (has_nnnorm (has_lt char))) := sorry --non-trivial
lemma new_lemma_180567 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_180568 (h0 : topological_space (mul_zero_class (has_to_string (has_add Type)))) : irreducible_space (mul_zero_class (has_to_string (has_add Type))) := sorry --non-trivial
lemma new_lemma_180569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_180570 (h0 : topological_space (id linarith.ineq)) : totally_separated_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_180571 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_180572 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180573 (h0 : ring (mul_one_class std_gen)) : is_field (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_180574 (h0 : ring (mul_one_class (add_comm_semigroup enat))) : strong_rank_condition (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_180575 (h0 : topological_space (simple_graph (has_add (has_pos_part linarith.comp)))) : totally_disconnected_space (simple_graph (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_180576 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180577 (h0 : group (ordered_comm_monoid linarith.comp)) : group.fg (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_180578 (h0 : ring (has_to_string (comm_group name))) : strong_rank_condition (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_180579 (h0 : complete_lattice (has_compl (random_gen (random_gen char)))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_180580 (h0 : group (has_norm (comm_ring (has_top fun_info)))) : group.fg (has_norm (comm_ring (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_180581 (h1 : not (ring (uniform_space linarith.ineq) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_180582 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180583 (h0 : group (boolean_algebra linarith.comp)) : is_simple_group (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_180584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180585 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180586 (h0 : add_group (comm_ring (random_gen linarith.ineq))) : is_add_cyclic (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180587 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180588 (h0 : not (topological_space (random_gen num) -> false)) : @normal_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180589 (h0 : monoid (as_linear_order unsigned)) : monoid.fg (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_180590 (h0 : topological_space (has_Inf (has_neg Type))) : preconnected_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_180591 (h2 : not (complete_lattice num -> false)) : @is_compactly_generated.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h2)  := sorry --non-trivial
lemma new_lemma_180592 (h0 : functor.comp topological_space add_comm_monoid Type) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_180593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_180594 (h0 : complete_lattice (semigroup (boolean_algebra name))) : complete_lattice.is_Sup_finite_compact (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_180595 (h0 : not (ring (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_180596 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180597 (h0 : add_group (random_gen (has_norm fun_info))) : is_add_cyclic (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_180598 (h0 : uniform_space (ordered_comm_monoid name)) : complete_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_180599 (h0 : topological_space (random_gen congr_arg_kind)) : totally_separated_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180600 (h0 : not (ordered_add_comm_monoid (add_group unsigned) -> false)) : @archimedean.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (ordered_add_comm_monoid.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180601 (h0 : group (random_gen (comm_ring to_additive.value_type))) : group.fg (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_180602 (h0 : complete_lattice (has_zero (boolean_algebra name))) : is_compactly_generated (has_zero (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_180603 (h0 : ordered_comm_monoid (ordered_comm_ring pos)) : has_exists_mul_of_le (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_180604 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_180605 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180606 (h0 : topological_space (has_zero (has_neg (finset (finset (finset (finset linarith.comp))))))) : totally_disconnected_space (has_zero (has_neg (finset (finset (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_180607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_180608 (h0 : finset (has_nndist (has_add unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180609 (h0 : list (add_semigroup unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_180610 (h0 : functor.add_const (list (has_Inf pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180611 (h0 : functor.add_const (filter (has_nndist name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180612 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_180613 (h0 : boolean_algebra.core (option (option ennreal)) -> boolean_algebra.core (option (option ennreal)) -> Prop) : is_symm (boolean_algebra.core (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_180614 (h0 : topological_space (comm_group (canonically_ordered_comm_semiring pos))) : irreducible_space (comm_group (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_180615 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add name)) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} name) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_180616 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180617 (h0 : functor.add_const (finset (add_cancel_monoid Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180618 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180619 (h0 : list (has_add (has_Inf Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180620 (h1 : ring (uniform_space (has_dist string_imp))) : rank_condition (uniform_space (has_dist string_imp)) := sorry --non-trivial
lemma new_lemma_180621 (h0 : topological_space (boolean_algebra.core (finset linarith.comp))) : regular_space (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_180622 (h0 : uniform_space (has_Sup (option (option (option empty))))) : separated_space (has_Sup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_180623 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) name) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_180624 (h0 : functor.add_const (semiring (finset Type)) pos) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_180625 (h1 : not (filter (comm_ring char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_180626 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @totally_separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_180627 (h0 : not (topological_space (mul_zero_class num) -> false)) : @t0_space.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180628 (h0 : ring (cancel_monoid (normed_comm_ring (normed_comm_ring Type)))) : is_principal_ideal_ring (cancel_monoid (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_180629 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180630 (h0 : topological_space (free_add_monoid num)) : totally_separated_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_180631 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (ring Type)) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180632 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180633 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_180634 (h0 : functor.add_const (group (ring pos)) Type) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180635 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : path_connected_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_180636 (h0 : ring (has_nnnorm (has_nnnorm (random_gen reducibility_hints)))) : strong_rank_condition (has_nnnorm (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_180637 (h0 : not (group (measure_theory.measure_space unsigned) -> false)) : @normalizer_condition.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180638 (h0 : fin has_zero.zero) : @t0_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_180639 (h0 : finset (has_zero (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180640 (h0 : functor.add_const (group (as_linear_order empty)) num) : @is_cyclic.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_180641 (h0 : function.extfun nat fin) : @is_simple_group.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_180642 (h0 : function.extfun Type (functor.add_const (list Type))) : palindrome (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_180643 (h0 : functor.add_const (monoid (has_add linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180644 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_180645 (h0 : topological_space (plift num)) : t0_space (plift num) := sorry --non-trivial
lemma new_lemma_180646 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_180647 (h0 : group (pseudo_metric_space (option (option empty)))) : normalizer_condition (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_180648 (h0 : add_group (uniform_space (random_gen (metric_space char)))) : is_add_cyclic (uniform_space (random_gen (metric_space char))) := sorry --non-trivial
lemma new_lemma_180649 (h0 : topological_space (has_neg_part (option name))) : totally_separated_space (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_180650 (h0 : complete_lattice (semiring (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180651 (h0 : not (topological_space (id num) -> false)) : @path_connected_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_180652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_180653 (h0 : add_group (has_union (has_norm empty))) : is_add_cyclic (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_180654 (h0 : functor.add_const (topological_space (finset name)) name) : @loc_path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180655 (h0 : topological_space (add_cancel_monoid (option (finset pos)))) : sequential_space (add_cancel_monoid (option (finset pos))) := sorry --non-trivial
lemma new_lemma_180656 (h0 : not (add_group (has_one unsigned) -> false)) : @is_add_cyclic.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180657 (h2 : ring empty) : is_domain empty := sorry --non-trivial
lemma new_lemma_180658 (h0 : functor.add_const (topological_space (has_zero Type)) (finset environment.implicit_infer_kind)) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_180659 (h0 : group (canonically_ordered_monoid (has_Inf pos))) : is_cyclic (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_180660 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @locally_compact_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_180661 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @loc_path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_180662 (h0 : add_monoid (has_zero (ring (ring pos)))) : add_monoid.fg (has_zero (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_180663 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180664 (h0 : filter (plift (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180665 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : t0_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180666 (h0 : topological_space (has_add (has_add (has_add Type)))) : totally_disconnected_space (has_add (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_180667 (h0 : ring (with_bot (has_norm (has_norm linarith.ineq)))) : rank_condition (with_bot (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180668 (h2 : complete_lattice fun_info) : complete_lattice.is_Sup_finite_compact fun_info := sorry --non-trivial
lemma new_lemma_180669 (h0 : topological_space (linear_ordered_field name)) : t0_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_180670 (h0 : ring (complete_lattice linarith.comp_source)) : rank_condition (complete_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180671 (h0 : not (topological_space (plift unsigned) -> false)) : @locally_compact_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_180672 (h0 : functor.add_const (topological_space (complete_linear_order empty)) num) : @normal_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_180673 (h0 : ring (metric_space reducibility_hints)) : is_domain (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_180674 (h0 : topological_space (semiring (metric_space empty))) : preirreducible_space (semiring (metric_space empty)) := sorry --non-trivial
lemma new_lemma_180675 (h0 : topological_space (has_nndist (finset (has_to_string pos)))) : topological_space.separable_space (has_nndist (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_180676 (h0 : group (div_inv_monoid linarith.comp_source)) : is_cyclic (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180677 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : path_connected_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_180678 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (ring pos))) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (ring.{0} pos)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180679 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180680 (h1 : complete_lattice (encodable (has_inv linarith.ineq))) : is_compactly_generated (encodable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180681 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_180682 (h0 : filter (semiring (random_gen num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180683 (h0 : topological_space (generalized_boolean_algebra name)) : t1_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_180684 (h0 : topological_space (ring (comm_group Type))) : regular_space (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_180685 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_180686 (h0 : order_hom nat (topological_space (has_top to_additive.value_type))) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@monotonic_sequence_limit.{0} (topological_space.{0} (has_top.{0} to_additive.value_type)) (@topological_space.partial_order.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_180687 (h0 : not (monoid (bin_tree congr_arg_kind) -> false)) : @monoid.fg.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_180688 (h0 : semiring (normed_comm_ring num)) : is_noetherian_ring (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_180689 (h0 : functor.add_const (topological_space (has_add name)) (has_zero Type)) : @irreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180690 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup enat))) : path_connected_space (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_180691 (h0 : functor.add_const (functor.add_const (group pos) pos) unsigned) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) pos) unsigned h0))  := sorry --non-trivial
lemma new_lemma_180692 (h0 : monoid (random_gen (has_norm empty))) : monoid.fg (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_180693 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) name) : @is_atomistic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_180694 (h0 : complete_lattice (comm_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180695 (h0 : ring (has_Inf (has_Inf Type))) : is_principal_ideal_ring (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_180696 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_180697 (h0 : complete_lattice (option (ordered_cancel_comm_monoid (ordered_cancel_comm_monoid num)))) : is_atomistic (option (ordered_cancel_comm_monoid (ordered_cancel_comm_monoid num))) := sorry --non-trivial
lemma new_lemma_180698 (h0 : functor.comp ring add_comm_monoid environment.implicit_infer_kind) : @is_domain.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180699 (h0 : to_additive.value_type -> uniform_space (random_gen char)) : @complete_space.{0} (random_gen.{0} char) (@infi.{0 1} (uniform_space.{0} (random_gen.{0} char)) (@uniform_space.has_Inf.{0} (random_gen.{0} char)) to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_180700 (h0 : list (pseudo_metric_space (option num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180701 (h0 : topological_space (has_inv (has_top fun_info))) : locally_compact_space (has_inv (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_180702 (h0 : add_monoid (has_to_string (has_neg (semigroup (has_neg environment.implicit_infer_kind))))) : add_monoid.fg (has_to_string (has_neg (semigroup (has_neg environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_180703 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180704 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_add_group.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_180705 (h0 : topological_space (dlist (has_inv fun_info))) : path_connected_space (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_180706 (h0 : ring (has_nndist empty)) : rank_condition (has_nndist empty) := sorry --non-trivial
lemma new_lemma_180707 (h0 : group (comm_group (has_neg environment.implicit_infer_kind))) : is_simple_group (comm_group (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180708 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) Type) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_180709 (h0 : functor.add_const (ring (comm_group name)) linarith.comp) : @is_domain.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180710 (h0 : functor.add_const (group auto.case_option) congr_arg_kind) : @is_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_180711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_180712 (h0 : functor.add_const (group (semigroup pos)) unsigned) : @normalizer_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180713 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_180714 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_180715 (h0 : add_group (has_bot (has_Inf linarith.comp))) : is_add_cyclic (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_180716 (h0 : semiring (complete_distrib_lattice (option unsigned))) : is_noetherian_ring (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_180717 (h0 : ring (simple_graph (ring Type))) : strong_rank_condition (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_180718 (h0 : topological_space (comm_ring (has_inv string_imp))) : totally_disconnected_space (comm_ring (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_180719 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_neg pos)) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_180720 (h3 : uniform_space (random_gen to_additive.value_type)) : complete_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180721 (h0 : not (ring (comm_ring reducibility_hints) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_180722 (h0 : functor.add_const (uniform_space (cancel_monoid name)) name) : @complete_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180723 (h0 : monoid (has_neg (ring (ring (ring linarith.comp))))) : monoid.fg (has_neg (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_180724 (h0 : not (ring (mul_one_class linarith.ineq) -> false)) : @strong_rank_condition.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_180725 (h0 : complete_lattice (id (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180726 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180727 (h0 : functor.add_const (uniform_space (comm_group name)) name) : @separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180728 (h0 : functor.add_const (list (has_nndist unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180729 (h0 : has_nnnorm fun_info) (h1 : sym2 (has_nnnorm fun_info)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_180730 (h0 : topological_space (comm_semigroup (ordered_comm_monoid linarith.comp))) : normal_space (comm_semigroup (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_180731 (h0 : topological_space (normed_comm_ring (add_comm_monoid Type))) : t1_space (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_180732 (h0 : functor.add_const (group (complete_distrib_lattice Type)) name) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_180733 (h0 : complete_lattice (sub_neg_monoid (ring Type))) : is_compactly_generated (sub_neg_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_180734 (h0 : has_nndist num -> has_nndist num -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_180735 (h0 : topological_space (has_nndist (left_cancel_monoid unsigned))) : preirreducible_space (has_nndist (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_180736 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_180737 (h0 : topological_space (has_top congr_arg_kind)) : locally_compact_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180738 (h0 : topological_space (has_pos_part (has_neg Type))) : sequential_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_180739 (h0 : not (ring (conditionally_complete_linear_order num) -> false)) : @is_principal_ideal_ring.{0} (conditionally_complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (conditionally_complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180740 (h0 : functor.add_const (uniform_space (has_add name)) unsigned) : @complete_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180741 (h0 : not (uniform_space (comm_ring reducibility_hints) -> false)) : @complete_space.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_180742 (h0 : functor.add_const (ring (non_assoc_semiring empty)) (option (option empty))) : @rank_condition.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_180743 (h0 : topological_space (has_add (option (canonically_ordered_comm_semiring name)))) : preirreducible_space (has_add (option (canonically_ordered_comm_semiring name))) := sorry --non-trivial
lemma new_lemma_180744 (h0 : ordered_comm_monoid (has_pos_part (has_pos_part pos))) : has_exists_mul_of_le (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_180745 (h0 : topological_space (has_ssubset (mul_one_class fun_info))) : path_connected_space (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_180746 (h0 : functor.add_const (monoid (ordered_comm_monoid name)) Type) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (ordered_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_180747 (h0 : group (boolean_algebra (has_add (has_add Type)))) : is_cyclic (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_180748 (h0 : topological_space (has_to_string (has_to_string num))) : discrete_topology (has_to_string (has_to_string num)) := sorry --non-trivial
lemma new_lemma_180749 (h0 : complete_lattice (with_bot (semiring unsigned))) : is_atomistic (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_180750 (h0 : has_mem.mem ring has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_180751 (h0 : not (ring (has_compl (mul_one_class (mul_one_class linarith.comp_source))) -> false)) : @strong_rank_condition.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_180752 (h0 : function.extfun Type (functor.add_const (ring (normed_linear_ordered_group num)))) : @rank_condition.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_180753 (h0 : not (ring (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_180754 (h0 : topological_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind))) : preconnected_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180755 (h0 : topological_space (add_monoid (has_nnnorm linarith.comp_source))) : t0_space (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180756 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : loc_path_connected_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180757 (h0 : complete_lattice (with_one (has_norm (semiring (has_norm (semiring fun_info)))))) : is_atomistic (with_one (has_norm (semiring (has_norm (semiring fun_info))))) := sorry --non-trivial
lemma new_lemma_180758 (h0 : functor.add_const (topological_space (has_dist num)) num) : @locally_compact_space.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_180759 (h0 : ring (pseudo_metric_space (option (option (option ennreal))))) : rank_condition (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_180760 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option ennreal)))) : preirreducible_space (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_180761 (h0 : topological_space (has_top linarith.comp)) : discrete_topology (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_180762 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180763 (h0 : semiring (has_sub unsigned)) : is_noetherian_ring (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_180764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} nnreal)) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ring.{0} nnreal))) empty))  := sorry --non-trivial
lemma new_lemma_180765 (h0 : topological_space (boolean_algebra.core (has_add (has_neg Type)))) : t1_space (boolean_algebra.core (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_180766 (h0 : functor.add_const (group (semigroup pos)) (has_neg environment.implicit_infer_kind)) : @is_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_180767 (h1 : ring (with_zero linarith.ineq)) : rank_condition (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_180768 (h0 : functor.comp ring has_add Type) : @is_domain.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_180769 (h0 : group (boolean_algebra.core (has_neg_part environment.implicit_infer_kind))) : is_cyclic (boolean_algebra.core (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_180770 (h3 : set (add_comm_semigroup char)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_180771 (h0 : ring (semi_normed_comm_ring to_additive.value_type)) : strong_rank_condition (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_180772 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_180774 (h1 : topological_space (nondiscrete_normed_field environment.projection_info)) (h2 : add_group (nondiscrete_normed_field environment.projection_info)) : topological_add_group (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_180775 (h0 : functor.add_const (list (add_cancel_monoid name)) (has_add Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180776 (h0 : add_group (comm_group (has_add (has_add Type)))) : is_add_cyclic (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_180777 (h0 : not (filter (semi_normed_ring char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_180778 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180779 (h0 : filter (add_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180780 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_180781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180782 (h0 : semiring (as_linear_order (complete_distrib_lattice num))) : is_noetherian_ring (as_linear_order (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_180783 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180784 (h0 : group (comm_ring (has_top (random_gen char)))) : group.fg (comm_ring (has_top (random_gen char))) := sorry --non-trivial
lemma new_lemma_180785 (h0 : ring (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : rank_condition (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_180786 (h0 : functor.add_const (group (boolean_algebra.core linarith.comp)) Type) : @normalizer_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_180787 (h0 : complete_lattice (measurable_space num)) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_180788 (h0 : complete_lattice (complete_semilattice_Sup (has_inv (has_inv linarith.comp_source)))) : is_compactly_generated (complete_semilattice_Sup (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_180789 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option pos)))) : complete_space (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_180790 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_180791 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : path_connected_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_180793 (h1 : set (has_nnnorm ereal)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_180794 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_180795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180796 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_180797 (h0 : ulower pnat) (h1 : pnat) : pnat.coprime (ulower.up h0) (id h1) := sorry --non-trivial
lemma new_lemma_180798 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_180799 (h0 : list (has_zero (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180800 (h0 : ordered_comm_monoid (has_to_string pos)) : has_exists_mul_of_le (has_to_string pos) := sorry --non-trivial
lemma new_lemma_180801 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring unsigned)))) : @totally_disconnected_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180802 (h0 : not (topological_space (has_sub linarith.comp) -> false)) : @discrete_topology.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_180803 (h0 : function.extfun Type group) : @group.fg.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180804 (h0 : functor.add_const (semiring (option empty)) empty) : @is_noetherian_ring.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_180805 (h1 : uniform_space (simple_graph ereal)) : complete_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_180806 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) name) : @is_compactly_generated.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_180807 (h0 : topological_space (measurable_space (has_union (semiring linarith.comp)))) : irreducible_space (measurable_space (has_union (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_180808 (h0 : complete_lattice (group_with_zero (option ennreal))) : is_atomistic (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_180809 (h0 : ordered_comm_monoid (has_Inf pos) -> ordered_comm_monoid (has_Inf pos) -> Prop) : is_extensional (ordered_comm_monoid (has_Inf pos)) h0 := sorry --non-trivial
lemma new_lemma_180810 (h0 : topological_space (finset name)) : totally_separated_space (finset name) := sorry --non-trivial
lemma new_lemma_180811 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_180812 (h0 : group (has_top linarith.comp)) : is_cyclic (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_180813 (h0 : topological_space (has_top (random_gen (semiring unsigned)))) : totally_separated_space (has_top (random_gen (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_180814 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_180815 (h0 : function.extfun Type topological_space) : @regular_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180816 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @normal_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_180817 (h0 : set (has_ssubset (mul_one_class ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_180818 (h0 : complete_lattice (has_nnnorm (random_gen linarith.comp_source))) : is_compactly_generated (has_nnnorm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180819 (h0 : topological_space (add_cancel_monoid (ordered_ring Type))) : locally_compact_space (add_cancel_monoid (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_180820 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @t1_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180822 (h0 : group (ring (finset pos))) : normalizer_condition (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_180823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_180824 (h0 : functor.add_const (topological_space (plift empty)) empty) : @locally_compact_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_180825 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_180826 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_180827 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180828 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @irreducible_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_180829 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring Type)) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180830 (h0 : add_monoid (has_nndist (finset (has_neg (finset pos))))) : add_monoid.fg (has_nndist (finset (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_180831 (h0 : fin has_zero.zero) : @separated_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_180832 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180833 (h1 : topological_space (topological_space (random_gen (random_gen (random_gen char))))) : t0_space (topological_space (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_180834 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid pos)) : has_exists_mul_of_le (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_180835 (h0 : topological_space (add_monoid fun_info)) : path_connected_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_180836 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : regular_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_180837 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring name)) name) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_180838 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180839 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180840 (h0 : ring (mul_zero_class unsigned)) : is_domain (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_180841 (h0 : topological_space (add_group (has_norm empty))) : preirreducible_space (add_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_180842 (h0 : topological_space (sub_neg_monoid (has_Inf (has_neg pos)))) : totally_disconnected_space (sub_neg_monoid (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_180843 (h0 : functor.add_const (ring (has_nndist pos)) Type) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_180844 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_180845 (h0 : group (denumerable (has_nnnorm linarith.ineq))) : is_cyclic (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180846 (h0 : topological_space (has_zero (has_neg_part name))) : t0_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_180847 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_180848 (h0 : topological_space (has_nndist (has_to_string (has_to_string (has_to_string name))))) : path_connected_space (has_nndist (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_180849 (h0 : function.extfun Type group) : @is_simple_group.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_180850 (h0 : not (topological_space (measurable_space linarith.comp_source) -> false)) : @t0_space.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_180851 (h0 : set (add_comm_semigroup ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_180852 (h0 : group (linear_ordered_add_comm_group (has_top linarith.comp_source))) : group.fg (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180853 (h0 : has_top congr_arg_kind -> has_top congr_arg_kind -> Prop) : is_refl (has_top congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_180854 (h0 : ring (add_group empty)) : is_principal_ideal_ring (add_group empty) := sorry --non-trivial
lemma new_lemma_180855 (h0 : function.extfun Type (functor.comp list has_to_string)) : palindrome (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_180856 (h2 : ring (normed_field string_imp)) : rank_condition (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_180857 (h0 : complete_lattice (canonically_ordered_comm_semiring congr_arg_kind)) : is_compactly_generated (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180858 (h1 : group (comm_ring string_imp)) : is_cyclic (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_180859 (h0 : topological_space (semigroup linarith.comp)) : locally_compact_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_180860 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_180861 (h0 : semiring (has_top unsigned)) : is_noetherian_ring (has_top unsigned) := sorry --non-trivial
lemma new_lemma_180862 (h0 : functor.add_const (list (has_to_string Type)) (ring (ring (ring Type)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180863 (h0 : add_group (cancel_monoid (add_comm_monoid Type))) : is_add_cyclic (cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_180864 (h0 : add_monoid (has_norm (semiring (metric_space (metric_space linarith.comp))))) : add_monoid.fg (has_norm (semiring (metric_space (metric_space linarith.comp)))) := sorry --non-trivial
lemma new_lemma_180865 (h0 : functor.add_const (complete_lattice (mul_zero_class Type)) environment.implicit_infer_kind) : @is_atomistic.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (mul_zero_class.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180866 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : totally_disconnected_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_180867 (h0 : ring (ordered_comm_monoid real)) : strong_rank_condition (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_180868 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_180869 (h0 : not (monoid (has_union num) -> false)) : @monoid.fg.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_180870 (h0 : functor.add_const (monoid (finset Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_180871 (h0 : complete_lattice (has_compl (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180872 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_180873 (h0 : list (complete_distrib_lattice (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_180874 (h0 : list pnat) (h1 : pnat) : pnat.coprime (list.head h0) h1 := sorry --non-trivial
lemma new_lemma_180875 (h0 : functor.add_const (complete_lattice (normed_comm_ring environment.implicit_infer_kind)) name) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_180876 (h0 : functor.add_const (group (semigroup empty)) empty) : @normalizer_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_180877 (h0 : topological_space (group_with_zero (option (option ennreal)))) : totally_disconnected_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_180878 (h0 : filter (normed_comm_ring (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180879 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_180880 (h0 : topological_space (normed_field (add_cancel_comm_monoid (has_nnnorm linarith.ineq)))) : totally_disconnected_space (normed_field (add_cancel_comm_monoid (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180881 (h0 : functor.add_const (topological_space nnreal) empty) : path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_180882 (h0 : ring (has_inter congr_arg_kind)) : strong_rank_condition (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180883 (h0 : functor.add_const (add_monoid (left_cancel_monoid unsigned)) congr_arg_kind) : @add_monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_180884 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (ring linarith.comp)) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (ring.{0} linarith.comp) h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_180885 (h0 : uniform_space (add_right_cancel_monoid linarith.comp)) : separated_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_180886 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring empty))) : t1_space (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_180887 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_180888 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf name)) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} name) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_180889 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{1} Type (@finset.pi.empty.{2 1} (Type 1) complete_lattice.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_180890 (h0 : complete_lattice (measure_theory.measure_space (has_top empty))) : is_compactly_generated (measure_theory.measure_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_180891 (h0 : topological_space (has_pos_part (sub_neg_monoid (has_Inf real)))) : t1_space (has_pos_part (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_180892 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @add_monoid.fg.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_180893 (h0 : functor.add_const (topological_space (has_neg unsigned)) (ring Type)) : @t1_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_180894 (h0 : functor.add_const (finset (simple_graph pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180895 (h0 : monoid (measurable_space (semiring empty))) : monoid.fg (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_180896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_180897 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_180898 (h0 : ordered_add_comm_monoid (has_Inf (ring pos))) : archimedean (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_180899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_180900 (h0 : topological_space (has_Inf (has_neg Type))) : locally_compact_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_180901 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180902 (h0 : add_group (normed_field (comm_ring (semi_normed_ring linarith.ineq)))) : is_add_cyclic (normed_field (comm_ring (semi_normed_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_180903 (h0 : functor.comp group mul_zero_class unsigned) : @normalizer_condition.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_180904 (h0 : add_group (complete_distrib_lattice Type)) : is_add_cyclic (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_180905 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180906 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) name) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_180907 (h0 : topological_space (pseudo_metric_space unsigned)) : topological_space.separable_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_180908 (h0 : functor.add_const (topological_space (has_add pos)) (has_zero pos)) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_180909 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring (semiring empty)))))) : discrete_topology (linear_ordered_semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_180910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_180911 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_180912 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_180913 (h0 : complete_lattice (has_ssubset (has_ssubset linarith.ineq))) : is_compactly_generated (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_180914 (h0 : topological_space (option (option ennreal))) : t1_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_180915 (h0 : not (add_monoid (add_right_cancel_monoid stieltjes_function) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} stieltjes_function) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_right_cancel_monoid.{0} stieltjes_function)) h0)  := sorry --non-trivial
lemma new_lemma_180916 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180917 (h0 : functor.add_const (filter (semigroup environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_180918 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_180919 (h5 : topological_space (has_div reducibility_hints)) (h6 : preorder (has_div reducibility_hints)) : order_topology (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_180920 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) (has_neg (has_neg (has_neg name)))) : @group.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_neg.{0} (has_neg.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_180921 (h0 : topological_space (add_right_cancel_monoid (semiring (with_bot (with_bot unsigned))))) : totally_separated_space (add_right_cancel_monoid (semiring (with_bot (with_bot unsigned)))) := sorry --non-trivial
lemma new_lemma_180922 (h0 : complete_lattice (non_unital_non_assoc_semiring environment.projection_info)) : is_compactly_generated (non_unital_non_assoc_semiring environment.projection_info) := sorry --non-trivial
lemma new_lemma_180923 (h0 : uniform_space (encodable (random_gen char))) : complete_space (encodable (random_gen char)) := sorry --non-trivial
lemma new_lemma_180924 (h0 : complete_lattice (has_neg_part name)) : is_compactly_generated (has_neg_part name) := sorry --non-trivial
lemma new_lemma_180925 (h0 : ring (with_one linarith.comp_source)) : rank_condition (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180926 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_180927 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} (random_gen.{0} (random_gen.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_180928 (h0 : filter (random_gen linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180929 (h0 : filter (finset unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_180930 (h0 : fin has_zero.zero) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_180931 (h0 : topological_space (boolean_algebra (add_cancel_monoid (boolean_algebra Type)))) : loc_path_connected_space (boolean_algebra (add_cancel_monoid (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_180932 (h0 : list (generalized_boolean_algebra (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_180933 (h0 : filter (comm_group (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_180934 (h0 : ring (topological_space (mul_one_class string_imp))) : is_domain (topological_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_180935 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_180936 (h0 : topological_space (has_bot (has_Inf (has_Inf pos)))) : topological_space.separable_space (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_180937 (h0 : topological_space (has_nndist (finset (finset (finset (finset linarith.comp)))))) : loc_path_connected_space (has_nndist (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_180938 (h0 : uniform_space (semiring (has_norm empty))) : separated_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_180939 (h0 : group (canonically_linear_ordered_monoid Type)) : is_cyclic (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_180940 (h1 : ring (normed_group char)) : rank_condition (normed_group char) := sorry --non-trivial
lemma new_lemma_180941 (h0 : group (has_zero (has_nndist (has_add (has_add linarith.comp))))) : is_cyclic (has_zero (has_nndist (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_180942 (h0 : environment.implicit_infer_kind -> monoid_with_zero num -> monoid_with_zero num) (h1 : monoid_with_zero num -> monoid_with_zero num -> Prop) : contravariant_class environment.implicit_infer_kind (monoid_with_zero num) h0 h1 := sorry --non-trivial
lemma new_lemma_180943 (h0 : finset Type) (h1 h2 : Pi (i : Type), complete_lattice i) (h3 : Pi (j : Type), decidable (has_mem.mem j h0)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_180944 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_180945 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (ring name)) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_180946 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup (mul_one_class string.iterator_imp)))) : t0_space (nondiscrete_normed_field (add_comm_semigroup (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_180947 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : regular_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_180948 (h0 : topological_space ereal) (h3 : preorder ereal) : order_topology ereal := sorry --non-trivial
lemma new_lemma_180949 (h0 : group (canonically_ordered_monoid linarith.comp)) : normalizer_condition (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_180950 (h0 : functor.add_const (ring (add_left_cancel_semigroup num)) congr_arg_kind) : @rank_condition.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_180951 (h0 : ring (id unsigned)) : rank_condition (id unsigned) := sorry --non-trivial
lemma new_lemma_180952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_180953 (h0 : group (semi_normed_comm_ring (boolean_algebra.core linarith.comp_source))) : is_cyclic (semi_normed_comm_ring (boolean_algebra.core linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180954 (h0 : ring (omega_complete_partial_order congr_arg_kind)) : strong_rank_condition (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180955 (h0 : semiring (has_inter (option unsigned))) : is_noetherian_ring (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_180956 (h0 : functor.add_const (topological_space (mul_zero_class linarith.comp)) pos) : @discrete_topology.{0} (mul_zero_class.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_180957 (h0 : topological_space (has_zero (has_to_string unsigned))) : irreducible_space (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_180958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_180959 (h0 : ring (add_cancel_monoid (option empty))) : strong_rank_condition (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_180960 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero unsigned)) : is_compactly_generated (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_180961 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_180962 (h0 : topological_space (ordered_comm_monoid (ring pos))) : totally_separated_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_180963 (h0 : topological_space (linear_order (semiring unsigned))) : locally_compact_space (linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_180964 (h1 : complete_lattice (has_compl (random_gen string_imp))) : is_compactly_generated (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_180965 (h0 : functor.add_const (complete_lattice (pseudo_emetric_space unsigned)) congr_arg_kind) : @is_atomistic.{0} (pseudo_emetric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_emetric_space.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_180966 (h0 : function.extfun (Type 1) (functor.comp topological_space has_to_string)) : @normal_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_to_string.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_180967 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_inter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_180968 (h3 : complete_lattice (has_compl (has_nnnorm char))) : is_compactly_generated (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_180969 (h0 : monoid (ordered_cancel_add_comm_monoid num)) : monoid.fg (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_180970 (h0 : filter (comm_ring (dlist fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_180971 (h0 : functor.add_const (group (has_bot empty)) unsigned) : @normalizer_condition.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_180972 (h0 : set (mul_one_class enat -> mul_one_class char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_180973 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))))) : t0_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_180974 (h0 : complete_lattice (has_zero linarith.comp)) : is_compactly_generated (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_180975 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_180976 (h0 : group (normed_comm_ring (add_cancel_monoid (comm_group pos)))) : is_cyclic (normed_comm_ring (add_cancel_monoid (comm_group pos))) := sorry --non-trivial
lemma new_lemma_180977 (h0 : topological_space (has_to_string (has_neg Type))) : locally_compact_space (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_180978 (h0 : ring (measurable_space linarith.comp_source)) : is_domain (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_180979 (h1 : complete_lattice std_gen) : complete_lattice.is_Sup_finite_compact std_gen := sorry --non-trivial
lemma new_lemma_180980 (h0 : topological_space (plift unsigned)) : totally_separated_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_180981 (h0 : finset (has_ssubset linarith.ineq)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_180982 (h0 : topological_space (comm_group (ring pos))) : topological_space.separable_space (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_180983 (h0 : topological_space (has_nndist (has_add ennreal))) : t1_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_180984 (h0 : ring (with_zero (comm_ring to_additive.value_type))) : strong_rank_condition (with_zero (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_180985 (h0 : not (add_group (mul_zero_class congr_arg_kind) -> false)) : @is_add_cyclic.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_180986 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_180987 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @preconnected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_180988 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : preconnected_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_180989 (h0 : monoid (with_bot (semiring (semiring (semiring empty))))) : monoid.fg (with_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_180990 (h3 : ring (uniform_space (metric_space to_additive.value_type))) : strong_rank_condition (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_180991 (h0 : ring (fintype linarith.ineq)) : strong_rank_condition (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_180992 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_180993 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_compactly_generated.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_180994 (h0 : linear_ordered_field (monoid_with_zero num) -> linear_ordered_field (monoid_with_zero num) -> Prop) : is_symm (linear_ordered_field (monoid_with_zero num)) h0 := sorry --non-trivial
lemma new_lemma_180995 (h1 : topological_space linarith.comp_source) (h2 : preorder linarith.comp_source) : order_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_180996 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_180997 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @preconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_180998 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero ennreal))) : @unique_factorization_monoid.{0} ennreal (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_180999 (h0 : functor.add_const (topological_space (ring ennreal)) num) : @normal_space.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_181000 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_181001 (h0 : topological_space (metric_space (semiring empty))) : totally_separated_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_181002 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_neg name)))) : normal_space (canonically_linear_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_181003 (h0 : add_group (add_comm_semigroup std_gen)) : is_add_cyclic (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_181004 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_181005 (h0 : topological_space (add_comm_monoid (add_cancel_monoid name))) : totally_disconnected_space (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_181006 (h1 : not (add_group (distrib_lattice char) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_181007 (h1 : ring (normed_field (has_nnnorm char))) : strong_rank_condition (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_181008 (h0 : topological_space (canonically_linear_ordered_monoid real)) : sequential_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_181009 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181010 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (normed_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181011 (h0 : ring (id (has_top (has_norm linarith.comp)))) : strong_rank_condition (id (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_181012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_181013 (h0 : ring (dlist (add_zero_class fun_info))) : is_domain (dlist (add_zero_class fun_info)) := sorry --non-trivial
lemma new_lemma_181014 (h0 : functor.add_const (uniform_space nnreal) empty) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_181015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_181016 (h0 : not (topological_space (encodable linarith.ineq) -> false)) : @path_connected_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_181017 (h0 : group (finset (has_pos_part pos))) : group.fg (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_181018 (h0 : list (complete_distrib_lattice environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181019 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra Type)) (ring name)) : @complete_lattice.is_Sup_finite_compact.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_181020 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) Type) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_181021 (h0 : topological_space (semiring (semiring (semiring unsigned)))) : t1_space (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_181022 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_181023 (h3 : measurable_space enat) (h4 : has_mul enat) (h5 : measure_theory.measure enat) : measure_theory.measure.is_mul_right_invariant h5 := sorry --non-trivial
lemma new_lemma_181024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181025 (h0 : topological_space (has_star congr_arg_kind)) : locally_compact_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181026 (h1 : complete_lattice (id linarith.comp)) : is_atomistic (id linarith.comp) := sorry --non-trivial
lemma new_lemma_181027 (h0 : filter (monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181028 (h0 : functor.add_const (monoid (has_zero name)) (finset Type)) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181029 (h0 : ordered_add_comm_monoid (has_add (boolean_algebra.core linarith.comp))) : archimedean (has_add (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_181030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_181031 (h0 : ring (ring (comm_group Type))) : is_domain (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_181032 (h0 : ring (plift (semiring empty))) : is_principal_ideal_ring (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_181033 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181034 (h1 : functor.add_const Prop to_additive.value_type) : functor.add_const.run h1 := sorry --non-trivial
lemma new_lemma_181035 (h1 : topological_space (distrib linarith.comp_source)) : path_connected_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181036 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) name) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_181037 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_181038 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181039 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_181040 (h5 : set (enat -> fun_info)) : set.separates_points h5 := sorry --non-trivial
lemma new_lemma_181041 (h0 h1 : multiset (mul_one_class to_additive.value_type)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_181042 (h0 : fin has_zero.zero) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_181043 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181044 (h0 : functor.add_const (ring (add_cancel_monoid empty)) (option (option empty))) : @is_domain.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_181045 (h0 : functor.add_const (group (finset pos)) pos) : @normalizer_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_181046 (h0 : functor.add_const (topological_space (finset pos)) name) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_181047 (h0 : topological_space string.iterator_imp) (h1 : preorder string.iterator_imp) : order_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_181048 (h1 : not (topological_space (div_inv_monoid linarith.ineq) -> false)) : @path_connected_space.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_181049 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @monoid.fg.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_181050 (h0 : function.extfun Type (functor.comp group boolean_algebra)) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} boolean_algebra.{0}) h0 name)))  := sorry --non-trivial
lemma new_lemma_181051 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_181052 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_181053 (h0 : topological_space (semigroup (comm_group unsigned))) : normal_space (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_181054 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_181055 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181056 (h0 : ring (normed_group to_additive.value_type)) : strong_rank_condition (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181057 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) Type) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_181058 (h0 : topological_space (has_add (sub_neg_monoid (has_Inf (has_Inf Type))))) : normal_space (has_add (sub_neg_monoid (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_181059 (h0 : not (topological_space unsigned -> false)) : @topological_space.separable_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_181060 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : normal_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181062 (h0 : ordered_comm_monoid (has_bot (has_Inf name))) : has_exists_mul_of_le (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_181063 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_181064 (h0 : topological_space (add_group num)) : totally_disconnected_space (add_group num) := sorry --non-trivial
lemma new_lemma_181065 (h0 : topological_space (with_bot (semiring (semiring linarith.comp)))) : locally_compact_space (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_181066 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group empty)) empty) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_181067 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @topological_space.separable_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_181068 (h0 : function.extfun Type ring) : @rank_condition.{0} (uniform_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (uniform_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_181069 (h0 : topological_space (cancel_monoid (option (option (option empty))))) : totally_disconnected_space (cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_181070 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset (finset pos))) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181071 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup unsigned)) empty) : @archimedean.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181072 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : totally_disconnected_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_181073 (h0 : topological_space (measurable_space (id (has_union congr_arg_kind)))) : path_connected_space (measurable_space (id (has_union congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_181074 (h0 : not (filter (add_left_cancel_monoid char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_181075 (h0 : semiring (mul_one_class ereal)) (h1 : mul_one_class ereal) : even h1 := sorry --non-trivial
lemma new_lemma_181076 (h0 : topological_space (has_to_string empty)) : discrete_topology (has_to_string empty) := sorry --non-trivial
lemma new_lemma_181077 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_181078 (h0 : ring (complete_distrib_lattice pos)) : is_domain (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_181079 (h0 : topological_space (ordered_comm_monoid (has_add (has_neg Type)))) : topological_space.separable_space (ordered_comm_monoid (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_181080 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181081 (h0 : complete_lattice (has_top linarith.comp)) : is_atomistic (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_181082 (h0 : ordered_add_comm_monoid (finset (finset (finset environment.implicit_infer_kind)))) : archimedean (finset (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_181083 (h0 : functor.add_const Prop (pseudo_metric_space unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_181084 (h0 : group (has_emptyc (semiring empty))) : group.fg (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_181085 (h0 : topological_space (has_append (has_ssubset (has_nnnorm linarith.ineq)))) : path_connected_space (has_append (has_ssubset (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_181086 (h0 : function.extfun Type (prod (partial_order (semiring empty)))) : id_rel (function.extfun_app h0 (partial_order (semiring empty))) := sorry --non-trivial
lemma new_lemma_181087 (h0 : group (has_zero (option ennreal))) : group.fg (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_181088 (h0 : has_neg (normed_field linarith.comp_source)) (h1 : measurable_space (normed_field linarith.comp_source)) : has_measurable_neg (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181089 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_181090 (h0 : uniform_space (finset environment.implicit_infer_kind)) : complete_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_181091 (h0 : topological_space (boolean_algebra (has_Inf (has_bot real)))) : preconnected_space (boolean_algebra (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_181092 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_181093 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (semigroup pos)))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_add (semigroup pos))) := sorry --non-trivial
lemma new_lemma_181094 (h0 : functor.add_const (group (pseudo_metric_space unsigned)) unsigned) : @is_simple_group.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181095 (h0 : functor.add_const (add_monoid (ring unsigned)) linarith.comp) : @add_monoid.fg.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181096 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181097 (h0 : topological_space (with_one (semiring congr_arg_kind))) : t0_space (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181098 (h0 : topological_space (ring (has_add (has_add name)))) : irreducible_space (ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_181099 (h0 : topological_space (has_nndist (finset linarith.comp))) : t0_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_181100 (h0 : functor.add_const (ring (add_comm_monoid name)) pos) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_181101 (h0 : topological_space (finset Type)) : preirreducible_space (finset Type) := sorry --non-trivial
lemma new_lemma_181102 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_181103 (h0 : topological_space (has_neg (has_add linarith.comp))) : regular_space (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181104 (h0 : uniform_space (ordered_comm_monoid (boolean_algebra.core Type))) : complete_space (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_181105 (h0 h1 : multiset (has_lt std_gen)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_181106 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_181107 (h0 : topological_space (add_cancel_monoid (ring (has_add Type)))) : locally_compact_space (add_cancel_monoid (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_181108 (h0 : functor.add_const (function.extfun Type group) (ring environment.implicit_infer_kind)) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} environment.implicit_infer_kind) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181109 (h0 : add_group (add_comm_semigroup (mul_one_class (mul_one_class (add_comm_semigroup enat))))) : is_add_cyclic (add_comm_semigroup (mul_one_class (mul_one_class (add_comm_semigroup enat)))) := sorry --non-trivial
lemma new_lemma_181110 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_181111 (h0 : filter (with_bot string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181112 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero empty)) : separated_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_181113 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181114 (h0 : ring (has_nndist (has_neg_part pos))) : strong_rank_condition (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_181115 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_181116 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_181117 (h0 : functor.add_const (group (left_cancel_monoid empty)) empty) : @group.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_181118 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : t0_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_181119 (h1 : add_group (measurable_space (random_gen (with_bot (with_bot linarith.ineq))))) : is_add_cyclic (measurable_space (random_gen (with_bot (with_bot linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_181120 (h0 : ring (has_neg (option ennreal))) : rank_condition (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_181121 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_181122 (h0 : ring (complete_distrib_lattice empty)) : strong_rank_condition (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_181123 (h0 : group (simple_graph (ring (has_neg pos)))) : is_cyclic (simple_graph (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_181124 (h0 : group (id linarith.ineq)) : is_cyclic (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_181125 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_181126 (h0 : ring (has_top (semiring num))) : rank_condition (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_181127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_181128 (h0 : ring (denumerable (random_gen to_additive.value_type))) : is_domain (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181129 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) unsigned) : @t1_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181130 (h0 : group (boolean_algebra.core (has_Inf (has_Inf linarith.comp)))) : is_cyclic (boolean_algebra.core (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_181131 (h0 : ring (semigroup (option (option (option ennreal))))) : is_domain (semigroup (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_181132 (h0 : add_group (has_to_string (finset pos))) : is_add_cyclic (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_181133 (h0 : complete_lattice (complete_distrib_lattice ennreal)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_181134 (h1 : ring (metric_space linarith.comp)) : rank_condition (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_181135 (h0 : topological_space (add_semigroup empty)) : normal_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_181136 (h0 : monoid (with_one (has_top empty))) : monoid.fg (with_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_181137 (h0 : ring (complete_distrib_lattice (ring (ring linarith.comp)))) : rank_condition (complete_distrib_lattice (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_181138 (h0 : topological_space (has_div ereal)) : t0_space (has_div ereal) := sorry --non-trivial
lemma new_lemma_181139 (h0 : topological_space (has_zero (has_neg_part pos))) : discrete_topology (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_181140 (h0 : finset (linear_ordered_comm_group congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_181141 (h0 : topological_space (has_add (has_pos_part (has_pos_part linarith.comp)))) : t0_space (has_add (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_181142 (h0 : functor.add_const (complete_lattice (normed_comm_ring environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_181143 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} name (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_181144 (h1 : topological_space (with_bot (has_norm fun_info))) : t0_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_181145 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181146 (h0 : topological_space (has_to_string num)) : path_connected_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_181147 (h1 : uniform_space (random_gen (random_gen to_additive.value_type))) : complete_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181148 (h0 : topological_space (has_zero (finset (has_neg linarith.comp)))) : totally_disconnected_space (has_zero (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_181149 (h0 : functor.add_const (complete_lattice (ordered_comm_ring real)) pos) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_181150 (h0 : filter (dlist fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181151 (h0 : topological_space (with_one linarith.ineq)) : t0_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_181152 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (finset Type)) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181153 (h0 : topological_space (random_gen (has_nnnorm fun_info))) : t0_space (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_181154 (h0 : nat) (h1 : ring (plift (nat.prime h0))) : is_domain (plift (nat.prime h0)) := sorry --non-trivial
lemma new_lemma_181155 (h0 : filter (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_inv linarith.ineq))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181156 (h0 : ring (linear_ordered_add_comm_group (random_gen (has_norm linarith.ineq)))) : is_domain (linear_ordered_add_comm_group (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_181157 (h0 : uniform_space (has_nndist name)) : complete_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_181158 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181159 (h0 : functor.add_const (ring (linear_ordered_field name)) unsigned) : @strong_rank_condition.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_field.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181160 (h0 : add_group (add_cancel_monoid (has_to_string linarith.comp))) : is_add_cyclic (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_181161 (h0 : functor.add_const (ring (semigroup Type)) linarith.comp) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181162 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181164 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_181165 (h0 : topological_space (cancel_monoid Type)) : totally_separated_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_181166 (h0 : function.extfun Type (functor.add_const (topological_space (has_star unsigned)))) : @t1_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181167 (h0 h1 : multiset (has_nnnorm (mul_one_class string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_181168 (h0 : topological_space (metric_space reducibility_hints)) : totally_disconnected_space (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_181169 (h0 : ring (preorder (option (option unsigned)))) : is_principal_ideal_ring (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_181170 (h0 : not (ring (random_gen (mul_one_class char)) -> false)) : @is_domain.{0} (random_gen.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_181171 (h0 : topological_space (plift complex)) : topological_space.separable_space (plift complex) := sorry --non-trivial
lemma new_lemma_181172 (h0 : not (filter (has_star empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_181173 (h0 : ring (semigroup (has_neg name))) : strong_rank_condition (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_181174 (h0 : functor.add_const (ring (semigroup Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181176 (h0 : functor.add_const (add_group (comm_semigroup real)) real) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (add_group.{0} (comm_semigroup.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_181177 (h3 : topological_space (nondiscrete_normed_field linarith.ineq)) (h4 : add_group (nondiscrete_normed_field linarith.ineq)) : topological_add_group (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_181178 (h0 : topological_space (canonically_ordered_monoid real)) : topological_space.separable_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_181179 (h0 : ordered_add_comm_monoid (has_neg congr_arg_kind)) : archimedean (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181180 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @preirreducible_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_181181 (h0 : group (add_cancel_monoid (finset Type))) : normalizer_condition (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_181182 (h0 : functor.add_const (finset (comm_group linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181183 (h0 : topological_space (complete_distrib_lattice (ordered_comm_ring linarith.comp))) : topological_space.separable_space (complete_distrib_lattice (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_181184 (h0 : group (has_to_string (has_neg (has_to_string Type)))) : is_simple_group (has_to_string (has_neg (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_181185 (h0 : ring (ring (option (option ennreal)))) : strong_rank_condition (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_181186 (h0 : semiring (semigroup congr_arg_kind)) : is_noetherian_ring (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181187 (h0 : topological_space (boolean_algebra (comm_semigroup Type))) : topological_space.separable_space (boolean_algebra (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_181188 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_181189 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181190 (h0 : group (distrib (has_nnnorm (random_gen linarith.ineq)))) : is_cyclic (distrib (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_181191 (h0 : uniform_space (add_cancel_monoid (finset linarith.comp))) : separated_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_181192 (h0 : group (add_cancel_monoid (has_Inf (has_neg Type)))) : group.fg (add_cancel_monoid (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_181193 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_181194 (h0 : functor.add_const (topological_space (has_zero Type)) (finset pos)) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181195 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_to_string Type)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181196 (h0 : topological_space (has_one (has_norm linarith.comp))) : preirreducible_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_181197 (h0 : has_coe (mul_one_class environment.projection_info) Prop) (h1 : mul_one_class environment.projection_info) : @coe_b.{1 1} (mul_one_class.{0} environment.projection_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_181198 (h0 : add_group (canonically_ordered_comm_semiring (has_pos_part Type))) : is_add_cyclic (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_181199 (h0 : topological_space (has_zero (ring (has_add (has_add Type))))) : locally_compact_space (has_zero (ring (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_181200 (h0 : ring (comm_group (has_add (has_add Type)))) : strong_rank_condition (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_181201 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) (has_add (has_add Type))) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181202 (h0 : group (with_one (has_ssubset fun_info))) : group.fg (with_one (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_181203 (h0 : ring (random_gen (has_top (has_norm (has_top fun_info))))) : strong_rank_condition (random_gen (has_top (has_norm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_181204 (h0 : functor.add_const (topological_space (semigroup Type)) (has_zero (has_zero (has_zero linarith.comp)))) : @t1_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_181205 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_181206 (h0 : filter (complete_distrib_lattice linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181207 (h0 : ring (has_to_string (has_Inf name))) : is_principal_ideal_ring (has_to_string (has_Inf name)) := sorry --non-trivial
lemma new_lemma_181208 (h0 : functor.add_const (ring (boolean_algebra.core Type)) linarith.comp) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181209 (h0 : fin has_zero.zero) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_181210 (h0 : list (boolean_algebra unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181211 (h3 : ring (has_div to_additive.value_type)) : is_domain (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181212 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (fintype empty)) := sorry --non-trivial
lemma new_lemma_181213 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181214 (h0 : group (left_cancel_semigroup congr_arg_kind)) : group.fg (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181215 (h2 : ring (metric_space linarith.comp_source)) : rank_condition (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181216 (h0 : filter (finset (finset (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181217 (h0 : topological_space (has_to_string (ring unsigned))) : t0_space (has_to_string (ring unsigned)) := sorry --non-trivial
lemma new_lemma_181218 (h0 : add_group (ordered_comm_monoid real)) : is_add_cyclic (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_181219 (h0 : topological_space (normed_group (has_norm (has_norm (has_norm empty))))) : discrete_topology (normed_group (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_181220 (h0 : topological_space (ordered_comm_ring (has_add (has_add (ring Type))))) : totally_disconnected_space (ordered_comm_ring (has_add (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_181221 (h0 : topological_space (has_bot (has_add (has_add Type)))) : discrete_topology (has_bot (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_181222 (h0 : ring (has_neg (has_neg_part Type))) : is_domain (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_181223 (h0 : add_group (semiring (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : is_add_cyclic (semiring (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_181224 (h0 : functor.comp group boolean_algebra linarith.comp) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181225 (h0 : ring (normed_field (has_nnnorm string.iterator_imp))) : is_domain (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_181226 (h0 : topological_space (normed_group (has_nnnorm fun_info))) : totally_disconnected_space (normed_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_181227 (h0 : topological_space (has_star (semiring (semiring (semiring (semiring unsigned)))))) : irreducible_space (has_star (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_181228 (h0 : functor.add_const (group (has_add Type)) (ring Type)) : @is_simple_group.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_add.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181229 (h0 : group (has_lt (mul_one_class char))) : is_cyclic (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_181230 (h0 : group (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_181231 (h0 : functor.add_const (group nnreal) empty) : @is_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (group.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_181232 (h0 : list (cancel_monoid (has_add (has_add environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181233 (h0 : topological_space (comm_semigroup (generalized_boolean_algebra (has_pos_part pos)))) : preirreducible_space (comm_semigroup (generalized_boolean_algebra (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_181234 (h1 : fintype std_gen) (h2 : decidable_eq std_gen) (h3 : equiv.perm std_gen) : equiv.perm.is_three_cycle h3 := sorry --non-trivial
lemma new_lemma_181235 (h0 : semiring (has_inner empty empty)) : is_noetherian_ring (has_inner empty empty) := sorry --non-trivial
lemma new_lemma_181236 (h0 : functor.add_const (function.extfun Type group) (finset (finset linarith.comp))) : @normalizer_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_181237 (h0 : functor.add_const (monoid (comm_group environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181238 (h0 : functor.add_const (finset (add_right_cancel_monoid unsigned)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181239 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_181240 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) unsigned) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181241 (h0 : not (topological_space (has_compl linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_181242 (h1 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h1 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_181243 (h0 : complete_lattice (complete_distrib_lattice pos)) : is_compactly_generated (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_181244 (h0 : topological_space (has_to_string (has_add pos))) : preirreducible_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_181245 (h0 : function.extfun (Type 1) (functor.comp topological_space has_zero)) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_zero.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_181246 (h0 : functor.add_const (ordered_add_comm_monoid (sub_neg_monoid name)) real) : @archimedean.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (sub_neg_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_181247 (h0 : ring (with_bot (has_top linarith.comp_source))) : strong_rank_condition (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_181248 (h0 : topological_space (boolean_algebra.core (has_pos_part linarith.comp))) : irreducible_space (boolean_algebra.core (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_181249 (h0 : filter (pseudo_metric_space (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181250 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_181251 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181252 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_181253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181254 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181255 (h0 : add_group (boolean_algebra.core (has_neg Type))) : is_add_cyclic (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181256 (h0 : topological_space (has_zero (comm_group pos))) : topological_space.separable_space (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_181257 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_181258 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : preconnected_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_181259 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181260 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181261 (h0 : not (ring (has_union linarith.comp) -> false)) : @is_domain.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_181262 (h0 : complete_lattice (with_bot fun_info)) : complete_lattice.is_Sup_finite_compact (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_181263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_181264 (h0 : fin has_zero.zero) : @monoid.fg.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_181265 (h1 : not (topological_space (topological_space char) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_181266 (h0 : list (normed_comm_ring (has_add (has_add ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181267 (h0 : complete_lattice (measurable_space.dynkin_system congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181268 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) name) : @group.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_181269 (h0 : functor.add_const (uniform_space (mul_zero_class num)) empty) : @separated_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_181270 (h0 : not (uniform_space (plift string_imp) -> false)) : @complete_space.{1} (plift.{1} string_imp) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_181271 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_dist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_181272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181273 (h0 : uniform_space (has_Inf (ring (ring Type)))) : separated_space (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_181274 (h0 : ring (add_cancel_monoid (has_pos_part linarith.comp))) : rank_condition (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_181275 (h0 : group (ordered_comm_ring (has_Inf (linear_ordered_add_comm_group_with_top Type)))) : group.fg (ordered_comm_ring (has_Inf (linear_ordered_add_comm_group_with_top Type))) := sorry --non-trivial
lemma new_lemma_181276 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181277 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) (finset (has_neg (has_neg pos)))) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{0} (has_neg.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_181278 (h0 : uniform_space (finset (ring (has_Inf (finset environment.implicit_infer_kind))))) : complete_space (finset (ring (has_Inf (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_181279 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_181280 (h0 : ordered_add_comm_monoid (left_cancel_semigroup empty)) : archimedean (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_181281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181282 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_181283 (h0 : add_group (simple_graph (option unsigned))) : is_add_cyclic (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_181284 (h0 : group (mul_zero_class name)) : is_simple_group (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_181285 (h0 : not (topological_space (add_monoid to_additive.value_type) -> false)) : @path_connected_space.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_181286 (h1 : topological_space linarith.ineq) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_181287 (h0 : function.extfun Type ring) : @is_domain.{0} (uniform_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (uniform_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_181288 (h0 : topological_space (has_nndist (comm_group linarith.comp))) : preirreducible_space (has_nndist (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_181289 (h0 : ordered_add_comm_monoid (boolean_algebra (has_add (has_neg (has_neg_part Type))))) : archimedean (boolean_algebra (has_add (has_neg (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_181290 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_181291 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_181292 (h0 : not (complete_lattice (has_ssubset linarith.comp_source) -> false)) : @is_atomistic.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_181293 (h0 : not (topological_space (uniform_space (random_gen string.iterator_imp)) -> false)) : @t0_space.{0} (uniform_space.{0} (random_gen.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (random_gen.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_181294 (h0 : topological_space (ordered_comm_ring (has_Inf (boolean_algebra.core pos)))) : sequential_space (ordered_comm_ring (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_181295 (h0 : complete_lattice (random_gen reducibility_hints)) : complete_lattice.is_Sup_finite_compact (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_181296 (h0 : cancel_comm_monoid_with_zero (has_to_string (boolean_algebra name))) : unique_factorization_monoid (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_181297 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181298 (h0 : add_group (has_compl (has_inv (random_gen (random_gen string_imp))))) : is_add_cyclic (has_compl (has_inv (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_181299 (h2 : uniform_space (ordered_comm_semiring enat)) : complete_space (ordered_comm_semiring enat) := sorry --non-trivial
lemma new_lemma_181300 (h0 : uniform_space (random_gen (has_norm linarith.comp))) : complete_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_181301 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_181302 (h0 : functor.add_const (complete_lattice (mul_zero_class num)) empty) : @is_atomistic.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_181303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181304 (h0 : functor.add_const (ring (has_Inf pos)) (ring linarith.comp)) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_181305 (h0 : topological_space (has_to_string (option unsigned))) : totally_disconnected_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_181306 (h0 : Prop -> add_comm_semigroup enat) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_181307 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_181308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_181309 (h0 : topological_space (comm_ring (random_gen (random_gen (has_nnnorm string_imp))))) : t0_space (comm_ring (random_gen (random_gen (has_nnnorm string_imp)))) := sorry --non-trivial
lemma new_lemma_181310 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (boolean_algebra (has_neg (has_neg (has_neg name)))))) : archimedean (normed_lattice_add_comm_group (boolean_algebra (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_181311 (h0 : group (id (random_gen string_imp))) : is_cyclic (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_181312 (h0 : ordered_comm_monoid (ring (has_neg pos))) : has_exists_mul_of_le (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_181313 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) pos) : @is_compactly_generated.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_181314 (h0 : functor.add_const (filter (preorder empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181315 (h0 : not (topological_space (semi_normed_ring to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_181316 (h0 : complete_lattice (has_add (has_neg (has_add (has_neg name))))) : complete_lattice.is_Sup_finite_compact (has_add (has_neg (has_add (has_neg name)))) := sorry --non-trivial
lemma new_lemma_181317 (h0 : ring (has_neg (finset pos))) : rank_condition (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_181318 (h0 : functor.add_const (filter (has_zero pos)) (option name)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181319 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_181320 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181321 (h0 : complete_lattice (has_add (ring name))) : complete_lattice.is_Sup_finite_compact (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_181322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181323 (h1 : not (group (normed_field char) -> false)) : @is_cyclic.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_181324 (h0 : ring (has_compl (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : rank_condition (has_compl (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_181325 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : regular_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_181326 (h0 : topological_space (denumerable (has_ssubset to_additive.value_type))) : path_connected_space (denumerable (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181327 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181328 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) Type) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_181329 (h0 : group (has_neg (has_neg Type))) : group.fg (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181330 (h0 : ring (dlist (has_inv (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_inv fun_info)))))))) : is_domain (dlist (has_inv (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_inv fun_info))))))) := sorry --non-trivial
lemma new_lemma_181331 (h0 : functor.comp list dlist (random_gen to_additive.value_type)) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_181332 (h0 : cancel_comm_monoid_with_zero (semigroup unsigned)) : unique_factorization_monoid (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_181333 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181334 (h0 : not (has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_181335 (h0 : list unsigned) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181336 (h0 : list (normed_comm_ring (has_to_string (has_add (has_to_string Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181337 (h0 : topological_space (plift empty)) : t0_space (plift empty) := sorry --non-trivial
lemma new_lemma_181338 (h0 : not (order_hom nat (topological_space char) -> false)) : @totally_disconnected_space.{0} char (@monotonic_sequence_limit.{0} (topological_space.{0} char) (@topological_space.partial_order.{0} char) (@classical.by_contradiction'.{1} (@order_hom.{0 0} nat (topological_space.{0} char) (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} (topological_space.{0} char) (@topological_space.partial_order.{0} char))) h0))  := sorry --non-trivial
lemma new_lemma_181339 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @separated_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_181340 (h1 : function.extfun Type ring) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_181341 (h5 : topological_space (topological_space (comm_ring char))) : totally_disconnected_space (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_181342 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group empty)) (semiring num)) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_181343 (h0 : set (set (semiring empty))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_181344 (h0 : topological_space (metric_space (metric_space to_additive.value_type))) : t0_space (metric_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181345 (h0 : not (group string.iterator_imp -> false)) : @is_cyclic.{0} string.iterator_imp (@classical.by_contradiction'.{1} (group.{0} string.iterator_imp) h0)  := sorry --non-trivial
lemma new_lemma_181346 (h0 : topological_space (comm_monoid unsigned)) : t0_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_181347 (h0 : functor.add_const (add_group (has_add pos)) unsigned) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181348 (h0 : functor.add_const (filter (ring unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181349 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_181350 (h0 : topological_space (comm_group (cancel_monoid (comm_group ennreal)))) : preconnected_space (comm_group (cancel_monoid (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_181351 (h0 : topological_space (has_edist (semiring unsigned))) : topological_space.separable_space (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_181352 (h0 : semiring (ordered_comm_ring (has_neg name))) : is_noetherian_ring (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_181353 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) pos) : @is_atomistic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_181354 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) empty) : @is_compactly_generated.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181355 (h0 : complete_lattice (complete_distrib_lattice (option (option congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_181356 (h0 : add_group (boolean_algebra.core (has_Inf pos))) : is_add_cyclic (boolean_algebra.core (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_181357 (h0 : topological_space (add_comm_monoid (has_add Type))) : t1_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_181358 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) Type) : @t1_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_181359 (h0 : complete_lattice (plift (has_edist (option (option unsigned))))) : is_atomistic (plift (has_edist (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_181360 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_181361 (h0 : fin has_zero.zero) : @t1_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181362 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @complete_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181363 (h2 : group (distrib linarith.ineq)) : is_cyclic (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_181364 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_181365 (h0 : topological_space (has_div string.iterator_imp)) : totally_disconnected_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_181366 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181367 (h0 : ring (ordered_comm_ring (sub_neg_monoid name))) : rank_condition (ordered_comm_ring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_181368 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nnnorm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_181369 (h0 : functor.add_const (add_group (has_to_string environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181370 (h0 : ring (normed_field (mul_one_class char))) : rank_condition (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_181371 (h0 : add_group (with_bot (with_bot string_imp))) : is_add_cyclic (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_181372 (h0 : uniform_space (has_emptyc (random_gen congr_arg_kind))) : separated_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181373 (h1 : add_group (denumerable (has_nnnorm char))) : is_add_cyclic (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_181374 (h0 : topological_space (add_comm_monoid (comm_group (has_neg_part Type)))) : totally_separated_space (add_comm_monoid (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_181375 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_181376 (h0 : add_group (with_one (has_inv linarith.ineq))) : is_add_cyclic (with_one (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_181377 (h1 : topological_space (has_top (with_bot to_additive.value_type))) : path_connected_space (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181379 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181381 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 uniform_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_181382 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_181383 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_Inf pos))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_181384 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181385 (h0 : add_monoid (has_add (finset (finset environment.implicit_infer_kind)))) : add_monoid.fg (has_add (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_181386 (h0 : topological_space (has_bot (comm_monoid unsigned))) : locally_compact_space (has_bot (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_181387 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_181388 (h0 : functor.add_const (complete_lattice (has_neg name)) (mul_zero_class pos)) : @is_atomistic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181389 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string name)))) : sequential_space (normed_comm_ring (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_181390 (h0 : topological_space (has_neg (has_neg (has_neg (has_neg linarith.comp))))) : loc_path_connected_space (has_neg (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_181391 (h0 : add_monoid (add_comm_monoid (finset linarith.comp))) : add_monoid.fg (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_181392 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} fun_info)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_bot.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_181393 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_181394 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_181395 (h0 : topological_space (add_cancel_monoid (option (option pos)))) : regular_space (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_181396 (h0 : filter (option (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181397 (h0 : topological_space (omega_complete_partial_order (option (option (option unsigned))))) : discrete_topology (omega_complete_partial_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_181398 (h0 : ring (has_add string_imp)) : is_domain (has_add string_imp) := sorry --non-trivial
lemma new_lemma_181399 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181400 (h0 : topological_space (add_comm_monoid (option (option (option (option ennreal)))))) : t0_space (add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_181401 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181402 (h0 : topological_space (has_pos_part (has_add (has_Inf pos)))) : locally_compact_space (has_pos_part (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_181403 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_181404 (h0 : topological_space (has_dist num)) : path_connected_space (has_dist num) := sorry --non-trivial
lemma new_lemma_181405 (h0 : filter (pseudo_metric_space congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181406 (h0 : functor.add_const (group (has_zero pos)) (has_neg pos)) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181407 (h1 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} char) (@function.extfun_app.{2 1} Type ring.{0} h1 (random_gen.{0} char))  := sorry --non-trivial
lemma new_lemma_181408 (h0 : filter (boolean_algebra.core name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181409 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class pos)) ennreal) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_181410 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} pos (@function.extfun_app.{2 1} Type add_monoid.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_181411 (h0 : add_group (semigroup (has_add (has_add linarith.comp)))) : is_add_cyclic (semigroup (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_181412 (h1 : group (denumerable (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_cyclic (denumerable (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_181413 (h0 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @discrete_topology.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_181414 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_181415 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181416 (h0 : functor.add_const (group (has_zero Type)) (has_nndist pos)) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181417 (h0 : topological_space (add_cancel_monoid (has_nndist (ring (has_Inf name))))) : irreducible_space (add_cancel_monoid (has_nndist (ring (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_181418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_181419 (h0 : ordered_add_comm_monoid (boolean_algebra (add_comm_monoid pos))) : archimedean (boolean_algebra (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_181420 (h0 : ring (add_comm_monoid (option ennreal))) : is_principal_ideal_ring (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_181421 (h0 : not (filter (has_nnnorm char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_181422 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_181423 (h0 : topological_space (has_to_string (ring Type))) : totally_disconnected_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_181424 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_181425 (h0 : has_neg (has_neg environment.implicit_infer_kind) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_181426 (h0 : topological_space (add_comm_monoid (finset (has_neg (finset name))))) : preirreducible_space (add_comm_monoid (finset (has_neg (finset name)))) := sorry --non-trivial
lemma new_lemma_181427 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181428 (h0 : filter (pseudo_metric_space (option (option (option (option (option ennreal))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181429 (h0 : functor.add_const (filter (has_to_string Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_181431 (h0 : topological_space (finset (normed_comm_ring name))) : regular_space (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_181432 (h0 : functor.add_const (function.extfun (Type 1) monoid) (finset (has_neg environment.implicit_infer_kind))) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) (finset.{0} (has_neg.{0} environment.implicit_infer_kind)) h0) Type)  := sorry --non-trivial
lemma new_lemma_181433 (h0 h1 : pnat) : id (pnat.coprime h0 h1) := sorry --non-trivial
lemma new_lemma_181434 (h0 : monoid (has_top empty)) : monoid.fg (has_top empty) := sorry --non-trivial
lemma new_lemma_181435 (h0 : function.extfun nat fin) : @is_simple_group.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_181436 (h0 : complete_lattice (linear_ordered_comm_ring (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_181437 (h0 : topological_space (id (has_norm linarith.comp))) : preirreducible_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_181438 (h0 : function.extfun Type (functor.comp monoid has_neg)) : @monoid.fg.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} monoid.{0} has_neg.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_181439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_181440 (h0 : cancel_comm_monoid_with_zero (has_add (has_neg_part (has_neg_part unsigned)))) : unique_factorization_monoid (has_add (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_181441 (h0 : ordered_add_comm_monoid (has_pos_part pos)) : archimedean (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_181442 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181443 (h0 : not (topological_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) (h1 : preorder (non_unital_non_assoc_semiring linarith.ineq)) : @order_topology.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0) h1  := sorry --non-trivial
lemma new_lemma_181444 (h0 : not (group (encodable to_additive.value_type) -> false)) : @is_cyclic.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_181445 (h0 : semiring (ordered_comm_ring (finset (has_Inf Type)))) : is_noetherian_ring (ordered_comm_ring (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_181446 (h0 : functor.add_const (list (has_Inf pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181447 (h0 : ring (has_neg_part (add_comm_monoid unsigned))) : is_principal_ideal_ring (has_neg_part (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_181448 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181449 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181450 (h0 : ring (random_gen (with_bot (with_bot string_imp)))) : is_domain (random_gen (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_181451 (h0 : ring (left_cancel_monoid (semiring empty))) : is_domain (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_181452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181453 (h2 : ring (topological_space char)) : is_domain (topological_space char) := sorry --non-trivial
lemma new_lemma_181454 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_181455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (measurable_space string_imp)) := sorry --non-trivial
lemma new_lemma_181456 (h0 : topological_space (canonically_linear_ordered_monoid (finset Type))) : preirreducible_space (canonically_linear_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_181457 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_Inf (has_Inf pos))) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_Inf.{0} (has_Inf.{0} pos)) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_181458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_181459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (simple_graph empty)) := sorry --non-trivial
lemma new_lemma_181460 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_181461 (h0 : monoid (semiring (random_gen congr_arg_kind))) : monoid.fg (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181462 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_181463 (h3 : not (complete_lattice (has_ssubset to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} to_additive.value_type)) h3)  := sorry --non-trivial
lemma new_lemma_181464 (h0 : add_group (metric_space (normed_group linarith.comp))) : is_add_cyclic (metric_space (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_181465 (h0 : group (complete_distrib_lattice (has_nndist name))) : is_simple_group (complete_distrib_lattice (has_nndist name)) := sorry --non-trivial
lemma new_lemma_181466 (h0 : complete_lattice (bin_tree unsigned)) : is_compactly_generated (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_181467 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_181468 (h0 : monoid (comm_group pos)) : monoid.fg (comm_group pos) := sorry --non-trivial
lemma new_lemma_181469 (h0 : topological_space (comm_ring (comm_ring linarith.comp_source))) : t0_space (comm_ring (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_181470 (h0 : functor.add_const (group (has_Sup unsigned)) empty) : @group.fg.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181471 (h0 : functor.add_const (finset (has_add pos)) (has_neg name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181472 (h0 : functor.add_const (group (finset linarith.comp)) linarith.comp) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181473 (h0 : preorder (mul_one_class std_gen)) (h1 : set (mul_one_class std_gen)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_181474 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181475 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset linarith.comp)) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_181476 (h0 : group (distrib_lattice (random_gen (random_gen (has_nnnorm (random_gen fun_info)))))) : group.fg (distrib_lattice (random_gen (random_gen (has_nnnorm (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_181477 (h0 : ring (finset (finset environment.implicit_infer_kind))) : is_principal_ideal_ring (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_181478 (h0 : functor.add_const (group (ring pos)) (boolean_algebra Type)) : @is_simple_group.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181479 (h0 : topological_space (ring empty)) : path_connected_space (ring empty) := sorry --non-trivial
lemma new_lemma_181480 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_181482 (h0 : add_monoid (simple_graph (has_add (has_to_string (has_to_string Type))))) : add_monoid.fg (simple_graph (has_add (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_181483 (h0 : complete_lattice (ordered_cancel_add_comm_monoid pos)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_181484 (h1 : topological_space string_imp) : locally_compact_space string_imp := sorry --non-trivial
lemma new_lemma_181485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181486 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_181487 (h0 : has_scalar (add_semigroup char) char) (h1 : has_scalar (mul_opposite (add_semigroup char)) char) : is_central_scalar (add_semigroup char) char := sorry --non-trivial
lemma new_lemma_181488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181489 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181490 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf linarith.comp))))) : loc_path_connected_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_181491 (h0 : topological_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) : t0_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_181492 (h0 : list (linear_ordered_comm_group pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181493 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) empty) : @normal_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181494 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_181495 (h0 : complete_lattice (has_to_string (finset Type))) : is_compactly_generated (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_181496 (h0 : complete_lattice (has_to_string linarith.comp)) : is_atomistic (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_181497 (h0 : group (sub_neg_monoid (finset (finset linarith.comp)))) : is_simple_group (sub_neg_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_181498 (h0 : topological_space (ordered_comm_ring (has_neg name))) : regular_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_181499 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_181500 (h0 : functor.add_const (add_monoid (has_nndist linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181501 (h0 : ring (measure_theory.measure_space (semiring (semiring empty)))) : strong_rank_condition (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_181502 (h0 : topological_space (distrib (has_nnnorm linarith.ineq))) : path_connected_space (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_181503 (h0 : uniform_space (has_le string.iterator_imp)) : complete_space (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_181504 (h0 : complete_lattice (ring (has_add pos))) : is_atomistic (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_181505 (h0 : function.extfun Type (functor.add_const (finset ennreal))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_181506 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) num) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_181507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_181508 (h0 : functor.add_const (group (semigroup pos)) pos) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_181509 (h0 : finset Type) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_181510 (h0 : functor.add_const (group (has_neg Type)) (finset (has_neg (has_neg Type)))) : @is_simple_group.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg.{1} Type)) (finset.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_181511 (h0 : add_group (random_gen (semiring empty))) : is_simple_add_group (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_181512 (h0 : has_lt (has_le environment.projection_info)) : no_max_order (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_181513 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_neg (has_neg Type)))) : has_exists_mul_of_le (complete_distrib_lattice (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_181514 (h0 : finset (finset (finset (normed_comm_ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_181515 (h0 : ring (has_bot (ordered_comm_monoid real))) : is_principal_ideal_ring (has_bot (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_181516 (h0 : functor.add_const (monoid (has_bot pos)) Type) : @monoid.fg.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_181517 (h0 : topological_space (with_one (has_nnnorm char))) : locally_compact_space (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_181518 (h0 : ring (generalized_boolean_algebra Type)) : rank_condition (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_181519 (h2 : ring (comm_ring char)) : strong_rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_181520 (h0 : complete_lattice (semi_normed_comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_181521 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_emetric_space.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 pos)) (pseudo_emetric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_181522 (h0 : topological_space (has_top empty)) : locally_compact_space (has_top empty) := sorry --non-trivial
lemma new_lemma_181523 (h0 : add_monoid (has_pos_part (has_Inf (has_Inf pos)))) : add_monoid.fg (has_pos_part (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_181524 (h3 : ring (topological_space (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_181525 (h1 : semiring (add_comm_semigroup linarith.ineq)) (h2 : ideal (add_comm_semigroup linarith.ineq)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_181526 (h0 h1 : multiset (add_comm_semigroup char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_181527 (h0 : ring (topological_space char)) : strong_rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_181528 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181529 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) pos) : @normalizer_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_181530 (h0 : filter (has_zero unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181531 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_181532 (h0 : monoid (with_bot (random_gen (semiring congr_arg_kind)))) : monoid.fg (with_bot (random_gen (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_181533 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @is_atomistic.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_181534 (h0 : function.extfun (multiset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@multiset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (multiset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_zero.zero.{2} (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_zero.{2} ((Type → Type) → Type 1))))) ring.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181535 (h0 : topological_space (mul_zero_class (ordered_comm_group (mul_zero_class pos)))) : totally_disconnected_space (mul_zero_class (ordered_comm_group (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_181536 (h0 : complete_lattice environment.projection_info) : complete_lattice.is_Sup_finite_compact environment.projection_info := sorry --non-trivial
lemma new_lemma_181537 (h0 : topological_space (has_one (semiring (has_top congr_arg_kind)))) : totally_separated_space (has_one (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_181538 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181539 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_181540 (h0 : functor.add_const (group Type) pos) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_181541 (h0 : uniform_space (has_compl (has_nnnorm string_imp))) : complete_space (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_181542 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_181543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181544 (h0 : topological_space (has_Sup pos)) : totally_separated_space (has_Sup pos) := sorry --non-trivial
lemma new_lemma_181545 (h0 : add_group (linear_ordered_comm_group_with_zero string.iterator_imp)) : is_add_cyclic (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_181546 (h1 : topological_space (has_nnnorm (random_gen (random_gen char)))) : t0_space (has_nnnorm (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_181547 (h0 : add_group (boolean_algebra (has_add linarith.comp))) : is_add_cyclic (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181548 (h2 : ring (add_cancel_comm_monoid char)) : is_domain (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_181549 (h0 : group (cancel_monoid (finset ennreal))) : group.fg (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_181550 (h0 : topological_space (has_neg_part (has_add name))) : discrete_topology (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_181551 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : locally_compact_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_181552 (h2 : has_nnnorm (has_nnnorm to_additive.value_type) -> has_nnnorm (has_nnnorm to_additive.value_type) -> Prop) : is_trans (has_nnnorm (has_nnnorm to_additive.value_type)) h2 := sorry --non-trivial
lemma new_lemma_181553 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @t0_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_181554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181555 (h0 : topological_space (ring (has_add (has_neg (has_Inf Type))))) : locally_compact_space (ring (has_add (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_181556 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181557 (h0 : add_group (has_to_string (has_to_string (has_to_string (has_to_string pos))))) : is_add_cyclic (has_to_string (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_181558 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181559 (h0 : ring (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source))))) : rank_condition (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_181560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_181561 (h0 h1 : not (multiset (random_gen reducibility_hints) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_181562 (h0 : function.extfun Type (functor.add_const (topological_space (measurable_space.dynkin_system num)))) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_181563 (h0 : topological_space ereal) : totally_disconnected_space ereal := sorry --non-trivial
lemma new_lemma_181564 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_181565 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (id (id h0)))))) := sorry --non-trivial
lemma new_lemma_181566 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : totally_disconnected_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_181567 (h0 : cancel_comm_monoid_with_zero (linear_order congr_arg_kind)) : unique_factorization_monoid (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181568 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181569 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181570 (h0 : topological_space (add_cancel_monoid (has_add pos))) : preirreducible_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_181571 (h0 : group (complete_distrib_lattice (has_to_string (has_to_string pos)))) : group.fg (complete_distrib_lattice (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_181572 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_181573 (h0 : topological_space (ring (has_add linarith.comp))) : loc_path_connected_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181574 (h0 : group (has_neg linarith.comp)) : normalizer_condition (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_181575 (h0 : group (has_sdiff congr_arg_kind)) : is_cyclic (has_sdiff congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181576 (h0 : group (add_cancel_monoid (has_to_string (finset pos)))) : is_simple_group (add_cancel_monoid (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_181577 (h0 : functor.add_const (functor.add_const (topological_space environment.implicit_infer_kind) name) name) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind) name) name h0))  := sorry --non-trivial
lemma new_lemma_181578 (h0 : topological_space (add_comm_monoid (comm_group (comm_group (comm_group Type))))) : path_connected_space (add_comm_monoid (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_181579 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_181580 (h0 : topological_space (ring (option empty))) : topological_space.separable_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_181581 (h0 : uniform_space (with_one (random_gen (random_gen num)))) : separated_space (with_one (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_181582 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @locally_compact_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_181583 (h0 : topological_space (has_append (random_gen (random_gen char)))) : path_connected_space (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_181584 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf pos)))) : sequential_space (boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_181585 (h0 : list (has_top empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181586 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_181587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181588 (h0 : functor.add_const (topological_space (has_nndist ennreal)) Type) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_181589 (h0 : not (topological_space (metric_space empty) -> false)) : @normal_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_181590 (h1 : not (nat -> false)) (h2 : topological_space (sym (has_norm num) (classical.by_contradiction' h1))) : discrete_topology (sym (has_norm num) (classical.by_contradiction' h1)) := sorry --non-trivial
lemma new_lemma_181591 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} (sub_neg_monoid.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} (sub_neg_monoid.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_181592 (h0 : topological_space (mul_zero_class ennreal)) : irreducible_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_181593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_181594 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_neg environment.implicit_infer_kind)) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_181595 (h0 : not (uniform_space (semiring linarith.comp) -> false)) : @separated_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_181596 (h1 : add_group (div_inv_monoid to_additive.value_type)) : is_add_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181597 (h0 : topological_space (add_comm_monoid (option (option empty)))) : loc_path_connected_space (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_181598 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_181599 (h0 : group (boolean_algebra (comm_group (comm_group unsigned)))) : is_cyclic (boolean_algebra (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_181600 (h0 : complete_lattice (has_compl (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_181601 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181602 (h0 : ring (has_add (with_zero string_imp))) : rank_condition (has_add (with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_181603 (h0 : topological_space (finset (option (option pos)))) : path_connected_space (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_181604 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (has_Inf linarith.comp)) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_181605 (h0 : set ordering) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_181606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_181607 (h0 : has_mem.mem (normed_group (has_top (semiring empty))) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} (has_top.{0} (semiring.{0} empty))) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_top.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_181608 (h0 : ring (has_div (has_ssubset reducibility_hints))) : strong_rank_condition (has_div (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_181609 (h0 : not (add_group (complete_semilattice_Sup fun_info) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_181610 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) empty) : @archimedean.{1} (plift.{1} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) empty h0) (plift.{1} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_181611 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181612 (h0 : not (complete_lattice (has_add linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_181613 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg (has_neg real)))) : unique_factorization_monoid (has_pos_part (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_181614 (h0 : filter (pseudo_metric_space ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181615 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @preirreducible_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181616 (h0 : function.extfun num (fun (x : num), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) num (@function.extfun_app.{1 1} num (λ (x : num), Prop) h0)  := sorry --non-trivial
lemma new_lemma_181617 (h0 : topological_space (add_cancel_comm_monoid empty)) : totally_separated_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_181618 (h0 : fin has_zero.zero) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181619 (h1 : group (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_cyclic (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_181620 (h0 : topological_space (denumerable to_additive.value_type)) : t0_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181621 (h0 : monoid (canonically_linear_ordered_monoid (option (has_zero (option (option (option ennreal))))))) : monoid.fg (canonically_linear_ordered_monoid (option (has_zero (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_181622 (h0 : complete_lattice (add_comm_monoid (add_cancel_monoid name))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_181623 (h0 : uniform_space (has_zero num)) : separated_space (has_zero num) := sorry --non-trivial
lemma new_lemma_181624 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181625 (h0 : list (add_cancel_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181626 (h0 : topological_space (linear_ordered_field (option (option (option empty))))) : path_connected_space (linear_ordered_field (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_181627 (h0 : functor.add_const (topological_space (plift empty)) congr_arg_kind) : @locally_compact_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_181628 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_181629 (h0 : list (linear_ordered_field (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181630 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181631 (h0 : functor.add_const (list (has_add (has_to_string environment.implicit_infer_kind))) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181632 (h0 : uniform_space (has_div string_imp)) : complete_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_181633 (h0 : ordered_comm_monoid (has_nndist (finset (finset (finset pos))))) : has_exists_mul_of_le (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_181634 (h0 : monoid (measurable_space (comm_ring to_additive.value_type))) : monoid.fg (measurable_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181635 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_181636 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_181637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_181638 (h0 : functor.comp topological_space finset name) : @preconnected_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_181639 (h0 : finset (complete_distrib_lattice (ring (has_neg (ring name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_181640 (h0 : ring (has_neg (has_neg linarith.comp))) : is_domain (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_181641 (h0 : topological_space (add_left_cancel_semigroup (option (option unsigned)))) : totally_separated_space (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_181642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181643 (h0 : topological_space (as_linear_order (option (option (option num))))) : path_connected_space (as_linear_order (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_181644 (h0 h1 : uniform_space std_gen) (h2 : std_gen -> std_gen) : uniform_embedding h2 := sorry --non-trivial
lemma new_lemma_181645 (h0 : add_group (linear_ordered_comm_ring (semiring empty))) : is_add_cyclic (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_181646 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181647 (h0 : function.extfun Type (functor.add_const (function.extfun Type ring))) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ordered_ring.{0} linarith.comp) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0})) h0 (ordered_ring.{0} linarith.comp))) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_181648 (h0 : topological_space (complete_distrib_lattice (comm_group Type))) : irreducible_space (complete_distrib_lattice (comm_group Type)) := sorry --non-trivial
lemma new_lemma_181649 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181650 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181651 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_181652 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_181653 (h0 : complete_lattice (with_bot (has_norm linarith.comp))) : is_compactly_generated (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_181654 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph pos)) pos) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_181655 (h0 : group (has_nndist empty)) : is_cyclic (has_nndist empty) := sorry --non-trivial
lemma new_lemma_181656 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : irreducible_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_181657 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181658 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : preconnected_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_181659 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_181660 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_181661 (h0 : uniform_space (comm_group (has_neg_part (has_neg_part unsigned)))) : complete_space (comm_group (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_181662 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) name) : @sequential_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_181663 (h0 : topological_space (has_add (has_add (has_add (has_add (has_Inf (has_Inf Type))))))) : totally_separated_space (has_add (has_add (has_add (has_add (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_181664 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_181665 (h0 : topological_space (has_add (mul_one_class linarith.comp))) : totally_disconnected_space (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_181666 (h0 : functor.add_const (list (has_zero linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181667 (h0 : filter (preorder unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181668 (h0 : topological_space (has_to_string (finset (has_to_string linarith.comp)))) : irreducible_space (has_to_string (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_181669 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_pos_part linarith.comp)) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_pos_part.{0} linarith.comp) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_181670 (h0 : topological_space (semigroup (mul_zero_class (cancel_monoid pos)))) : totally_disconnected_space (semigroup (mul_zero_class (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_181671 (h0 : monoid (with_bot (random_gen linarith.comp_source))) : monoid.fg (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_181672 (h0 : topological_space (left_cancel_monoid unsigned)) : topological_space.separable_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_181673 (h0 : add_group (has_pos_part (has_add linarith.comp))) : is_add_cyclic (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181674 (h0 : topological_space (has_neg (option ennreal))) : totally_disconnected_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_181675 (h2 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : t0_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181676 (h0 : group (canonically_ordered_monoid (has_add linarith.comp))) : normalizer_condition (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_181678 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : irreducible_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181679 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_181680 (h0 : complete_lattice (semigroup (ring Type))) : is_compactly_generated (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_181681 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_181682 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_181683 (h0 : topological_space (has_nnnorm (topological_space char))) : t0_space (has_nnnorm (topological_space char)) := sorry --non-trivial
lemma new_lemma_181684 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) (has_Inf Type)) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181685 (h0 : topological_space (group_with_zero (option num))) : t0_space (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_181686 (h0 : finset (free_add_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_181687 (h1 : topological_space (right_cancel_semigroup char)) : totally_disconnected_space (right_cancel_semigroup char) := sorry --non-trivial
lemma new_lemma_181688 (h0 : functor.comp topological_space comm_group Type) : @totally_separated_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_181689 (h0 : topological_space (add_cancel_monoid (has_add (finset (finset linarith.comp))))) : loc_path_connected_space (add_cancel_monoid (has_add (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_181690 (h0 : topological_space (conditionally_complete_linear_order empty)) : discrete_topology (conditionally_complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_181691 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181692 (h0 : functor.add_const (ring (semigroup pos)) name) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_181693 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_atomistic (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181694 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_181695 (h0 : topological_space (id (has_norm fun_info))) : totally_separated_space (id (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_181696 (h0 : ordered_comm_monoid (has_add (finset (has_add environment.implicit_infer_kind)))) : has_exists_mul_of_le (has_add (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_181697 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) pos) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_181698 (h0 : monoid (ring (option (option (option empty))))) : monoid.fg (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_181699 (h0 : monoid environment.implicit_infer_kind) : monoid.fg environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_181700 (h0 : functor.add_const (add_monoid (ring Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181701 (h0 : topological_space (add_cancel_monoid (ring name))) : totally_separated_space (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_181702 (h0 : list (ring (has_zero (ring Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181703 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_181704 (h0 : uniform_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf real))))) : separated_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_181705 (h1 : complete_lattice (has_emptyc linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181706 (h0 : add_monoid (ordered_comm_ring environment.implicit_infer_kind)) : add_monoid.fg (ordered_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_181707 (h0 : measurable_space (id unsigned)) (h1 : has_add (id unsigned)) : has_measurable_add (id unsigned) := sorry --non-trivial
lemma new_lemma_181708 (h0 : ring (cancel_monoid (option (option pos)))) : is_principal_ideal_ring (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_181709 (h0 : has_mem.mem filter has_emptyc.emptyc) : filter.ne_bot (function.extfun_app (finset.pi.empty (function.extfun Type) filter h0) unsigned) := sorry --non-trivial
lemma new_lemma_181710 (h0 : topological_space (has_bot (has_Inf (has_bot (has_Inf real))))) : regular_space (has_bot (has_Inf (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_181711 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order unsigned)))) : @irreducible_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_181712 (h0 : topological_space (has_star congr_arg_kind)) : normal_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181713 (h0 : not (topological_space num -> false)) : @preirreducible_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_181714 (h0 : uniform_space (sub_neg_monoid (finset linarith.comp))) : separated_space (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_181715 (h0 : not (topological_space (bin_tree congr_arg_kind) -> false)) : @totally_separated_space.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_181716 (h0 : functor.comp complete_lattice complete_distrib_lattice name) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_181717 (h0 : group (metric_space (comm_ring reducibility_hints))) : is_cyclic (metric_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_181718 (h0 : has_mem.mem (semiring (has_norm (has_norm linarith.comp))) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (semiring (has_norm (has_norm linarith.comp))) h0) := sorry --non-trivial
lemma new_lemma_181719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181720 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @irreducible_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_181721 (h1 : has_coe char Prop) (h2 : char) : @coe_b.{1 1} char Prop h1 h2  := sorry --non-trivial
lemma new_lemma_181722 (h0 : topological_space (has_dist (option empty))) : normal_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_181723 (h0 : complete_lattice (comm_group (add_cancel_monoid name))) : is_atomistic (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_181724 (h0 : topological_space (has_nndist (boolean_algebra (boolean_algebra (semigroup name))))) : irreducible_space (has_nndist (boolean_algebra (boolean_algebra (semigroup name)))) := sorry --non-trivial
lemma new_lemma_181725 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181726 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181727 (h0 : topological_space (pseudo_metric_space ennreal)) : preirreducible_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_181728 (h0 : list (free_add_monoid (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181729 (h0 : complete_lattice (group_with_zero (option empty))) : is_atomistic (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_181730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_181731 (h0 : ring (denumerable (random_gen (random_gen (random_gen linarith.comp_source))))) : rank_condition (denumerable (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_181732 (h0 : topological_space (has_Sup empty)) : path_connected_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_181733 (h0 : topological_space (has_add (option (option ennreal)))) : t1_space (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_181734 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_181735 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) : path_connected_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_181736 (h1 : ring (denumerable linarith.ineq)) : rank_condition (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_181737 (h0 : functor.add_const (topological_space Type) pos) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_181738 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_181739 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_order empty)) congr_arg_kind) : @unique_factorization_monoid.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_181740 (h0 : topological_space (has_add (ring (semigroup Type)))) : topological_space.separable_space (has_add (ring (semigroup Type))) := sorry --non-trivial
lemma new_lemma_181741 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_181742 (h0 : functor.comp ring add_group name) : @is_principal_ideal_ring.{0} (add_group.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_181743 (h0 : ring (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_domain (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181744 (h0 : topological_space (has_to_string (has_nndist pos))) : topological_space.separable_space (has_to_string (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_181745 (h0 : topological_space (comm_semigroup (has_add Type))) : sequential_space (comm_semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_181746 (h0 : ordered_comm_monoid (has_neg pos)) : has_exists_mul_of_le (has_neg pos) := sorry --non-trivial
lemma new_lemma_181747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_181748 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @is_cyclic.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_181749 (h0 : semiring (has_zero unsigned)) : is_noetherian_ring (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_181750 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_181751 (h3 : not (complete_lattice linarith.ineq -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.ineq) h3)  := sorry --non-trivial
lemma new_lemma_181752 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_181753 (h0 : ring (complete_linear_order unsigned)) : strong_rank_condition (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_181754 (h0 : topological_space (monoid unsigned) -> Prop) (h1 : Exists (fun (x : topological_space (monoid unsigned)), h0 x)) : @totally_separated_space.{0} (monoid.{0} unsigned) (@classical.some.{1} (topological_space.{0} (monoid.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_181755 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) unsigned) : @is_atomistic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181756 (h0 : topological_space (complete_semilattice_Sup (finset (has_to_string pos)))) : locally_compact_space (complete_semilattice_Sup (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_181757 (h0 : functor.add_const (complete_lattice (has_zero name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181758 (h0 : not (group (option num) -> false)) : @group.fg.{0} (option.{0} num) (@classical.by_contradiction'.{1} (group.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_181759 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181761 (h0 : monoid (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf pos))))) : monoid.fg (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_181762 (h0 : ring (ordered_comm_ring (has_neg (has_pos_part pos)))) : rank_condition (ordered_comm_ring (has_neg (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_181763 (h0 : functor.add_const (finset (cancel_monoid pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181764 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @irreducible_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181765 (h0 : list (has_Inf (has_pos_part (finset (has_add pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181766 (h0 : functor.add_const (complete_lattice (has_dist empty)) (option empty)) : @is_atomistic.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_181767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181768 (h0 : not (ring (with_zero linarith.comp_source) -> false)) : @strong_rank_condition.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_181769 (h0 : group (has_top (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (has_top (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_181770 (h0 : topological_space (has_one unsigned)) : locally_compact_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_181771 (h0 : not (ring (measurable_space.dynkin_system linarith.comp) -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_181772 (h0 : functor.add_const (topological_space (preorder num)) num) : @locally_compact_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_181773 (h2 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_disconnected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181774 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : @unique_factorization_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181775 (h2 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h2 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181776 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : topological_space.separable_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_181777 (h0 : functor.add_const (filter (semigroup linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181778 (h0 : ring (has_top linarith.comp)) : strong_rank_condition (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_181779 (h0 : list (add_left_cancel_semigroup (semiring (semiring unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181780 (h0 : list (ring (encodable string_imp))) (h1 : ne h0 list.nil) : @is_domain.{0} (encodable.{0} string_imp) (@list.last.{0} (ring.{0} (encodable.{0} string_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_181781 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_181782 (h0 : function.extfun Type (functor.add_const (ring (left_cancel_monoid unsigned)))) : @strong_rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_181783 (h0 : topological_space (has_norm (has_norm (has_norm unsigned)))) : irreducible_space (has_norm (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_181784 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @normal_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_181785 (h7 : add_group (simple_graph linarith.ineq)) : is_add_cyclic (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_181786 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero ennreal)) linarith.comp) : @unique_factorization_monoid.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181787 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) add_monoid.{1}) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_181788 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) pos) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_181789 (h1 : topological_space to_additive.value_type) (h2 : add_group to_additive.value_type) : topological_add_group to_additive.value_type := sorry --non-trivial
lemma new_lemma_181790 (h0 : functor.add_const (list (has_neg pos)) (has_neg name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181791 (h0 : functor.add_const (complete_lattice (cancel_monoid environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_181792 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181793 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @discrete_topology.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_181794 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_181795 (h0 : not (complete_lattice (linear_ordered_comm_ring unsigned) -> false)) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_181796 (h0 : fin has_zero.zero) : @monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181797 (h1 : uniform_space (simple_graph std_gen)) : complete_space (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_181798 (h0 : ring (distrib (has_nnnorm (random_gen (has_nnnorm (has_nnnorm (has_nnnorm char))))))) : rank_condition (distrib (has_nnnorm (random_gen (has_nnnorm (has_nnnorm (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_181799 (h0 : functor.add_const (topological_space (preorder unsigned)) unsigned) : @locally_compact_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181800 (h0 : topological_space (comm_ring (random_gen fun_info))) : totally_disconnected_space (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_181801 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : loc_path_connected_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_181802 (h0 : fin has_zero.zero) : @irreducible_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181803 (h0 : not (complete_lattice (fintype fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_181804 (h1 : bool -> bool -> Prop) (h2 h3 : not (bool -> false)) : relation.refl_gen h1 (classical.by_contradiction' h2) (classical.by_contradiction' h3) := sorry --trivial
lemma new_lemma_181805 (h0 : uniform_space (add_group (has_norm unsigned))) : separated_space (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_181806 (h0 : topological_space (comm_group (has_neg linarith.comp))) : totally_separated_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_181807 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_181808 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_181809 (h0 : filter (has_to_string (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181810 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_181811 (h0 : topological_space (ordered_ring congr_arg_kind)) : irreducible_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181812 (h0 : ring (comm_ring (has_ssubset (has_ssubset string_imp)))) : strong_rank_condition (comm_ring (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_181813 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_181814 (h0 : topological_space (has_lt linarith.ineq) -> topological_space (has_lt linarith.ineq) -> Prop) (h1 : well_founded h0) (h2 : set (topological_space (has_lt linarith.ineq))) (h3 : set.bounded h0 h2) : @t0_space.{0} (has_lt.{0} linarith.ineq) (@well_founded.sup.{0} (topological_space.{0} (has_lt.{0} linarith.ineq)) h0 h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_181815 (h0 : monoid (semiring to_additive.value_type)) : monoid.fg (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181817 (h0 : not (complete_lattice (bin_tree congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_181818 (h0 : ordered_add_comm_monoid (has_neg_part (semigroup name))) : archimedean (has_neg_part (semigroup name)) := sorry --non-trivial
lemma new_lemma_181819 (h0 : group (canonically_ordered_monoid pos)) : normalizer_condition (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_181820 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_181821 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181822 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_181823 (h0 : not (prod (with_bot congr_arg_kind) (with_bot congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_181824 (h0 : topological_space (has_nndist (comm_group (ring Type)))) : normal_space (has_nndist (comm_group (ring Type))) := sorry --non-trivial
lemma new_lemma_181825 (h0 : ring (linear_ordered_comm_monoid_with_zero (semiring (semiring (option unsigned))))) : strong_rank_condition (linear_ordered_comm_monoid_with_zero (semiring (semiring (option unsigned)))) := sorry --non-trivial
lemma new_lemma_181826 (h0 : topological_space (has_emptyc (semiring linarith.comp))) : totally_separated_space (has_emptyc (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_181827 (h0 : ring (has_dist unsigned)) : strong_rank_condition (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_181828 (h0 : list (has_to_string (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181829 (h0 : complete_lattice (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : is_compactly_generated (normed_linear_ordered_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_181830 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf (has_Inf (has_Inf pos)))) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_Inf.{0} (has_Inf.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_181831 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_181832 (h1 : ring (random_gen (comm_ring (metric_space reducibility_hints)))) : strong_rank_condition (random_gen (comm_ring (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_181833 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_181834 (h0 : ring (has_norm (has_top (has_top linarith.comp_source)))) : is_domain (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_181835 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @separated_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_181836 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181837 (h0 : ring (has_one num)) : is_domain (has_one num) := sorry --non-trivial
lemma new_lemma_181838 (h0 : topological_space (with_one unsigned)) : totally_separated_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_181839 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_181840 (h0 : ordered_comm_monoid (has_Inf (has_add (generalized_boolean_algebra linarith.comp)))) : has_exists_mul_of_le (has_Inf (has_add (generalized_boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_181841 (h1 : not (ring (has_compl linarith.ineq) -> false)) : @rank_condition.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_181842 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_181843 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_181844 (h0 : function.extfun Type (functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)))) : @is_compactly_generated.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_181845 (h0 : set (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_181846 (h0 : topological_space (has_to_string congr_arg_kind)) : irreducible_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181848 (h0 : topological_space (has_nndist (has_neg Type))) : totally_disconnected_space (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181849 (h0 : functor.add_const (filter (ring Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_181850 (h1 : set (uniform_space linarith.ineq)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_181851 (h0 : topological_space (has_top (random_gen (has_norm linarith.ineq)))) : irreducible_space (has_top (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_181852 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181853 (h0 : complete_lattice (boolean_algebra.core empty)) : is_atomistic (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_181854 (h0 : not (topological_space Type -> false)) : @totally_disconnected_space.{1} Type (@classical.by_contradiction'.{2} (topological_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_181855 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_181856 (h0 : functor.comp ring canonically_ordered_comm_semiring (semigroup pos)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} (semigroup.{0} pos)) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} (semigroup.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181857 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181858 (h0 : filter (has_zero (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181859 (h0 : topological_space (has_norm (has_inv linarith.comp_source))) : totally_separated_space (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_181860 (h0 : group (ordered_comm_ring linarith.comp)) : is_simple_group (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_181861 (h0 : topological_space (has_zero (has_to_string environment.implicit_infer_kind))) : normal_space (has_zero (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_181862 (h0 : list (left_cancel_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_181863 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @is_cyclic.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_181864 (h0 : group (id (has_norm (has_norm num)))) : normalizer_condition (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_181865 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_181866 (h0 : functor.add_const (monoid (comm_group ennreal)) Type) : @monoid.fg.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_181867 (h0 : complete_lattice (add_group (semiring empty))) : complete_lattice.is_Sup_finite_compact (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_181868 (h0 : topological_space (semigroup (has_pos_part Type))) : totally_disconnected_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_181869 (h1 : complete_lattice (div_inv_monoid fun_info)) : is_compactly_generated (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_181870 (h0 : not (add_group (measure_theory.measure_space num) -> false)) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_181871 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_neg)) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_181872 (h0 : topological_space (has_neg_part (has_nndist name))) : totally_separated_space (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_181873 (h0 : add_group (semigroup (option unsigned))) : is_add_cyclic (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_181874 (h0 : functor.add_const (complete_lattice (sub_neg_monoid linarith.comp)) name) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_181875 (h1 : topological_space linarith.comp_source) : irreducible_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_181876 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_add (has_neg (has_Inf real)))))) : preirreducible_space (normed_lattice_add_comm_group (has_bot (has_add (has_neg (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_181877 (h0 : topological_space (add_comm_monoid empty)) : path_connected_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_181878 (h1 : topological_space (uniform_space fun_info)) : totally_disconnected_space (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_181879 (h0 : add_monoid (comm_group (has_to_string Type))) : add_monoid.fg (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_181880 (h0 : topological_space (complete_linear_order (semiring (semiring unsigned)))) : locally_compact_space (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_181881 (h0 : functor.add_const (complete_lattice (has_to_string pos)) (option (option (option pos)))) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_181882 (h0 : fin has_zero.zero) : @group.fg.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_181883 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) (option pos)) : @t0_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_181884 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm empty)) := sorry --non-trivial
lemma new_lemma_181885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_181887 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_181888 (h0 : ring (has_norm (has_norm (random_gen linarith.comp_source)))) : strong_rank_condition (has_norm (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_181889 (h1 : monoid (with_one linarith.comp_source)) : monoid.fg (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181890 (h0 : topological_space (add_group num)) : totally_separated_space (add_group num) := sorry --non-trivial
lemma new_lemma_181891 (h0 : complete_lattice (distrib_lattice char)) : is_compactly_generated (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_181892 (h0 : topological_space (add_cancel_monoid (has_nndist pos))) : loc_path_connected_space (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_181893 (h0 : functor.add_const (topological_space (ring Type)) pos) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_181894 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_181895 (h0 : functor.add_const (add_group (has_neg_part linarith.comp)) pos) : @is_add_cyclic.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_181896 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_181897 (h0 : ring (semi_normed_comm_ring ereal)) : rank_condition (semi_normed_comm_ring ereal) := sorry --non-trivial
lemma new_lemma_181898 (h0 : filter (ordered_comm_ring (has_Inf Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_181899 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_181900 (h1 : ring (uniform_space string_imp)) : is_domain (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_181901 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg Type))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181902 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_181903 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (has_add name)))) : normal_space (add_cancel_monoid (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_181904 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_181905 (h0 : topological_space (finset (has_add (finset linarith.comp)))) : path_connected_space (finset (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_181906 (h0 : add_monoid (simple_graph (ring Type))) : add_monoid.fg (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_181907 (h0 : topological_space (sub_neg_monoid (has_neg Type))) : locally_compact_space (sub_neg_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181908 (h3 : complete_lattice (nondiscrete_normed_field linarith.ineq)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_181909 (h0 : functor.add_const (group (plift empty)) (semiring (semiring (semiring num)))) : @normalizer_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_181910 (h0 : function.extfun Type topological_space) : @t1_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181911 (h0 : uniform_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : separated_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_181912 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg_part linarith.comp)) name) : @archimedean.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_181913 (h0 : topological_space (has_add (has_neg Type))) : regular_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_181914 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_181915 (h0 : topological_space (has_Inf linarith.comp)) : discrete_topology (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_181916 (h0 : topological_space (division_ring congr_arg_kind)) : irreducible_space (division_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181917 (h0 : complete_lattice (has_ssubset linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_181918 (h0 : list (has_zero (finset (finset environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_181920 (h0 : fin has_zero.zero) : @t0_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_181921 (h0 : topological_space (boolean_algebra (boolean_algebra (has_neg pos)))) : totally_separated_space (boolean_algebra (boolean_algebra (has_neg pos))) := sorry --non-trivial
lemma new_lemma_181922 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_181923 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_181924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181925 (h0 : topological_space (add_right_cancel_monoid unsigned)) : t0_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_181926 (h0 : semiring (add_left_cancel_semigroup unsigned)) : is_noetherian_ring (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_181927 (h0 : functor.comp finset normed_comm_ring name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_181928 (h0 : topological_space string_imp) : totally_disconnected_space string_imp := sorry --non-trivial
lemma new_lemma_181929 (h0 : topological_space (has_neg_part pos)) : totally_separated_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_181930 (h1 : topological_space (nondiscrete_normed_field linarith.ineq)) : totally_disconnected_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_181931 (h0 : complete_lattice (has_neg pos)) : complete_lattice.is_Sup_finite_compact (has_neg pos) := sorry --non-trivial
lemma new_lemma_181932 (h0 : ring (has_Sup congr_arg_kind)) : rank_condition (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181933 (h0 : topological_space (with_one (has_norm fun_info))) : irreducible_space (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_181934 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_181935 (h0 : not (topological_space real.angle -> false)) (h1 : preorder real.angle) : @order_topology.{0} real.angle (@classical.by_contradiction'.{1} (topological_space.{0} real.angle) h0) h1  := sorry --non-trivial
lemma new_lemma_181936 (h0 : complete_lattice (has_inv char)) : is_compactly_generated (has_inv char) := sorry --non-trivial
lemma new_lemma_181937 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_181939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_181940 (h0 : semiring (bin_tree empty)) : is_noetherian_ring (bin_tree empty) := sorry --non-trivial
lemma new_lemma_181941 (h0 : add_group (has_compl (linear_ordered_field linarith.ineq))) : is_add_cyclic (has_compl (linear_ordered_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_181942 (h0 : topological_space (linear_ordered_semiring (has_top (has_top empty)))) : totally_separated_space (linear_ordered_semiring (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_181943 (h0 : pseudo_metric_space (dlist string_imp)) (h1 : set (dlist string_imp)) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_181944 (h0 : group (has_inv (has_ssubset (random_gen to_additive.value_type)))) : group.fg (has_inv (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_181945 (h0 : not (topological_space (comm_ring linarith.comp_source) -> false)) : @t0_space.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_181946 (h0 : functor.add_const (complete_lattice (comm_group pos)) name) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_181947 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181948 (h0 : topological_space (has_pos_part (has_add real))) : loc_path_connected_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_181949 (h0 : group (has_emptyc num)) : is_cyclic (has_emptyc num) := sorry --non-trivial
lemma new_lemma_181950 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_181951 (h0 : complete_lattice (has_add (option ennreal))) : is_compactly_generated (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_181952 (h0 : topological_space (semiring linarith.comp)) : t0_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_181953 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid (has_Inf pos)))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_181954 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : totally_separated_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_181955 (h0 : uniform_space (normed_lattice_add_comm_group linarith.comp)) : complete_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_181956 (h0 : topological_space (add_cancel_monoid linarith.comp)) : totally_separated_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_181957 (h0 : ring (has_top (random_gen to_additive.value_type))) : is_domain (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_181958 (h0 : topological_space (has_inter (option (option (option (option ennreal)))))) : discrete_topology (has_inter (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_181959 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181960 (h1 : ring (random_gen string_imp)) : rank_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_181961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_181962 (h0 : complete_lattice (denumerable (random_gen (has_inv (has_inv linarith.ineq))))) : is_compactly_generated (denumerable (random_gen (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_181963 (h0 : topological_space (free_add_monoid empty)) : irreducible_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_181964 (h0 : topological_space (add_comm_monoid (ring (finset (ring (ring linarith.comp)))))) : preconnected_space (add_comm_monoid (ring (finset (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_181965 (h0 : ring (boolean_algebra (has_Inf linarith.comp))) : is_domain (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_181966 (h0 : topological_space (with_bot (has_inv linarith.ineq))) : totally_disconnected_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_181967 (h1 : filter (has_norm (comm_ring (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_181968 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_181969 (h0 : function.extfun nat fin) : @rank_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_181970 (h0 : topological_space (has_edist congr_arg_kind)) : totally_separated_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_181971 (h0 : topological_space (has_ssubset (random_gen fun_info))) : irreducible_space (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_181972 (h0 : topological_space (normed_field (random_gen string.iterator_imp))) : t0_space (normed_field (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_181973 (h0 : group (has_neg (ring (finset (ring (ring (ring pos))))))) : group.fg (has_neg (ring (finset (ring (ring (ring pos)))))) := sorry --non-trivial
lemma new_lemma_181974 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @locally_compact_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_181975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_181976 (h0 : topological_space (finset (has_Inf (has_Inf Type)))) : locally_compact_space (finset (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_181977 (h0 : topological_space (id (has_norm linarith.comp))) : discrete_topology (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_181978 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_181979 (h0 : list (has_star (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_181980 (h0 : topological_space (has_neg_part Type)) : irreducible_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_181981 (h0 : functor.add_const (topological_space (semigroup (option unsigned))) num) : @totally_separated_space.{0} (semigroup.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} (option.{0} unsigned))) num h0)  := sorry --non-trivial
lemma new_lemma_181982 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) congr_arg_kind) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_181983 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_181984 (h0 : complete_lattice (measurable_space.dynkin_system (has_top unsigned))) : is_atomistic (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_181985 (h1 : complete_lattice (semilattice_inf to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semilattice_inf to_additive.value_type) := sorry --non-trivial
lemma new_lemma_181986 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_181987 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_181988 (h0 : not (group (has_compl to_additive.value_type) -> false)) : @group.fg.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_181989 (h0 : group (non_unital_non_assoc_semiring (random_gen reducibility_hints))) : is_cyclic (non_unital_non_assoc_semiring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_181990 (h0 : has_to_string (normed_comm_ring pos) -> has_to_string (normed_comm_ring pos) -> Prop) : is_refl (has_to_string (normed_comm_ring pos)) h0 := sorry --non-trivial
lemma new_lemma_181991 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_181992 (h0 : functor.add_const (ring (has_add Type)) environment.implicit_infer_kind) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_181993 (h0 : ring (rel linarith.ineq linarith.ineq)) : is_domain (rel linarith.ineq linarith.ineq) := sorry --non-trivial
lemma new_lemma_181994 (h0 : random_gen string_imp -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_181995 (h0 : topological_space (linear_ordered_comm_group (option (option (option (option unsigned)))))) : totally_disconnected_space (linear_ordered_comm_group (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_181996 (h0 : fin has_zero.zero) : @separated_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_181997 (h0 : ring (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_181998 (h0 : filter (random_gen (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_181999 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_182000 (h1 : topological_space (simple_graph reducibility_hints)) : totally_disconnected_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_182001 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (has_neg pos)) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182002 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (omega_complete_partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182003 (h0 : filter (has_top (random_gen (random_gen string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182004 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @locally_compact_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_182005 (h0 : add_monoid (ordered_comm_monoid (has_Inf pos))) : add_monoid.fg (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_182006 (h0 : not (topological_space (has_norm unsigned) -> false)) : @locally_compact_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_182007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_union empty)) := sorry --non-trivial
lemma new_lemma_182008 (h0 : topological_space (group_with_zero (option ennreal))) : irreducible_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_182009 (h0 : topological_space (has_to_string (has_to_string pos))) : preconnected_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_182010 (h0 : ereal -> char) (h1 : char -> ereal) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_182011 (h1 : function.extfun Type group) : @group.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182012 (h0 : ring (semigroup (has_add Type))) : rank_condition (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_182013 (h0 : functor.add_const (group (complete_distrib_lattice Type)) Type) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_182014 (h0 : add_group (metric_space (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (metric_space (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_182015 (h0 : not (topological_space (has_one empty) -> false)) : @irreducible_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182016 (h0 : functor.add_const (group (ordered_comm_ring Type)) pos) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_182017 (h0 : monoid (has_Sup (partial_order (option empty)))) : monoid.fg (has_Sup (partial_order (option empty))) := sorry --non-trivial
lemma new_lemma_182018 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182019 (h0 : complete_lattice (normed_field (comm_ring (comm_ring char)))) : is_compactly_generated (normed_field (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_182020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_182021 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_182022 (h0 : function.extfun Type group) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182023 (h0 : topological_space (add_cancel_monoid (has_to_string name))) : totally_disconnected_space (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_182024 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring Type))) : locally_compact_space (canonically_ordered_comm_semiring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_182025 (h0 : group (has_one (semiring num))) : group.fg (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_182026 (h0 : topological_space (complete_semilattice_Sup empty)) : locally_compact_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_182027 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182028 (h0 : complete_lattice (has_emptyc (random_gen to_additive.value_type))) : is_compactly_generated (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_182029 (h0 : monoid (canonically_ordered_monoid (canonically_linear_ordered_monoid Type))) : monoid.fg (canonically_ordered_monoid (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_182030 (h0 : functor.add_const (functor.add_const (ring pos) Type) (add_cancel_monoid linarith.comp)) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 1} (ring.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ring.{0} pos) Type) (add_cancel_monoid.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_182031 (h0 : list (plift (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182032 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : discrete_topology (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_182033 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182034 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182035 (h0 : complete_lattice (mul_one_class linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_182036 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182037 (h0 : functor.add_const (uniform_space (ordered_ring empty)) (semiring (semiring (semiring congr_arg_kind)))) : @separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_182038 (h0 : topological_space (has_zero (ring (ring (ring Type))))) : sequential_space (has_zero (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_182039 (h0 : add_group (with_one (comm_ring fun_info))) : is_add_cyclic (with_one (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_182040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_182041 (h0 : topological_space (has_pos_part (has_pos_part pos))) : discrete_topology (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_182042 (h0 : topological_space (with_one (has_norm congr_arg_kind))) : t0_space (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182043 (h1 : complete_lattice (div_inv_monoid string_imp)) : is_compactly_generated (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_182044 (h0 : group (linear_ordered_semiring (semiring num))) : group.fg (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_182045 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_182046 (h0 : add_group (random_gen char)) : is_add_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_182047 (h0 : topological_space (with_bot unsigned)) : t0_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_182048 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_182049 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_Inf Type))) : is_compactly_generated (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_182050 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : t0_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_182051 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182052 (h0 : functor.add_const (topological_space (linear_ordered_comm_group unsigned)) unsigned) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182054 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_182055 (h0 : ordered_add_comm_monoid (has_nndist (option (option name)))) : archimedean (has_nndist (option (option name))) := sorry --non-trivial
lemma new_lemma_182056 (h0 : add_monoid (normed_group (has_top empty))) : add_monoid.fg (normed_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_182057 (h0 : group (has_top num)) : normalizer_condition (has_top num) := sorry --non-trivial
lemma new_lemma_182058 (h0 : ordered_comm_monoid (boolean_algebra.core (ring linarith.comp))) : has_exists_mul_of_le (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_182059 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182060 (h0 : list (topological_space (semiring linarith.ineq))) (h1 : function.extfun ((eq h0 list.nil -> Prop) -> Prop) (function.extfun (eq h0 list.nil -> Prop))) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@list.last.{0} (topological_space.{0} (semiring.{0} linarith.ineq)) h0 (@function.extfun_app.{0 0} (@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq)))) (λ (x : @eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq)))), false) (@function.extfun_app.{1 0} (@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) → Prop) (function.extfun.{0 0} (@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq))))) (@function.extfun_app.{1 0} ((@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) → Prop) → Prop) (function.extfun.{1 0} (@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) → Prop)) h1 (function.extfun.{0 0} (@eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq)))))) (λ (x : @eq.{1} (list.{0} (topological_space.{0} (semiring.{0} linarith.ineq))) h0 (@list.nil.{0} (topological_space.{0} (semiring.{0} linarith.ineq)))), false))))  := sorry --non-trivial
lemma new_lemma_182061 (h0 : topological_space (finset (has_neg (has_neg environment.implicit_infer_kind)))) : path_connected_space (finset (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_182062 (h0 : uniform_space (has_to_string (semigroup Type))) : separated_space (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_182063 (h0 : uniform_space (has_bot (finset Type))) : separated_space (has_bot (finset Type)) := sorry --non-trivial
lemma new_lemma_182064 (h0 : not (monoid (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_182065 (h0 : semiring (pseudo_metric_space empty)) : is_noetherian_ring (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_182066 (h0 : Type -> Type) (h1 : nat) (h2 : topological_space (has_ssubset (nat.iterate h0 h1 string.iterator_imp))) : totally_disconnected_space (has_ssubset (nat.iterate h0 h1 string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_182067 (h0 : not (topological_space (uniform_space reducibility_hints) -> false)) : @path_connected_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_182068 (h0 : list (has_dist (option (option (option num))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182069 (h4 : topological_space string.iterator_imp) : path_connected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_182070 (h0 : ring (normed_field (mul_one_class char))) : strong_rank_condition (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_182071 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_182072 (h0 : topological_space (boolean_algebra (has_bot (finset real)))) : preconnected_space (boolean_algebra (has_bot (finset real))) := sorry --non-trivial
lemma new_lemma_182073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182074 (h0 : not (topological_space (semi_normed_ring (uniform_space string.iterator_imp)) -> false)) : @t0_space.{0} (semi_normed_ring.{0} (uniform_space.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (uniform_space.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_182075 (h1 : uniform_space (add_right_cancel_monoid linarith.comp_source)) : complete_space (add_right_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_182076 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @totally_separated_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182077 (h0 : topological_space (normed_comm_ring (boolean_algebra (has_add pos)))) : regular_space (normed_comm_ring (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_182078 (h0 : topological_space (has_Inf (finset (has_add (has_add linarith.comp))))) : preirreducible_space (has_Inf (finset (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_182079 (h0 : topological_space (canonically_ordered_monoid (has_pos_part linarith.comp))) : loc_path_connected_space (canonically_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_182080 (h0 : add_monoid (ring (has_neg_part linarith.comp))) : add_monoid.fg (ring (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_182081 (h0 : uniform_space (partial_order empty)) : separated_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_182082 (h0 : topological_space (monoid ennreal)) : normal_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_182083 (h0 : semiring (complete_distrib_lattice (has_add linarith.comp))) : is_noetherian_ring (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_182084 (h0 : add_monoid (with_bot (has_top empty))) : add_monoid.fg (with_bot (has_top empty)) := sorry --non-trivial
lemma new_lemma_182085 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_182086 (h0 : list (has_zero (has_add unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182087 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : totally_separated_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_182088 (h0 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_182089 (h0 : group (linear_ordered_semiring (has_top linarith.comp))) : group.fg (linear_ordered_semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_182090 (h0 : topological_space (finset ennreal)) : totally_separated_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_182091 (h1 : has_lt (normed_field std_gen)) : no_max_order (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_182092 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @discrete_topology.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_182093 (h0 : complete_lattice (add_cancel_monoid (has_to_string name))) : is_atomistic (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_182094 (h0 : functor.add_const (functor.add_const (group linarith.comp) name) pos) : @group.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) name) pos h0))  := sorry --non-trivial
lemma new_lemma_182095 (h0 : list (canonically_ordered_comm_semiring (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182097 (h0 : filter (with_bot (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182098 (h0 : uniform_space (has_top (semiring unsigned))) : separated_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182099 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (with_bot to_additive.value_type) h0) := sorry --non-trivial
lemma new_lemma_182100 (h0 : group (boolean_algebra.core (option pos))) (h1 : subgroup (boolean_algebra.core (option pos))) : subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_182101 (h0 : functor.comp ring ordered_cancel_add_comm_monoid pos) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} ordered_cancel_add_comm_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_182102 (h0 : ring (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_Inf pos)))))) : rank_condition (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_182103 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_182104 (h0 : topological_space (complete_distrib_lattice (finset Type))) : totally_disconnected_space (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_182105 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) pos) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_182106 (h0 : complete_lattice string.iterator_imp) : complete_lattice.is_Sup_finite_compact string.iterator_imp := sorry --non-trivial
lemma new_lemma_182107 (h0 : filter (has_to_string (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182108 (h0 : uniform_space (nondiscrete_normed_field char)) : complete_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_182109 (h1 : complete_lattice (linear_ordered_add_comm_group num)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_182110 (h0 : filter (has_neg_part ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_182111 (h0 : group (semigroup (finset pos))) : is_simple_group (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_182112 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_182113 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_182114 (h0 : complete_lattice (has_ssubset enat)) : complete_lattice.is_Sup_finite_compact (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_182115 (h0 : group (semiring fun_info)) : normalizer_condition (semiring fun_info) := sorry --non-trivial
lemma new_lemma_182116 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182117 (h0 : topological_space (linear_ordered_comm_group empty)) : totally_disconnected_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_182118 (h0 : finset (has_nndist (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182119 (h0 : prod (has_one congr_arg_kind) (has_one congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_182120 (h0 : semiring (has_bot (sub_neg_monoid real))) : is_noetherian_ring (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_182121 (h0 : group (has_norm (random_gen congr_arg_kind))) : normalizer_condition (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182122 (h0 : function.extfun Type (functor.add_const (function.extfun Type ring))) : @is_domain.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0})) h0 pos)) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_182123 (h0 : ring (has_add (option (option pos)))) : rank_condition (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_182124 (h0 : functor.comp topological_space complete_distrib_lattice name) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_182125 (h0 : functor.add_const (ring (has_neg Type)) unsigned) : @rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182126 (h0 : uniform_space (linear_ordered_semiring (random_gen num))) : separated_space (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_182127 (h1 : ring (has_ssubset environment.projection_info)) : strong_rank_condition (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_182128 (h0 : functor.add_const (list (boolean_algebra Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182129 (h0 : topological_space (boolean_algebra (canonically_linear_ordered_add_monoid Type))) : irreducible_space (boolean_algebra (canonically_linear_ordered_add_monoid Type)) := sorry --non-trivial
lemma new_lemma_182130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_182131 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) (option name)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_182132 (h0 : functor.add_const (group (has_neg Type)) linarith.comp) : @is_simple_group.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182133 (h1 : add_group (nondiscrete_normed_field (normed_field environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_182134 (h0 : finset (ring (ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182135 (h0 : functor.comp group finset linarith.comp) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.comp.run.{0 0 0} group.{0} finset.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182136 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @discrete_topology.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182137 (h0 : add_group (with_bot to_additive.value_type)) : is_add_cyclic (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_182138 (h0 : functor.add_const (functor.add_const (topological_space (left_cancel_monoid empty)) num) (semiring empty)) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num) (semiring.{0} empty) h0))  := sorry --non-trivial
lemma new_lemma_182139 (h0 : add_monoid (comm_semigroup (has_Inf Type))) : add_monoid.fg (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_182140 (h0 : topological_space (has_neg (finset (finset (finset linarith.comp))))) : path_connected_space (has_neg (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_182141 (h0 : prod (plift unsigned) (plift unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_182142 (h0 : group (add_cancel_monoid (ring linarith.comp))) : is_cyclic (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_182143 (h0 : functor.add_const (topological_space (has_nndist ennreal)) ennreal) : @sequential_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_182144 (h0 : topological_space (uniform_space (metric_space (mul_one_class reducibility_hints)))) : totally_disconnected_space (uniform_space (metric_space (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_182145 (h0 : topological_space to_additive.value_type) (h1 : add_group to_additive.value_type) : topological_add_group to_additive.value_type := sorry --non-trivial
lemma new_lemma_182146 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : totally_disconnected_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_182147 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_182148 (h0 : functor.add_const (ring (has_zero unsigned)) linarith.comp) : @is_domain.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182149 (h0 : uniform_space (ordered_comm_ring (ring linarith.comp))) : complete_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_182150 (h1 : topological_space (has_emptyc (has_top to_additive.value_type))) : totally_separated_space (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_182151 (h0 : ordered_add_comm_monoid (has_neg Type)) : archimedean (has_neg Type) := sorry --non-trivial
lemma new_lemma_182152 (h0 : finset (comm_group linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182153 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (option (option (option (option empty)))))) : archimedean (ordered_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_182154 (h0 : topological_space (has_add (option congr_arg_kind))) : discrete_topology (has_add (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182155 (h0 : ring (has_compl (metric_space char))) : rank_condition (has_compl (metric_space char)) := sorry --non-trivial
lemma new_lemma_182156 (h0 : measurable_space (denumerable (mul_one_class to_additive.value_type))) (h1 : measure_theory.measure (denumerable (mul_one_class to_additive.value_type))) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_182157 (h0 : uniform_space (normed_group (semiring (semiring unsigned)))) : separated_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_182158 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (add_semigroup unsigned)))) : @archimedean.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (add_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_182159 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree unsigned)) congr_arg_kind) : @archimedean.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182160 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @discrete_topology.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182161 (h0 : functor.add_const (add_monoid (measurable_space.dynkin_system empty)) num) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_182162 (h1 : with_bot (group (linear_ordered_add_comm_group string_imp))) (h2 : ne h1 has_bot.bot) : @group.fg.{0} (linear_ordered_add_comm_group.{0} string_imp) (@with_bot.unbot.{0} (group.{0} (linear_ordered_add_comm_group.{0} string_imp)) h1 h2)  := sorry --non-trivial
lemma new_lemma_182163 (h0 : functor.add_const (uniform_space (comm_group ennreal)) Type) : @complete_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_182164 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_182165 (h0 : group (mul_zero_class (semiring (semiring (semiring empty))))) : is_cyclic (mul_zero_class (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_182166 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182167 (h0 : group (has_union (semiring unsigned))) : normalizer_condition (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182168 (h0 : topological_space (finset unsigned)) : totally_disconnected_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_182169 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @totally_separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182170 (h0 : finset (finset (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182171 (h0 : topological_space (with_bot (semiring (metric_space (semiring (semiring unsigned)))))) : discrete_topology (with_bot (semiring (metric_space (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_182172 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) (semiring empty)) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_182173 (h0 : topological_space (has_add (finset pos))) : preirreducible_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_182174 (h0 : complete_lattice (has_one (has_norm empty))) : is_atomistic (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_182175 (h0 : complete_lattice (partial_order (semiring empty))) : is_compactly_generated (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_182176 (h0 : add_group (has_zero (has_add Type))) : is_add_cyclic (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_182177 (h0 : topological_space (ring (has_add pos))) : preirreducible_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_182178 (h0 : ring (semigroup (has_add pos))) : is_domain (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_182179 (h0 : not (ring (distrib reducibility_hints) -> false)) : @rank_condition.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_182180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_182181 (h0 : ring (nondiscrete_normed_field char)) : rank_condition (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_182182 (h0 : group (has_zero (option pos))) : is_cyclic (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_182183 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_182184 (h0 : functor.add_const (group (has_bot pos)) name) : @is_cyclic.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_182185 (h0 : ring (ordered_comm_monoid (ring pos))) : is_domain (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_182186 (h1 : ring (mul_one_class (add_comm_semigroup environment.projection_info))) : strong_rank_condition (mul_one_class (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_182187 (h0 : uniform_space (uniform_space (has_lt linarith.comp_source))) : complete_space (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182188 (h0 : semiring (boolean_algebra (finset environment.implicit_infer_kind))) : is_noetherian_ring (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182189 (h0 : functor.add_const (topological_space (has_edist unsigned)) unsigned) : @totally_separated_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182190 (h0 : topological_space (has_add real)) : preirreducible_space (has_add real) := sorry --non-trivial
lemma new_lemma_182191 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_182192 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_182193 (h0 : topological_space (has_zero (comm_group (comm_group pos)))) : discrete_topology (has_zero (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_182194 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182195 (h0 : functor.add_const (filter (comm_group environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182196 (h0 : functor.add_const (group (boolean_algebra pos)) (has_add linarith.comp)) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_182197 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen fun_info)))) : irreducible_space (linear_ordered_semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_182198 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_182199 (h0 : topological_space (has_norm (random_gen num))) : discrete_topology (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_182200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182201 (h0 : functor.add_const (ring (ring pos)) name) : @strong_rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_182202 (h0 : topological_space (ordered_comm_ring (has_add (has_add pos)))) : sequential_space (ordered_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_182203 (h0 : ereal -> ereal) (h2 : ereal) : function.is_fixed_pt h0 h2 := sorry --non-trivial
lemma new_lemma_182204 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182205 (h0 : topological_space (linear_ordered_comm_group num)) : path_connected_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_182206 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_182207 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : path_connected_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182208 (h0 : functor.comp filter has_add Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_182209 (h0 : ring (random_gen (random_gen empty))) : is_domain (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_182210 (h0 : functor.add_const (ring (finset linarith.comp)) linarith.comp) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182211 (h1 : ring (has_top (random_gen string_imp))) : rank_condition (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_182212 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182213 (h0 : semiring rat) : is_noetherian_ring rat := sorry --non-trivial
lemma new_lemma_182214 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182215 (h0 : uniform_space (boolean_algebra.core name)) : complete_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_182216 (h0 : functor.comp topological_space pseudo_metric_space pos) : @totally_separated_space.{0} (pseudo_metric_space.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_182217 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_182218 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (option empty))) : unique_factorization_monoid (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_182219 (h0 : topological_space (linear_ordered_comm_group_with_zero (has_le fun_info))) : path_connected_space (linear_ordered_comm_group_with_zero (has_le fun_info)) := sorry --non-trivial
lemma new_lemma_182220 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset pos)) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182221 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182223 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class char)))) : rank_condition (semi_normed_ring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_182224 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_182225 (h0 : monoid (comm_semigroup (has_neg real))) : monoid.fg (comm_semigroup (has_neg real)) := sorry --non-trivial
lemma new_lemma_182226 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182227 (h0 : functor.comp topological_space add_comm_monoid name) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_182228 (h1 : ring (with_zero (has_nnnorm linarith.ineq))) : is_domain (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182229 (h0 : uniform_space (comm_semigroup real)) : complete_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_182230 (h0 : not (uniform_space (has_emptyc linarith.comp) -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182231 (h1 : complete_lattice (random_gen fun_info)) : complete_lattice.is_Sup_finite_compact (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_182232 (h0 : functor.add_const (add_monoid (has_inter ennreal)) num) : @add_monoid.fg.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_inter.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_182233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182235 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf linarith.comp))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_182236 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid name)) pos) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_182237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182238 (h0 h1 h2 : pnat) : pnat.coprime (pnat.mod h0 h1) h2 := sorry --non-trivial
lemma new_lemma_182239 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182240 (h0 : fin has_zero.zero) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182241 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @discrete_topology.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182242 (h0 : topological_space (has_to_string (has_add (has_to_string (has_add Type))))) : preirreducible_space (has_to_string (has_add (has_to_string (has_add Type)))) := sorry --non-trivial
lemma new_lemma_182243 (h0 : functor.add_const (topological_space (finset pos)) (finset pos)) : @totally_disconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182244 (h0 : group (has_norm (has_top (has_nnnorm fun_info)))) : group.fg (has_norm (has_top (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_182245 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @preconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182246 (h0 : functor.add_const (monoid (semigroup unsigned)) num) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_182247 (h0 : topological_space (option (semiring unsigned))) : topological_space.separable_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182248 (h0 : complete_lattice (comm_group unsigned)) : is_atomistic (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_182249 (h1 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h1) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_182250 (h0 : set (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : set.finite (set.compl h0) := sorry --non-trivial
lemma new_lemma_182251 (h0 : complete_lattice (simple_graph (option (option (option empty))))) : is_compactly_generated (simple_graph (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_182252 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : topological_space.separable_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182253 (h0 : ring (has_one (semiring congr_arg_kind))) : is_domain (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182254 (h0 : function.extfun nat fin) : @rank_condition.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_182255 (h0 : prod (cancel_monoid pos) (cancel_monoid pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_182256 (h0 : function.extfun (finset (Type 1 -> Type 1)) (has_mem.mem monoid)) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) monoid.{1} (@function.extfun_app.{3 0} (finset.{2} (Type 1 → Type 1)) (@has_mem.mem.{2 2} (Type 1 → Type 1) (finset.{2} (Type 1 → Type 1)) (@finset.has_mem.{2} (Type 1 → Type 1)) monoid.{1}) h0 (@has_emptyc.emptyc.{2} (finset.{2} (Type 1 → Type 1)) (@finset.has_emptyc.{2} (Type 1 → Type 1))))) Type)  := sorry --non-trivial
lemma new_lemma_182257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182258 (h1 : ring (with_zero to_additive.value_type)) : rank_condition (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_182259 (h0 : ring (has_le ereal)) : strong_rank_condition (has_le ereal) := sorry --non-trivial
lemma new_lemma_182260 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @path_connected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_182261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_182262 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_182263 (h0 : not (group (semi_normed_ring (mul_one_class (random_gen char))) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} (mul_one_class.{0} (random_gen.{0} char))) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} (mul_one_class.{0} (random_gen.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_182264 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182265 (h0 : complete_lattice (has_append (has_ssubset linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182266 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182267 (h0 : group (has_one (semiring congr_arg_kind))) : normalizer_condition (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182268 (h1 : not (ring (simple_graph linarith.comp_source) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_182269 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : t1_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_182270 (h0 : ring (finset (has_to_string (has_to_string (has_to_string (has_to_string pos)))))) : strong_rank_condition (finset (has_to_string (has_to_string (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_182271 (h0 : group (add_cancel_monoid (has_neg (boolean_algebra Type)))) : group.fg (add_cancel_monoid (has_neg (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_182272 (h0 : has_le (add_comm_semigroup ereal)) (h1 : add_comm_semigroup ereal) : is_bot h1 := sorry --non-trivial
lemma new_lemma_182273 (h0 : topological_space (semigroup (boolean_algebra Type))) : discrete_topology (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_182274 (h0 : topological_space (has_nndist Type)) : totally_disconnected_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_182275 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @discrete_topology.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_182276 (h0 : function.extfun Type (functor.comp ring add_comm_monoid)) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_182277 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring linarith.comp)) (finset pos)) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182278 (h0 : ordered_add_comm_monoid (plift empty)) : archimedean (plift empty) := sorry --non-trivial
lemma new_lemma_182279 (h0 : list (has_add (has_zero name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182280 (h0 : topological_space (add_group linarith.comp)) : preirreducible_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_182281 (h1 : measurable_space (nondiscrete_normed_field enat)) (h2 : measure_theory.measure (nondiscrete_normed_field enat)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_182282 (h0 : topological_space (comm_ring (has_top linarith.comp_source))) : locally_compact_space (comm_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182284 (h0 : functor.add_const (complete_lattice (mul_zero_class num)) num) : @is_compactly_generated.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_182285 (h0 : uniform_space (comm_group (canonically_ordered_comm_semiring (option name)))) : complete_space (comm_group (canonically_ordered_comm_semiring (option name))) := sorry --non-trivial
lemma new_lemma_182286 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_182287 (h0 : functor.add_const (topological_space (finset name)) pos) : @regular_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_182288 (h0 : fun_info -> fun_info -> Prop) : is_total_preorder fun_info h0 := sorry --non-trivial
lemma new_lemma_182289 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_182290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182291 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @totally_separated_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182292 (h0 : topological_space (left_cancel_monoid num)) : loc_path_connected_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_182293 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_182294 (h0 : topological_space (has_one (has_norm (has_norm num)))) : irreducible_space (has_one (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_182295 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182296 (h0 : prod (has_to_string congr_arg_kind) (has_to_string congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_182297 (h0 : functor.add_const (topological_space (cancel_monoid name)) (comm_group name)) : @loc_path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_182298 (h0 : list (normed_linear_ordered_group (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182299 (h0 h1 : multiset (linear_ordered_comm_group_with_zero ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_182300 (h0 : has_coe (mul_one_class (add_comm_semigroup (add_comm_semigroup char))) Prop) (h1 : mul_one_class (add_comm_semigroup (add_comm_semigroup char))) : @coe_b.{1 1} (mul_one_class.{0} (add_comm_semigroup.{0} (add_comm_semigroup.{0} char))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_182301 (h0 : not (topological_space (semi_normed_comm_ring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_182302 (h0 : finset (has_Inf Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182304 (h0 : ring (measure_theory.measure_space (has_top empty))) : strong_rank_condition (measure_theory.measure_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_182305 (h0 : functor.add_const (topological_space (mul_zero_class pos)) (finset ennreal)) : @irreducible_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_182306 (h0 : ring (random_gen (random_gen linarith.ineq))) : rank_condition (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182307 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_182308 (h0 : ring (normed_group unsigned)) : rank_condition (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_182309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182310 (h0 : function.extfun Type group) : @normalizer_condition.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_182311 (h0 : ring (complete_semilattice_Sup unsigned)) : strong_rank_condition (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_182312 (h0 : topological_space (has_ssubset (add_cancel_comm_monoid char))) : t0_space (has_ssubset (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_182313 (h0 : topological_space (plift (semiring (semiring (semiring empty))))) : loc_path_connected_space (plift (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_182314 (h0 : functor.add_const (fin has_zero.zero) (has_Inf Type)) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_182315 (h0 : not (ring (linear_ordered_comm_ring unsigned) -> false)) : @is_domain.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_182316 (h0 : filter (finset (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182317 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182318 (h0 : not (function.extfun Type complete_lattice -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182319 (h0 : filter (has_add (has_to_string (finset Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_182320 (h0 : add_group (comm_ring (mul_one_class fun_info))) : is_add_cyclic (comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_182321 (h0 : list (has_to_string (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182322 (h0 : functor.add_const (ring (bin_tree empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_182323 (h0 : fin has_zero.zero) : @preconnected_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_182324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_182325 (h0 : not (ring (mul_zero_class empty) -> false)) : @rank_condition.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182326 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_182327 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) : @path_connected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182328 (h0 : topological_space (add_left_cancel_monoid char)) : t0_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_182329 (h0 : ring unsigned -> ring unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_182330 (h0 : topological_space (has_neg_part ennreal)) : regular_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_182331 (h0 : ring auto.case_option) : strong_rank_condition auto.case_option := sorry --non-trivial
lemma new_lemma_182332 (h0 : ring (mul_one_class fun_info)) : strong_rank_condition (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_182333 (h0 : topological_space (canonically_ordered_monoid name)) : t0_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_182334 (h0 : filter (encodable (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182335 (h1 : group (random_gen congr_arg_kind)) : group.fg (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182336 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf (has_Inf linarith.comp)))) : regular_space (canonically_ordered_comm_semiring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_182337 (h0 : not (topological_space (bin_tree empty) -> false)) : @path_connected_space.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182338 (h0 : ring (ring (comm_group (has_neg_part (canonically_ordered_comm_semiring unsigned))))) : rank_condition (ring (comm_group (has_neg_part (canonically_ordered_comm_semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_182339 (h1 : add_group (complete_semilattice_Sup char)) : is_add_cyclic (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_182340 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : totally_separated_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_182341 (h0 : functor.add_const (function.extfun Type add_monoid) (normed_comm_ring linarith.comp)) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (normed_comm_ring.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_182342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182343 (h1 : topological_space (has_one (semiring (semiring empty)))) : t0_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_182344 (h0 : topological_space (normed_comm_ring (finset pos))) : t0_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_182345 (h0 : group (has_to_string (has_inter (has_neg ennreal)))) : is_cyclic (has_to_string (has_inter (has_neg ennreal))) := sorry --non-trivial
lemma new_lemma_182346 (h0 : functor.add_const (finset (normed_comm_ring Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182347 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : locally_compact_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182348 (h0 : uniform_space ordering) : complete_space ordering := sorry --non-trivial
lemma new_lemma_182349 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_182350 (h0 : topological_space (monoid (option unsigned))) : loc_path_connected_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_182351 (h0 : monoid (has_zero pos)) : monoid.fg (has_zero pos) := sorry --non-trivial
lemma new_lemma_182352 (h0 : finset (has_to_string (has_add (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182353 (h0 : functor.add_const (add_monoid (mul_zero_class name)) unsigned) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182354 (h0 : uniform_space (ring (has_add environment.implicit_infer_kind))) : separated_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182355 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_182356 (h3 : add_group (topological_space char)) : is_add_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_182357 (h0 : functor.add_const (topological_space (ring pos)) (has_Inf linarith.comp)) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_182358 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_182359 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_182360 (h0 : has_mem.mem (has_emptyc (random_gen congr_arg_kind)) has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} (random_gen.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_182361 (h0 : complete_lattice (has_add (ring name))) : is_atomistic (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_182362 (h0 : topological_space (normed_comm_ring pos)) : t1_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_182363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_182364 (h0 : functor.add_const (list (left_cancel_semigroup num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182366 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (mul_one_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_one_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182367 (h0 : topological_space (has_Sup congr_arg_kind)) : t0_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182368 (h0 : topological_space (mul_one_class to_additive.value_type)) : path_connected_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_182369 (h2 : linarith.ineq -> linarith.ineq -> bool) : is_dec_refl h2 := sorry --non-trivial
lemma new_lemma_182370 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice unsigned)) : unique_factorization_monoid (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_182371 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_182372 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_182373 (h0 : complete_lattice (semiring linarith.ineq)) : is_atomistic (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_182374 (h0 : functor.comp topological_space has_nndist Type) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_182375 (h1 : ring (comm_ring (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_domain (comm_ring (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_182376 (h0 : ring (normed_group (has_top (has_top linarith.comp_source)))) : is_domain (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_182377 (h0 : functor.add_const (list (ordered_ring num)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182378 (h0 : monoid (canonically_ordered_monoid (has_Inf (has_add (has_Inf real))))) : monoid.fg (canonically_ordered_monoid (has_Inf (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_182379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_182380 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @discrete_topology.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 pos))  := sorry --non-trivial
lemma new_lemma_182381 (h0 : function.extfun Type ring) : @is_domain.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182382 (h0 : ring (add_group (has_union empty))) : strong_rank_condition (add_group (has_union empty)) := sorry --non-trivial
lemma new_lemma_182383 (h0 : topological_space (left_cancel_semigroup empty)) : t0_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_182384 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_182385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_182386 (h0 : complete_lattice (has_one (has_norm congr_arg_kind))) : is_atomistic (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182387 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182388 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) num) : @topological_space.separable_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_182389 (h0 : topological_space (normed_comm_ring ennreal)) : sequential_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_182390 (h0 : topological_space (with_bot congr_arg_kind)) : path_connected_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182391 (h0 : topological_space (has_add (has_to_string linarith.comp))) : regular_space (has_add (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_182392 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @preirreducible_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_182393 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182394 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_182395 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_182396 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_182397 (h0 : topological_space (has_neg_part (option (ring pos)))) : t1_space (has_neg_part (option (ring pos))) := sorry --non-trivial
lemma new_lemma_182398 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_182399 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_182400 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) unsigned) : @loc_path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182401 (h0 : group (non_assoc_semiring unsigned)) : group.fg (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_182402 (h0 : complete_lattice (random_gen (random_gen reducibility_hints))) : is_compactly_generated (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_182403 (h0 : list (has_to_string (finset name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182404 (h0 : add_group (has_pos_part (boolean_algebra.core linarith.comp))) : is_add_cyclic (has_pos_part (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_182405 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring empty))))) : totally_disconnected_space (measurable_space.dynkin_system (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_182406 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182407 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_182408 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182409 (h0 : fin has_zero.zero) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_182410 (h0 : ring (dlist (has_top (has_nnnorm linarith.ineq)))) : is_domain (dlist (has_top (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_182411 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_182412 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_182413 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_182414 (h2 : topological_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) : t0_space (nondiscrete_normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182415 (h0 : topological_space (cancel_monoid (has_nndist (add_comm_monoid environment.implicit_infer_kind)))) : irreducible_space (cancel_monoid (has_nndist (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_182416 (h0 : not (ring (bin_tree unsigned) -> false)) : @rank_condition.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_182417 (h0 : topological_space (has_emptyc (has_norm congr_arg_kind))) : t0_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182418 (h0 : functor.add_const (topological_space (has_star unsigned)) empty) : @t1_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_182419 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_182420 (h0 : topological_space (has_add (has_add linarith.comp))) : normal_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_182421 (h0 : not (topological_space (has_sub empty) -> false)) : @t0_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182422 (h3 : not (uniform_space (random_gen string_imp) -> false)) : @complete_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} string_imp)) h3)  := sorry --non-trivial
lemma new_lemma_182423 (h0 : filter (with_one (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_182425 (h1 : not (ring znum -> false)) : @is_domain.{0} znum (@classical.by_contradiction'.{1} (ring.{0} znum) h1)  := sorry --non-trivial
lemma new_lemma_182426 (h0 : list (has_inner empty (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182427 (h0 : topological_space (has_add (sub_neg_monoid (sub_neg_monoid Type)))) : locally_compact_space (has_add (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_182428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_182429 (h0 : topological_space (partial_order (semiring empty))) : topological_space.separable_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_182430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_group empty)) := sorry --non-trivial
lemma new_lemma_182431 (h0 : topological_space (has_zero (has_nndist linarith.comp))) : locally_compact_space (has_zero (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_182432 (h0 : complete_lattice (has_add (fintype linarith.comp_source))) : is_compactly_generated (has_add (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182433 (h0 : not (has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_182434 (h1 : complete_lattice (non_unital_non_assoc_semiring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_182435 (h0 : not (topological_space (has_div reducibility_hints) -> false)) : @path_connected_space.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_182436 (h0 : topological_space (semiring (has_norm empty))) : path_connected_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_182437 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 nnreal) := sorry --non-trivial
lemma new_lemma_182438 (h0 : list (finset ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182439 (h0 : topological_space (linear_ordered_comm_group (option pos))) : preconnected_space (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_182440 (h0 : ring (ring (has_Inf (has_neg name)))) : rank_condition (ring (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_182441 (h0 : group (measurable_space.dynkin_system empty)) : group.fg (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_182442 (h0 : group (has_to_string (has_zero Type))) : is_simple_group (has_to_string (has_zero Type)) := sorry --non-trivial
lemma new_lemma_182443 (h0 : topological_space (generalized_boolean_algebra (ring (ring Type)))) : preconnected_space (generalized_boolean_algebra (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_182444 (h0 : add_monoid (ordered_comm_ring (has_add (boolean_algebra.core pos)))) : add_monoid.fg (ordered_comm_ring (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_182445 (h0 : functor.add_const (list (ordered_cancel_add_comm_monoid num)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182446 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_182447 (h0 : add_group (has_edist empty)) : is_add_cyclic (has_edist empty) := sorry --non-trivial
lemma new_lemma_182448 (h0 : ring (with_zero char)) : rank_condition (with_zero char) := sorry --non-trivial
lemma new_lemma_182449 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @t1_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182450 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (ring name)) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_182451 (h0 : semiring (ordered_comm_monoid (has_Inf pos))) : is_noetherian_ring (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_182452 (h0 : semiring (has_neg_part (has_nndist ennreal))) : is_noetherian_ring (has_neg_part (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_182453 (h0 : complete_lattice (has_Inf linarith.comp)) : is_compactly_generated (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_182454 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_182455 (h0 : functor.comp topological_space ring name) : @t0_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_182456 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_noetherian_ring.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) semiring.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_182457 (h0 : uniform_space (complete_distrib_lattice (has_Inf linarith.comp))) : complete_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_182458 (h0 : filter (has_add (has_add (canonically_linear_ordered_monoid (has_to_string ennreal))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182459 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182460 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_182461 (h0 : topological_space (semiring (has_norm num))) : t0_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_182462 (h0 : functor.add_const (semiring (ring pos)) (finset pos)) : @is_noetherian_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182463 (h0 : topological_space (id num)) : path_connected_space (id num) := sorry --non-trivial
lemma new_lemma_182464 (h0 : functor.add_const (function.extfun Type topological_space) name) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182465 (h0 : topological_space (has_pos_part (has_add real))) : totally_disconnected_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_182466 (h0 : topological_space (has_dist num)) : locally_compact_space (has_dist num) := sorry --non-trivial
lemma new_lemma_182467 (h0 : topological_space (add_left_cancel_monoid linarith.comp_source)) : t0_space (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_182468 (h0 : topological_space (has_nndist num)) : locally_compact_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_182469 (h0 : topological_space (monoid (option (option (option (option (option (option ennreal)))))))) : discrete_topology (monoid (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_182470 (h0 : topological_space (has_pos_part (has_add (ring Type)))) : totally_separated_space (has_pos_part (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_182471 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ring (has_neg (has_add name))))) : unique_factorization_monoid (ordered_comm_monoid (ring (has_neg (has_add name)))) := sorry --non-trivial
lemma new_lemma_182472 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_182473 (h0 : topological_space (semigroup (has_neg (normed_comm_ring (has_add Type))))) : totally_disconnected_space (semigroup (has_neg (normed_comm_ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_182474 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid_with_zero (option (option pos)))) := sorry --non-trivial
lemma new_lemma_182475 (h0 : fin has_zero.zero) : @is_cyclic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_182476 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @preirreducible_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_inner.{0 0} (option.{0} unsigned) (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_inner.{0 0} (option.{0} unsigned) (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_182478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182479 (h0 : topological_space (cancel_monoid (comm_group (comm_group name)))) : locally_compact_space (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_182480 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_182481 (h0 : has_mem.mem (with_bot (has_norm empty)) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182482 (h0 : list (has_zero (has_Inf (has_Inf Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182483 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182484 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182485 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (has_Inf name)) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (has_Inf.{0} name) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_182486 (h0 : fin has_zero.zero) : @complete_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_182487 (h0 : has_neg (has_lt std_gen)) (h1 : measurable_space (has_lt std_gen)) : has_measurable_neg (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_182488 (h0 : topological_space (ring (has_Inf Type))) : totally_disconnected_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_182489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182490 (h1 : not (ring (has_lt string_imp) -> false)) : @rank_condition.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_182491 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_182492 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182493 (h0 : ring (with_one unsigned)) : rank_condition (with_one unsigned) := sorry --non-trivial
lemma new_lemma_182494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_182495 (h0 : functor.add_const (topological_space (finset linarith.comp)) (ring environment.implicit_infer_kind)) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_182496 (h0 : add_monoid (has_norm (semiring fun_info))) : add_monoid.fg (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_182497 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_182498 (h0 : complete_lattice (has_neg_part (comm_group Type))) : is_compactly_generated (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_182499 (h1 : set (mul_one_class (mul_one_class std_gen) -> mul_one_class ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_182500 (h0 : finset (preorder (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182501 (h0 : char -> topological_space fun_info) : @totally_disconnected_space.{0} fun_info (@infi.{0 1} (topological_space.{0} fun_info) (@conditionally_complete_lattice.to_has_Inf.{0} (topological_space.{0} fun_info) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} fun_info) (@topological_space.complete_lattice.{0} fun_info))) char h0)  := sorry --non-trivial
lemma new_lemma_182502 (h0 : ring (has_nnnorm (linear_ordered_add_comm_group string_imp))) : rank_condition (has_nnnorm (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_182503 : infinite (finset ennreal) := sorry --non-trivial
lemma new_lemma_182504 (h0 : topological_space (semi_normed_comm_ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)))) : t0_space (semi_normed_comm_ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_182505 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) (has_add name)) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_182506 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_182507 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_182508 (h0 : complete_lattice name) : is_atomistic name := sorry --non-trivial
lemma new_lemma_182509 (h0 : uniform_space (has_zero Type)) : complete_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_182510 (h0 : topological_space (complete_semilattice_Sup (has_inv linarith.comp_source))) : totally_separated_space (complete_semilattice_Sup (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182511 (h0 : uniform_space (measurable_space.dynkin_system (semiring linarith.comp))) : complete_space (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_182512 (h0 : list (dlist (random_gen (random_gen (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182513 (h0 : set (string.iterator_imp -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_182514 (h0 : ring (linear_ordered_add_comm_group char)) : strong_rank_condition (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_182515 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : path_connected_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_182516 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_zero.zero) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@multiset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_182517 (h0 : monoid (has_bot (has_neg name))) : monoid.fg (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_182518 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add Type))) : has_exists_mul_of_le (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_182519 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (finset linarith.comp)) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_182520 (h0 : topological_space (encodable (has_ssubset (random_gen (has_ssubset to_additive.value_type))))) : t0_space (encodable (has_ssubset (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_182521 (h0 : topological_space (has_to_string num)) : normal_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_182522 (h0 : topological_space (has_Inf (has_Inf (has_Inf Type)))) : preconnected_space (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_182523 (h1 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182524 (h0 : topological_space (ordered_comm_monoid (has_pos_part pos))) : loc_path_connected_space (ordered_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_182525 (h0 : group (semigroup (finset (finset (has_add ennreal))))) : group.fg (semigroup (finset (finset (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_182526 (h0 : ring (has_inv (has_top string_imp))) : strong_rank_condition (has_inv (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_182527 (h0 : uniform_space (complete_distrib_lattice linarith.comp)) : complete_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_182528 (h0 : functor.add_const (semiring (semigroup unsigned)) unsigned) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182529 (h0 : topological_space (ordered_comm_ring name)) : totally_separated_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_182530 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (ring Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_182531 (h0 : topological_space (semiring (semiring linarith.comp))) : t0_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_182532 (h0 : topological_space (add_cancel_comm_monoid empty)) : loc_path_connected_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_182533 (h0 : not (semiring (complete_semilattice_Sup num) -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182534 (h0 : not (ring (measure_theory.measure_space congr_arg_kind) -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_182535 (h0 : complete_lattice (uniform_space (mul_one_class char))) : is_compactly_generated (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_182536 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h1 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182537 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_182538 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_182539 (h0 : topological_space (ring (has_pos_part (normed_comm_ring pos)))) : normal_space (ring (has_pos_part (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_182540 (h0 : finset (cancel_monoid Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_182541 (h0 : not (add_group (metric_space reducibility_hints) -> false)) : @is_add_cyclic.{0} (metric_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (metric_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_182542 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : totally_separated_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_182543 (h0 : not (ring (with_bot num) -> false)) : @strong_rank_condition.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182544 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_182545 (h1 : monoid (has_norm linarith.ineq)) : monoid.fg (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_182546 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_182547 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182548 (h0 : functor.add_const (add_group Type) Type) : @is_add_cyclic.{1} Type (@functor.add_const.run.{1 1} (add_group.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_182549 (h0 : monoid (linear_ordered_comm_ring empty)) : monoid.fg (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_182550 (h0 : topological_space (has_Inf (has_Inf (has_Inf linarith.comp)))) : locally_compact_space (has_Inf (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_182551 (h0 : uniform_space (has_norm empty)) : separated_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_182552 (h0 : list (finset (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182553 (h4 : ring (linear_ordered_add_comm_group (random_gen char))) : rank_condition (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_182554 (h0 : functor.comp cancel_comm_monoid_with_zero normed_comm_ring Type) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_182555 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (has_add name)) : @is_compactly_generated.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (has_add.{0} name) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_182556 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_182557 (h0 : monoid (has_to_string (has_add name))) : monoid.fg (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_182558 (h0 : ring name) : is_principal_ideal_ring name := sorry --non-trivial
lemma new_lemma_182559 (h0 : functor.add_const (topological_space (group_with_zero empty)) unsigned) : @totally_separated_space.{0} (group_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182560 (h0 : ring (non_unital_non_assoc_semiring (uniform_space string_imp))) : strong_rank_condition (non_unital_non_assoc_semiring (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_182561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_182562 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182563 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_neg Type)) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_182564 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_182565 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_ring (has_add linarith.comp)))) : path_connected_space (generalized_boolean_algebra (ordered_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_182566 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (lex.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (lex.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182567 (h0 : set (non_unital_non_assoc_semiring to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_182568 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : t1_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_182569 (h0 : complete_lattice (has_top (random_gen (has_norm fun_info)))) : is_compactly_generated (has_top (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_182570 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) name) : @rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_182571 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_182572 (h0 : add_group (measurable_space.dynkin_system (semiring (semiring (semiring (semiring unsigned)))))) : is_add_cyclic (measurable_space.dynkin_system (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_182573 (h0 : metric_space (with_bot empty)) (h1 : with_bot empty) : euclidean_geometry.cospherical (irreducible_component h1) := sorry --non-trivial
lemma new_lemma_182574 (h0 : group (has_add (has_nndist (finset Type)))) : is_cyclic (has_add (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_182575 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182576 (h0 : uniform_space (has_Inf (has_add Type))) : complete_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_182577 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182578 (h0 : ring (with_one (has_norm linarith.ineq))) : is_domain (with_one (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182579 (h0 : functor.add_const (group (boolean_algebra name)) (has_neg (has_neg linarith.comp))) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182580 (h0 : not (uniform_space (has_star empty) -> false)) : @separated_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182581 (h1 : filter (has_add znum)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_182582 (h0 : function.extfun Type topological_space) : @normal_space.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_182583 (h0 : has_mem.mem num has_emptyc.emptyc) : @is_add_cyclic.{0} num (@finset.pi.empty.{1 0} Type add_group.{0} num h0)  := sorry --non-trivial
lemma new_lemma_182584 (h0 : topological_space (cancel_monoid linarith.ineq)) : totally_disconnected_space (cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_182585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182586 (h0 : topological_space (ring (monoid congr_arg_kind))) : t0_space (ring (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182587 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_182588 (h0 : has_inv (has_nnnorm fun_info) -> has_inv (has_nnnorm fun_info)) : function.involutive h0 := sorry --non-trivial
lemma new_lemma_182589 (h0 : topological_space (has_one (has_top linarith.comp))) : irreducible_space (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_182590 (h0 : complete_lattice (with_bot (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182591 (h1 : uniform_space (has_top string_imp)) : complete_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_182592 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_182593 (h0 : functor.add_const (add_group (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_add_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_182594 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_182595 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182596 (h0 : topological_space (preorder (option (option unsigned)))) : discrete_topology (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_182597 (h0 : topological_space (has_Inf (ring (ring linarith.comp)))) : t0_space (has_Inf (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_182598 (h1 : topological_space (has_emptyc (has_top (has_norm (has_norm to_additive.value_type))))) : totally_separated_space (has_emptyc (has_top (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_182599 (h0 : complete_lattice (ring (option (option ennreal)))) : is_atomistic (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_182600 (h0 : nat) (h1 : vector (ulower Prop) (has_add.add h0 has_one.one)) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@vector.last.{0} h0 (@ulower.{0} Prop encodable.Prop) h1))  := sorry --non-trivial
lemma new_lemma_182601 (h0 : group (boolean_algebra name)) : group.fg (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_182602 (h0 : topological_space (has_one (semiring congr_arg_kind))) : locally_compact_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (bin_tree.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (uniform_space.{0} (bin_tree.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_182604 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_182605 (h0 : functor.add_const (list (bin_tree congr_arg_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182606 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero linarith.comp)) pos) : @archimedean.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_182607 (h1 : ring (topological_space (random_gen (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (topological_space (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_182608 (h0 : functor.add_const Prop (complete_distrib_lattice Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_182609 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @totally_disconnected_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182610 (h0 : ring (has_neg (boolean_algebra.core (has_neg Type)))) : strong_rank_condition (has_neg (boolean_algebra.core (has_neg Type))) := sorry --non-trivial
lemma new_lemma_182611 (h0 : not (add_group (with_zero linarith.comp_source) -> false)) : @is_add_cyclic.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_182612 (h0 : functor.comp ring add_comm_monoid (has_neg_part (has_add (has_add Type)))) : @rank_condition.{1} (add_comm_monoid.{1} (has_neg_part.{1} (has_add.{1} (has_add.{1} Type)))) (@functor.comp.run.{1 1 1} ring.{1} add_comm_monoid.{1} (has_neg_part.{1} (has_add.{1} (has_add.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_182613 (h0 : group (option (option (option num)))) : is_cyclic (option (option (option num))) := sorry --non-trivial
lemma new_lemma_182614 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182615 (h0 : functor.add_const (uniform_space (plift unsigned)) num) : @separated_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_182616 (h2 : uniform_space (normed_group string_imp)) : complete_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_182617 (h0 : topological_space (linear_ordered_field (option (option unsigned)))) : normal_space (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_182618 (h0 : ordered_comm_monoid (has_Inf pos)) : has_exists_mul_of_le (has_Inf pos) := sorry --non-trivial
lemma new_lemma_182619 (h2 : ring (add_zero_class (has_ssubset (random_gen char)))) : rank_condition (add_zero_class (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_182620 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_to_string name))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_182621 (h0 : topological_space (add_comm_monoid (comm_group pos))) : preirreducible_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_182622 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf linarith.comp))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_182623 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182624 (h0 : ring (boolean_algebra.core (has_Inf Type))) : is_domain (boolean_algebra.core (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_182625 (h0 : topological_space (add_cancel_comm_monoid (option empty))) : normal_space (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_182626 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) (boolean_algebra (boolean_algebra (has_neg_part Type)))) : @is_compactly_generated.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (cancel_monoid.{0} pos)) (boolean_algebra.{1} (boolean_algebra.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_182627 (h0 : complete_lattice (has_inv (has_inv (has_inv (random_gen (has_inv (has_inv to_additive.value_type))))))) : is_atomistic (has_inv (has_inv (has_inv (random_gen (has_inv (has_inv to_additive.value_type)))))) := sorry --non-trivial
lemma new_lemma_182628 (h0 : topological_space (finset (semilattice_inf Type))) : sequential_space (finset (semilattice_inf Type)) := sorry --non-trivial
lemma new_lemma_182629 (h0 : topological_space (semigroup (has_Inf pos))) : preirreducible_space (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_182630 (h0 : functor.add_const (group (has_nndist pos)) pos) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_182631 (h0 : topological_space (semigroup (finset pos))) : regular_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_182632 (h0 : ordered_add_comm_monoid (cancel_monoid (option unsigned))) : archimedean (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_182633 (h1 h2 : multiset (nondiscrete_normed_field (mul_one_class char))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_182634 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_182635 (h0 : topological_space (finset (has_neg real))) : discrete_topology (finset (has_neg real)) := sorry --non-trivial
lemma new_lemma_182636 (h0 : group (denumerable linarith.ineq)) : normalizer_condition (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_182637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_182638 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : totally_separated_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_182639 (h0 : functor.add_const (function.extfun Type ring) (has_pos_part linarith.comp)) : @is_principal_ideal_ring.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_pos_part.{0} linarith.comp) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182640 (h0 : topological_space (linear_order congr_arg_kind)) : preirreducible_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182642 (h0 : functor.add_const (group (semigroup linarith.comp)) Type) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_182643 (h0 : functor.add_const Prop unsigned) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_182644 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @rank_condition.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_182645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182646 (h0 : not (group (mul_zero_class num) -> false)) : @is_cyclic.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182647 (h0 : preorder linarith.ineq) (h2 : Prop) : set.is_pwo (id (fun (h1 : linarith.ineq), h2)) := sorry --non-trivial
lemma new_lemma_182648 (h1 : fun_info -> fun_info -> Prop) : is_trans fun_info h1 := sorry --non-trivial
lemma new_lemma_182649 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_182650 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182651 (h0 : topological_space (ring ennreal)) : totally_separated_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_182652 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182653 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @irreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_182654 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string name)) := sorry --non-trivial
lemma new_lemma_182655 (h0 : topological_space (with_bot (has_top linarith.comp_source))) : totally_disconnected_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182656 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_182657 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : normal_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182658 (h0 : topological_space (has_zero num)) : loc_path_connected_space (has_zero num) := sorry --non-trivial
lemma new_lemma_182659 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_182660 (h0 : ring (linear_ordered_comm_group ennreal)) : rank_condition (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_182661 (h0 : topological_space (bin_tree (semiring (semiring (semiring num))))) : path_connected_space (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_182662 (h0 : list (distrib_lattice (random_gen (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182663 (h0 : topological_space (random_gen (semiring num))) : discrete_topology (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_182664 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182665 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182666 (h0 : complete_lattice (pseudo_metric_space unsigned)) : is_compactly_generated (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_182667 (h0 : functor.comp semiring has_to_string pos) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_182668 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_182669 (h0 : uniform_space (has_lt (mul_one_class (mul_one_class string_imp)))) : complete_space (has_lt (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_182670 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @totally_separated_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_182671 (h0 : filter (boolean_algebra.core empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182672 (h0 : complete_lattice (has_norm (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_182673 (h0 : not (add_group (with_one linarith.ineq) -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_182674 (h0 : topological_space (normed_comm_ring (has_nndist pos))) : preconnected_space (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_182675 (h0 : topological_space (measurable_space (has_inv (has_inv fun_info)))) : totally_separated_space (measurable_space (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_182676 (h0 : not (add_group (has_emptyc fun_info) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_182677 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (filter empty)))) : @unique_factorization_monoid.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (filter.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (filter.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_182678 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : totally_disconnected_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_182679 (h0 : not (ring (add_right_cancel_monoid empty) -> false)) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182680 (h0 : topological_space (finset (cancel_monoid environment.implicit_infer_kind))) : preirreducible_space (finset (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182681 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @normal_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182682 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182683 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid pos) name) (option (option name))) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} pos) name) (option.{0} (option.{0} name)) h0))  := sorry --non-trivial
lemma new_lemma_182684 (h0 : topological_space (with_bot (has_inv (has_inv to_additive.value_type)))) : path_connected_space (with_bot (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_182685 (h0 : topological_space (finset name)) : locally_compact_space (finset name) := sorry --non-trivial
lemma new_lemma_182686 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_182687 (h0 : functor.add_const (list (has_Inf linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182688 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_182689 (h0 : set (char -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_182690 (h0 : not (add_group (add_group empty) -> false)) : @is_add_cyclic.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_182691 (h0 : fin has_zero.zero) : @is_domain.{0} (has_pos_part.{0} (has_Inf.{0} linarith.comp)) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_182692 (h0 : complete_lattice (has_compl (metric_space (random_gen to_additive.value_type)))) : is_compactly_generated (has_compl (metric_space (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_182693 (h0 : fin has_zero.zero) : @separated_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182694 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182695 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182696 (h0 : group_with_zero (ring (has_zero num)) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_182697 (h0 : not (topological_space (semiring linarith.comp) -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182698 (h0 : topological_space (add_semigroup congr_arg_kind)) : discrete_topology (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182699 (h0 : ring (semigroup (boolean_algebra.core pos))) : strong_rank_condition (semigroup (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_182700 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @irreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_182701 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_182702 (h0 : has_lt (complete_distrib_lattice string.iterator_imp)) : no_max_order (complete_distrib_lattice string.iterator_imp) := sorry --non-trivial
lemma new_lemma_182703 (h0 : function.extfun Type (functor.add_const (filter auto.case_option))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_182704 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_182705 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @preconnected_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_182706 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_182707 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_182708 (h0 : functor.add_const (ring pos) linarith.comp) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182709 (h0 : uniform_space (has_zero (has_neg (finset (has_neg (has_neg_part (ring linarith.comp))))))) : complete_space (has_zero (has_neg (finset (has_neg (has_neg_part (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_182710 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_182711 (h0 : topological_space (linear_ordered_semiring (semiring (semiring num)))) : preirreducible_space (linear_ordered_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_182712 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : t1_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182713 (h0 : topological_space (mul_one_class (pseudo_metric_space (pseudo_metric_space char)))) : totally_disconnected_space (mul_one_class (pseudo_metric_space (pseudo_metric_space char))) := sorry --non-trivial
lemma new_lemma_182714 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (complete_distrib_lattice linarith.comp)))) : @preconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_182715 (h0 : list (has_emptyc (has_emptyc fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182716 (h0 : group (linear_ordered_semiring fun_info)) : group.fg (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_182717 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))  := sorry --non-trivial
lemma new_lemma_182718 (h0 : group (add_group (has_norm (has_norm linarith.comp)))) : normalizer_condition (add_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_182719 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182721 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @irreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_182722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_182723 (h0 : topological_space (comm_group (has_add name))) : t1_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_182724 (h0 : semiring (normed_comm_ring (has_add linarith.comp))) : is_noetherian_ring (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_182725 (h0 : complete_lattice (has_zero (has_add environment.implicit_infer_kind))) : is_atomistic (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182726 (h0 : topological_space (has_nndist (has_to_string (has_to_string unsigned)))) : locally_compact_space (has_nndist (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_182727 (h0 : has_pos_part (has_add Type) -> has_pos_part (has_add Type) -> Prop) : is_per (has_pos_part (has_add Type)) h0 := sorry --non-trivial
lemma new_lemma_182728 (h0 : topological_space (has_bot (has_add (sub_neg_monoid Type)))) : t1_space (has_bot (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_182729 (h0 : functor.add_const (filter (ring pos)) (has_neg Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182730 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) Type) : @rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_182731 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182732 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182733 (h0 : add_group (complete_semilattice_Sup (has_inv fun_info))) : is_add_cyclic (complete_semilattice_Sup (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_182734 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @locally_compact_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_182735 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf name)) : @normal_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} name) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_182736 (h0 : functor.add_const (list (has_add Type)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182737 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group Type)) : @topological_space.separable_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_182738 (h0 : topological_space (with_one (has_norm congr_arg_kind))) : path_connected_space (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182739 (h0 h1 : nat) (h2 : eq h0 (has_add.add h1 h1)) (h3 : fin h0 -> Prop) (h4 : fin h1) : matrix.vec_alt0 h2 h3 h4 := sorry --non-trivial
lemma new_lemma_182740 (h0 : ring (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : rank_condition (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_182741 (h2 : ring (denumerable fun_info)) : is_domain (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_182742 (h0 : list (finset (measurable_space.dynkin_system unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : not (has_add empty -> false)) : @has_measurable_add.{0} empty (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 measurable_space.{0}) empty) (@classical.by_contradiction'.{1} (has_add.{0} empty) h1)  := sorry --non-trivial
lemma new_lemma_182744 (h0 : add_monoid (ordered_comm_ring (has_add pos))) : add_monoid.fg (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_182745 (h1 : uniform_space (distrib fun_info)) : complete_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_182746 (h0 : topological_space (metric_space (semiring (has_top congr_arg_kind)))) : normal_space (metric_space (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_182747 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182748 (h0 : uniform_space (has_to_string (semigroup linarith.comp))) : separated_space (has_to_string (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_182749 (h0 : char -> std_gen) (h1 : set char) (h2 : std_gen) : set.kern_image h0 h1 h2 := sorry --non-trivial
lemma new_lemma_182750 (h0 : topological_space (partial_order unsigned)) : loc_path_connected_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_182751 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_182752 (h0 : group (random_gen (semiring unsigned))) : is_cyclic (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182753 (h0 : topological_space (semiring (semiring congr_arg_kind))) : locally_compact_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182754 (h0 : group (encodable (random_gen (random_gen (random_gen (random_gen string_imp)))))) : group.fg (encodable (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_182755 (h0 : topological_space (has_one (semiring (has_norm congr_arg_kind)))) : preirreducible_space (has_one (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_182756 (h0 : functor.add_const (group (ordered_ring empty)) unsigned) : @group.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182757 (h2 : complete_lattice (random_gen linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_182758 (h1 : topological_space (with_bot (random_gen to_additive.value_type))) : t0_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_182759 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182760 (h0 : uniform_space (comm_group (has_to_string unsigned))) : complete_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_182761 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182762 (h0 : add_monoid (semiring (semiring (semiring (semiring empty))))) : add_monoid.fg (semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_182763 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182764 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_182765 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_182766 (h0 : functor.add_const (filter (semigroup pos)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_182767 (h2 : uniform_space environment.projection_info) : complete_space environment.projection_info := sorry --non-trivial
lemma new_lemma_182768 (h0 : topological_space (has_pos_part (finset (has_neg (has_neg (has_neg linarith.comp)))))) : preconnected_space (has_pos_part (finset (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_182769 (h0 : functor.add_const (uniform_space (has_nndist environment.implicit_infer_kind)) Type) : @complete_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_182770 (h0 : group (linear_order (option unsigned))) : is_cyclic (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_182771 (h2 : ring (comm_ring char)) : rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_182772 (h0 : uniform_space (has_neg empty)) : complete_space (has_neg empty) := sorry --non-trivial
lemma new_lemma_182773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_182774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182775 (h0 : measurable_space (semi_normed_comm_ring linarith.comp_source)) (h1 : filter (semi_normed_comm_ring linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_182776 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_182777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (partial_order num)) := sorry --non-trivial
lemma new_lemma_182778 (h0 : semiring (ordered_ring (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (ordered_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_182779 (h0 : topological_space (comm_group (has_to_string name))) : locally_compact_space (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_182780 (h0 : functor.add_const (topological_space (linear_ordered_field unsigned)) unsigned) : @t0_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182781 (h1 : complete_lattice (has_div string_imp)) : complete_lattice.is_Sup_finite_compact (has_div string_imp) := sorry --non-trivial
lemma new_lemma_182782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182783 (h0 : ring (has_to_string (option (option (option (option (option ennreal))))))) : is_principal_ideal_ring (has_to_string (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_182784 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_182785 (h0 : not (ring (add_right_cancel_monoid num) -> false)) : @rank_condition.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182786 (h0 : topological_space (semigroup (option pos))) : totally_separated_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_182787 (h0 : ordered_add_comm_monoid (semigroup (ring ennreal))) : archimedean (semigroup (ring ennreal)) := sorry --non-trivial
lemma new_lemma_182788 (h0 : ring (has_Inf (finset (has_add (has_pos_part (has_add pos)))))) : strong_rank_condition (has_Inf (finset (has_add (has_pos_part (has_add pos))))) := sorry --non-trivial
lemma new_lemma_182789 (h1 : function.extfun Type topological_space) : @normal_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182790 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_182791 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_182792 (h0 : uniform_space (semi_normed_comm_ring fun_info)) : complete_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_182793 (h0 : uniform_space (ordered_comm_monoid (ring name))) : complete_space (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_182794 (h0 : fin has_zero.zero) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_182795 (h1 : add_group (distrib_lattice string_imp)) : is_add_cyclic (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_182796 (h0 : topological_space (generalized_boolean_algebra (has_neg linarith.comp))) : path_connected_space (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_182797 (h1 : group (measurable_space (with_bot (with_bot string_imp)))) : normalizer_condition (measurable_space (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_182798 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_182799 (h0 : topological_space (canonically_ordered_add_monoid empty)) : loc_path_connected_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_182800 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182801 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @totally_separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182802 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_182803 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_182804 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_182805 (h0 : topological_space (add_cancel_monoid (option unsigned))) : preirreducible_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_182806 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_182807 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182808 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182809 (h1 : set (std_gen -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_182810 (h0 : complete_lattice (random_gen (semiring (has_norm linarith.comp)))) : is_compactly_generated (random_gen (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_182811 (h0 : filter (left_cancel_semigroup (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182812 (h1 : function.extfun Type ring) : @is_domain.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_182813 (h0 : topological_space (metric_space (semiring unsigned))) : t1_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182814 (h0 : topological_space (with_one (random_gen linarith.comp_source))) : totally_disconnected_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_182815 (h1 : list (has_top (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_182816 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182817 (h0 : functor.add_const (semiring (has_to_string Type)) Type) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_182818 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182819 (h0 : fin has_zero.zero) : @is_simple_group.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (group.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_182820 (h2 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h2) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_182821 (h0 : topological_space (uniform_space (has_div (mul_one_class linarith.comp_source)))) : totally_disconnected_space (uniform_space (has_div (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_182822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_182823 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182824 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182825 (h0 : topological_space (has_norm (semiring (semiring empty)))) : discrete_topology (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_182826 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_182827 (h0 : not (topological_space (semi_normed_ring to_additive.value_type) -> false)) : @t0_space.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_182828 (h0 : add_group (semigroup (finset (finset (has_neg (has_add linarith.comp)))))) : is_add_cyclic (semigroup (finset (finset (has_neg (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_182829 (h0 : uniform_space (has_bot (has_add (has_add (has_Inf Type))))) : complete_space (has_bot (has_add (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_182830 (h0 : set (mul_one_class fun_info -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_182831 (h1 : not (ring (comm_ring linarith.comp_source) -> false)) : @rank_condition.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_182832 (h1 : set (mul_one_class (linear_ordered_comm_monoid_with_zero std_gen))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_182833 (h0 : not (monoid (has_top num) -> false)) : @monoid.fg.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182834 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @preirreducible_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_182835 (h0 : topological_space (nondiscrete_normed_field (mul_one_class ereal))) : path_connected_space (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_182836 (h0 : topological_space (has_top (has_norm (has_norm (has_norm to_additive.value_type))))) : t0_space (has_top (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_182837 (h1 : topological_space (dlist linarith.ineq)) : t0_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_182838 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_182839 (h0 : pseudo_metric_space std_gen) (h1 : add_monoid std_gen) : has_lipschitz_add std_gen := sorry --non-trivial
lemma new_lemma_182840 (h0 : functor.add_const (topological_space (ordered_semiring unsigned)) num) : @locally_compact_space.{0} (ordered_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_182841 (h0 : group (with_bot (comm_ring (has_norm fun_info)))) : is_cyclic (with_bot (comm_ring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_182842 (h0 : not (ring (has_div string.iterator_imp) -> false)) : @rank_condition.{0} (has_div.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_182843 (h0 : functor.add_const (uniform_space (comm_group Type)) (has_neg_part environment.implicit_infer_kind)) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) (has_neg_part.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_182844 (h0 : topological_space (preorder (semiring num))) : t1_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_182845 (h0 : functor.add_const (add_group (add_cancel_monoid pos)) (finset pos)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_182846 (h0 : topological_space (add_cancel_monoid (has_to_string (has_to_string Type)))) : preirreducible_space (add_cancel_monoid (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_182847 (h0 : group (has_star (semiring congr_arg_kind))) : group.fg (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182848 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_atomistic.{0} (complete_semilattice_Sup.{0} (semiring.{0} (has_norm.{0} fun_info))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) (complete_semilattice_Sup.{0} (semiring.{0} (has_norm.{0} fun_info))))  := sorry --non-trivial
lemma new_lemma_182849 (h0 : ring (has_nndist (semigroup name))) : is_domain (has_nndist (semigroup name)) := sorry --non-trivial
lemma new_lemma_182850 (h0 : functor.add_const (topological_space (add_group empty)) unsigned) : @t1_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182851 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) (finset (has_Inf pos))) : @group.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) (finset.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_182852 (h0 : topological_space (group_with_zero (option unsigned))) : preirreducible_space (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_182853 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_182854 (h0 : group (comm_semigroup Type)) : normalizer_condition (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_182855 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_182856 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_182857 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_182858 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_182859 (h0 : group (has_star unsigned)) : group.fg (has_star unsigned) := sorry --non-trivial
lemma new_lemma_182860 (h0 : set (has_le string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_182861 (h0 h1 : multiset (has_le linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_182862 (h0 : add_group (bin_tree (option (option (option (option (option unsigned))))))) : is_add_cyclic (bin_tree (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_182863 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @sequential_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_182864 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid Type))) : preconnected_space (complete_distrib_lattice (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_182865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_182866 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_Inf name)) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_182867 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_182868 (h0 : complete_lattice (bin_tree (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182869 (h0 : cancel_comm_monoid_with_zero (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_182870 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_182871 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_182872 (h0 : topological_space (id string_imp)) : locally_compact_space (id string_imp) := sorry --non-trivial
lemma new_lemma_182873 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) pos) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_182874 (h1 : group (denumerable (random_gen reducibility_hints))) : is_cyclic (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_182875 (h0 : not (ring (has_top fun_info) -> false)) : @rank_condition.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_182876 (h0 : function.extfun (group (with_bot num) -> false) (fun (x : group (with_bot num) -> false), false)) : @normalizer_condition.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} num)) (@function.extfun_app.{0 0} (group.{0} (with_bot.{0} num) → false) (λ (x : group.{0} (with_bot.{0} num) → false), false) h0))  := sorry --non-trivial
lemma new_lemma_182877 (h0 : functor.add_const (monoid (has_zero linarith.comp)) (ring Type)) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_182878 (h0 : not (add_group (random_gen reducibility_hints) -> false)) : @is_add_cyclic.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_182879 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_182880 (h1 : set (random_gen string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_182881 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : locally_compact_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_182882 (h0 : topological_space (add_semigroup unsigned)) : totally_separated_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_182883 (h0 : function.extfun nat fin) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_182884 (h0 : complete_lattice (has_to_string (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_182885 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182886 (h0 : group (has_Inf (has_add (has_pos_part linarith.comp)))) : is_simple_group (has_Inf (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_182887 (h0 : measurable_space (has_compl string.iterator_imp)) (h1 : filter (has_compl string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_182888 (h0 : has_neg (has_compl (semi_normed_ring (mul_one_class linarith.ineq)))) (h1 : measurable_space (has_compl (semi_normed_ring (mul_one_class linarith.ineq)))) : has_measurable_neg (has_compl (semi_normed_ring (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_182889 (h0 : list (linear_ordered_comm_monoid_with_zero (has_edist (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_182890 (h0 : ring (has_star (has_norm empty))) : strong_rank_condition (has_star (has_norm empty)) := sorry --non-trivial
lemma new_lemma_182891 (h0 : complete_lattice (semigroup (has_neg (has_neg (has_neg Type))))) : is_compactly_generated (semigroup (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_182892 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_182893 (h0 : topological_space (has_add (has_Inf (has_Inf real)))) : discrete_topology (has_add (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_182894 (h0 : monoid (boolean_algebra (has_neg pos))) : monoid.fg (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_182895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182896 (h0 : topological_space (has_Inf (has_neg (ring name)))) : preconnected_space (has_Inf (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_182897 (h0 : ring (has_pos_part (has_add linarith.comp))) : is_domain (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_182898 (h2 : topological_space (mul_one_class to_additive.value_type)) : path_connected_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_182899 (h0 : uniform_space (linear_ordered_semiring (has_norm congr_arg_kind))) : separated_space (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182900 (h0 : ring (add_cancel_monoid (has_nndist Type))) : rank_condition (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_182901 (h0 : ring (sub_neg_monoid (has_add (has_Inf Type)))) : is_principal_ideal_ring (sub_neg_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_182902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182903 (h0 : ring (has_nndist (parser (ring name)))) : is_principal_ideal_ring (has_nndist (parser (ring name))) := sorry --non-trivial
lemma new_lemma_182904 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182905 (h0 : add_group (normed_group (has_norm (semiring num)))) : is_add_cyclic (normed_group (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_182906 (h0 : topological_space (has_star (semiring empty))) : irreducible_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_182907 (h0 : add_monoid (has_to_string (option unsigned))) : add_monoid.fg (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_182908 (h0 : monoid (has_top to_additive.value_type)) : monoid.fg (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_182909 (h0 : not (filter (linear_ordered_semiring congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_182910 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_Inf linarith.comp)))) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_182911 (h0 : topological_space (canonically_ordered_comm_semiring (option (option unsigned)))) : path_connected_space (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_182912 (h0 : group (measure_theory.measure_space (semiring unsigned))) : group.fg (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_182913 (h1 : not (has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_182914 (h0 : semiring (semigroup (has_to_string Type))) : is_noetherian_ring (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_182915 (h0 : add_group (linear_ordered_field ennreal)) : is_add_cyclic (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_182916 (h0 : not (ring (with_bot congr_arg_kind) -> false)) : @rank_condition.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_182917 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_182918 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_182920 (h0 : topological_space (complete_distrib_lattice ennreal)) : path_connected_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_182921 (h0 : functor.comp finset pseudo_metric_space name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_182922 (h0 : topological_space (random_gen (has_norm (has_norm (has_top fun_info))))) : locally_compact_space (random_gen (has_norm (has_norm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_182923 (h0 : not (ring (add_group num) -> false)) : @rank_condition.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_182924 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182925 (h0 : functor.add_const (ring (has_add Type)) name) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_182926 (h0 : topological_space (has_one empty)) : locally_compact_space (has_one empty) := sorry --non-trivial
lemma new_lemma_182927 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182928 (h0 : functor.comp topological_space complete_distrib_lattice pos) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_182929 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182930 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @discrete_topology.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_182931 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_182932 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_182933 (h0 : group (linear_ordered_comm_monoid_with_zero (option (option (option unsigned))))) : group.fg (linear_ordered_comm_monoid_with_zero (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_182934 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182935 (h0 : not (topological_space (has_nnnorm string.iterator_imp) -> false)) : @t0_space.{0} (has_nnnorm.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_182936 (h0 : group (option unsigned)) : is_simple_group (option unsigned) := sorry --non-trivial
lemma new_lemma_182937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_182938 (h0 : ring (ordered_cancel_add_comm_monoid (has_to_string congr_arg_kind))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_182939 (h0 : filter (topological_space (has_ssubset linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_182940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (metric_space empty)) := sorry --non-trivial
lemma new_lemma_182941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_182942 (h0 : group (with_bot (has_top (has_top (has_emptyc (has_top congr_arg_kind)))))) : group.fg (with_bot (has_top (has_top (has_emptyc (has_top congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_182943 (h0 : monoid (has_emptyc (has_inv linarith.ineq))) : monoid.fg (has_emptyc (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182944 (h0 : topological_space (has_dist empty)) : normal_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_182945 (h0 : topological_space (comm_semigroup real)) : totally_disconnected_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_182946 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_182947 (h0 : list (with_bot (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182948 (h0 : topological_space (canonically_ordered_comm_semiring (finset pos))) : discrete_topology (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_182949 (h0 : topological_space (normed_field (has_nnnorm linarith.ineq))) : t0_space (normed_field (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182950 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182951 (h0 : not (functor.add_const Prop (has_union unsigned) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_182952 (h0 : topological_space (simple_graph (has_neg (ring linarith.comp)))) : path_connected_space (simple_graph (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_182953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_182954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_182955 (h0 : functor.add_const (complete_lattice ennreal) ennreal) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_182956 (h0 : complete_lattice (normed_field (has_lt (metric_space linarith.comp_source)))) : is_compactly_generated (normed_field (has_lt (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_182957 (h0 : mul_one_class (add_cancel_comm_monoid char)) (h1 : ring (submonoid (add_cancel_comm_monoid char))) : strong_rank_condition (submonoid (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_182958 (h0 : list (measurable_space (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_182959 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup reducibility_hints))) : totally_disconnected_space (nondiscrete_normed_field (add_comm_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_182960 (h0 : not (uniform_space (random_gen linarith.comp) -> false)) : @separated_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_182961 (h0 : monoid (id (has_norm linarith.comp))) : monoid.fg (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_182962 (h0 : functor.add_const Prop (finset (finset Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_182963 (h0 : topological_space (dlist (random_gen (random_gen string_imp)))) : irreducible_space (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_182964 (h0 : uniform_space (mul_one_class (mul_one_class pos))) : separated_space (mul_one_class (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_182965 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid (has_add name)))) : regular_space (add_cancel_monoid (add_cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_182966 (h0 : filter (ordered_comm_ring (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_182967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182968 (h0 : topological_space (topological_space (random_gen to_additive.value_type))) : t0_space (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_182969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_top.{0} (with_bot.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} (with_bot.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_182970 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_182971 (h0 : not (uniform_space (uniform_space char) -> false)) : @complete_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_182972 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_182973 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (add_comm_monoid pos))) : unique_factorization_monoid (cancel_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_182974 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @preconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_182975 (h0 : ordered_add_comm_monoid (has_Inf (simple_graph pos))) : archimedean (has_Inf (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_182976 (h0 : add_group (dlist fun_info)) : is_add_cyclic (dlist fun_info) := sorry --non-trivial
lemma new_lemma_182977 (h0 : topological_space (has_nndist (finset (finset name)))) : totally_separated_space (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_182978 (h0 : group (add_comm_monoid (has_add (has_add Type)))) : is_simple_group (add_comm_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_182979 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) name) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_182980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182981 (h0 : ordered_add_comm_monoid (finset linarith.comp)) : archimedean (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_182982 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) name) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_182983 (h0 : functor.add_const (topological_space (has_add pos)) (ring environment.implicit_infer_kind)) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_182984 (h0 : group (ordered_comm_group empty)) : group.fg (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_182985 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist (option unsigned))) := sorry --non-trivial
lemma new_lemma_182986 (h0 : topological_space (preorder (semiring (semiring unsigned)))) : irreducible_space (preorder (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_182987 (h0 : topological_space (ring (option (option empty)))) : preconnected_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_182988 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_182989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_182990 (h0 : function.extfun Type (prod (canonically_linear_ordered_monoid ennreal))) : id_rel (function.extfun_app h0 (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_182991 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_182992 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf (sub_neg_monoid (has_Inf pos))))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf (sub_neg_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_182993 (h0 : group (with_bot congr_arg_kind)) : normalizer_condition (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_182994 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_182995 (h0 : topological_space (with_one (has_one (has_one (has_one (id (id linarith.comp))))))) : irreducible_space (with_one (has_one (has_one (has_one (id (id linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_182996 (h0 : topological_space (has_top fun_info)) : irreducible_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_182997 (h0 : ring (add_monoid (add_monoid linarith.ineq))) : strong_rank_condition (add_monoid (add_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182998 (h0 : add_monoid (has_add (finset Type))) : add_monoid.fg (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_182999 (h0 : complete_lattice (with_bot (has_top (has_top (has_top linarith.comp_source))))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_183000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183002 (h0 : metric_space (as_linear_order congr_arg_kind)) (h1 : set (as_linear_order congr_arg_kind)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_183003 (h0 : not (group (denumerable fun_info) -> false)) : @is_cyclic.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_183004 (h2 : not (ring (has_compl char) -> false)) : @rank_condition.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_183005 (h0 : topological_space (has_add unsigned)) : preirreducible_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_183006 (h0 : num -> num -> Prop) : is_strict_order num h0 := sorry --non-trivial
lemma new_lemma_183007 (h0 : topological_space (linear_ordered_add_comm_group string_imp)) : totally_separated_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_183008 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183009 (h0 : topological_space (has_pos_part (has_Inf Type))) : locally_compact_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_183010 (h1 : topological_space (semi_normed_comm_ring string.iterator_imp)) : path_connected_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_183011 (h0 : Prop) (h1 : decidable h0) (h2 : uniform_space (plift (as_false h0))) : complete_space (plift (as_false h0)) := sorry --non-trivial
lemma new_lemma_183012 (h0 : functor.add_const (ring (has_nndist pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_183013 (h0 : topological_space (encodable char)) : path_connected_space (encodable char) := sorry --non-trivial
lemma new_lemma_183014 (h0 : topological_space (complete_distrib_lattice (has_neg_part Type))) : topological_space.separable_space (complete_distrib_lattice (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_183015 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (boolean_algebra Type)) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_183016 (h0 : finset (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183017 (h0 : topological_space (semigroup (ring environment.implicit_infer_kind))) : regular_space (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183018 (h0 : list (has_zero (boolean_algebra (comm_group (has_neg_part Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_183019 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_Inf pos)) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183020 (h0 : ring (free_add_monoid (option unsigned))) : is_domain (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_183021 (h0 : semiring (finset (normed_comm_ring linarith.comp))) : is_noetherian_ring (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_183022 (h0 : topological_space (comm_group (has_to_string unsigned))) : loc_path_connected_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_183023 (h0 : functor.add_const (add_monoid (has_neg_part name)) pos) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_183024 (h0 : functor.add_const (topological_space (finset Type)) Type) : @topological_space.separable_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_183025 (h0 : group (boolean_algebra.core (has_neg (has_pos_part (has_Inf (has_neg Type)))))) : group.fg (boolean_algebra.core (has_neg (has_pos_part (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_183026 (h0 : topological_space (ring (has_to_string (comm_group Type)))) : path_connected_space (ring (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_183027 (h0 : not (ring (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @is_domain.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_183028 (h0 : topological_space (random_gen (has_norm num))) : t0_space (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_183029 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183030 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183031 (h0 : ring (dlist (has_inv linarith.ineq))) : rank_condition (dlist (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183032 (h0 : functor.add_const (ring (finset Type)) name) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_183033 (h0 : group (has_add (has_ssubset to_additive.value_type))) : is_cyclic (has_add (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183034 (h0 : prod (has_nndist (has_add pos)) (has_nndist (has_add pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_183035 (h0 : group (random_gen (semiring (has_top unsigned)))) : normalizer_condition (random_gen (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_183036 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183037 (h0 : functor.add_const (ring (has_to_string pos)) Type) : @strong_rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_183038 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_183040 (h0 : complete_lattice (has_star num)) : is_compactly_generated (has_star num) := sorry --non-trivial
lemma new_lemma_183041 (h0 : topological_space (has_bot (has_neg pos))) : t0_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_183042 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183043 (h0 : filter (ordered_comm_ring (has_pos_part name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_183044 (h0 : not (topological_space (has_inv to_additive.value_type) -> false)) : @path_connected_space.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_183045 (h0 : not (topological_space (with_bot linarith.comp_source) -> false)) : @locally_compact_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_183046 (h0 : topological_space (option empty)) : totally_separated_space (option empty) := sorry --non-trivial
lemma new_lemma_183047 (h0 : complete_lattice (random_gen (has_norm to_additive.value_type))) : is_atomistic (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183048 (h0 : complete_lattice (has_Sup (option (option unsigned)))) : is_compactly_generated (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_183049 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_183050 (h0 : add_group (semi_normed_comm_ring enat)) : is_add_cyclic (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_183051 (h1 : filter (dlist (random_gen (with_zero char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_183052 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_183053 (h0 : ring (denumerable (random_gen string_imp))) : is_domain (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_183054 (h0 : semiring (non_assoc_semiring unsigned)) : is_noetherian_ring (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_183055 (h0 : topological_space (has_zero pos)) : totally_disconnected_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_183056 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : locally_compact_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183057 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : normal_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183058 (h0 : topological_space (has_one (linear_ordered_semiring congr_arg_kind))) : locally_compact_space (has_one (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183059 (h0 : add_group (semigroup (option (has_nndist (has_nndist ennreal))))) : is_add_cyclic (semigroup (option (has_nndist (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_183060 (h0 : ring (encodable (has_nnnorm (has_nnnorm string_imp)))) : strong_rank_condition (encodable (has_nnnorm (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_183061 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (random_gen linarith.comp_source)))) : totally_disconnected_space (semi_normed_comm_ring (has_ssubset (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_183062 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183063 (h0 : list (add_comm_monoid (normed_comm_ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_183064 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_183065 (h0 : group (linear_ordered_semiring (has_norm empty))) : normalizer_condition (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_183066 (h0 : topological_space (boolean_algebra (has_to_string Type))) : topological_space.separable_space (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_183067 (h0 : topological_space (has_add (has_add (has_to_string linarith.comp)))) : path_connected_space (has_add (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_183068 (h0 : function.extfun Type topological_space) : @normal_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_183069 (h0 : complete_lattice (has_append (has_nnnorm fun_info))) : is_compactly_generated (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_183070 (h0 : not (topological_space (random_gen linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_183071 (h0 : set (add_comm_semigroup std_gen -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183072 (h0 : topological_space (boolean_algebra (cancel_monoid Type))) : normal_space (boolean_algebra (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_183073 (h0 : topological_space (mul_zero_class pos)) : t0_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_183074 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183075 (h0 : topological_space (has_pos_part (has_add (boolean_algebra.core linarith.comp)))) : preconnected_space (has_pos_part (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_183076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_183077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183078 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183079 (h0 : topological_space (has_add to_additive.value_type)) : t0_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183080 (h0 : add_group (has_pos_part (has_Inf (has_add linarith.comp)))) : is_add_cyclic (has_pos_part (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_183081 (h0 : topological_space (distrib_lattice (has_inv (comm_ring (has_inv linarith.ineq))))) : totally_separated_space (distrib_lattice (has_inv (comm_ring (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_183082 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) Type) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_183083 (h0 : functor.comp add_monoid has_nndist pos) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_183084 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_183085 (h0 : group (semiring unsigned)) : group.fg (semiring unsigned) := sorry --non-trivial
lemma new_lemma_183086 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @topological_space.separable_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_183087 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_183088 (h0 : group (ring (has_neg pos))) : is_simple_group (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_183089 (h1 : preorder (mul_one_class (mul_one_class enat))) (h2 : set (mul_one_class (mul_one_class enat))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_183090 (h0 : set (normed_field string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_183091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_183092 (h0 : semiring (ring (has_zero (finset (finset linarith.comp))))) : is_noetherian_ring (ring (has_zero (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_183093 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @regular_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_183094 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_183095 (h1 : uniform_space (semiring linarith.comp)) : complete_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_183096 (h0 : filter (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183097 (h0 : functor.add_const (topological_space (has_neg pos)) (comm_group name)) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_183098 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_183099 (h0 : complete_lattice (metric_space (has_norm (has_norm (has_norm linarith.comp))))) : is_atomistic (metric_space (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_183100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_183101 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_183102 (h0 : ring (semigroup unsigned)) : strong_rank_condition (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_183103 (h0 : complete_lattice (semi_normed_ring (mul_one_class to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183104 (h0 : complete_lattice (has_nndist Type)) : is_atomistic (has_nndist Type) := sorry --non-trivial
lemma new_lemma_183105 (h0 : topological_space (add_left_cancel_semigroup (option (option empty)))) : path_connected_space (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_183106 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_183107 (h0 : monoid (has_top (random_gen num))) : monoid.fg (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_183108 (h0 : ordered_add_comm_monoid (normed_comm_ring empty)) : archimedean (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_183109 (h0 : functor.add_const (function.extfun Type group) name) : @is_simple_group.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_183110 (h0 : add_monoid (add_cancel_monoid Type)) : add_monoid.fg (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_183111 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183112 (h0 : complete_lattice (option empty)) : is_atomistic (option empty) := sorry --non-trivial
lemma new_lemma_183113 (h0 : functor.add_const (uniform_space (linear_ordered_cancel_comm_monoid empty)) empty) : @complete_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183114 (h0 : not (group (mul_zero_class congr_arg_kind) -> false)) : @is_cyclic.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_183115 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183116 (h0 : ordered_add_comm_monoid (boolean_algebra (add_comm_monoid (has_add (comm_group unsigned))))) : archimedean (boolean_algebra (add_comm_monoid (has_add (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_183117 (h0 : topological_space (has_sub (semiring num))) : t0_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_183118 (h0 : add_group (random_gen (random_gen fun_info))) : is_add_cyclic (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_183119 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_183120 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183121 (h0 : cancel_comm_monoid_with_zero (plift empty)) : unique_factorization_monoid (plift empty) := sorry --non-trivial
lemma new_lemma_183122 (h0 : ordered_comm_monoid (normed_comm_ring (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183123 (h0 : not (ring (has_compl (has_nnnorm linarith.ineq)) -> false)) : @is_domain.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_183124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_183125 (h0 : functor.add_const (list (cancel_monoid name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183126 (h0 : fin has_zero.zero) : @is_cyclic.{0} real (@matrix.vec_empty.{0} (group.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_183127 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : preconnected_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_183128 (h0 : set (char -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183129 (h0 : function.extfun Type ring) : @rank_condition.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183130 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183131 (h0 : ring (cancel_monoid pos)) : rank_condition (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_183132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_183133 (h0 : functor.add_const (topological_space (option empty)) unsigned) : @irreducible_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183134 (h0 : functor.add_const (list (has_to_string linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183135 (h0 : functor.add_const (list (normed_comm_ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183136 (h0 : ring (has_compl (mul_one_class reducibility_hints))) : rank_condition (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_183137 (h0 : topological_space (comm_group (has_nndist Type))) : sequential_space (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_183138 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_183139 (h0 : not (topological_space (partial_order empty) -> false)) : @t0_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_183140 (h0 : functor.add_const (group auto.case_option) linarith.comp) : @is_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183141 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_183142 (h0 : fin has_zero.zero) (h1 : has_add (has_Inf name)) : @has_measurable_add.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (measurable_space.{0} (has_Inf.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) h1  := sorry --non-trivial
lemma new_lemma_183143 (h0 : topological_space (boolean_algebra.core (has_neg (has_neg unsigned)))) : regular_space (boolean_algebra.core (has_neg (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_183144 (h0 : functor.add_const (list (mul_zero_class Type)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183145 (h0 : topological_space (add_left_cancel_semigroup (option (option empty)))) : discrete_topology (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_183146 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183147 (h0 : group (plift unsigned)) : group.fg (plift unsigned) := sorry --non-trivial
lemma new_lemma_183148 (h0 : fin has_zero.zero) : @rank_condition.{1} (ordered_comm_monoid.{1} (has_Inf.{1} (has_add.{1} Type))) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} (has_Inf.{1} (has_add.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_183149 (h0 : uniform_space (left_cancel_semigroup (semiring num))) : separated_space (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_183150 (h0 : topological_space (has_nndist (has_pos_part (has_add name)))) : locally_compact_space (has_nndist (has_pos_part (has_add name))) := sorry --non-trivial
lemma new_lemma_183151 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg linarith.comp)) : @normal_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_183152 (h0 : topological_space (has_ssubset (has_ssubset (random_gen to_additive.value_type)))) : path_connected_space (has_ssubset (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_183153 (h0 : ring (has_inv (random_gen (random_gen to_additive.value_type)))) : strong_rank_condition (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_183154 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183155 (h0 : topological_space (has_bot (has_Inf (ordered_comm_monoid (sub_neg_monoid Type))))) : sequential_space (has_bot (has_Inf (ordered_comm_monoid (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_183156 (h1 : uniform_space (with_one congr_arg_kind)) : complete_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183157 (h0 : topological_space (has_zero name)) : sequential_space (has_zero name) := sorry --non-trivial
lemma new_lemma_183158 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (ring linarith.comp)) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_183159 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_183160 (h0 : finset (simple_graph (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183161 (h0 : group (has_neg ennreal)) : is_cyclic (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_183162 (h0 : ordered_add_comm_monoid (normed_comm_ring (option (option (option empty))))) : archimedean (normed_comm_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_183163 (h0 : topological_space (has_ssubset (random_gen (has_nnnorm linarith.ineq)))) : path_connected_space (has_ssubset (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_183164 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_183165 (h0 : ring (has_zero (has_neg Type))) : rank_condition (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_183166 (h0 : ring (add_comm_semigroup (add_comm_semigroup fun_info))) : rank_condition (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_183167 (h0 : topological_space (with_bot (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (with_bot (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_183168 (h0 : list (add_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183169 (h1 : topological_space (comm_ring (has_ssubset (random_gen to_additive.value_type)))) : locally_compact_space (comm_ring (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_183170 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : regular_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_183171 (h1 : ring (encodable char)) : is_domain (encodable char) := sorry --non-trivial
lemma new_lemma_183172 (h1 : filter (encodable fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_183173 (h0 : group (finset (add_comm_monoid pos))) : is_cyclic (finset (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_183174 (h0 : ring (boolean_algebra (has_Inf (has_Inf pos)))) : rank_condition (boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_183175 (h0 : ring (has_to_string (has_to_string Type))) : strong_rank_condition (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_183176 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183177 (h0 : function.extfun Type topological_space) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183178 (h0 : functor.add_const (ring (option empty)) congr_arg_kind) : @rank_condition.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_183179 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183180 (h0 : complete_lattice (has_bot empty)) : complete_lattice.is_Sup_finite_compact (has_bot empty) := sorry --non-trivial
lemma new_lemma_183181 (h0 : add_group (random_gen linarith.comp)) : is_add_cyclic (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_183182 (h0 : group (has_add (boolean_algebra environment.implicit_infer_kind))) : is_simple_group (has_add (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183183 (h0 : topological_space (finset congr_arg_kind)) : t0_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183184 (h0 : group (denumerable to_additive.value_type)) : normalizer_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183185 (h0 : group (comm_group (has_neg_part (has_to_string unsigned)))) : normalizer_condition (comm_group (has_neg_part (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_183186 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp))) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183187 (h0 : monoid (normed_lattice_add_comm_group (has_bot (has_bot real)))) : monoid.fg (normed_lattice_add_comm_group (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_183188 (h0 : topological_space (ordered_comm_ring unsigned)) : discrete_topology (ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_183189 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_183190 (h0 : cancel_comm_monoid_with_zero (has_top (semiring (semiring (semiring unsigned))))) : unique_factorization_monoid (has_top (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_183191 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_183192 (h0 : topological_space (ring congr_arg_kind)) : loc_path_connected_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183193 (h1 : complete_lattice enat) : complete_lattice.is_Sup_finite_compact enat := sorry --non-trivial
lemma new_lemma_183194 (h0 : group (has_nndist (finset (finset (finset ennreal))))) : is_cyclic (has_nndist (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_183195 (h0 : ring (add_left_cancel_monoid string_imp)) : is_domain (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_183196 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : topological_space.separable_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_183197 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183198 (h0 : finset (boolean_algebra (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183199 (h0 : set (add_comm_semigroup std_gen -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183201 (h1 : ring (semi_normed_comm_ring linarith.ineq)) : strong_rank_condition (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_183202 (h0 : functor.add_const (complete_lattice (has_nndist pos)) linarith.comp) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183203 (h0 : add_monoid (add_comm_monoid empty)) : add_monoid.fg (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_183204 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_183205 (h0 : monoid (with_bot (comm_monoid (has_inv linarith.ineq)))) : monoid.fg (with_bot (comm_monoid (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_183206 (h1 : set (char -> add_comm_semigroup char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_183207 (h5 : ring (normed_field (mul_one_class std_gen))) : is_domain (normed_field (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_183208 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183209 (h0 : functor.add_const (semiring (has_to_string Type)) linarith.comp) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183210 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) (has_neg Type)) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_183211 (h0 : function.extfun Type (prod (ordered_ring (semiring empty)))) : id_rel (function.extfun_app h0 (ordered_ring (semiring empty))) := sorry --non-trivial
lemma new_lemma_183212 (h0 : functor.comp topological_space boolean_algebra name) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0))  := sorry --non-trivial
lemma new_lemma_183213 (h0 : functor.add_const (group (has_neg_part ennreal)) linarith.comp) : @is_simple_group.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183214 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183215 (h0 : has_lt (has_div linarith.comp_source)) : no_max_order (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183216 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183217 (h0 : add_monoid (boolean_algebra.core (normed_comm_ring Type))) : add_monoid.fg (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_183218 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183219 (h0 : not (uniform_space (topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) -> false)) : @complete_space.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_183220 (h0 : function.extfun Type (functor.add_const (list (measurable_space.dynkin_system empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 (semiring num))) := sorry --non-trivial
lemma new_lemma_183221 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_183222 (h0 : complete_lattice (has_norm unsigned)) : is_compactly_generated (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_183223 (h0 : topological_space (as_linear_order empty)) : totally_separated_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_183224 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183225 (h0 : group (add_cancel_comm_monoid (topological_space (has_nnnorm reducibility_hints)))) : is_cyclic (add_cancel_comm_monoid (topological_space (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_183226 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) (has_pos_part (boolean_algebra.core Type))) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_Inf.{0} linarith.comp)) (has_pos_part.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_183227 (h0 : fin has_zero.zero) : @preconnected_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_183228 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183229 (h0 : topological_space (complete_distrib_lattice (option pos))) : topological_space.separable_space (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_183230 (h0 : topological_space (add_right_cancel_monoid empty)) : totally_disconnected_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_183231 (h0 : preorder (mul_one_class (add_comm_semigroup char))) (h1 : set (mul_one_class (add_comm_semigroup char))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_183232 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_183233 (h0 : uniform_space (comm_group linarith.comp)) : complete_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_183234 (h2 : topological_space string_imp) : t0_space string_imp := sorry --non-trivial
lemma new_lemma_183235 (h0 : topological_space (mul_zero_class (normed_comm_ring Type))) : discrete_topology (mul_zero_class (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_183236 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra pos)) pos) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_183237 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) : unique_factorization_monoid (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_183238 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183239 (h0 : uniform_space (semiring (has_top fun_info))) : complete_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_183240 (h0 : topological_space (has_top (has_top (has_top num)))) : totally_disconnected_space (has_top (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_183241 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_ring num)) := sorry --non-trivial
lemma new_lemma_183242 (h0 : ring (generalized_boolean_algebra (has_Inf Type))) : strong_rank_condition (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_183243 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183244 (h0 : group (distrib_lattice (has_inv (random_gen fun_info)))) : group.fg (distrib_lattice (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_183245 (h0 : ring (boolean_algebra (has_add environment.implicit_infer_kind))) : is_domain (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183246 (h1 : ring (random_gen string_imp)) : strong_rank_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_183247 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.ineq))) : @is_domain.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183248 (h1 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_183249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183250 (h0 : topological_space (has_zero (measurable_space name))) : preconnected_space (has_zero (measurable_space name)) := sorry --non-trivial
lemma new_lemma_183251 (h1 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183252 (h0 : functor.add_const Prop (has_nndist name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_183253 (h0 : topological_space (random_gen (random_gen (random_gen (has_top (random_gen linarith.comp_source)))))) : irreducible_space (random_gen (random_gen (random_gen (has_top (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_183254 (h0 : group (has_nndist (finset environment.implicit_infer_kind))) : is_simple_group (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183255 (h0 : cancel_comm_monoid_with_zero (comm_group (comm_group Type))) : unique_factorization_monoid (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_183256 (h0 : functor.add_const (complete_lattice (pseudo_metric_space empty)) (option (option (option (option unsigned))))) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} empty)) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_183257 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183258 (h1 : ring (has_ssubset string_imp)) : strong_rank_condition (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_183259 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t0_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_183260 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_183261 (h0 : ordered_add_comm_monoid (boolean_algebra (finset (finset linarith.comp)))) : archimedean (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_183262 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183263 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_183264 (h0 : complete_lattice (has_nndist (option (option (option empty))))) : is_compactly_generated (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_183265 (h0 : set (add_comm_semigroup char -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183266 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_183267 (h0 : nat) (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (zmod h0) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (zmod h0))  := sorry --non-trivial
lemma new_lemma_183268 (h0 : topological_space (add_cancel_monoid (has_Inf name))) : irreducible_space (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_183269 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183270 (h0 : not (group (normed_group to_additive.value_type) -> false)) : @group.fg.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_183271 (h0 : topological_space (has_nnnorm (dlist fun_info))) : locally_compact_space (has_nnnorm (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_183272 (h0 : filter (with_zero (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183273 (h0 : topological_space (partial_order (semiring (semiring (semiring unsigned))))) : discrete_topology (partial_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_183274 (h0 : topological_space (has_top linarith.ineq)) : locally_compact_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_183275 (h0 : semiring (id (complete_semilattice_Sup (semiring empty)))) : is_noetherian_ring (id (complete_semilattice_Sup (semiring empty))) := sorry --non-trivial
lemma new_lemma_183276 (h0 : topological_space (monoid_with_zero (option (option unsigned)))) : discrete_topology (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_183277 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_183278 (h0 : functor.add_const (filter (boolean_algebra name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183279 (h0 : functor.comp cancel_comm_monoid_with_zero ring name) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_183280 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : preirreducible_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_183281 (h0 : finset (canonically_ordered_comm_semiring (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183282 (h0 : semiring (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg name)))))) : is_noetherian_ring (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_183283 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183284 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part name)) pos) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_183285 (h0 : topological_space string.iterator) : t0_space string.iterator := sorry --non-trivial
lemma new_lemma_183286 (h0 : functor.add_const (finset (complete_linear_order empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183287 (h0 : topological_space (comm_group (cancel_monoid name))) : locally_compact_space (comm_group (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_183288 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_183289 (h0 : topological_space (measurable_space.dynkin_system (mul_one_class linarith.ineq))) : totally_disconnected_space (measurable_space.dynkin_system (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183290 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_183291 (h0 : functor.add_const (add_group (simple_graph linarith.comp)) name) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_183292 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_183293 (h0 : not (list (non_assoc_semiring empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_183294 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup num))) : @is_cyclic.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183295 (h0 : ring (has_Inf (has_add (has_add name)))) : rank_condition (has_Inf (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_183296 (h0 : uniform_space (has_nnnorm enat)) : complete_space (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_183297 (h0 : ring (has_neg (semigroup name))) : is_domain (has_neg (semigroup name)) := sorry --non-trivial
lemma new_lemma_183298 (h0 : fin has_zero.zero) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_183299 (h0 : functor.add_const (topological_space (has_inter unsigned)) unsigned) : @path_connected_space.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183300 (h0 : topological_space (has_emptyc (has_norm to_additive.value_type))) : path_connected_space (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183301 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183302 (h0 : uniform_space (has_neg (comm_group (semigroup Type)))) : separated_space (has_neg (comm_group (semigroup Type))) := sorry --non-trivial
lemma new_lemma_183303 (h0 : topological_space (add_semigroup num)) : t0_space (add_semigroup num) := sorry --non-trivial
lemma new_lemma_183304 (h0 : topological_space (has_add (mul_one_class environment.implicit_infer_kind))) : regular_space (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183305 (h0 : add_monoid (has_neg (has_pos_part (has_neg (has_pos_part linarith.comp))))) : add_monoid.fg (has_neg (has_pos_part (has_neg (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_183306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_183307 (h0 : add_monoid (has_zero (has_add linarith.comp))) : add_monoid.fg (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_183308 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : loc_path_connected_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_183309 (h2 : ring (complete_semilattice_Sup (has_norm linarith.comp))) : strong_rank_condition (complete_semilattice_Sup (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_183310 (h0 : functor.add_const (function.extfun Type add_group) unsigned) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) unsigned h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183311 (h0 : group (comm_monoid congr_arg_kind)) : is_cyclic (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183313 (h0 : topological_space (comm_group (comm_group name))) : discrete_topology (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_183314 (h0 : uniform_space (has_neg (has_pos_part linarith.comp))) : complete_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_183315 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid Type))) : discrete_topology (complete_distrib_lattice (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_183316 (h1 : ring (comm_ring (has_nnnorm char))) : is_domain (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_183317 (h0 : ring (semiring linarith.comp)) : is_domain (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_183318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183319 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_183320 (h0 : topological_space (semigroup (has_to_string linarith.comp))) : totally_disconnected_space (semigroup (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_183321 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_183322 (h0 : ring (has_compl (comm_ring (comm_ring (random_gen linarith.ineq))))) : rank_condition (has_compl (comm_ring (comm_ring (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_183323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_183324 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_183325 (h1 : set (add_comm_semigroup enat -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_183326 (h0 : add_group (uniform_space enat)) : is_add_cyclic (uniform_space enat) := sorry --non-trivial
lemma new_lemma_183327 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen fun_info))))) : locally_compact_space (has_ssubset (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_183328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183329 (h0 : functor.add_const (add_group (add_cancel_monoid name)) (has_add pos)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183330 (h0 : thunk pnat) (h1 : list pnat) (h2 : pnat) : pnat.coprime (@list.ilast'.{0} pnat (@trace_call_stack.{0} pnat h0) h1) h2  := sorry --non-trivial
lemma new_lemma_183331 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183332 (h0 : topological_space (option pos)) : normal_space (option pos) := sorry --non-trivial
lemma new_lemma_183333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_183334 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_add_monoid congr_arg_kind)) : unique_factorization_monoid (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183335 (h0 : not (topological_space (has_norm linarith.comp) -> false)) : @totally_separated_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_183336 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_183337 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @totally_separated_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_183338 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_183339 (h0 : topological_space (monoid_with_zero linarith.comp_source)) : path_connected_space (monoid_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183340 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @irreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183341 (h1 : group (semi_normed_comm_ring linarith.ineq)) : is_cyclic (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_183342 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183343 (h0 : add_group nnreal) : is_add_cyclic nnreal := sorry --non-trivial
lemma new_lemma_183344 (h0 : function.extfun Type measurable_space) (h1 : has_add (comm_ring to_additive.value_type)) : @has_measurable_add.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (comm_ring.{0} to_additive.value_type)) h1  := sorry --non-trivial
lemma new_lemma_183345 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183346 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_183347 (h0 : topological_space (has_Inf (ring pos))) : totally_disconnected_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_183348 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183349 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @t1_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183350 (h0 : ring (has_bot congr_arg_kind)) : is_principal_ideal_ring (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183351 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_183352 (h0 : list (has_emptyc (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183353 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183354 (h0 : pnat) (h1 : ulower (ulower pnat)) : pnat.coprime h0 (ulower.up (ulower.up (id h1))) := sorry --non-trivial
lemma new_lemma_183355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183356 (h0 : uniform_space (id string_imp)) : complete_space (id string_imp) := sorry --non-trivial
lemma new_lemma_183357 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) empty) : @t1_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_183358 (h0 : group (add_group (semiring congr_arg_kind))) : normalizer_condition (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183359 (h3 : topological_space (simple_graph (mul_one_class char))) (h4 : preorder (simple_graph (mul_one_class char))) : order_closed_topology (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_183360 (h0 : topological_space (has_norm (semiring (has_norm linarith.comp)))) : totally_separated_space (has_norm (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_183361 (h0 : ring (has_emptyc (has_top num))) : rank_condition (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_183362 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_183363 (h0 : uniform_space (semigroup environment.implicit_infer_kind)) : separated_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_183364 (h0 : topological_space (has_to_string (ring environment.implicit_infer_kind))) : sequential_space (has_to_string (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183365 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (option (option (option unsigned))))) : unique_factorization_monoid (complete_distrib_lattice (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_183366 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_183367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_183368 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_183369 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_183370 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : normal_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_183371 (h0 : topological_space (boolean_algebra (cancel_monoid name))) : totally_disconnected_space (boolean_algebra (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_183372 (h0 : topological_space (cancel_monoid (add_cancel_monoid Type))) : path_connected_space (cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_183373 (h0 : add_monoid (has_pos_part (finset environment.implicit_infer_kind))) : add_monoid.fg (has_pos_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183374 (h0 : not (topological_space (has_norm char) -> false)) : @locally_compact_space.{0} (has_norm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_183375 (h0 : functor.add_const (filter (has_to_string pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183377 (h0 : uniform_space (linear_order empty)) : separated_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_183378 (h0 : functor.add_const (ring (mul_zero_class num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_183379 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183380 (h0 : group (complete_distrib_lattice (has_neg (has_neg linarith.comp)))) : group.fg (complete_distrib_lattice (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_183381 (h0 : topological_space (cancel_monoid unsigned)) : preirreducible_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_183382 (h0 : list (has_nndist (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183383 (h0 : complete_lattice (normed_lattice_add_comm_group name)) : is_compactly_generated (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_183384 (h0 : not (topological_space (has_top fun_info) -> false)) : @irreducible_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_183385 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_183386 (h0 : complete_lattice (has_bot (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_183387 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_183388 (h0 : finset (comm_group (has_add (cancel_monoid unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183390 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) empty) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183391 (h3 : not (topological_space (nondiscrete_normed_field char) -> false)) (h4 : add_group (nondiscrete_normed_field char)) : @topological_add_group.{0} (nondiscrete_normed_field.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (nondiscrete_normed_field.{0} char)) h3) h4  := sorry --non-trivial
lemma new_lemma_183392 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183393 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : irreducible_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_183394 (h0 : topological_space (has_top (has_top fun_info))) : path_connected_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_183395 (h0 : group (boolean_algebra (sub_neg_monoid pos))) : normalizer_condition (boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_183396 (h0 : topological_space (ordered_comm_ring (has_add (has_add (has_neg (has_neg Type)))))) : normal_space (ordered_comm_ring (has_add (has_add (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_183397 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : t0_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_183398 (h0 : function.extfun (function.extfun Type ring -> false) (fun (x : function.extfun Type ring -> false), false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{0 0} (function.extfun.{2 1} Type ring.{0} → false) (λ (x : function.extfun.{2 1} Type ring.{0} → false), false) h0)) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183399 (h0 : topological_space (has_ssubset (random_gen (has_nnnorm linarith.comp_source)))) : t0_space (has_ssubset (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_183400 (h0 : set (has_div (mul_one_class (mul_one_class fun_info)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_183401 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183402 (h0 : ring (has_add (ordered_comm_monoid linarith.comp))) : is_domain (has_add (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_183403 (h1 : group (normed_group linarith.ineq)) : group.fg (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_183404 (h0 : topological_space (boolean_algebra.core pos)) : path_connected_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_183405 (h0 : topological_space (semiring (random_gen (random_gen string_imp)))) : path_connected_space (semiring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_183406 (h0 : topological_space (mul_zero_class (has_to_string Type))) : normal_space (mul_zero_class (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_183407 (h0 : cancel_comm_monoid_with_zero (has_add (option (option ennreal)))) : unique_factorization_monoid (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_183408 (h0 : functor.comp list add_cancel_monoid name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_183409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183410 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183411 (h0 : function.extfun nat fin) : @is_simple_group.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_183412 (h1 : prod (add_comm_semigroup enat) (add_comm_semigroup enat)) : set.diagonal (add_comm_semigroup enat) h1 := sorry --non-trivial
lemma new_lemma_183413 (h0 : group (measurable_space (has_norm (normed_group (has_top congr_arg_kind))))) : normalizer_condition (measurable_space (has_norm (normed_group (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_183414 (h0 : topological_space (semiring congr_arg_kind)) : path_connected_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183415 (h0 : set (simple_graph string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_183416 (h0 : pos -> pos -> Prop) (h1 : set pos) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_183417 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp))))) : irreducible_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_183418 (h1 : ring (has_inv (random_gen to_additive.value_type))) : is_domain (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183419 (h0 : uniform_space (ordered_comm_group (option empty))) : separated_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_183420 (h2 : topological_space (has_ssubset string_imp)) : path_connected_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_183421 (h0 : topological_space (random_gen (semiring (semiring (has_norm (semiring congr_arg_kind)))))) : normal_space (random_gen (semiring (semiring (has_norm (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_183422 (h0 : has_lt (mul_one_class std_gen)) : no_max_order (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_183423 (h0 : topological_space (ring (option (option (option ennreal))))) : irreducible_space (ring (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_183424 (h0 : functor.add_const (list (ordered_comm_ring pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183425 (h0 : monoid (has_bot (has_add Type))) : monoid.fg (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_183426 (h0 : set (sym2 std_gen)) (h1 h2 : std_gen) : sym2.to_rel h0 h1 h2 := sorry --non-trivial
lemma new_lemma_183427 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) (has_neg (finset Type))) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) (has_neg.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_183428 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_183429 (h0 : group (comm_ring linarith.ineq)) : is_cyclic (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_183430 (h0 : add_group (random_gen (comm_ring (comm_ring (has_nnnorm char))))) : is_add_cyclic (random_gen (comm_ring (comm_ring (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_183431 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @topological_space.separable_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_183432 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_183433 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_183434 (h0 : functor.add_const (ring (normed_comm_ring ennreal)) ennreal) : @strong_rank_condition.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_183435 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183436 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : topological_space.separable_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_183437 (h0 : functor.add_const Prop (has_neg_part ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_183438 (h0 : group (linear_ordered_semiring (has_norm unsigned))) : group.fg (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_183439 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183440 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183441 (h2 : group (id linarith.comp_source)) : normalizer_condition (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183442 (h0 : ring (free_add_monoid unsigned)) : strong_rank_condition (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_183443 (h0 h1 : multiset (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_183444 (h0 : not (group (has_sdiff string.iterator_imp) -> false)) : @is_cyclic.{0} (has_sdiff.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (has_sdiff.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_183445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_183446 (h0 : functor.add_const (topological_space (ring Type)) (ring pos)) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183447 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183448 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : preirreducible_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183449 (h0 : congr_arg_kind -> congr_arg_kind -> Prop) (h1 : set congr_arg_kind) : is_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_183450 (h0 : uniform_space reducibility_hints -> reducibility_hints) (h1 : coe_sort (set.range h0)) : @complete_space.{0} reducibility_hints (@set.range_splitting.{0 0} (uniform_space.{0} reducibility_hints) reducibility_hints h0 h1)  := sorry --non-trivial
lemma new_lemma_183451 (h0 : ring (pseudo_metric_space congr_arg_kind)) : strong_rank_condition (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183452 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_183453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183454 (h0 : topological_space (has_pos_part (finset (has_add (has_pos_part pos))))) : totally_disconnected_space (has_pos_part (finset (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_183455 (h0 : set (has_le reducibility_hints -> mul_one_class environment.projection_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183456 (h0 : add_group (distrib (has_nnnorm (has_nnnorm (mul_one_class (has_nnnorm reducibility_hints)))))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm (mul_one_class (has_nnnorm reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_183457 (h0 : not (uniform_space (partial_order empty) -> false)) : @separated_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_183458 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string environment.implicit_infer_kind)) pos) : @unique_factorization_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_183459 (h1 : set (enat -> add_comm_semigroup enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_183460 (h0 : fin has_zero.zero) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_183461 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @monoid.fg.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))))))))))  := sorry --non-trivial
lemma new_lemma_183462 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_183463 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_183464 (h0 : not (add_group (normed_field linarith.comp_source) -> false)) : @is_add_cyclic.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_183465 (h0 : functor.add_const (group (normed_comm_ring Type)) environment.implicit_infer_kind) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_183466 (h0 : topological_space (has_zero ennreal)) : normal_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_183467 (h1 : filter (has_add linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_183468 (h0 : topological_space (semigroup (has_neg_part pos))) : sequential_space (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_183469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : normal_space ennreal := sorry --non-trivial
lemma new_lemma_183470 (h0 : filter (has_add (ring pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183471 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183472 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183473 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_183474 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_183475 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183476 (h0 : has_lt (has_ssubset (add_comm_semigroup enat))) : no_max_order (has_ssubset (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_183477 (h0 : group (linear_ordered_comm_monoid_with_zero empty)) : normalizer_condition (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_183478 (h0 : ring (normed_linear_ordered_group num)) : rank_condition (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_183479 (h0 : topological_space (has_zero (finset linarith.comp))) : irreducible_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_183480 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_183481 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra real)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_183482 (h0 : functor.add_const (filter (ordered_comm_monoid Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183483 (h0 : topological_space (add_comm_monoid (has_neg_part linarith.comp))) : sequential_space (add_comm_monoid (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_183484 (h0 : topological_space (comm_semigroup (has_Inf (has_pos_part (ordered_comm_monoid pos))))) : normal_space (comm_semigroup (has_Inf (has_pos_part (ordered_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_183485 (h0 : function.extfun Type (functor.add_const (ring znum))) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_183486 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183487 (h0 : topological_space (complete_distrib_lattice (has_Inf real))) : locally_compact_space (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_183488 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf (has_bot Type)))))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf (has_bot Type))))) := sorry --non-trivial
lemma new_lemma_183489 (h0 : functor.add_const (group (has_nndist ennreal)) (option name)) : @normalizer_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} ennreal)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_183490 (h0 : fin has_zero.zero) : @archimedean.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_183491 (h0 : functor.add_const (semiring (left_cancel_monoid num)) unsigned) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183492 (h0 : complete_lattice (has_pos_part pos)) : is_atomistic (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_183493 (h0 : list (linear_ordered_comm_ring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183494 (h0 : list (ring (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_183495 (h0 : functor.add_const (uniform_space (has_to_string Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_183496 (h0 : ring (add_right_cancel_monoid unsigned)) : is_principal_ideal_ring (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_183497 (h0 : complete_lattice (has_neg_part (finset (ring (add_comm_monoid (has_neg_part (finset Type))))))) : is_atomistic (has_neg_part (finset (ring (add_comm_monoid (has_neg_part (finset Type)))))) := sorry --non-trivial
lemma new_lemma_183498 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_183499 (h0 : topological_space (has_to_string (has_pos_part Type))) : locally_compact_space (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_183500 (h0 : ring (group_with_zero (option num))) : is_principal_ideal_ring (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_183501 (h0 : topological_space (complete_distrib_lattice name)) : t1_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_183502 (h0 : topological_space (fintype string_imp)) : t0_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_183503 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @normal_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_183504 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183505 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_183506 (h0 : topological_space (ring (has_neg (has_neg linarith.comp)))) : preirreducible_space (ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_183507 (h0 : functor.add_const (finset (has_dist unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183508 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183509 (h5 : function.extfun Type group) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h5 string_imp)  := sorry --non-trivial
lemma new_lemma_183510 (h0 : topological_space (ring (has_add pos))) : sequential_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_183511 (h0 : functor.add_const (complete_lattice (has_Sup empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183512 (h0 : functor.add_const (semiring (has_to_string linarith.comp)) Type) : @is_noetherian_ring.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_183513 (h0 : functor.add_const (add_monoid (cancel_monoid Type)) name) : @add_monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_183514 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_183515 (h0 : function.extfun Type group) : @group.fg.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_183516 (h0 : fin has_zero.zero) : @complete_space.{0} (normed_group.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} string_imp)))))) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_group.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} (with_bot.{0} string_imp))))))) h0)  := sorry --non-trivial
lemma new_lemma_183517 (h0 : not (complete_lattice (measurable_space.dynkin_system linarith.comp) -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_183518 (h0 : group (add_group (semiring fun_info))) : is_cyclic (add_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_183519 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : discrete_topology (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_183520 (h0 : functor.add_const (semiring (bin_tree unsigned)) unsigned) : @is_noetherian_ring.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183521 (h0 : functor.add_const (filter (has_add unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183522 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_183523 (h0 : not (filter (power_series linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_183524 (h0 : ring (has_add char)) : strong_rank_condition (has_add char) := sorry --non-trivial
lemma new_lemma_183525 (h0 : complete_lattice (with_one (has_top (has_top (has_top linarith.comp_source))))) : is_atomistic (with_one (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_183526 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183527 (h1 : ring (has_one fun_info)) : is_domain (has_one fun_info) := sorry --non-trivial
lemma new_lemma_183528 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_183529 (h0 : topological_space (has_dist (comm_monoid (comm_monoid unsigned)))) : irreducible_space (has_dist (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_183530 (h0 : ring (boolean_algebra (boolean_algebra.core Type))) : rank_condition (boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_183531 (h0 : list (semigroup (semigroup (boolean_algebra (boolean_algebra (semigroup pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183532 (h0 : topological_space (has_neg (option pos))) : t0_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_183533 (h0 : complete_lattice (distrib (denumerable to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (distrib (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183534 (h0 : not (add_group (has_compl fun_info) -> false)) : @is_add_cyclic.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_183535 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : normal_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_183536 (h0 : uniform_space (measurable_space (has_top num))) : complete_space (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_183537 (h0 : filter (canonically_ordered_comm_semiring (comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_183538 (h0 : uniform_space (add_comm_monoid (sub_neg_monoid (comm_semigroup pos)))) : complete_space (add_comm_monoid (sub_neg_monoid (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_183539 (h0 : uniform_space (distrib (comm_ring linarith.ineq))) : complete_space (distrib (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183540 (h0 : not (semiring (complete_linear_order num) -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_183541 (h0 : uniform_space (has_one (has_top num))) : complete_space (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_183542 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : irreducible_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_183543 (h0 : topological_space (uniform_space (has_div linarith.comp_source))) : t0_space (uniform_space (has_div linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_183544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183545 (h0 : group (ordered_comm_ring (has_add (has_Inf (has_neg linarith.comp))))) : normalizer_condition (ordered_comm_ring (has_add (has_Inf (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_183546 (h0 : uniform_space (ring (has_neg name))) : separated_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_183547 (h0 : filter (has_emptyc (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183548 (h1 : not (add_group (linear_ordered_comm_group_with_zero string_imp) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_183549 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183550 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_183551 (h0 : topological_space (boolean_algebra pos)) : normal_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_183552 (h0 : add_monoid (add_comm_monoid (has_add (has_to_string name)))) : add_monoid.fg (add_comm_monoid (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_183553 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_neg (has_neg name))) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_183554 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : totally_separated_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183555 (h0 : functor.add_const Prop (has_neg name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_183556 (h0 : topological_space (comm_ring (random_gen (has_top linarith.ineq)))) : t0_space (comm_ring (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_183557 (h0 : uniform_space (with_one (has_norm congr_arg_kind))) : separated_space (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_183559 (h0 : not (topological_space (semi_normed_comm_ring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_183560 (h1 : ring (comm_ring (has_nnnorm linarith.ineq))) : rank_condition (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183561 (h0 : topological_space (complete_linear_order (semiring num))) : totally_disconnected_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_183562 (h0 : not (monoid (non_assoc_semiring congr_arg_kind) -> false)) : @monoid.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_183563 (h0 : add_monoid (has_union (has_top (semiring congr_arg_kind)))) : add_monoid.fg (has_union (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_183564 (h2 : ring (fintype (distrib char))) : rank_condition (fintype (distrib char)) := sorry --non-trivial
lemma new_lemma_183565 (h0 : not (add_group (mul_one_class reducibility_hints) -> false)) : @is_add_cyclic.{0} (mul_one_class.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (mul_one_class.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_183566 (h0 : topological_space (has_nndist (has_Inf real))) : irreducible_space (has_nndist (has_Inf real)) := sorry --non-trivial
lemma new_lemma_183567 (h0 : function.extfun (Type 1) (functor.comp topological_space has_to_string)) : @preirreducible_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_to_string.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_183568 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_183569 (h1 : group (normed_field (normed_field linarith.ineq))) : is_cyclic (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183570 (h0 : topological_space (has_neg Type)) : locally_compact_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_183571 (h0 : ring (complete_semilattice_Sup fun_info)) : strong_rank_condition (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_183572 (h0 : topological_space (has_zero (has_add (has_add pos)))) : preconnected_space (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_183573 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) unsigned) : @preirreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) unsigned h0))  := sorry --non-trivial
lemma new_lemma_183574 (h0 : complete_lattice (id linarith.ineq)) : complete_lattice.is_Sup_finite_compact (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_183575 (h0 : topological_space (linear_ordered_field (option unsigned))) : preconnected_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_183576 (h2 : filter (has_emptyc linarith.comp)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_183577 (h0 : topological_space (add_cancel_monoid (measure_theory.measure_space pos))) : preconnected_space (add_cancel_monoid (measure_theory.measure_space pos)) := sorry --non-trivial
lemma new_lemma_183578 (h0 : group (complete_semilattice_Sup (has_nnnorm (random_gen char)))) : group.fg (complete_semilattice_Sup (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_183579 (h1 : topological_space (has_emptyc (random_gen linarith.ineq))) : totally_disconnected_space (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183580 (h0 : functor.add_const (group (cancel_monoid Type)) pos) : @is_simple_group.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_183581 (h0 : functor.add_const (complete_lattice (sub_neg_monoid name)) pos) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_183582 (h0 : group (has_pos_part (has_add pos))) : is_cyclic (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_183583 (h0 : ring (normed_lattice_add_comm_group linarith.comp)) : rank_condition (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_183584 (h0 : add_monoid (linear_ordered_comm_group unsigned)) : add_monoid.fg (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_183585 (h0 : topological_space (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : normal_space (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_183586 (h0 : ring (semiring (random_gen to_additive.value_type))) : strong_rank_condition (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183587 (h0 : set (has_nnnorm (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_183588 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) unsigned) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183589 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_183590 (h0 : group (complete_distrib_lattice (option empty))) : normalizer_condition (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_183591 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_183592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_183593 (h0 : ring (random_gen (has_ssubset reducibility_hints))) : is_domain (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_183594 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_183595 (h0 : has_lt (non_unital_non_assoc_semiring char)) : no_max_order (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_183596 (h0 : topological_space (has_compl (mul_one_class reducibility_hints))) : totally_disconnected_space (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_183597 (h0 : topological_space (measurable_space linarith.comp_source)) : path_connected_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183598 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (normed_comm_ring pos)) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183599 (h0 : monoid (canonically_ordered_comm_semiring pos)) : monoid.fg (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_183600 (h0 : fin has_zero.zero) : @monoid.fg.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_183601 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183602 (h0 : functor.comp topological_space mul_zero_class ennreal) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_183603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_183604 (h0 : function.extfun Type group) : @group.fg.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183605 (h0 : fin has_zero.zero) : @separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_183606 (h0 : topological_space (encodable linarith.ineq)) : totally_disconnected_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_183607 (h0 : functor.add_const (group (finset linarith.comp)) (has_neg pos)) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183608 (h0 : ordered_comm_monoid (boolean_algebra (has_add name))) : has_exists_mul_of_le (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_183609 (h1 : add_group (has_inv string_imp)) : is_add_cyclic (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_183610 (h0 : topological_space (add_cancel_monoid (has_pos_part Type))) : discrete_topology (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_183611 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_183612 (h0 : not (topological_space (has_div string_imp) -> false)) : @totally_disconnected_space.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_183613 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_183614 (h0 : monoid (has_add unsigned)) : monoid.fg (has_add unsigned) := sorry --non-trivial
lemma new_lemma_183615 (h0 : topological_space (add_semigroup congr_arg_kind)) : totally_separated_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183616 (h0 : complete_lattice (topological_space (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_183617 (h0 : group (fintype to_additive.value_type)) : group.fg (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183618 (h0 : functor.add_const (filter Type) (has_Inf (finset Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183619 (h0 : has_mem.mem (linear_ordered_semiring linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_183620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_183621 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_inv.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} fun_info))))))) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_inv.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} fun_info))))))))  := sorry --non-trivial
lemma new_lemma_183622 (h0 : ring (has_neg_part (has_zero ennreal))) : strong_rank_condition (has_neg_part (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_183623 (h2 : monoid string_imp) : monoid.fg string_imp := sorry --non-trivial
lemma new_lemma_183624 (h0 : not (has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_183625 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_183626 (h0 : add_monoid (normed_group (semiring num))) : add_monoid.fg (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_183627 (h0 : topological_space (has_to_string (has_add pos))) : discrete_topology (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_183628 (h0 : topological_space (left_cancel_monoid (semiring num))) : t0_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_183629 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183630 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_183631 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_183632 (h0 : topological_space (has_union empty)) : totally_disconnected_space (has_union empty) := sorry --non-trivial
lemma new_lemma_183633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183634 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_183635 (h0 : ring (partial_order congr_arg_kind)) : is_domain (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183636 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) congr_arg_kind) : @rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_183637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : has_mem.mem (canonically_linear_ordered_monoid linarith.comp_source) has_emptyc.emptyc) : @normed_group.core.{0} (canonically_linear_ordered_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_comm_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_comm_group.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type has_norm.{0} (canonically_linear_ordered_monoid.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_183639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_183640 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) pos) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_183641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183642 (h0 : topological_space (has_bot (ordered_comm_monoid (ordered_comm_monoid real)))) : normal_space (has_bot (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_183643 (h0 : function.extfun nat fin) : @separated_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_183644 (h0 : add_group (simple_graph linarith.comp)) : is_add_cyclic (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_183645 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) (has_add pos)) : @strong_rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_183646 (h0 : ring (has_compl to_additive.value_type)) : strong_rank_condition (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183647 (h0 : add_monoid (normed_lattice_add_comm_group (ordered_comm_monoid (sub_neg_monoid pos)))) : add_monoid.fg (normed_lattice_add_comm_group (ordered_comm_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_183648 (h2 : filter (complete_distrib_lattice (has_nnnorm fun_info))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_183649 (h0 : not (function.extfun (finset Type) (has_mem.mem unsigned) -> false)) : @is_compactly_generated.{0} unsigned (@finset.pi.empty.{1 0} Type complete_lattice.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_183650 (h0 : topological_space (cancel_monoid congr_arg_kind)) : normal_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183651 (h0 : function.extfun Type (functor.comp filter normed_comm_ring)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_183652 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_183653 (h0 : topological_space (ring (ring (ring (ring (ring linarith.comp)))))) : loc_path_connected_space (ring (ring (ring (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_183654 (h0 : has_neg (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) (h1 : measurable_space (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : has_measurable_neg (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_183655 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : locally_compact_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183656 (h0 : topological_space (normed_field (has_nnnorm fun_info))) : path_connected_space (normed_field (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_183657 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183658 (h0 : topological_space (normed_comm_ring (comm_group ennreal))) : locally_compact_space (normed_comm_ring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_183659 (h0 : topological_space (add_cancel_monoid name)) : totally_disconnected_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_183660 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_183661 (h0 : topological_space (boolean_algebra (comm_group linarith.comp))) : normal_space (boolean_algebra (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_183662 (h2 : group (with_zero char)) : is_cyclic (with_zero char) := sorry --non-trivial
lemma new_lemma_183663 (h0 : not (ring (has_union num) -> false)) : @is_principal_ideal_ring.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_183664 (h0 : topological_space (ordered_comm_group (comm_monoid (option empty)))) : preirreducible_space (ordered_comm_group (comm_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_183665 (h0 : uniform_space (pseudo_metric_space (option ennreal))) : separated_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_183666 (h0 : group (with_zero (has_nnnorm string_imp))) : is_cyclic (with_zero (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_183667 (h0 : topological_space (ring (has_pos_part Type))) : discrete_topology (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_183668 (h0 : semiring (simple_graph (boolean_algebra.core (ordered_comm_monoid (has_neg name))))) : is_noetherian_ring (simple_graph (boolean_algebra.core (ordered_comm_monoid (has_neg name)))) := sorry --non-trivial
lemma new_lemma_183669 (h0 : complete_lattice (has_add (cancel_monoid (has_add name)))) : is_compactly_generated (has_add (cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_183670 (h0 : functor.add_const (ring (has_Inf pos)) Type) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_183671 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) Type) := sorry --non-trivial
lemma new_lemma_183672 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))))))  := sorry --non-trivial
lemma new_lemma_183673 (h0 : topological_space (has_top (has_top linarith.comp_source))) : totally_separated_space (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_183674 (h0 : ring (normed_group (random_gen (random_gen fun_info)))) : rank_condition (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_183675 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (has_add Type))) : discrete_topology (linear_ordered_add_comm_monoid_with_top (has_add Type)) := sorry --non-trivial
lemma new_lemma_183676 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_183677 (h0 : ordered_comm_monoid (has_neg_part environment.implicit_infer_kind)) : has_exists_mul_of_le (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_183678 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_183679 (h0 : uniform_space (semigroup (finset (has_neg (finset (has_pos_part linarith.comp)))))) : complete_space (semigroup (finset (has_neg (finset (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_183680 (h0 : cancel_comm_monoid_with_zero (has_neg (has_to_string (has_add pos)))) : unique_factorization_monoid (has_neg (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_183681 (h0 : functor.add_const (list (boolean_algebra pos)) (has_Inf pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183682 (h0 : functor.add_const (list (has_add Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183683 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183684 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183685 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp)))) : normal_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_183686 (h0 : topological_space (ordered_comm_monoid pos)) : loc_path_connected_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_183687 (h1 : ring (denumerable (random_gen (random_gen (random_gen (random_gen char)))))) : rank_condition (denumerable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_183688 (h0 : functor.add_const (monoid (has_add name)) pos) : @monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_183689 (h1 : ring (linear_ordered_add_comm_group char)) : is_domain (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_183690 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_183691 (h0 : not (topological_space (random_gen (random_gen char)) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (random_gen.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_183692 (h0 : not (ring (with_bot num) -> false)) : @is_domain.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_183693 (h2 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : is_domain (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183694 (h0 : not (group (option unsigned) -> false)) : @group.fg.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_183695 (h0 : group (ring (has_Inf (has_neg (has_neg name))))) : normalizer_condition (ring (has_Inf (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_183696 (h0 : topological_space (has_add (option num))) : preirreducible_space (has_add (option num)) := sorry --non-trivial
lemma new_lemma_183697 (h0 : functor.add_const (topological_space (finset pos)) name) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_183698 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_183699 (h0 : topological_space (has_Inf (ordered_ring pos))) : topological_space.separable_space (has_Inf (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_183700 (h0 : group (encodable (random_gen linarith.comp_source))) : is_cyclic (encodable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_183701 (h2 : ring (with_one char)) : is_domain (with_one char) := sorry --non-trivial
lemma new_lemma_183702 (h0 : has_le (measurable_space linarith.comp_source)) (h1 : measurable_space linarith.comp_source) : is_bot h1 := sorry --non-trivial
lemma new_lemma_183703 (h0 : not (semiring (id num) -> false)) : @is_noetherian_ring.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (semiring.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_183704 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option (option unsigned)))))) : preconnected_space (canonically_linear_ordered_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_183705 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_183706 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) Type) Type) : @is_atomistic.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (complete_lattice.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (complete_lattice.{0} environment.implicit_infer_kind) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_183707 (h0 : has_lt (normed_field linarith.comp_source)) : no_max_order (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183708 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) linarith.comp)  := sorry --non-trivial
lemma new_lemma_183709 (h0 : set (semi_normed_comm_ring (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_183710 (h0 : ring (option (semiring empty))) : strong_rank_condition (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_183711 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_183712 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_183713 (h0 : ring (lattice (has_norm (has_norm linarith.comp)))) : rank_condition (lattice (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_183714 (h0 : topological_space (has_add linarith.comp)) (h1 : set (has_add linarith.comp)) : is_totally_separated h1 := sorry --non-trivial
lemma new_lemma_183715 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_183716 (h0 : topological_space (has_Sup (option (option unsigned)))) : preirreducible_space (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_183717 (h0 : monoid (id num)) : monoid.fg (id num) := sorry --non-trivial
lemma new_lemma_183718 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_183719 (h0 : complete_lattice (has_top (has_inv linarith.comp_source))) : is_compactly_generated (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_183720 (h0 : set (add_comm_semigroup (has_nnnorm linarith.ineq) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_183721 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_183722 (h0 : add_group (has_nnnorm string.iterator_imp)) : is_add_cyclic (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_183723 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183724 (h0 : functor.add_const (complete_lattice (finset Type)) Type) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_183725 (h0 : complete_lattice (complete_linear_order congr_arg_kind)) : is_compactly_generated (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_183726 (h0 : topological_space (normed_comm_ring num)) : t1_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_183727 (h0 : topological_space (has_bot (option empty))) : irreducible_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_183728 (h0 : not (group (partial_order num) -> false)) : @group.fg.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_183729 (h0 : functor.add_const (add_group (has_neg_part pos)) name) : @is_add_cyclic.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_183730 (h0 : group (complete_semilattice_Sup (random_gen to_additive.value_type))) : group.fg (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183731 (h0 : topological_space (metric_space (linear_ordered_semiring unsigned))) : t0_space (metric_space (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_183732 (h0 : topological_space (id empty)) : irreducible_space (id empty) := sorry --non-trivial
lemma new_lemma_183733 (h0 : uniform_space (complete_distrib_lattice (option (option empty)))) : separated_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_183734 (h0 : list (is_R_or_C empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183735 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) (has_neg linarith.comp)) : @group.fg.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_183736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183737 (h0 : semiring (ordered_comm_monoid name)) : is_noetherian_ring (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_183738 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part pos)) pos) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_183739 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183740 (h0 : group (add_cancel_comm_monoid (has_neg_part string_imp))) : is_cyclic (add_cancel_comm_monoid (has_neg_part string_imp)) := sorry --non-trivial
lemma new_lemma_183741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_183742 (h0 h1 : multiset (semi_normed_ring (mul_one_class string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_183743 (h0 : complete_lattice (has_to_string (ordered_comm_monoid pos))) : is_compactly_generated (has_to_string (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_183744 (h0 : group (has_neg_part (has_add Type))) : normalizer_condition (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_183745 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_183746 (h0 : functor.add_const (function.extfun Type group) (finset pos)) : @normalizer_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} pos) h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_183747 (h0 : not (cancel_comm_monoid_with_zero (complete_linear_order unsigned) -> false)) : @unique_factorization_monoid.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_183748 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_183749 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) name) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_183750 (h0 : has_lt (has_le to_additive.value_type)) : no_max_order (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183751 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (comm_group (comm_group (comm_group (comm_group name)))))) : archimedean (complete_distrib_lattice (comm_group (comm_group (comm_group (comm_group name))))) := sorry --non-trivial
lemma new_lemma_183752 (h0 : pfun char (topological_space environment.implicit_infer_kind)) (h1 : coe_sort (pfun.dom h0)) (h2 : set (set environment.implicit_infer_kind)) : @topological_space.is_topological_basis.{0} environment.implicit_infer_kind (@pfun.as_subtype.{0 0} char (topological_space.{0} environment.implicit_infer_kind) h0 h1) h2  := sorry --non-trivial
lemma new_lemma_183753 (h2 : has_le enat) (h3 : enat) : is_bot h3 := sorry --non-trivial
lemma new_lemma_183754 (h0 : functor.add_const (complete_lattice (has_neg ennreal)) ennreal) : @is_compactly_generated.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_183755 (h0 : complete_lattice (cancel_monoid (option num))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_183756 (h0 : functor.add_const (list (add_cancel_monoid pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183757 (h1 : uniform_space (has_norm (measurable_space linarith.comp))) : complete_space (has_norm (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_183758 (h0 : has_mem.mem (random_gen fun_info) has_zero.zero) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@multiset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_183759 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_183760 (h1 : has_lt (mul_one_class char)) : no_max_order (mul_one_class char) := sorry --non-trivial
lemma new_lemma_183761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_183762 (h0 : topological_space (with_one (random_gen congr_arg_kind))) : locally_compact_space (with_one (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_183763 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_183764 (h0 : ring (has_add (has_Inf pos))) : is_domain (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_183765 (h0 : ring (has_nndist unsigned)) : strong_rank_condition (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_183766 (h0 : topological_space (semigroup (has_add (add_comm_monoid Type)))) : normal_space (semigroup (has_add (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_183767 (h0 : ring (has_compl (random_gen to_additive.value_type))) : is_domain (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183768 (h1 : ring (semiring (has_norm to_additive.value_type))) : strong_rank_condition (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_183769 (h0 : topological_space (has_bot (has_Inf real))) : path_connected_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_183770 (h0 : functor.add_const (group (has_to_string Type)) (has_neg_part Type)) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_to_string.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_183771 (h0 : list (add_comm_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183772 (h0 : group (normed_group (semiring (semiring num)))) : group.fg (normed_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_183773 (h0 : functor.add_const (ring (has_neg unsigned)) (has_neg environment.implicit_infer_kind)) : @is_domain.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_183774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_183775 (h0 : filter (has_inv to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183776 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_183777 (h0 : complete_lattice (has_le char)) : complete_lattice.is_Sup_finite_compact (has_le char) := sorry --non-trivial
lemma new_lemma_183778 (h0 : functor.add_const (list (ring name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183779 (h0 : topological_space (random_gen (has_one linarith.comp))) : preirreducible_space (random_gen (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_183780 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_183781 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid (comm_group linarith.comp)))) : is_compactly_generated (add_cancel_monoid (add_comm_monoid (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_183782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_183783 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_183784 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_183785 : nonempty char := sorry --simp
lemma new_lemma_183786 (h0 : ring (complete_semilattice_Sup (semiring linarith.comp_source))) : strong_rank_condition (complete_semilattice_Sup (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_183787 (h0 : add_group (has_neg_part (has_add Type))) : is_add_cyclic (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_183788 (h0 : functor.add_const (list (has_Inf linarith.comp)) (finset pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_183789 (h0 : ordered_comm_monoid (option (option (option (ring (option (option pos))))))) : has_exists_mul_of_le (option (option (option (ring (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_183790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) empty)  := sorry --non-trivial
lemma new_lemma_183791 (h0 : list (dlist (denumerable (random_gen (random_gen (random_gen fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_183792 (h0 : group (monoid unsigned)) : is_cyclic (monoid unsigned) := sorry --non-trivial
lemma new_lemma_183793 (h0 : multiset (dlist (has_nnnorm (has_nnnorm linarith.comp_source)))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_183794 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_183795 (h1 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_183796 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_183797 (h0 : functor.add_const (topological_space (has_add ennreal)) ennreal) : @preirreducible_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_183798 (h0 : measurable_space (has_norm string_imp)) (h1 : has_sup (has_norm string_imp)) : has_measurable_sup (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_183799 (h0 : semiring (simple_graph (ring Type))) : is_noetherian_ring (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_183800 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_183801 (h2 : ring (semi_normed_ring string_imp)) : is_domain (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_183802 (h0 : function.extfun Type (functor.comp list has_nndist)) : list.nodup (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_183803 (h0 : filter (has_nndist (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183804 (h0 : topological_space (has_add (has_pos_part (has_pos_part pos)))) : totally_disconnected_space (has_add (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_183805 (h0 : functor.add_const (function.extfun Type semiring) (finset pos)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (finset.{0} pos) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_183806 (h0 : complete_lattice (has_inv (random_gen string_imp))) : is_atomistic (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_183807 (h0 : ring (semi_normed_ring to_additive.value_type)) : strong_rank_condition (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_183808 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t1_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_183809 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : t1_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_183810 (h0 : functor.add_const (monoid (ring pos)) Type) : @monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_183811 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_183812 (h0 : functor.add_const (add_monoid (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_183813 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup fun_info)) := sorry --non-trivial
lemma new_lemma_183814 (h0 : add_group (has_add (has_bot (has_bot real)))) : is_add_cyclic (has_add (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_183815 (h0 : group (complete_semilattice_Sup (has_inv (has_inv (has_top linarith.comp_source))))) : normalizer_condition (complete_semilattice_Sup (has_inv (has_inv (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_183816 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_183817 (h0 : group (has_add (has_Inf (ordered_comm_monoid pos)))) : normalizer_condition (has_add (has_Inf (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_183818 (h3 : ring (ordered_comm_ring linarith.comp_source)) : is_domain (ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_183819 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_183820 (h0 : finset (has_inner unsigned unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_183821 (h0 : filter (has_nndist (ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183822 (h0 : topological_space (normed_group (semiring num))) : t0_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_183823 (h0 : monoid (complete_distrib_lattice (semigroup name))) : monoid.fg (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
